"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@firebase";
exports.ids = ["vendor-chunks/@firebase"];
exports.modules = {

/***/ "(ssr)/../node_modules/@firebase/app/dist/esm/index.esm2017.js":
/*!***************************************************************!*\
  !*** ../node_modules/@firebase/app/dist/esm/index.esm2017.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: () => (/* reexport safe */ _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError),\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION),\n/* harmony export */   _DEFAULT_ENTRY_NAME: () => (/* binding */ DEFAULT_ENTRY_NAME),\n/* harmony export */   _addComponent: () => (/* binding */ _addComponent),\n/* harmony export */   _addOrOverwriteComponent: () => (/* binding */ _addOrOverwriteComponent),\n/* harmony export */   _apps: () => (/* binding */ _apps),\n/* harmony export */   _clearComponents: () => (/* binding */ _clearComponents),\n/* harmony export */   _components: () => (/* binding */ _components),\n/* harmony export */   _getProvider: () => (/* binding */ _getProvider),\n/* harmony export */   _isFirebaseApp: () => (/* binding */ _isFirebaseApp),\n/* harmony export */   _isFirebaseServerApp: () => (/* binding */ _isFirebaseServerApp),\n/* harmony export */   _registerComponent: () => (/* binding */ _registerComponent),\n/* harmony export */   _removeServiceInstance: () => (/* binding */ _removeServiceInstance),\n/* harmony export */   _serverApps: () => (/* binding */ _serverApps),\n/* harmony export */   deleteApp: () => (/* binding */ deleteApp),\n/* harmony export */   getApp: () => (/* binding */ getApp),\n/* harmony export */   getApps: () => (/* binding */ getApps),\n/* harmony export */   initializeApp: () => (/* binding */ initializeApp),\n/* harmony export */   initializeServerApp: () => (/* binding */ initializeServerApp),\n/* harmony export */   onLog: () => (/* binding */ onLog),\n/* harmony export */   registerVersion: () => (/* binding */ registerVersion),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/../node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/../node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/../node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(ssr)/../node_modules/idb/build/index.js\");\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass PlatformLoggerServiceImpl {\n    constructor(container) {\n        this.container = container;\n    }\n    // In initial implementation, this will be called by installations on\n    // auth token refresh, and installations will send this string.\n    getPlatformInfoString() {\n        const providers = this.container.getProviders();\n        // Loop through providers and get library/version pairs from any that are\n        // version components.\n        return providers\n            .map(provider => {\n            if (isVersionServiceProvider(provider)) {\n                const service = provider.getImmediate();\n                return `${service.library}/${service.version}`;\n            }\n            else {\n                return null;\n            }\n        })\n            .filter(logString => logString)\n            .join(' ');\n    }\n}\n/**\n *\n * @param provider check if this provider provides a VersionService\n *\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\n * provides VersionService. The provider is not necessarily a 'app-version'\n * provider.\n */\nfunction isVersionServiceProvider(provider) {\n    const component = provider.getComponent();\n    return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* ComponentType.VERSION */;\n}\n\nconst name$q = \"@firebase/app\";\nconst version$1 = \"0.11.3\";\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger('@firebase/app');\n\nconst name$p = \"@firebase/app-compat\";\n\nconst name$o = \"@firebase/analytics-compat\";\n\nconst name$n = \"@firebase/analytics\";\n\nconst name$m = \"@firebase/app-check-compat\";\n\nconst name$l = \"@firebase/app-check\";\n\nconst name$k = \"@firebase/auth\";\n\nconst name$j = \"@firebase/auth-compat\";\n\nconst name$i = \"@firebase/database\";\n\nconst name$h = \"@firebase/data-connect\";\n\nconst name$g = \"@firebase/database-compat\";\n\nconst name$f = \"@firebase/functions\";\n\nconst name$e = \"@firebase/functions-compat\";\n\nconst name$d = \"@firebase/installations\";\n\nconst name$c = \"@firebase/installations-compat\";\n\nconst name$b = \"@firebase/messaging\";\n\nconst name$a = \"@firebase/messaging-compat\";\n\nconst name$9 = \"@firebase/performance\";\n\nconst name$8 = \"@firebase/performance-compat\";\n\nconst name$7 = \"@firebase/remote-config\";\n\nconst name$6 = \"@firebase/remote-config-compat\";\n\nconst name$5 = \"@firebase/storage\";\n\nconst name$4 = \"@firebase/storage-compat\";\n\nconst name$3 = \"@firebase/firestore\";\n\nconst name$2 = \"@firebase/vertexai\";\n\nconst name$1 = \"@firebase/firestore-compat\";\n\nconst name = \"firebase\";\nconst version = \"11.5.0\";\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The default app name\n *\n * @internal\n */\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\nconst PLATFORM_LOG_STRING = {\n    [name$q]: 'fire-core',\n    [name$p]: 'fire-core-compat',\n    [name$n]: 'fire-analytics',\n    [name$o]: 'fire-analytics-compat',\n    [name$l]: 'fire-app-check',\n    [name$m]: 'fire-app-check-compat',\n    [name$k]: 'fire-auth',\n    [name$j]: 'fire-auth-compat',\n    [name$i]: 'fire-rtdb',\n    [name$h]: 'fire-data-connect',\n    [name$g]: 'fire-rtdb-compat',\n    [name$f]: 'fire-fn',\n    [name$e]: 'fire-fn-compat',\n    [name$d]: 'fire-iid',\n    [name$c]: 'fire-iid-compat',\n    [name$b]: 'fire-fcm',\n    [name$a]: 'fire-fcm-compat',\n    [name$9]: 'fire-perf',\n    [name$8]: 'fire-perf-compat',\n    [name$7]: 'fire-rc',\n    [name$6]: 'fire-rc-compat',\n    [name$5]: 'fire-gcs',\n    [name$4]: 'fire-gcs-compat',\n    [name$3]: 'fire-fst',\n    [name$1]: 'fire-fst-compat',\n    [name$2]: 'fire-vertex',\n    'fire-js': 'fire-js', // Platform identifier for JS SDK.\n    [name]: 'fire-js-all'\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @internal\n */\nconst _apps = new Map();\n/**\n * @internal\n */\nconst _serverApps = new Map();\n/**\n * Registered components.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst _components = new Map();\n/**\n * @param component - the component being added to this app's container\n *\n * @internal\n */\nfunction _addComponent(app, component) {\n    try {\n        app.container.addComponent(component);\n    }\n    catch (e) {\n        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\n    }\n}\n/**\n *\n * @internal\n */\nfunction _addOrOverwriteComponent(app, component) {\n    app.container.addOrOverwriteComponent(component);\n}\n/**\n *\n * @param component - the component to register\n * @returns whether or not the component is registered successfully\n *\n * @internal\n */\nfunction _registerComponent(component) {\n    const componentName = component.name;\n    if (_components.has(componentName)) {\n        logger.debug(`There were multiple attempts to register component ${componentName}.`);\n        return false;\n    }\n    _components.set(componentName, component);\n    // add the component to existing app instances\n    for (const app of _apps.values()) {\n        _addComponent(app, component);\n    }\n    for (const serverApp of _serverApps.values()) {\n        _addComponent(serverApp, component);\n    }\n    return true;\n}\n/**\n *\n * @param app - FirebaseApp instance\n * @param name - service name\n *\n * @returns the provider for the service with the matching name\n *\n * @internal\n */\nfunction _getProvider(app, name) {\n    const heartbeatController = app.container\n        .getProvider('heartbeat')\n        .getImmediate({ optional: true });\n    if (heartbeatController) {\n        void heartbeatController.triggerHeartbeat();\n    }\n    return app.container.getProvider(name);\n}\n/**\n *\n * @param app - FirebaseApp instance\n * @param name - service name\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\n *\n * @internal\n */\nfunction _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {\n    _getProvider(app, name).clearInstance(instanceIdentifier);\n}\n/**\n *\n * @param obj - an object of type FirebaseApp or FirebaseOptions.\n *\n * @returns true if the provide object is of type FirebaseApp.\n *\n * @internal\n */\nfunction _isFirebaseApp(obj) {\n    return obj.options !== undefined;\n}\n/**\n *\n * @param obj - an object of type FirebaseApp.\n *\n * @returns true if the provided object is of type FirebaseServerAppImpl.\n *\n * @internal\n */\nfunction _isFirebaseServerApp(obj) {\n    if (obj === null || obj === undefined) {\n        return false;\n    }\n    return obj.settings !== undefined;\n}\n/**\n * Test only\n *\n * @internal\n */\nfunction _clearComponents() {\n    _components.clear();\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst ERRORS = {\n    [\"no-app\" /* AppError.NO_APP */]: \"No Firebase App '{$appName}' has been created - \" +\n        'call initializeApp() first',\n    [\"bad-app-name\" /* AppError.BAD_APP_NAME */]: \"Illegal App name: '{$appName}'\",\n    [\"duplicate-app\" /* AppError.DUPLICATE_APP */]: \"Firebase App named '{$appName}' already exists with different options or config\",\n    [\"app-deleted\" /* AppError.APP_DELETED */]: \"Firebase App named '{$appName}' already deleted\",\n    [\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */]: 'Firebase Server App has been deleted',\n    [\"no-options\" /* AppError.NO_OPTIONS */]: 'Need to provide options, when not being deployed to hosting via source.',\n    [\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */]: 'firebase.{$appName}() takes either no argument or a ' +\n        'Firebase App instance.',\n    [\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */]: 'First argument to `onLog` must be null or a function.',\n    [\"idb-open\" /* AppError.IDB_OPEN */]: 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-get\" /* AppError.IDB_GET */]: 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-set\" /* AppError.IDB_WRITE */]: 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-delete\" /* AppError.IDB_DELETE */]: 'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */]: 'FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.',\n    [\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */]: 'FirebaseServerApp is not for use in browser environments.'\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory('app', 'Firebase', ERRORS);\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass FirebaseAppImpl {\n    constructor(options, config, container) {\n        this._isDeleted = false;\n        this._options = Object.assign({}, options);\n        this._config = Object.assign({}, config);\n        this._name = config.name;\n        this._automaticDataCollectionEnabled =\n            config.automaticDataCollectionEnabled;\n        this._container = container;\n        this.container.addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('app', () => this, \"PUBLIC\" /* ComponentType.PUBLIC */));\n    }\n    get automaticDataCollectionEnabled() {\n        this.checkDestroyed();\n        return this._automaticDataCollectionEnabled;\n    }\n    set automaticDataCollectionEnabled(val) {\n        this.checkDestroyed();\n        this._automaticDataCollectionEnabled = val;\n    }\n    get name() {\n        this.checkDestroyed();\n        return this._name;\n    }\n    get options() {\n        this.checkDestroyed();\n        return this._options;\n    }\n    get config() {\n        this.checkDestroyed();\n        return this._config;\n    }\n    get container() {\n        return this._container;\n    }\n    get isDeleted() {\n        return this._isDeleted;\n    }\n    set isDeleted(val) {\n        this._isDeleted = val;\n    }\n    /**\n     * This function will throw an Error if the App has already been deleted -\n     * use before performing API actions on the App.\n     */\n    checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"app-deleted\" /* AppError.APP_DELETED */, { appName: this._name });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Parse the token and check to see if the `exp` claim is in the future.\n// Reports an error to the console if the token or claim could not be parsed, or if `exp` is in\n// the past.\nfunction validateTokenTTL(base64Token, tokenName) {\n    const secondPart = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64Decode)(base64Token.split('.')[1]);\n    if (secondPart === null) {\n        console.error(`FirebaseServerApp ${tokenName} is invalid: second part could not be parsed.`);\n        return;\n    }\n    const expClaim = JSON.parse(secondPart).exp;\n    if (expClaim === undefined) {\n        console.error(`FirebaseServerApp ${tokenName} is invalid: expiration claim could not be parsed`);\n        return;\n    }\n    const exp = JSON.parse(secondPart).exp * 1000;\n    const now = new Date().getTime();\n    const diff = exp - now;\n    if (diff <= 0) {\n        console.error(`FirebaseServerApp ${tokenName} is invalid: the token has expired.`);\n    }\n}\nclass FirebaseServerAppImpl extends FirebaseAppImpl {\n    constructor(options, serverConfig, name, container) {\n        // Build configuration parameters for the FirebaseAppImpl base class.\n        const automaticDataCollectionEnabled = serverConfig.automaticDataCollectionEnabled !== undefined\n            ? serverConfig.automaticDataCollectionEnabled\n            : false;\n        // Create the FirebaseAppSettings object for the FirebaseAppImp constructor.\n        const config = {\n            name,\n            automaticDataCollectionEnabled\n        };\n        if (options.apiKey !== undefined) {\n            // Construct the parent FirebaseAppImp object.\n            super(options, config, container);\n        }\n        else {\n            const appImpl = options;\n            super(appImpl.options, config, container);\n        }\n        // Now construct the data for the FirebaseServerAppImpl.\n        this._serverConfig = Object.assign({ automaticDataCollectionEnabled }, serverConfig);\n        // Ensure that the current time is within the `authIdtoken` window of validity.\n        if (this._serverConfig.authIdToken) {\n            validateTokenTTL(this._serverConfig.authIdToken, 'authIdToken');\n        }\n        // Ensure that the current time is within the `appCheckToken` window of validity.\n        if (this._serverConfig.appCheckToken) {\n            validateTokenTTL(this._serverConfig.appCheckToken, 'appCheckToken');\n        }\n        this._finalizationRegistry = null;\n        if (typeof FinalizationRegistry !== 'undefined') {\n            this._finalizationRegistry = new FinalizationRegistry(() => {\n                this.automaticCleanup();\n            });\n        }\n        this._refCount = 0;\n        this.incRefCount(this._serverConfig.releaseOnDeref);\n        // Do not retain a hard reference to the dref object, otherwise the FinalizationRegistry\n        // will never trigger.\n        this._serverConfig.releaseOnDeref = undefined;\n        serverConfig.releaseOnDeref = undefined;\n        registerVersion(name$q, version$1, 'serverapp');\n    }\n    toJSON() {\n        return undefined;\n    }\n    get refCount() {\n        return this._refCount;\n    }\n    // Increment the reference count of this server app. If an object is provided, register it\n    // with the finalization registry.\n    incRefCount(obj) {\n        if (this.isDeleted) {\n            return;\n        }\n        this._refCount++;\n        if (obj !== undefined && this._finalizationRegistry !== null) {\n            this._finalizationRegistry.register(obj, this);\n        }\n    }\n    // Decrement the reference count.\n    decRefCount() {\n        if (this.isDeleted) {\n            return 0;\n        }\n        return --this._refCount;\n    }\n    // Invoked by the FinalizationRegistry callback to note that this app should go through its\n    // reference counts and delete itself if no reference count remain. The coordinating logic that\n    // handles this is in deleteApp(...).\n    automaticCleanup() {\n        void deleteApp(this);\n    }\n    get settings() {\n        this.checkDestroyed();\n        return this._serverConfig;\n    }\n    /**\n     * This function will throw an Error if the App has already been deleted -\n     * use before performing API actions on the App.\n     */\n    checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The current SDK version.\n *\n * @public\n */\nconst SDK_VERSION = version;\nfunction initializeApp(_options, rawConfig = {}) {\n    let options = _options;\n    if (typeof rawConfig !== 'object') {\n        const name = rawConfig;\n        rawConfig = { name };\n    }\n    const config = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);\n    const name = config.name;\n    if (typeof name !== 'string' || !name) {\n        throw ERROR_FACTORY.create(\"bad-app-name\" /* AppError.BAD_APP_NAME */, {\n            appName: String(name)\n        });\n    }\n    options || (options = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)());\n    if (!options) {\n        throw ERROR_FACTORY.create(\"no-options\" /* AppError.NO_OPTIONS */);\n    }\n    const existingApp = _apps.get(name);\n    if (existingApp) {\n        // return the existing app if options and config deep equal the ones in the existing app.\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, existingApp.options) &&\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(config, existingApp.config)) {\n            return existingApp;\n        }\n        else {\n            throw ERROR_FACTORY.create(\"duplicate-app\" /* AppError.DUPLICATE_APP */, { appName: name });\n        }\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(name);\n    for (const component of _components.values()) {\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseAppImpl(options, config, container);\n    _apps.set(name, newApp);\n    return newApp;\n}\nfunction initializeServerApp(_options, _serverAppConfig) {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isBrowser)() && !(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isWebWorker)()) {\n        // FirebaseServerApp isn't designed to be run in browsers.\n        throw ERROR_FACTORY.create(\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */);\n    }\n    if (_serverAppConfig.automaticDataCollectionEnabled === undefined) {\n        _serverAppConfig.automaticDataCollectionEnabled = false;\n    }\n    let appOptions;\n    if (_isFirebaseApp(_options)) {\n        appOptions = _options.options;\n    }\n    else {\n        appOptions = _options;\n    }\n    // Build an app name based on a hash of the configuration options.\n    const nameObj = Object.assign(Object.assign({}, _serverAppConfig), appOptions);\n    // However, Do not mangle the name based on releaseOnDeref, since it will vary between the\n    // construction of FirebaseServerApp instances. For example, if the object is the request headers.\n    if (nameObj.releaseOnDeref !== undefined) {\n        delete nameObj.releaseOnDeref;\n    }\n    const hashCode = (s) => {\n        return [...s].reduce((hash, c) => (Math.imul(31, hash) + c.charCodeAt(0)) | 0, 0);\n    };\n    if (_serverAppConfig.releaseOnDeref !== undefined) {\n        if (typeof FinalizationRegistry === 'undefined') {\n            throw ERROR_FACTORY.create(\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */, {});\n        }\n    }\n    const nameString = '' + hashCode(JSON.stringify(nameObj));\n    const existingApp = _serverApps.get(nameString);\n    if (existingApp) {\n        existingApp.incRefCount(_serverAppConfig.releaseOnDeref);\n        return existingApp;\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(nameString);\n    for (const component of _components.values()) {\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseServerAppImpl(appOptions, _serverAppConfig, nameString, container);\n    _serverApps.set(nameString, newApp);\n    return newApp;\n}\n/**\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\n *\n * When called with no arguments, the default app is returned. When an app name\n * is provided, the app corresponding to that name is returned.\n *\n * An exception is thrown if the app being retrieved has not yet been\n * initialized.\n *\n * @example\n * ```javascript\n * // Return the default app\n * const app = getApp();\n * ```\n *\n * @example\n * ```javascript\n * // Return a named app\n * const otherApp = getApp(\"otherApp\");\n * ```\n *\n * @param name - Optional name of the app to return. If no name is\n *   provided, the default is `\"[DEFAULT]\"`.\n *\n * @returns The app corresponding to the provided app name.\n *   If no app name is provided, the default app is returned.\n *\n * @public\n */\nfunction getApp(name = DEFAULT_ENTRY_NAME) {\n    const app = _apps.get(name);\n    if (!app && name === DEFAULT_ENTRY_NAME && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)()) {\n        return initializeApp();\n    }\n    if (!app) {\n        throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */, { appName: name });\n    }\n    return app;\n}\n/**\n * A (read-only) array of all initialized apps.\n * @public\n */\nfunction getApps() {\n    return Array.from(_apps.values());\n}\n/**\n * Renders this app unusable and frees the resources of all associated\n * services.\n *\n * @example\n * ```javascript\n * deleteApp(app)\n *   .then(function() {\n *     console.log(\"App deleted successfully\");\n *   })\n *   .catch(function(error) {\n *     console.log(\"Error deleting app:\", error);\n *   });\n * ```\n *\n * @public\n */\nasync function deleteApp(app) {\n    let cleanupProviders = false;\n    const name = app.name;\n    if (_apps.has(name)) {\n        cleanupProviders = true;\n        _apps.delete(name);\n    }\n    else if (_serverApps.has(name)) {\n        const firebaseServerApp = app;\n        if (firebaseServerApp.decRefCount() <= 0) {\n            _serverApps.delete(name);\n            cleanupProviders = true;\n        }\n    }\n    if (cleanupProviders) {\n        await Promise.all(app.container\n            .getProviders()\n            .map(provider => provider.delete()));\n        app.isDeleted = true;\n    }\n}\n/**\n * Registers a library's name and version for platform logging purposes.\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\n * @param version - Current version of that library.\n * @param variant - Bundle variant, e.g., node, rn, etc.\n *\n * @public\n */\nfunction registerVersion(libraryKeyOrName, version, variant) {\n    var _a;\n    // TODO: We can use this check to whitelist strings when/if we set up\n    // a good whitelist system.\n    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\n    if (variant) {\n        library += `-${variant}`;\n    }\n    const libraryMismatch = library.match(/\\s|\\//);\n    const versionMismatch = version.match(/\\s|\\//);\n    if (libraryMismatch || versionMismatch) {\n        const warning = [\n            `Unable to register library \"${library}\" with version \"${version}\":`\n        ];\n        if (libraryMismatch) {\n            warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        if (libraryMismatch && versionMismatch) {\n            warning.push('and');\n        }\n        if (versionMismatch) {\n            warning.push(`version name \"${version}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        logger.warn(warning.join(' '));\n        return;\n    }\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(`${library}-version`, () => ({ library, version }), \"VERSION\" /* ComponentType.VERSION */));\n}\n/**\n * Sets log handler for all Firebase SDKs.\n * @param logCallback - An optional custom log handler that executes user code whenever\n * the Firebase SDK makes a logging call.\n *\n * @public\n */\nfunction onLog(logCallback, options) {\n    if (logCallback !== null && typeof logCallback !== 'function') {\n        throw ERROR_FACTORY.create(\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */);\n    }\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setUserLogHandler)(logCallback, options);\n}\n/**\n * Sets log level for all Firebase SDKs.\n *\n * All of the log types above the current log level are captured (i.e. if\n * you set the log level to `info`, errors are logged, but `debug` and\n * `verbose` logs are not).\n *\n * @public\n */\nfunction setLogLevel(logLevel) {\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(logLevel);\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DB_NAME = 'firebase-heartbeat-database';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'firebase-heartbeat-store';\nlet dbPromise = null;\nfunction getDbPromise() {\n    if (!dbPromise) {\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DB_NAME, DB_VERSION, {\n            upgrade: (db, oldVersion) => {\n                // We don't use 'break' in this switch statement, the fall-through\n                // behavior is what we want, because if there are multiple versions between\n                // the old version and the current version, we want ALL the migrations\n                // that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch (oldVersion) {\n                    case 0:\n                        try {\n                            db.createObjectStore(STORE_NAME);\n                        }\n                        catch (e) {\n                            // Safari/iOS browsers throw occasional exceptions on\n                            // db.createObjectStore() that may be a bug. Avoid blocking\n                            // the rest of the app functionality.\n                            console.warn(e);\n                        }\n                }\n            }\n        }).catch(e => {\n            throw ERROR_FACTORY.create(\"idb-open\" /* AppError.IDB_OPEN */, {\n                originalErrorMessage: e.message\n            });\n        });\n    }\n    return dbPromise;\n}\nasync function readHeartbeatsFromIndexedDB(app) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME);\n        const result = await tx.objectStore(STORE_NAME).get(computeKey(app));\n        // We already have the value but tx.done can throw,\n        // so we need to await it here to catch errors\n        await tx.done;\n        return result;\n    }\n    catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        }\n        else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-get\" /* AppError.IDB_GET */, {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME, 'readwrite');\n        const objectStore = tx.objectStore(STORE_NAME);\n        await objectStore.put(heartbeatObject, computeKey(app));\n        await tx.done;\n    }\n    catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        }\n        else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-set\" /* AppError.IDB_WRITE */, {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nfunction computeKey(app) {\n    return `${app.name}!${app.options.appId}`;\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst MAX_HEADER_BYTES = 1024;\nconst MAX_NUM_STORED_HEARTBEATS = 30;\nclass HeartbeatServiceImpl {\n    constructor(container) {\n        this.container = container;\n        /**\n         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\n         * the header string.\n         * Stores one record per date. This will be consolidated into the standard\n         * format of one record per user agent string before being sent as a header.\n         * Populated from indexedDB when the controller is instantiated and should\n         * be kept in sync with indexedDB.\n         * Leave public for easier testing.\n         */\n        this._heartbeatsCache = null;\n        const app = this.container.getProvider('app').getImmediate();\n        this._storage = new HeartbeatStorageImpl(app);\n        this._heartbeatsCachePromise = this._storage.read().then(result => {\n            this._heartbeatsCache = result;\n            return result;\n        });\n    }\n    /**\n     * Called to report a heartbeat. The function will generate\n     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\n     * to IndexedDB.\n     * Note that we only store one heartbeat per day. So if a heartbeat for today is\n     * already logged, subsequent calls to this function in the same day will be ignored.\n     */\n    async triggerHeartbeat() {\n        var _a, _b;\n        try {\n            const platformLogger = this.container\n                .getProvider('platform-logger')\n                .getImmediate();\n            // This is the \"Firebase user agent\" string from the platform logger\n            // service, not the browser user agent.\n            const agent = platformLogger.getPlatformInfoString();\n            const date = getUTCDateString();\n            if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {\n                this._heartbeatsCache = await this._heartbeatsCachePromise;\n                // If we failed to construct a heartbeats cache, then return immediately.\n                if (((_b = this._heartbeatsCache) === null || _b === void 0 ? void 0 : _b.heartbeats) == null) {\n                    return;\n                }\n            }\n            // Do not store a heartbeat if one is already stored for this day\n            // or if a header has already been sent today.\n            if (this._heartbeatsCache.lastSentHeartbeatDate === date ||\n                this._heartbeatsCache.heartbeats.some(singleDateHeartbeat => singleDateHeartbeat.date === date)) {\n                return;\n            }\n            else {\n                // There is no entry for this date. Create one.\n                this._heartbeatsCache.heartbeats.push({ date, agent });\n                // If the number of stored heartbeats exceeds the maximum number of stored heartbeats, remove the heartbeat with the earliest date.\n                // Since this is executed each time a heartbeat is pushed, the limit can only be exceeded by one, so only one needs to be removed.\n                if (this._heartbeatsCache.heartbeats.length > MAX_NUM_STORED_HEARTBEATS) {\n                    const earliestHeartbeatIdx = getEarliestHeartbeatIdx(this._heartbeatsCache.heartbeats);\n                    this._heartbeatsCache.heartbeats.splice(earliestHeartbeatIdx, 1);\n                }\n            }\n            return this._storage.overwrite(this._heartbeatsCache);\n        }\n        catch (e) {\n            logger.warn(e);\n        }\n    }\n    /**\n     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\n     * It also clears all heartbeats from memory as well as in IndexedDB.\n     *\n     * NOTE: Consuming product SDKs should not send the header if this method\n     * returns an empty string.\n     */\n    async getHeartbeatsHeader() {\n        var _a;\n        try {\n            if (this._heartbeatsCache === null) {\n                await this._heartbeatsCachePromise;\n            }\n            // If it's still null or the array is empty, there is no data to send.\n            if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null ||\n                this._heartbeatsCache.heartbeats.length === 0) {\n                return '';\n            }\n            const date = getUTCDateString();\n            // Extract as many heartbeats from the cache as will fit under the size limit.\n            const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\n            const headerString = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));\n            // Store last sent date to prevent another being logged/sent for the same day.\n            this._heartbeatsCache.lastSentHeartbeatDate = date;\n            if (unsentEntries.length > 0) {\n                // Store any unsent entries if they exist.\n                this._heartbeatsCache.heartbeats = unsentEntries;\n                // This seems more likely than emptying the array (below) to lead to some odd state\n                // since the cache isn't empty and this will be called again on the next request,\n                // and is probably safest if we await it.\n                await this._storage.overwrite(this._heartbeatsCache);\n            }\n            else {\n                this._heartbeatsCache.heartbeats = [];\n                // Do not wait for this, to reduce latency.\n                void this._storage.overwrite(this._heartbeatsCache);\n            }\n            return headerString;\n        }\n        catch (e) {\n            logger.warn(e);\n            return '';\n        }\n    }\n}\nfunction getUTCDateString() {\n    const today = new Date();\n    // Returns date format 'YYYY-MM-DD'\n    return today.toISOString().substring(0, 10);\n}\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\n    // Heartbeats grouped by user agent in the standard format to be sent in\n    // the header.\n    const heartbeatsToSend = [];\n    // Single date format heartbeats that are not sent.\n    let unsentEntries = heartbeatsCache.slice();\n    for (const singleDateHeartbeat of heartbeatsCache) {\n        // Look for an existing entry with the same user agent.\n        const heartbeatEntry = heartbeatsToSend.find(hb => hb.agent === singleDateHeartbeat.agent);\n        if (!heartbeatEntry) {\n            // If no entry for this user agent exists, create one.\n            heartbeatsToSend.push({\n                agent: singleDateHeartbeat.agent,\n                dates: [singleDateHeartbeat.date]\n            });\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                // If the header would exceed max size, remove the added heartbeat\n                // entry and stop adding to the header.\n                heartbeatsToSend.pop();\n                break;\n            }\n        }\n        else {\n            heartbeatEntry.dates.push(singleDateHeartbeat.date);\n            // If the header would exceed max size, remove the added date\n            // and stop adding to the header.\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                heartbeatEntry.dates.pop();\n                break;\n            }\n        }\n        // Pop unsent entry from queue. (Skipped if adding the entry exceeded\n        // quota and the loop breaks early.)\n        unsentEntries = unsentEntries.slice(1);\n    }\n    return {\n        heartbeatsToSend,\n        unsentEntries\n    };\n}\nclass HeartbeatStorageImpl {\n    constructor(app) {\n        this.app = app;\n        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\n    }\n    async runIndexedDBEnvironmentCheck() {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\n            return false;\n        }\n        else {\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)()\n                .then(() => true)\n                .catch(() => false);\n        }\n    }\n    /**\n     * Read all heartbeats.\n     */\n    async read() {\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return { heartbeats: [] };\n        }\n        else {\n            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\n            if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {\n                return idbHeartbeatObject;\n            }\n            else {\n                return { heartbeats: [] };\n            }\n        }\n    }\n    // overwrite the storage with the provided heartbeats\n    async overwrite(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        }\n        else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: heartbeatsObject.heartbeats\n            });\n        }\n    }\n    // add heartbeats\n    async add(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        }\n        else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: [\n                    ...existingHeartbeatsObject.heartbeats,\n                    ...heartbeatsObject.heartbeats\n                ]\n            });\n        }\n    }\n}\n/**\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\n * in a platform logging header JSON object, stringified, and converted\n * to base 64.\n */\nfunction countBytes(heartbeatsCache) {\n    // base64 has a restricted set of characters, all of which should be 1 byte.\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(\n    // heartbeatsCache wrapper properties\n    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })).length;\n}\n/**\n * Returns the index of the heartbeat with the earliest date.\n * If the heartbeats array is empty, -1 is returned.\n */\nfunction getEarliestHeartbeatIdx(heartbeats) {\n    if (heartbeats.length === 0) {\n        return -1;\n    }\n    let earliestHeartbeatIdx = 0;\n    let earliestHeartbeatDate = heartbeats[0].date;\n    for (let i = 1; i < heartbeats.length; i++) {\n        if (heartbeats[i].date < earliestHeartbeatDate) {\n            earliestHeartbeatDate = heartbeats[i].date;\n            earliestHeartbeatIdx = i;\n        }\n    }\n    return earliestHeartbeatIdx;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction registerCoreComponents(variant) {\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('platform-logger', container => new PlatformLoggerServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('heartbeat', container => new HeartbeatServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\n    // Register `app` package.\n    registerVersion(name$q, version$1, variant);\n    // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n    registerVersion(name$q, version$1, 'esm2017');\n    // Register platform SDK identifier (no version).\n    registerVersion('fire-js', '');\n}\n\n/**\n * Firebase App\n *\n * @remarks This package coordinates the communication between the different Firebase components\n * @packageDocumentation\n */\nregisterCoreComponents('');\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hcHAvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUN1QjtBQUN3SDtBQUNwSztBQUNsQjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQixHQUFHLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFNOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCLHNDQUFzQyxTQUFTO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGNBQWM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFNBQVM7QUFDbEU7QUFDQSx1RUFBdUUsU0FBUztBQUNoRiwwRUFBMEUsU0FBUztBQUNuRixzRUFBc0UsU0FBUztBQUMvRTtBQUNBO0FBQ0EsNkVBQTZFLFNBQVM7QUFDdEY7QUFDQTtBQUNBLGlHQUFpRyxzQkFBc0I7QUFDdkgsb0dBQW9HLHNCQUFzQjtBQUMxSCxvR0FBb0csc0JBQXNCO0FBQzFILDJHQUEyRyxzQkFBc0I7QUFDakk7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdEQUFZOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMERBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHFCQUFxQjtBQUN4RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0REFBWTtBQUNuQztBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0NBQWdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLG1DQUFtQyxpRUFBaUU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwwQkFBMEIsbUVBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQVM7QUFDckIsWUFBWSx5REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsZUFBZTtBQUN0RztBQUNBO0FBQ0EsMEJBQTBCLG1FQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBUyxPQUFPLDJEQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSUFBbUk7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtRUFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxtRUFBbUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGVBQWU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsa0JBQWtCLFFBQVE7QUFDN0U7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwREFBUyxJQUFJLFFBQVEsb0JBQW9CLGtCQUFrQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1FQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2REFBYTtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQ0FBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlEQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseURBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLEdBQUcsa0JBQWtCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsYUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3RELGlDQUFpQyw2RUFBNkIsa0JBQWtCLDBDQUEwQztBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9FQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUVBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2RUFBNkI7QUFDeEM7QUFDQSxxQkFBcUIseUNBQXlDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMERBQVM7QUFDcEMsMkJBQTJCLDBEQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtVztBQUNuVyIsInNvdXJjZXMiOlsid2VicGFjazovL3RhbGtfdG9fdGV4dC8uLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzPzM0NDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRDb250YWluZXIgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IExvZ2dlciwgc2V0VXNlckxvZ0hhbmRsZXIsIHNldExvZ0xldmVsIGFzIHNldExvZ0xldmVsJDEgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yRmFjdG9yeSwgYmFzZTY0RGVjb2RlLCBnZXREZWZhdWx0QXBwQ29uZmlnLCBkZWVwRXF1YWwsIGlzQnJvd3NlciwgaXNXZWJXb3JrZXIsIEZpcmViYXNlRXJyb3IsIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nLCBpc0luZGV4ZWREQkF2YWlsYWJsZSwgdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmV4cG9ydCB7IEZpcmViYXNlRXJyb3IgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBvcGVuREIgfSBmcm9tICdpZGInO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH1cbiAgICAvLyBJbiBpbml0aWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdpbGwgYmUgY2FsbGVkIGJ5IGluc3RhbGxhdGlvbnMgb25cbiAgICAvLyBhdXRoIHRva2VuIHJlZnJlc2gsIGFuZCBpbnN0YWxsYXRpb25zIHdpbGwgc2VuZCB0aGlzIHN0cmluZy5cbiAgICBnZXRQbGF0Zm9ybUluZm9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVycygpO1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggcHJvdmlkZXJzIGFuZCBnZXQgbGlicmFyeS92ZXJzaW9uIHBhaXJzIGZyb20gYW55IHRoYXQgYXJlXG4gICAgICAgIC8vIHZlcnNpb24gY29tcG9uZW50cy5cbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyc1xuICAgICAgICAgICAgLm1hcChwcm92aWRlciA9PiB7XG4gICAgICAgICAgICBpZiAoaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyKHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c2VydmljZS5saWJyYXJ5fS8ke3NlcnZpY2UudmVyc2lvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGxvZ1N0cmluZyA9PiBsb2dTdHJpbmcpXG4gICAgICAgICAgICAuam9pbignICcpO1xuICAgIH1cbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBwcm92aWRlciBjaGVjayBpZiB0aGlzIHByb3ZpZGVyIHByb3ZpZGVzIGEgVmVyc2lvblNlcnZpY2VcbiAqXG4gKiBOT1RFOiBVc2luZyBQcm92aWRlcjwnYXBwLXZlcnNpb24nPiBpcyBhIGhhY2sgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcHJvdmlkZXJcbiAqIHByb3ZpZGVzIFZlcnNpb25TZXJ2aWNlLiBUaGUgcHJvdmlkZXIgaXMgbm90IG5lY2Vzc2FyaWx5IGEgJ2FwcC12ZXJzaW9uJ1xuICogcHJvdmlkZXIuXG4gKi9cbmZ1bmN0aW9uIGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcikge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHByb3ZpZGVyLmdldENvbXBvbmVudCgpO1xuICAgIHJldHVybiAoY29tcG9uZW50ID09PSBudWxsIHx8IGNvbXBvbmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50LnR5cGUpID09PSBcIlZFUlNJT05cIiAvKiBDb21wb25lbnRUeXBlLlZFUlNJT04gKi87XG59XG5cbmNvbnN0IG5hbWUkcSA9IFwiQGZpcmViYXNlL2FwcFwiO1xuY29uc3QgdmVyc2lvbiQxID0gXCIwLjExLjNcIjtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoJ0BmaXJlYmFzZS9hcHAnKTtcblxuY29uc3QgbmFtZSRwID0gXCJAZmlyZWJhc2UvYXBwLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJG8gPSBcIkBmaXJlYmFzZS9hbmFseXRpY3MtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkbiA9IFwiQGZpcmViYXNlL2FuYWx5dGljc1wiO1xuXG5jb25zdCBuYW1lJG0gPSBcIkBmaXJlYmFzZS9hcHAtY2hlY2stY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkbCA9IFwiQGZpcmViYXNlL2FwcC1jaGVja1wiO1xuXG5jb25zdCBuYW1lJGsgPSBcIkBmaXJlYmFzZS9hdXRoXCI7XG5cbmNvbnN0IG5hbWUkaiA9IFwiQGZpcmViYXNlL2F1dGgtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkaSA9IFwiQGZpcmViYXNlL2RhdGFiYXNlXCI7XG5cbmNvbnN0IG5hbWUkaCA9IFwiQGZpcmViYXNlL2RhdGEtY29ubmVjdFwiO1xuXG5jb25zdCBuYW1lJGcgPSBcIkBmaXJlYmFzZS9kYXRhYmFzZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRmID0gXCJAZmlyZWJhc2UvZnVuY3Rpb25zXCI7XG5cbmNvbnN0IG5hbWUkZSA9IFwiQGZpcmViYXNlL2Z1bmN0aW9ucy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRkID0gXCJAZmlyZWJhc2UvaW5zdGFsbGF0aW9uc1wiO1xuXG5jb25zdCBuYW1lJGMgPSBcIkBmaXJlYmFzZS9pbnN0YWxsYXRpb25zLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGIgPSBcIkBmaXJlYmFzZS9tZXNzYWdpbmdcIjtcblxuY29uc3QgbmFtZSRhID0gXCJAZmlyZWJhc2UvbWVzc2FnaW5nLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDkgPSBcIkBmaXJlYmFzZS9wZXJmb3JtYW5jZVwiO1xuXG5jb25zdCBuYW1lJDggPSBcIkBmaXJlYmFzZS9wZXJmb3JtYW5jZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ3ID0gXCJAZmlyZWJhc2UvcmVtb3RlLWNvbmZpZ1wiO1xuXG5jb25zdCBuYW1lJDYgPSBcIkBmaXJlYmFzZS9yZW1vdGUtY29uZmlnLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDUgPSBcIkBmaXJlYmFzZS9zdG9yYWdlXCI7XG5cbmNvbnN0IG5hbWUkNCA9IFwiQGZpcmViYXNlL3N0b3JhZ2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkMyA9IFwiQGZpcmViYXNlL2ZpcmVzdG9yZVwiO1xuXG5jb25zdCBuYW1lJDIgPSBcIkBmaXJlYmFzZS92ZXJ0ZXhhaVwiO1xuXG5jb25zdCBuYW1lJDEgPSBcIkBmaXJlYmFzZS9maXJlc3RvcmUtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUgPSBcImZpcmViYXNlXCI7XG5jb25zdCB2ZXJzaW9uID0gXCIxMS41LjBcIjtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhlIGRlZmF1bHQgYXBwIG5hbWVcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XG5jb25zdCBQTEFURk9STV9MT0dfU1RSSU5HID0ge1xuICAgIFtuYW1lJHFdOiAnZmlyZS1jb3JlJyxcbiAgICBbbmFtZSRwXTogJ2ZpcmUtY29yZS1jb21wYXQnLFxuICAgIFtuYW1lJG5dOiAnZmlyZS1hbmFseXRpY3MnLFxuICAgIFtuYW1lJG9dOiAnZmlyZS1hbmFseXRpY3MtY29tcGF0JyxcbiAgICBbbmFtZSRsXTogJ2ZpcmUtYXBwLWNoZWNrJyxcbiAgICBbbmFtZSRtXTogJ2ZpcmUtYXBwLWNoZWNrLWNvbXBhdCcsXG4gICAgW25hbWUka106ICdmaXJlLWF1dGgnLFxuICAgIFtuYW1lJGpdOiAnZmlyZS1hdXRoLWNvbXBhdCcsXG4gICAgW25hbWUkaV06ICdmaXJlLXJ0ZGInLFxuICAgIFtuYW1lJGhdOiAnZmlyZS1kYXRhLWNvbm5lY3QnLFxuICAgIFtuYW1lJGddOiAnZmlyZS1ydGRiLWNvbXBhdCcsXG4gICAgW25hbWUkZl06ICdmaXJlLWZuJyxcbiAgICBbbmFtZSRlXTogJ2ZpcmUtZm4tY29tcGF0JyxcbiAgICBbbmFtZSRkXTogJ2ZpcmUtaWlkJyxcbiAgICBbbmFtZSRjXTogJ2ZpcmUtaWlkLWNvbXBhdCcsXG4gICAgW25hbWUkYl06ICdmaXJlLWZjbScsXG4gICAgW25hbWUkYV06ICdmaXJlLWZjbS1jb21wYXQnLFxuICAgIFtuYW1lJDldOiAnZmlyZS1wZXJmJyxcbiAgICBbbmFtZSQ4XTogJ2ZpcmUtcGVyZi1jb21wYXQnLFxuICAgIFtuYW1lJDddOiAnZmlyZS1yYycsXG4gICAgW25hbWUkNl06ICdmaXJlLXJjLWNvbXBhdCcsXG4gICAgW25hbWUkNV06ICdmaXJlLWdjcycsXG4gICAgW25hbWUkNF06ICdmaXJlLWdjcy1jb21wYXQnLFxuICAgIFtuYW1lJDNdOiAnZmlyZS1mc3QnLFxuICAgIFtuYW1lJDFdOiAnZmlyZS1mc3QtY29tcGF0JyxcbiAgICBbbmFtZSQyXTogJ2ZpcmUtdmVydGV4JyxcbiAgICAnZmlyZS1qcyc6ICdmaXJlLWpzJywgLy8gUGxhdGZvcm0gaWRlbnRpZmllciBmb3IgSlMgU0RLLlxuICAgIFtuYW1lXTogJ2ZpcmUtanMtYWxsJ1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IF9hcHBzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgX3NlcnZlckFwcHMgPSBuZXcgTWFwKCk7XG4vKipcbiAqIFJlZ2lzdGVyZWQgY29tcG9uZW50cy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IF9jb21wb25lbnRzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBAcGFyYW0gY29tcG9uZW50IC0gdGhlIGNvbXBvbmVudCBiZWluZyBhZGRlZCB0byB0aGlzIGFwcCdzIGNvbnRhaW5lclxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfYWRkQ29tcG9uZW50KGFwcCwgY29tcG9uZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXBwLmNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gZmFpbGVkIHRvIHJlZ2lzdGVyIHdpdGggRmlyZWJhc2VBcHAgJHthcHAubmFtZX1gLCBlKTtcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX2FkZE9yT3ZlcndyaXRlQ29tcG9uZW50KGFwcCwgY29tcG9uZW50KSB7XG4gICAgYXBwLmNvbnRhaW5lci5hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChjb21wb25lbnQpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudCAtIHRoZSBjb21wb25lbnQgdG8gcmVnaXN0ZXJcbiAqIEByZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBjb21wb25lbnQgaXMgcmVnaXN0ZXJlZCBzdWNjZXNzZnVsbHlcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX3JlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQubmFtZTtcbiAgICBpZiAoX2NvbXBvbmVudHMuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlcmUgd2VyZSBtdWx0aXBsZSBhdHRlbXB0cyB0byByZWdpc3RlciBjb21wb25lbnQgJHtjb21wb25lbnROYW1lfS5gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfY29tcG9uZW50cy5zZXQoY29tcG9uZW50TmFtZSwgY29tcG9uZW50KTtcbiAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCB0byBleGlzdGluZyBhcHAgaW5zdGFuY2VzXG4gICAgZm9yIChjb25zdCBhcHAgb2YgX2FwcHMudmFsdWVzKCkpIHtcbiAgICAgICAgX2FkZENvbXBvbmVudChhcHAsIGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc2VydmVyQXBwIG9mIF9zZXJ2ZXJBcHBzLnZhbHVlcygpKSB7XG4gICAgICAgIF9hZGRDb21wb25lbnQoc2VydmVyQXBwLCBjb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZUFwcCBpbnN0YW5jZVxuICogQHBhcmFtIG5hbWUgLSBzZXJ2aWNlIG5hbWVcbiAqXG4gKiBAcmV0dXJucyB0aGUgcHJvdmlkZXIgZm9yIHRoZSBzZXJ2aWNlIHdpdGggdGhlIG1hdGNoaW5nIG5hbWVcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX2dldFByb3ZpZGVyKGFwcCwgbmFtZSkge1xuICAgIGNvbnN0IGhlYXJ0YmVhdENvbnRyb2xsZXIgPSBhcHAuY29udGFpbmVyXG4gICAgICAgIC5nZXRQcm92aWRlcignaGVhcnRiZWF0JylcbiAgICAgICAgLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xuICAgIGlmIChoZWFydGJlYXRDb250cm9sbGVyKSB7XG4gICAgICAgIHZvaWQgaGVhcnRiZWF0Q29udHJvbGxlci50cmlnZ2VySGVhcnRiZWF0KCk7XG4gICAgfVxuICAgIHJldHVybiBhcHAuY29udGFpbmVyLmdldFByb3ZpZGVyKG5hbWUpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIGFwcCAtIEZpcmViYXNlQXBwIGluc3RhbmNlXG4gKiBAcGFyYW0gbmFtZSAtIHNlcnZpY2UgbmFtZVxuICogQHBhcmFtIGluc3RhbmNlSWRlbnRpZmllciAtIHNlcnZpY2UgaW5zdGFuY2UgaWRlbnRpZmllciBpbiBjYXNlIHRoZSBzZXJ2aWNlIHN1cHBvcnRzIG11bHRpcGxlIGluc3RhbmNlc1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfcmVtb3ZlU2VydmljZUluc3RhbmNlKGFwcCwgbmFtZSwgaW5zdGFuY2VJZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgX2dldFByb3ZpZGVyKGFwcCwgbmFtZSkuY2xlYXJJbnN0YW5jZShpbnN0YW5jZUlkZW50aWZpZXIpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIG9iaiAtIGFuIG9iamVjdCBvZiB0eXBlIEZpcmViYXNlQXBwIG9yIEZpcmViYXNlT3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlIG9iamVjdCBpcyBvZiB0eXBlIEZpcmViYXNlQXBwLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfaXNGaXJlYmFzZUFwcChvYmopIHtcbiAgICByZXR1cm4gb2JqLm9wdGlvbnMgIT09IHVuZGVmaW5lZDtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBvYmogLSBhbiBvYmplY3Qgb2YgdHlwZSBGaXJlYmFzZUFwcC5cbiAqXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBvYmplY3QgaXMgb2YgdHlwZSBGaXJlYmFzZVNlcnZlckFwcEltcGwuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9pc0ZpcmViYXNlU2VydmVyQXBwKG9iaikge1xuICAgIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqLnNldHRpbmdzICE9PSB1bmRlZmluZWQ7XG59XG4vKipcbiAqIFRlc3Qgb25seVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfY2xlYXJDb21wb25lbnRzKCkge1xuICAgIF9jb21wb25lbnRzLmNsZWFyKCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBFUlJPUlMgPSB7XG4gICAgW1wibm8tYXBwXCIgLyogQXBwRXJyb3IuTk9fQVBQICovXTogXCJObyBGaXJlYmFzZSBBcHAgJ3skYXBwTmFtZX0nIGhhcyBiZWVuIGNyZWF0ZWQgLSBcIiArXG4gICAgICAgICdjYWxsIGluaXRpYWxpemVBcHAoKSBmaXJzdCcsXG4gICAgW1wiYmFkLWFwcC1uYW1lXCIgLyogQXBwRXJyb3IuQkFEX0FQUF9OQU1FICovXTogXCJJbGxlZ2FsIEFwcCBuYW1lOiAneyRhcHBOYW1lfSdcIixcbiAgICBbXCJkdXBsaWNhdGUtYXBwXCIgLyogQXBwRXJyb3IuRFVQTElDQVRFX0FQUCAqL106IFwiRmlyZWJhc2UgQXBwIG5hbWVkICd7JGFwcE5hbWV9JyBhbHJlYWR5IGV4aXN0cyB3aXRoIGRpZmZlcmVudCBvcHRpb25zIG9yIGNvbmZpZ1wiLFxuICAgIFtcImFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuQVBQX0RFTEVURUQgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBkZWxldGVkXCIsXG4gICAgW1wic2VydmVyLWFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuU0VSVkVSX0FQUF9ERUxFVEVEICovXTogJ0ZpcmViYXNlIFNlcnZlciBBcHAgaGFzIGJlZW4gZGVsZXRlZCcsXG4gICAgW1wibm8tb3B0aW9uc1wiIC8qIEFwcEVycm9yLk5PX09QVElPTlMgKi9dOiAnTmVlZCB0byBwcm92aWRlIG9wdGlvbnMsIHdoZW4gbm90IGJlaW5nIGRlcGxveWVkIHRvIGhvc3RpbmcgdmlhIHNvdXJjZS4nLFxuICAgIFtcImludmFsaWQtYXBwLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9BUFBfQVJHVU1FTlQgKi9dOiAnZmlyZWJhc2UueyRhcHBOYW1lfSgpIHRha2VzIGVpdGhlciBubyBhcmd1bWVudCBvciBhICcgK1xuICAgICAgICAnRmlyZWJhc2UgQXBwIGluc3RhbmNlLicsXG4gICAgW1wiaW52YWxpZC1sb2ctYXJndW1lbnRcIiAvKiBBcHBFcnJvci5JTlZBTElEX0xPR19BUkdVTUVOVCAqL106ICdGaXJzdCBhcmd1bWVudCB0byBgb25Mb2dgIG11c3QgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLicsXG4gICAgW1wiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqL106ICdFcnJvciB0aHJvd24gd2hlbiBvcGVuaW5nIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXG4gICAgW1wiaWRiLWdldFwiIC8qIEFwcEVycm9yLklEQl9HRVQgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gcmVhZGluZyBmcm9tIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXG4gICAgW1wiaWRiLXNldFwiIC8qIEFwcEVycm9yLklEQl9XUklURSAqL106ICdFcnJvciB0aHJvd24gd2hlbiB3cml0aW5nIHRvIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXG4gICAgW1wiaWRiLWRlbGV0ZVwiIC8qIEFwcEVycm9yLklEQl9ERUxFVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gZGVsZXRpbmcgZnJvbSBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxuICAgIFtcImZpbmFsaXphdGlvbi1yZWdpc3RyeS1ub3Qtc3VwcG9ydGVkXCIgLyogQXBwRXJyb3IuRklOQUxJWkFUSU9OX1JFR0lTVFJZX05PVF9TVVBQT1JURUQgKi9dOiAnRmlyZWJhc2VTZXJ2ZXJBcHAgZGVsZXRlT25EZXJlZiBmaWVsZCBkZWZpbmVkIGJ1dCB0aGUgSlMgcnVudGltZSBkb2VzIG5vdCBzdXBwb3J0IEZpbmFsaXphdGlvblJlZ2lzdHJ5LicsXG4gICAgW1wiaW52YWxpZC1zZXJ2ZXItYXBwLWVudmlyb25tZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9TRVJWRVJfQVBQX0VOVklST05NRU5UICovXTogJ0ZpcmViYXNlU2VydmVyQXBwIGlzIG5vdCBmb3IgdXNlIGluIGJyb3dzZXIgZW52aXJvbm1lbnRzLidcbn07XG5jb25zdCBFUlJPUl9GQUNUT1JZID0gbmV3IEVycm9yRmFjdG9yeSgnYXBwJywgJ0ZpcmViYXNlJywgRVJST1JTKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEZpcmViYXNlQXBwSW1wbCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5faXNEZWxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgICAgICB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPVxuICAgICAgICAgICAgY29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDb21wb25lbnQobmV3IENvbXBvbmVudCgnYXBwJywgKCkgPT4gdGhpcywgXCJQVUJMSUNcIiAvKiBDb21wb25lbnRUeXBlLlBVQkxJQyAqLykpO1xuICAgIH1cbiAgICBnZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKCkge1xuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XG4gICAgfVxuICAgIHNldCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQodmFsKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gdmFsO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgfVxuICAgIGdldCBjb25maWcoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgICB9XG4gICAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9XG4gICAgZ2V0IGlzRGVsZXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGVsZXRlZDtcbiAgICB9XG4gICAgc2V0IGlzRGVsZXRlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5faXNEZWxldGVkID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IgaWYgdGhlIEFwcCBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQgLVxuICAgICAqIHVzZSBiZWZvcmUgcGVyZm9ybWluZyBBUEkgYWN0aW9ucyBvbiB0aGUgQXBwLlxuICAgICAqL1xuICAgIGNoZWNrRGVzdHJveWVkKCkge1xuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5BUFBfREVMRVRFRCAqLywgeyBhcHBOYW1lOiB0aGlzLl9uYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gUGFyc2UgdGhlIHRva2VuIGFuZCBjaGVjayB0byBzZWUgaWYgdGhlIGBleHBgIGNsYWltIGlzIGluIHRoZSBmdXR1cmUuXG4vLyBSZXBvcnRzIGFuIGVycm9yIHRvIHRoZSBjb25zb2xlIGlmIHRoZSB0b2tlbiBvciBjbGFpbSBjb3VsZCBub3QgYmUgcGFyc2VkLCBvciBpZiBgZXhwYCBpcyBpblxuLy8gdGhlIHBhc3QuXG5mdW5jdGlvbiB2YWxpZGF0ZVRva2VuVFRMKGJhc2U2NFRva2VuLCB0b2tlbk5hbWUpIHtcbiAgICBjb25zdCBzZWNvbmRQYXJ0ID0gYmFzZTY0RGVjb2RlKGJhc2U2NFRva2VuLnNwbGl0KCcuJylbMV0pO1xuICAgIGlmIChzZWNvbmRQYXJ0ID09PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZpcmViYXNlU2VydmVyQXBwICR7dG9rZW5OYW1lfSBpcyBpbnZhbGlkOiBzZWNvbmQgcGFydCBjb3VsZCBub3QgYmUgcGFyc2VkLmApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4cENsYWltID0gSlNPTi5wYXJzZShzZWNvbmRQYXJ0KS5leHA7XG4gICAgaWYgKGV4cENsYWltID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmlyZWJhc2VTZXJ2ZXJBcHAgJHt0b2tlbk5hbWV9IGlzIGludmFsaWQ6IGV4cGlyYXRpb24gY2xhaW0gY291bGQgbm90IGJlIHBhcnNlZGApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4cCA9IEpTT04ucGFyc2Uoc2Vjb25kUGFydCkuZXhwICogMTAwMDtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCBkaWZmID0gZXhwIC0gbm93O1xuICAgIGlmIChkaWZmIDw9IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmlyZWJhc2VTZXJ2ZXJBcHAgJHt0b2tlbk5hbWV9IGlzIGludmFsaWQ6IHRoZSB0b2tlbiBoYXMgZXhwaXJlZC5gKTtcbiAgICB9XG59XG5jbGFzcyBGaXJlYmFzZVNlcnZlckFwcEltcGwgZXh0ZW5kcyBGaXJlYmFzZUFwcEltcGwge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHNlcnZlckNvbmZpZywgbmFtZSwgY29udGFpbmVyKSB7XG4gICAgICAgIC8vIEJ1aWxkIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyBmb3IgdGhlIEZpcmViYXNlQXBwSW1wbCBiYXNlIGNsYXNzLlxuICAgICAgICBjb25zdCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSBzZXJ2ZXJDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gc2VydmVyQ29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZFxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBGaXJlYmFzZUFwcFNldHRpbmdzIG9iamVjdCBmb3IgdGhlIEZpcmViYXNlQXBwSW1wIGNvbnN0cnVjdG9yLlxuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLmFwaUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIHBhcmVudCBGaXJlYmFzZUFwcEltcCBvYmplY3QuXG4gICAgICAgICAgICBzdXBlcihvcHRpb25zLCBjb25maWcsIGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhcHBJbXBsID0gb3B0aW9ucztcbiAgICAgICAgICAgIHN1cGVyKGFwcEltcGwub3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyBjb25zdHJ1Y3QgdGhlIGRhdGEgZm9yIHRoZSBGaXJlYmFzZVNlcnZlckFwcEltcGwuXG4gICAgICAgIHRoaXMuX3NlcnZlckNvbmZpZyA9IE9iamVjdC5hc3NpZ24oeyBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgfSwgc2VydmVyQ29uZmlnKTtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGN1cnJlbnQgdGltZSBpcyB3aXRoaW4gdGhlIGBhdXRoSWR0b2tlbmAgd2luZG93IG9mIHZhbGlkaXR5LlxuICAgICAgICBpZiAodGhpcy5fc2VydmVyQ29uZmlnLmF1dGhJZFRva2VuKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZVRva2VuVFRMKHRoaXMuX3NlcnZlckNvbmZpZy5hdXRoSWRUb2tlbiwgJ2F1dGhJZFRva2VuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGN1cnJlbnQgdGltZSBpcyB3aXRoaW4gdGhlIGBhcHBDaGVja1Rva2VuYCB3aW5kb3cgb2YgdmFsaWRpdHkuXG4gICAgICAgIGlmICh0aGlzLl9zZXJ2ZXJDb25maWcuYXBwQ2hlY2tUb2tlbikge1xuICAgICAgICAgICAgdmFsaWRhdGVUb2tlblRUTCh0aGlzLl9zZXJ2ZXJDb25maWcuYXBwQ2hlY2tUb2tlbiwgJ2FwcENoZWNrVG9rZW4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maW5hbGl6YXRpb25SZWdpc3RyeSA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6YXRpb25SZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvbWF0aWNDbGVhbnVwKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWZDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuaW5jUmVmQ291bnQodGhpcy5fc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmKTtcbiAgICAgICAgLy8gRG8gbm90IHJldGFpbiBhIGhhcmQgcmVmZXJlbmNlIHRvIHRoZSBkcmVmIG9iamVjdCwgb3RoZXJ3aXNlIHRoZSBGaW5hbGl6YXRpb25SZWdpc3RyeVxuICAgICAgICAvLyB3aWxsIG5ldmVyIHRyaWdnZXIuXG4gICAgICAgIHRoaXMuX3NlcnZlckNvbmZpZy5yZWxlYXNlT25EZXJlZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmID0gdW5kZWZpbmVkO1xuICAgICAgICByZWdpc3RlclZlcnNpb24obmFtZSRxLCB2ZXJzaW9uJDEsICdzZXJ2ZXJhcHAnKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgcmVmQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZDb3VudDtcbiAgICB9XG4gICAgLy8gSW5jcmVtZW50IHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBzZXJ2ZXIgYXBwLiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQsIHJlZ2lzdGVyIGl0XG4gICAgLy8gd2l0aCB0aGUgZmluYWxpemF0aW9uIHJlZ2lzdHJ5LlxuICAgIGluY1JlZkNvdW50KG9iaikge1xuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWZDb3VudCsrO1xuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmFsaXphdGlvblJlZ2lzdHJ5LnJlZ2lzdGVyKG9iaiwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRGVjcmVtZW50IHRoZSByZWZlcmVuY2UgY291bnQuXG4gICAgZGVjUmVmQ291bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0tdGhpcy5fcmVmQ291bnQ7XG4gICAgfVxuICAgIC8vIEludm9rZWQgYnkgdGhlIEZpbmFsaXphdGlvblJlZ2lzdHJ5IGNhbGxiYWNrIHRvIG5vdGUgdGhhdCB0aGlzIGFwcCBzaG91bGQgZ28gdGhyb3VnaCBpdHNcbiAgICAvLyByZWZlcmVuY2UgY291bnRzIGFuZCBkZWxldGUgaXRzZWxmIGlmIG5vIHJlZmVyZW5jZSBjb3VudCByZW1haW4uIFRoZSBjb29yZGluYXRpbmcgbG9naWMgdGhhdFxuICAgIC8vIGhhbmRsZXMgdGhpcyBpcyBpbiBkZWxldGVBcHAoLi4uKS5cbiAgICBhdXRvbWF0aWNDbGVhbnVwKCkge1xuICAgICAgICB2b2lkIGRlbGV0ZUFwcCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJ2ZXJDb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBFcnJvciBpZiB0aGUgQXBwIGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZCAtXG4gICAgICogdXNlIGJlZm9yZSBwZXJmb3JtaW5nIEFQSSBhY3Rpb25zIG9uIHRoZSBBcHAuXG4gICAgICovXG4gICAgY2hlY2tEZXN0cm95ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJzZXJ2ZXItYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5TRVJWRVJfQVBQX0RFTEVURUQgKi8pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgY3VycmVudCBTREsgdmVyc2lvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IFNES19WRVJTSU9OID0gdmVyc2lvbjtcbmZ1bmN0aW9uIGluaXRpYWxpemVBcHAoX29wdGlvbnMsIHJhd0NvbmZpZyA9IHt9KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBfb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIHJhd0NvbmZpZyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHJhd0NvbmZpZztcbiAgICAgICAgcmF3Q29uZmlnID0geyBuYW1lIH07XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oeyBuYW1lOiBERUZBVUxUX0VOVFJZX05BTUUsIGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDogZmFsc2UgfSwgcmF3Q29uZmlnKTtcbiAgICBjb25zdCBuYW1lID0gY29uZmlnLm5hbWU7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCAhbmFtZSkge1xuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImJhZC1hcHAtbmFtZVwiIC8qIEFwcEVycm9yLkJBRF9BUFBfTkFNRSAqLywge1xuICAgICAgICAgICAgYXBwTmFtZTogU3RyaW5nKG5hbWUpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0gZ2V0RGVmYXVsdEFwcENvbmZpZygpKTtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1vcHRpb25zXCIgLyogQXBwRXJyb3IuTk9fT1BUSU9OUyAqLyk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQXBwID0gX2FwcHMuZ2V0KG5hbWUpO1xuICAgIGlmIChleGlzdGluZ0FwcCkge1xuICAgICAgICAvLyByZXR1cm4gdGhlIGV4aXN0aW5nIGFwcCBpZiBvcHRpb25zIGFuZCBjb25maWcgZGVlcCBlcXVhbCB0aGUgb25lcyBpbiB0aGUgZXhpc3RpbmcgYXBwLlxuICAgICAgICBpZiAoZGVlcEVxdWFsKG9wdGlvbnMsIGV4aXN0aW5nQXBwLm9wdGlvbnMpICYmXG4gICAgICAgICAgICBkZWVwRXF1YWwoY29uZmlnLCBleGlzdGluZ0FwcC5jb25maWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdBcHA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImR1cGxpY2F0ZS1hcHBcIiAvKiBBcHBFcnJvci5EVVBMSUNBVEVfQVBQICovLCB7IGFwcE5hbWU6IG5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyID0gbmV3IENvbXBvbmVudENvbnRhaW5lcihuYW1lKTtcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xuICAgICAgICBjb250YWluZXIuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZUFwcEltcGwob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpO1xuICAgIF9hcHBzLnNldChuYW1lLCBuZXdBcHApO1xuICAgIHJldHVybiBuZXdBcHA7XG59XG5mdW5jdGlvbiBpbml0aWFsaXplU2VydmVyQXBwKF9vcHRpb25zLCBfc2VydmVyQXBwQ29uZmlnKSB7XG4gICAgaWYgKGlzQnJvd3NlcigpICYmICFpc1dlYldvcmtlcigpKSB7XG4gICAgICAgIC8vIEZpcmViYXNlU2VydmVyQXBwIGlzbid0IGRlc2lnbmVkIHRvIGJlIHJ1biBpbiBicm93c2Vycy5cbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpbnZhbGlkLXNlcnZlci1hcHAtZW52aXJvbm1lbnRcIiAvKiBBcHBFcnJvci5JTlZBTElEX1NFUlZFUl9BUFBfRU5WSVJPTk1FTlQgKi8pO1xuICAgIH1cbiAgICBpZiAoX3NlcnZlckFwcENvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBfc2VydmVyQXBwQ29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBsZXQgYXBwT3B0aW9ucztcbiAgICBpZiAoX2lzRmlyZWJhc2VBcHAoX29wdGlvbnMpKSB7XG4gICAgICAgIGFwcE9wdGlvbnMgPSBfb3B0aW9ucy5vcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXBwT3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIH1cbiAgICAvLyBCdWlsZCBhbiBhcHAgbmFtZSBiYXNlZCBvbiBhIGhhc2ggb2YgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICBjb25zdCBuYW1lT2JqID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfc2VydmVyQXBwQ29uZmlnKSwgYXBwT3B0aW9ucyk7XG4gICAgLy8gSG93ZXZlciwgRG8gbm90IG1hbmdsZSB0aGUgbmFtZSBiYXNlZCBvbiByZWxlYXNlT25EZXJlZiwgc2luY2UgaXQgd2lsbCB2YXJ5IGJldHdlZW4gdGhlXG4gICAgLy8gY29uc3RydWN0aW9uIG9mIEZpcmViYXNlU2VydmVyQXBwIGluc3RhbmNlcy4gRm9yIGV4YW1wbGUsIGlmIHRoZSBvYmplY3QgaXMgdGhlIHJlcXVlc3QgaGVhZGVycy5cbiAgICBpZiAobmFtZU9iai5yZWxlYXNlT25EZXJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSBuYW1lT2JqLnJlbGVhc2VPbkRlcmVmO1xuICAgIH1cbiAgICBjb25zdCBoYXNoQ29kZSA9IChzKSA9PiB7XG4gICAgICAgIHJldHVybiBbLi4uc10ucmVkdWNlKChoYXNoLCBjKSA9PiAoTWF0aC5pbXVsKDMxLCBoYXNoKSArIGMuY2hhckNvZGVBdCgwKSkgfCAwLCAwKTtcbiAgICB9O1xuICAgIGlmIChfc2VydmVyQXBwQ29uZmlnLnJlbGVhc2VPbkRlcmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiZmluYWxpemF0aW9uLXJlZ2lzdHJ5LW5vdC1zdXBwb3J0ZWRcIiAvKiBBcHBFcnJvci5GSU5BTElaQVRJT05fUkVHSVNUUllfTk9UX1NVUFBPUlRFRCAqLywge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5hbWVTdHJpbmcgPSAnJyArIGhhc2hDb2RlKEpTT04uc3RyaW5naWZ5KG5hbWVPYmopKTtcbiAgICBjb25zdCBleGlzdGluZ0FwcCA9IF9zZXJ2ZXJBcHBzLmdldChuYW1lU3RyaW5nKTtcbiAgICBpZiAoZXhpc3RpbmdBcHApIHtcbiAgICAgICAgZXhpc3RpbmdBcHAuaW5jUmVmQ291bnQoX3NlcnZlckFwcENvbmZpZy5yZWxlYXNlT25EZXJlZik7XG4gICAgICAgIHJldHVybiBleGlzdGluZ0FwcDtcbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyID0gbmV3IENvbXBvbmVudENvbnRhaW5lcihuYW1lU3RyaW5nKTtcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xuICAgICAgICBjb250YWluZXIuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZVNlcnZlckFwcEltcGwoYXBwT3B0aW9ucywgX3NlcnZlckFwcENvbmZpZywgbmFtZVN0cmluZywgY29udGFpbmVyKTtcbiAgICBfc2VydmVyQXBwcy5zZXQobmFtZVN0cmluZywgbmV3QXBwKTtcbiAgICByZXR1cm4gbmV3QXBwO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgYSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gaW5zdGFuY2UuXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIHRoZSBkZWZhdWx0IGFwcCBpcyByZXR1cm5lZC4gV2hlbiBhbiBhcHAgbmFtZVxuICogaXMgcHJvdmlkZWQsIHRoZSBhcHAgY29ycmVzcG9uZGluZyB0byB0aGF0IG5hbWUgaXMgcmV0dXJuZWQuXG4gKlxuICogQW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiB0aGUgYXBwIGJlaW5nIHJldHJpZXZlZCBoYXMgbm90IHlldCBiZWVuXG4gKiBpbml0aWFsaXplZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gUmV0dXJuIHRoZSBkZWZhdWx0IGFwcFxuICogY29uc3QgYXBwID0gZ2V0QXBwKCk7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gUmV0dXJuIGEgbmFtZWQgYXBwXG4gKiBjb25zdCBvdGhlckFwcCA9IGdldEFwcChcIm90aGVyQXBwXCIpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgLSBPcHRpb25hbCBuYW1lIG9mIHRoZSBhcHAgdG8gcmV0dXJuLiBJZiBubyBuYW1lIGlzXG4gKiAgIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBpcyBgXCJbREVGQVVMVF1cImAuXG4gKlxuICogQHJldHVybnMgVGhlIGFwcCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBhcHAgbmFtZS5cbiAqICAgSWYgbm8gYXBwIG5hbWUgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGFwcCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldEFwcChuYW1lID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgY29uc3QgYXBwID0gX2FwcHMuZ2V0KG5hbWUpO1xuICAgIGlmICghYXBwICYmIG5hbWUgPT09IERFRkFVTFRfRU5UUllfTkFNRSAmJiBnZXREZWZhdWx0QXBwQ29uZmlnKCkpIHtcbiAgICAgICAgcmV0dXJuIGluaXRpYWxpemVBcHAoKTtcbiAgICB9XG4gICAgaWYgKCFhcHApIHtcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1hcHBcIiAvKiBBcHBFcnJvci5OT19BUFAgKi8sIHsgYXBwTmFtZTogbmFtZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFwcDtcbn1cbi8qKlxuICogQSAocmVhZC1vbmx5KSBhcnJheSBvZiBhbGwgaW5pdGlhbGl6ZWQgYXBwcy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZ2V0QXBwcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShfYXBwcy52YWx1ZXMoKSk7XG59XG4vKipcbiAqIFJlbmRlcnMgdGhpcyBhcHAgdW51c2FibGUgYW5kIGZyZWVzIHRoZSByZXNvdXJjZXMgb2YgYWxsIGFzc29jaWF0ZWRcbiAqIHNlcnZpY2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBkZWxldGVBcHAoYXBwKVxuICogICAudGhlbihmdW5jdGlvbigpIHtcbiAqICAgICBjb25zb2xlLmxvZyhcIkFwcCBkZWxldGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAqICAgfSlcbiAqICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJFcnJvciBkZWxldGluZyBhcHA6XCIsIGVycm9yKTtcbiAqICAgfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFwcChhcHApIHtcbiAgICBsZXQgY2xlYW51cFByb3ZpZGVycyA9IGZhbHNlO1xuICAgIGNvbnN0IG5hbWUgPSBhcHAubmFtZTtcbiAgICBpZiAoX2FwcHMuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNsZWFudXBQcm92aWRlcnMgPSB0cnVlO1xuICAgICAgICBfYXBwcy5kZWxldGUobmFtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKF9zZXJ2ZXJBcHBzLmhhcyhuYW1lKSkge1xuICAgICAgICBjb25zdCBmaXJlYmFzZVNlcnZlckFwcCA9IGFwcDtcbiAgICAgICAgaWYgKGZpcmViYXNlU2VydmVyQXBwLmRlY1JlZkNvdW50KCkgPD0gMCkge1xuICAgICAgICAgICAgX3NlcnZlckFwcHMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgY2xlYW51cFByb3ZpZGVycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsZWFudXBQcm92aWRlcnMpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYXBwLmNvbnRhaW5lclxuICAgICAgICAgICAgLmdldFByb3ZpZGVycygpXG4gICAgICAgICAgICAubWFwKHByb3ZpZGVyID0+IHByb3ZpZGVyLmRlbGV0ZSgpKSk7XG4gICAgICAgIGFwcC5pc0RlbGV0ZWQgPSB0cnVlO1xuICAgIH1cbn1cbi8qKlxuICogUmVnaXN0ZXJzIGEgbGlicmFyeSdzIG5hbWUgYW5kIHZlcnNpb24gZm9yIHBsYXRmb3JtIGxvZ2dpbmcgcHVycG9zZXMuXG4gKiBAcGFyYW0gbGlicmFyeSAtIE5hbWUgb2YgMXAgb3IgM3AgbGlicmFyeSAoZS5nLiBmaXJlc3RvcmUsIGFuZ3VsYXJmaXJlKVxuICogQHBhcmFtIHZlcnNpb24gLSBDdXJyZW50IHZlcnNpb24gb2YgdGhhdCBsaWJyYXJ5LlxuICogQHBhcmFtIHZhcmlhbnQgLSBCdW5kbGUgdmFyaWFudCwgZS5nLiwgbm9kZSwgcm4sIGV0Yy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyVmVyc2lvbihsaWJyYXJ5S2V5T3JOYW1lLCB2ZXJzaW9uLCB2YXJpYW50KSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIFRPRE86IFdlIGNhbiB1c2UgdGhpcyBjaGVjayB0byB3aGl0ZWxpc3Qgc3RyaW5ncyB3aGVuL2lmIHdlIHNldCB1cFxuICAgIC8vIGEgZ29vZCB3aGl0ZWxpc3Qgc3lzdGVtLlxuICAgIGxldCBsaWJyYXJ5ID0gKF9hID0gUExBVEZPUk1fTE9HX1NUUklOR1tsaWJyYXJ5S2V5T3JOYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbGlicmFyeUtleU9yTmFtZTtcbiAgICBpZiAodmFyaWFudCkge1xuICAgICAgICBsaWJyYXJ5ICs9IGAtJHt2YXJpYW50fWA7XG4gICAgfVxuICAgIGNvbnN0IGxpYnJhcnlNaXNtYXRjaCA9IGxpYnJhcnkubWF0Y2goL1xcc3xcXC8vKTtcbiAgICBjb25zdCB2ZXJzaW9uTWlzbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKC9cXHN8XFwvLyk7XG4gICAgaWYgKGxpYnJhcnlNaXNtYXRjaCB8fCB2ZXJzaW9uTWlzbWF0Y2gpIHtcbiAgICAgICAgY29uc3Qgd2FybmluZyA9IFtcbiAgICAgICAgICAgIGBVbmFibGUgdG8gcmVnaXN0ZXIgbGlicmFyeSBcIiR7bGlicmFyeX1cIiB3aXRoIHZlcnNpb24gXCIke3ZlcnNpb259XCI6YFxuICAgICAgICBdO1xuICAgICAgICBpZiAobGlicmFyeU1pc21hdGNoKSB7XG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goYGxpYnJhcnkgbmFtZSBcIiR7bGlicmFyeX1cIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMgKHdoaXRlc3BhY2Ugb3IgXCIvXCIpYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpYnJhcnlNaXNtYXRjaCAmJiB2ZXJzaW9uTWlzbWF0Y2gpIHtcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaCgnYW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcnNpb25NaXNtYXRjaCkge1xuICAgICAgICAgICAgd2FybmluZy5wdXNoKGB2ZXJzaW9uIG5hbWUgXCIke3ZlcnNpb259XCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzICh3aGl0ZXNwYWNlIG9yIFwiL1wiKWApO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci53YXJuKHdhcm5pbmcuam9pbignICcpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudChgJHtsaWJyYXJ5fS12ZXJzaW9uYCwgKCkgPT4gKHsgbGlicmFyeSwgdmVyc2lvbiB9KSwgXCJWRVJTSU9OXCIgLyogQ29tcG9uZW50VHlwZS5WRVJTSU9OICovKSk7XG59XG4vKipcbiAqIFNldHMgbG9nIGhhbmRsZXIgZm9yIGFsbCBGaXJlYmFzZSBTREtzLlxuICogQHBhcmFtIGxvZ0NhbGxiYWNrIC0gQW4gb3B0aW9uYWwgY3VzdG9tIGxvZyBoYW5kbGVyIHRoYXQgZXhlY3V0ZXMgdXNlciBjb2RlIHdoZW5ldmVyXG4gKiB0aGUgRmlyZWJhc2UgU0RLIG1ha2VzIGEgbG9nZ2luZyBjYWxsLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gb25Mb2cobG9nQ2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAobG9nQ2FsbGJhY2sgIT09IG51bGwgJiYgdHlwZW9mIGxvZ0NhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW52YWxpZC1sb2ctYXJndW1lbnRcIiAvKiBBcHBFcnJvci5JTlZBTElEX0xPR19BUkdVTUVOVCAqLyk7XG4gICAgfVxuICAgIHNldFVzZXJMb2dIYW5kbGVyKGxvZ0NhbGxiYWNrLCBvcHRpb25zKTtcbn1cbi8qKlxuICogU2V0cyBsb2cgbGV2ZWwgZm9yIGFsbCBGaXJlYmFzZSBTREtzLlxuICpcbiAqIEFsbCBvZiB0aGUgbG9nIHR5cGVzIGFib3ZlIHRoZSBjdXJyZW50IGxvZyBsZXZlbCBhcmUgY2FwdHVyZWQgKGkuZS4gaWZcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgaW5mb2AsIGVycm9ycyBhcmUgbG9nZ2VkLCBidXQgYGRlYnVnYCBhbmRcbiAqIGB2ZXJib3NlYCBsb2dzIGFyZSBub3QpLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobG9nTGV2ZWwpIHtcbiAgICBzZXRMb2dMZXZlbCQxKGxvZ0xldmVsKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERCX05BTUUgPSAnZmlyZWJhc2UtaGVhcnRiZWF0LWRhdGFiYXNlJztcbmNvbnN0IERCX1ZFUlNJT04gPSAxO1xuY29uc3QgU1RPUkVfTkFNRSA9ICdmaXJlYmFzZS1oZWFydGJlYXQtc3RvcmUnO1xubGV0IGRiUHJvbWlzZSA9IG51bGw7XG5mdW5jdGlvbiBnZXREYlByb21pc2UoKSB7XG4gICAgaWYgKCFkYlByb21pc2UpIHtcbiAgICAgICAgZGJQcm9taXNlID0gb3BlbkRCKERCX05BTUUsIERCX1ZFUlNJT04sIHtcbiAgICAgICAgICAgIHVwZ3JhZGU6IChkYiwgb2xkVmVyc2lvbikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHVzZSAnYnJlYWsnIGluIHRoaXMgc3dpdGNoIHN0YXRlbWVudCwgdGhlIGZhbGwtdGhyb3VnaFxuICAgICAgICAgICAgICAgIC8vIGJlaGF2aW9yIGlzIHdoYXQgd2Ugd2FudCwgYmVjYXVzZSBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgdmVyc2lvbnMgYmV0d2VlblxuICAgICAgICAgICAgICAgIC8vIHRoZSBvbGQgdmVyc2lvbiBhbmQgdGhlIGN1cnJlbnQgdmVyc2lvbiwgd2Ugd2FudCBBTEwgdGhlIG1pZ3JhdGlvbnNcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhvc2UgdmVyc2lvbnMgdG8gcnVuLCBub3Qgb25seSB0aGUgbGFzdCBvbmUuXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgICAgICAgICAgICAgIHN3aXRjaCAob2xkVmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkvaU9TIGJyb3dzZXJzIHRocm93IG9jY2FzaW9uYWwgZXhjZXB0aW9ucyBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRiLmNyZWF0ZU9iamVjdFN0b3JlKCkgdGhhdCBtYXkgYmUgYSBidWcuIEF2b2lkIGJsb2NraW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlc3Qgb2YgdGhlIGFwcCBmdW5jdGlvbmFsaXR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpZGItb3BlblwiIC8qIEFwcEVycm9yLklEQl9PUEVOICovLCB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvck1lc3NhZ2U6IGUubWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGJQcm9taXNlO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKGFwcCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHR4Lm9iamVjdFN0b3JlKFNUT1JFX05BTUUpLmdldChjb21wdXRlS2V5KGFwcCkpO1xuICAgICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgdGhlIHZhbHVlIGJ1dCB0eC5kb25lIGNhbiB0aHJvdyxcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byBhd2FpdCBpdCBoZXJlIHRvIGNhdGNoIGVycm9yc1xuICAgICAgICBhd2FpdCB0eC5kb25lO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpZGJHZXRFcnJvciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLWdldFwiIC8qIEFwcEVycm9yLklEQl9HRVQgKi8sIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQihhcHAsIGhlYXJ0YmVhdE9iamVjdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICBjb25zdCBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xuICAgICAgICBhd2FpdCBvYmplY3RTdG9yZS5wdXQoaGVhcnRiZWF0T2JqZWN0LCBjb21wdXRlS2V5KGFwcCkpO1xuICAgICAgICBhd2FpdCB0eC5kb25lO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpZGJHZXRFcnJvciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLXNldFwiIC8qIEFwcEVycm9yLklEQl9XUklURSAqLywge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2dnZXIud2FybihpZGJHZXRFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVLZXkoYXBwKSB7XG4gICAgcmV0dXJuIGAke2FwcC5uYW1lfSEke2FwcC5vcHRpb25zLmFwcElkfWA7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBNQVhfSEVBREVSX0JZVEVTID0gMTAyNDtcbmNvbnN0IE1BWF9OVU1fU1RPUkVEX0hFQVJUQkVBVFMgPSAzMDtcbmNsYXNzIEhlYXJ0YmVhdFNlcnZpY2VJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbi1tZW1vcnkgY2FjaGUgZm9yIGhlYXJ0YmVhdHMsIHVzZWQgYnkgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIHRvIGdlbmVyYXRlXG4gICAgICAgICAqIHRoZSBoZWFkZXIgc3RyaW5nLlxuICAgICAgICAgKiBTdG9yZXMgb25lIHJlY29yZCBwZXIgZGF0ZS4gVGhpcyB3aWxsIGJlIGNvbnNvbGlkYXRlZCBpbnRvIHRoZSBzdGFuZGFyZFxuICAgICAgICAgKiBmb3JtYXQgb2Ygb25lIHJlY29yZCBwZXIgdXNlciBhZ2VudCBzdHJpbmcgYmVmb3JlIGJlaW5nIHNlbnQgYXMgYSBoZWFkZXIuXG4gICAgICAgICAqIFBvcHVsYXRlZCBmcm9tIGluZGV4ZWREQiB3aGVuIHRoZSBjb250cm9sbGVyIGlzIGluc3RhbnRpYXRlZCBhbmQgc2hvdWxkXG4gICAgICAgICAqIGJlIGtlcHQgaW4gc3luYyB3aXRoIGluZGV4ZWREQi5cbiAgICAgICAgICogTGVhdmUgcHVibGljIGZvciBlYXNpZXIgdGVzdGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGFwcCA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgdGhpcy5fc3RvcmFnZSA9IG5ldyBIZWFydGJlYXRTdG9yYWdlSW1wbChhcHApO1xuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGVQcm9taXNlID0gdGhpcy5fc3RvcmFnZS5yZWFkKCkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byByZXBvcnQgYSBoZWFydGJlYXQuIFRoZSBmdW5jdGlvbiB3aWxsIGdlbmVyYXRlXG4gICAgICogYSBIZWFydGJlYXRzQnlVc2VyQWdlbnQgb2JqZWN0LCB1cGRhdGUgaGVhcnRiZWF0c0NhY2hlLCBhbmQgcGVyc2lzdCBpdFxuICAgICAqIHRvIEluZGV4ZWREQi5cbiAgICAgKiBOb3RlIHRoYXQgd2Ugb25seSBzdG9yZSBvbmUgaGVhcnRiZWF0IHBlciBkYXkuIFNvIGlmIGEgaGVhcnRiZWF0IGZvciB0b2RheSBpc1xuICAgICAqIGFscmVhZHkgbG9nZ2VkLCBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoaXMgZnVuY3Rpb24gaW4gdGhlIHNhbWUgZGF5IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKi9cbiAgICBhc3luYyB0cmlnZ2VySGVhcnRiZWF0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGxhdGZvcm1Mb2dnZXIgPSB0aGlzLmNvbnRhaW5lclxuICAgICAgICAgICAgICAgIC5nZXRQcm92aWRlcigncGxhdGZvcm0tbG9nZ2VyJylcbiAgICAgICAgICAgICAgICAuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBcIkZpcmViYXNlIHVzZXIgYWdlbnRcIiBzdHJpbmcgZnJvbSB0aGUgcGxhdGZvcm0gbG9nZ2VyXG4gICAgICAgICAgICAvLyBzZXJ2aWNlLCBub3QgdGhlIGJyb3dzZXIgdXNlciBhZ2VudC5cbiAgICAgICAgICAgIGNvbnN0IGFnZW50ID0gcGxhdGZvcm1Mb2dnZXIuZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gZ2V0VVRDRGF0ZVN0cmluZygpO1xuICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFydGJlYXRzKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBmYWlsZWQgdG8gY29uc3RydWN0IGEgaGVhcnRiZWF0cyBjYWNoZSwgdGhlbiByZXR1cm4gaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgaWYgKCgoX2IgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWFydGJlYXRzKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEbyBub3Qgc3RvcmUgYSBoZWFydGJlYXQgaWYgb25lIGlzIGFscmVhZHkgc3RvcmVkIGZvciB0aGlzIGRheVxuICAgICAgICAgICAgLy8gb3IgaWYgYSBoZWFkZXIgaGFzIGFscmVhZHkgYmVlbiBzZW50IHRvZGF5LlxuICAgICAgICAgICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPT09IGRhdGUgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5zb21lKHNpbmdsZURhdGVIZWFydGJlYXQgPT4gc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlID09PSBkYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGVudHJ5IGZvciB0aGlzIGRhdGUuIENyZWF0ZSBvbmUuXG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMucHVzaCh7IGRhdGUsIGFnZW50IH0pO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBudW1iZXIgb2Ygc3RvcmVkIGhlYXJ0YmVhdHMgZXhjZWVkcyB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc3RvcmVkIGhlYXJ0YmVhdHMsIHJlbW92ZSB0aGUgaGVhcnRiZWF0IHdpdGggdGhlIGVhcmxpZXN0IGRhdGUuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBleGVjdXRlZCBlYWNoIHRpbWUgYSBoZWFydGJlYXQgaXMgcHVzaGVkLCB0aGUgbGltaXQgY2FuIG9ubHkgYmUgZXhjZWVkZWQgYnkgb25lLCBzbyBvbmx5IG9uZSBuZWVkcyB0byBiZSByZW1vdmVkLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5sZW5ndGggPiBNQVhfTlVNX1NUT1JFRF9IRUFSVEJFQVRTKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVhcmxpZXN0SGVhcnRiZWF0SWR4ID0gZ2V0RWFybGllc3RIZWFydGJlYXRJZHgodGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5zcGxpY2UoZWFybGllc3RIZWFydGJlYXRJZHgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHdoaWNoIGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgaGVhcnRiZWF0LXNwZWNpZmljIGhlYWRlciBkaXJlY3RseS5cbiAgICAgKiBJdCBhbHNvIGNsZWFycyBhbGwgaGVhcnRiZWF0cyBmcm9tIG1lbW9yeSBhcyB3ZWxsIGFzIGluIEluZGV4ZWREQi5cbiAgICAgKlxuICAgICAqIE5PVEU6IENvbnN1bWluZyBwcm9kdWN0IFNES3Mgc2hvdWxkIG5vdCBzZW5kIHRoZSBoZWFkZXIgaWYgdGhpcyBtZXRob2RcbiAgICAgKiByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRIZWFydGJlYXRzSGVhZGVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGVhcnRiZWF0c0NhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGl0J3Mgc3RpbGwgbnVsbCBvciB0aGUgYXJyYXkgaXMgZW1wdHksIHRoZXJlIGlzIG5vIGRhdGEgdG8gc2VuZC5cbiAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhcnRiZWF0cykgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBnZXRVVENEYXRlU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IGFzIG1hbnkgaGVhcnRiZWF0cyBmcm9tIHRoZSBjYWNoZSBhcyB3aWxsIGZpdCB1bmRlciB0aGUgc2l6ZSBsaW1pdC5cbiAgICAgICAgICAgIGNvbnN0IHsgaGVhcnRiZWF0c1RvU2VuZCwgdW5zZW50RW50cmllcyB9ID0gZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIodGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMpO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyU3RyaW5nID0gYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkoeyB2ZXJzaW9uOiAyLCBoZWFydGJlYXRzOiBoZWFydGJlYXRzVG9TZW5kIH0pKTtcbiAgICAgICAgICAgIC8vIFN0b3JlIGxhc3Qgc2VudCBkYXRlIHRvIHByZXZlbnQgYW5vdGhlciBiZWluZyBsb2dnZWQvc2VudCBmb3IgdGhlIHNhbWUgZGF5LlxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA9IGRhdGU7XG4gICAgICAgICAgICBpZiAodW5zZW50RW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgYW55IHVuc2VudCBlbnRyaWVzIGlmIHRoZXkgZXhpc3QuXG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPSB1bnNlbnRFbnRyaWVzO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2VlbXMgbW9yZSBsaWtlbHkgdGhhbiBlbXB0eWluZyB0aGUgYXJyYXkgKGJlbG93KSB0byBsZWFkIHRvIHNvbWUgb2RkIHN0YXRlXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGNhY2hlIGlzbid0IGVtcHR5IGFuZCB0aGlzIHdpbGwgYmUgY2FsbGVkIGFnYWluIG9uIHRoZSBuZXh0IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgLy8gYW5kIGlzIHByb2JhYmx5IHNhZmVzdCBpZiB3ZSBhd2FpdCBpdC5cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3Qgd2FpdCBmb3IgdGhpcywgdG8gcmVkdWNlIGxhdGVuY3kuXG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhlYWRlclN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZSk7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRVVENEYXRlU3RyaW5nKCkge1xuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAvLyBSZXR1cm5zIGRhdGUgZm9ybWF0ICdZWVlZLU1NLUREJ1xuICAgIHJldHVybiB0b2RheS50b0lTT1N0cmluZygpLnN1YnN0cmluZygwLCAxMCk7XG59XG5mdW5jdGlvbiBleHRyYWN0SGVhcnRiZWF0c0ZvckhlYWRlcihoZWFydGJlYXRzQ2FjaGUsIG1heFNpemUgPSBNQVhfSEVBREVSX0JZVEVTKSB7XG4gICAgLy8gSGVhcnRiZWF0cyBncm91cGVkIGJ5IHVzZXIgYWdlbnQgaW4gdGhlIHN0YW5kYXJkIGZvcm1hdCB0byBiZSBzZW50IGluXG4gICAgLy8gdGhlIGhlYWRlci5cbiAgICBjb25zdCBoZWFydGJlYXRzVG9TZW5kID0gW107XG4gICAgLy8gU2luZ2xlIGRhdGUgZm9ybWF0IGhlYXJ0YmVhdHMgdGhhdCBhcmUgbm90IHNlbnQuXG4gICAgbGV0IHVuc2VudEVudHJpZXMgPSBoZWFydGJlYXRzQ2FjaGUuc2xpY2UoKTtcbiAgICBmb3IgKGNvbnN0IHNpbmdsZURhdGVIZWFydGJlYXQgb2YgaGVhcnRiZWF0c0NhY2hlKSB7XG4gICAgICAgIC8vIExvb2sgZm9yIGFuIGV4aXN0aW5nIGVudHJ5IHdpdGggdGhlIHNhbWUgdXNlciBhZ2VudC5cbiAgICAgICAgY29uc3QgaGVhcnRiZWF0RW50cnkgPSBoZWFydGJlYXRzVG9TZW5kLmZpbmQoaGIgPT4gaGIuYWdlbnQgPT09IHNpbmdsZURhdGVIZWFydGJlYXQuYWdlbnQpO1xuICAgICAgICBpZiAoIWhlYXJ0YmVhdEVudHJ5KSB7XG4gICAgICAgICAgICAvLyBJZiBubyBlbnRyeSBmb3IgdGhpcyB1c2VyIGFnZW50IGV4aXN0cywgY3JlYXRlIG9uZS5cbiAgICAgICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQucHVzaCh7XG4gICAgICAgICAgICAgICAgYWdlbnQ6IHNpbmdsZURhdGVIZWFydGJlYXQuYWdlbnQsXG4gICAgICAgICAgICAgICAgZGF0ZXM6IFtzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGVdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb3VudEJ5dGVzKGhlYXJ0YmVhdHNUb1NlbmQpID4gbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBoZWFkZXIgd291bGQgZXhjZWVkIG1heCBzaXplLCByZW1vdmUgdGhlIGFkZGVkIGhlYXJ0YmVhdFxuICAgICAgICAgICAgICAgIC8vIGVudHJ5IGFuZCBzdG9wIGFkZGluZyB0byB0aGUgaGVhZGVyLlxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQucG9wKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWFydGJlYXRFbnRyeS5kYXRlcy5wdXNoKHNpbmdsZURhdGVIZWFydGJlYXQuZGF0ZSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgaGVhZGVyIHdvdWxkIGV4Y2VlZCBtYXggc2l6ZSwgcmVtb3ZlIHRoZSBhZGRlZCBkYXRlXG4gICAgICAgICAgICAvLyBhbmQgc3RvcCBhZGRpbmcgdG8gdGhlIGhlYWRlci5cbiAgICAgICAgICAgIGlmIChjb3VudEJ5dGVzKGhlYXJ0YmVhdHNUb1NlbmQpID4gbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdEVudHJ5LmRhdGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFBvcCB1bnNlbnQgZW50cnkgZnJvbSBxdWV1ZS4gKFNraXBwZWQgaWYgYWRkaW5nIHRoZSBlbnRyeSBleGNlZWRlZFxuICAgICAgICAvLyBxdW90YSBhbmQgdGhlIGxvb3AgYnJlYWtzIGVhcmx5LilcbiAgICAgICAgdW5zZW50RW50cmllcyA9IHVuc2VudEVudHJpZXMuc2xpY2UoMSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQsXG4gICAgICAgIHVuc2VudEVudHJpZXNcbiAgICB9O1xufVxuY2xhc3MgSGVhcnRiZWF0U3RvcmFnZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKGFwcCkge1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZSA9IHRoaXMucnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjaygpO1xuICAgIH1cbiAgICBhc3luYyBydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCkge1xuICAgICAgICBpZiAoIWlzSW5kZXhlZERCQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlKClcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0cnVlKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhbGwgaGVhcnRiZWF0cy5cbiAgICAgKi9cbiAgICBhc3luYyByZWFkKCkge1xuICAgICAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xuICAgICAgICAgICAgcmV0dXJuIHsgaGVhcnRiZWF0czogW10gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlkYkhlYXJ0YmVhdE9iamVjdCA9IGF3YWl0IHJlYWRIZWFydGJlYXRzRnJvbUluZGV4ZWREQih0aGlzLmFwcCk7XG4gICAgICAgICAgICBpZiAoaWRiSGVhcnRiZWF0T2JqZWN0ID09PSBudWxsIHx8IGlkYkhlYXJ0YmVhdE9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaWRiSGVhcnRiZWF0T2JqZWN0LmhlYXJ0YmVhdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWRiSGVhcnRiZWF0T2JqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaGVhcnRiZWF0czogW10gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBvdmVyd3JpdGUgdGhlIHN0b3JhZ2Ugd2l0aCB0aGUgcHJvdmlkZWQgaGVhcnRiZWF0c1xuICAgIGFzeW5jIG92ZXJ3cml0ZShoZWFydGJlYXRzT2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCA9IGF3YWl0IHRoaXMucmVhZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKHRoaXMuYXBwLCB7XG4gICAgICAgICAgICAgICAgbGFzdFNlbnRIZWFydGJlYXREYXRlOiAoX2EgPSBoZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSxcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzOiBoZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBoZWFydGJlYXRzXG4gICAgYXN5bmMgYWRkKGhlYXJ0YmVhdHNPYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0ID0gYXdhaXQgdGhpcy5yZWFkKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVIZWFydGJlYXRzVG9JbmRleGVkREIodGhpcy5hcHAsIHtcbiAgICAgICAgICAgICAgICBsYXN0U2VudEhlYXJ0YmVhdERhdGU6IChfYSA9IGhlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlLFxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHM6IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHMsXG4gICAgICAgICAgICAgICAgICAgIC4uLmhlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0c1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDYWxjdWxhdGUgYnl0ZXMgb2YgYSBIZWFydGJlYXRzQnlVc2VyQWdlbnQgYXJyYXkgYWZ0ZXIgYmVpbmcgd3JhcHBlZFxuICogaW4gYSBwbGF0Zm9ybSBsb2dnaW5nIGhlYWRlciBKU09OIG9iamVjdCwgc3RyaW5naWZpZWQsIGFuZCBjb252ZXJ0ZWRcbiAqIHRvIGJhc2UgNjQuXG4gKi9cbmZ1bmN0aW9uIGNvdW50Qnl0ZXMoaGVhcnRiZWF0c0NhY2hlKSB7XG4gICAgLy8gYmFzZTY0IGhhcyBhIHJlc3RyaWN0ZWQgc2V0IG9mIGNoYXJhY3RlcnMsIGFsbCBvZiB3aGljaCBzaG91bGQgYmUgMSBieXRlLlxuICAgIHJldHVybiBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhcbiAgICAvLyBoZWFydGJlYXRzQ2FjaGUgd3JhcHBlciBwcm9wZXJ0aWVzXG4gICAgSlNPTi5zdHJpbmdpZnkoeyB2ZXJzaW9uOiAyLCBoZWFydGJlYXRzOiBoZWFydGJlYXRzQ2FjaGUgfSkpLmxlbmd0aDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGhlYXJ0YmVhdCB3aXRoIHRoZSBlYXJsaWVzdCBkYXRlLlxuICogSWYgdGhlIGhlYXJ0YmVhdHMgYXJyYXkgaXMgZW1wdHksIC0xIGlzIHJldHVybmVkLlxuICovXG5mdW5jdGlvbiBnZXRFYXJsaWVzdEhlYXJ0YmVhdElkeChoZWFydGJlYXRzKSB7XG4gICAgaWYgKGhlYXJ0YmVhdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgbGV0IGVhcmxpZXN0SGVhcnRiZWF0SWR4ID0gMDtcbiAgICBsZXQgZWFybGllc3RIZWFydGJlYXREYXRlID0gaGVhcnRiZWF0c1swXS5kYXRlO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaGVhcnRiZWF0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaGVhcnRiZWF0c1tpXS5kYXRlIDwgZWFybGllc3RIZWFydGJlYXREYXRlKSB7XG4gICAgICAgICAgICBlYXJsaWVzdEhlYXJ0YmVhdERhdGUgPSBoZWFydGJlYXRzW2ldLmRhdGU7XG4gICAgICAgICAgICBlYXJsaWVzdEhlYXJ0YmVhdElkeCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVhcmxpZXN0SGVhcnRiZWF0SWR4O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDb3JlQ29tcG9uZW50cyh2YXJpYW50KSB7XG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ3BsYXRmb3JtLWxvZ2dlcicsIGNvbnRhaW5lciA9PiBuZXcgUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlSW1wbChjb250YWluZXIpLCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pKTtcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgnaGVhcnRiZWF0JywgY29udGFpbmVyID0+IG5ldyBIZWFydGJlYXRTZXJ2aWNlSW1wbChjb250YWluZXIpLCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pKTtcbiAgICAvLyBSZWdpc3RlciBgYXBwYCBwYWNrYWdlLlxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJHEsIHZlcnNpb24kMSwgdmFyaWFudCk7XG4gICAgLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtMjAxNywgY2pzMjAxNywgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cbiAgICByZWdpc3RlclZlcnNpb24obmFtZSRxLCB2ZXJzaW9uJDEsICdlc20yMDE3Jyk7XG4gICAgLy8gUmVnaXN0ZXIgcGxhdGZvcm0gU0RLIGlkZW50aWZpZXIgKG5vIHZlcnNpb24pLlxuICAgIHJlZ2lzdGVyVmVyc2lvbignZmlyZS1qcycsICcnKTtcbn1cblxuLyoqXG4gKiBGaXJlYmFzZSBBcHBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIHBhY2thZ2UgY29vcmRpbmF0ZXMgdGhlIGNvbW11bmljYXRpb24gYmV0d2VlbiB0aGUgZGlmZmVyZW50IEZpcmViYXNlIGNvbXBvbmVudHNcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5yZWdpc3RlckNvcmVDb21wb25lbnRzKCcnKTtcblxuZXhwb3J0IHsgU0RLX1ZFUlNJT04sIERFRkFVTFRfRU5UUllfTkFNRSBhcyBfREVGQVVMVF9FTlRSWV9OQU1FLCBfYWRkQ29tcG9uZW50LCBfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQsIF9hcHBzLCBfY2xlYXJDb21wb25lbnRzLCBfY29tcG9uZW50cywgX2dldFByb3ZpZGVyLCBfaXNGaXJlYmFzZUFwcCwgX2lzRmlyZWJhc2VTZXJ2ZXJBcHAsIF9yZWdpc3RlckNvbXBvbmVudCwgX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSwgX3NlcnZlckFwcHMsIGRlbGV0ZUFwcCwgZ2V0QXBwLCBnZXRBcHBzLCBpbml0aWFsaXplQXBwLCBpbml0aWFsaXplU2VydmVyQXBwLCBvbkxvZywgcmVnaXN0ZXJWZXJzaW9uLCBzZXRMb2dMZXZlbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@firebase/app/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@firebase/component/dist/esm/index.esm2017.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@firebase/component/dist/esm/index.esm2017.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ Component),\n/* harmony export */   ComponentContainer: () => (/* binding */ ComponentContainer),\n/* harmony export */   Provider: () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/../node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n\n\n/**\n * Component for service name T, e.g. `auth`, `auth-internal`\n */\nclass Component {\n    /**\n     *\n     * @param name The public service name, e.g. app, auth, firestore, database\n     * @param instanceFactory Service factory responsible for creating the public interface\n     * @param type whether the service provided by the component is public or private\n     */\n    constructor(name, instanceFactory, type) {\n        this.name = name;\n        this.instanceFactory = instanceFactory;\n        this.type = type;\n        this.multipleInstances = false;\n        /**\n         * Properties to be added to the service namespace\n         */\n        this.serviceProps = {};\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */;\n        this.onInstanceCreated = null;\n    }\n    setInstantiationMode(mode) {\n        this.instantiationMode = mode;\n        return this;\n    }\n    setMultipleInstances(multipleInstances) {\n        this.multipleInstances = multipleInstances;\n        return this;\n    }\n    setServiceProps(props) {\n        this.serviceProps = props;\n        return this;\n    }\n    setInstanceCreatedCallback(callback) {\n        this.onInstanceCreated = callback;\n        return this;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\n * NameServiceMapping[T] is an alias for the type of the instance\n */\nclass Provider {\n    constructor(name, container) {\n        this.name = name;\n        this.container = container;\n        this.component = null;\n        this.instances = new Map();\n        this.instancesDeferred = new Map();\n        this.instancesOptions = new Map();\n        this.onInitCallbacks = new Map();\n    }\n    /**\n     * @param identifier A provider can provide multiple instances of a service\n     * if this.component.multipleInstances is true.\n     */\n    get(identifier) {\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\n            const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\n            if (this.isInitialized(normalizedIdentifier) ||\n                this.shouldAutoInitialize()) {\n                // initialize the service if it can be auto-initialized\n                try {\n                    const instance = this.getOrInitializeService({\n                        instanceIdentifier: normalizedIdentifier\n                    });\n                    if (instance) {\n                        deferred.resolve(instance);\n                    }\n                }\n                catch (e) {\n                    // when the instance factory throws an exception during get(), it should not cause\n                    // a fatal error. We just return the unresolved promise in this case.\n                }\n            }\n        }\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\n    }\n    getImmediate(options) {\n        var _a;\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n        if (this.isInitialized(normalizedIdentifier) ||\n            this.shouldAutoInitialize()) {\n            try {\n                return this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n            }\n            catch (e) {\n                if (optional) {\n                    return null;\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        else {\n            // In case a component is not initialized and should/cannot be auto-initialized at the moment, return null if the optional flag is set, or throw\n            if (optional) {\n                return null;\n            }\n            else {\n                throw Error(`Service ${this.name} is not available`);\n            }\n        }\n    }\n    getComponent() {\n        return this.component;\n    }\n    setComponent(component) {\n        if (component.name !== this.name) {\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n        }\n        if (this.component) {\n            throw Error(`Component for ${this.name} has already been provided`);\n        }\n        this.component = component;\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n        if (!this.shouldAutoInitialize()) {\n            return;\n        }\n        // if the service is eager, initialize the default instance\n        if (isComponentEager(component)) {\n            try {\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\n            }\n            catch (e) {\n                // when the instance factory for an eager Component throws an exception during the eager\n                // initialization, it should not cause a fatal error.\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\n                // a fatal error in this case?\n            }\n        }\n        // Create service instances for the pending promises and resolve them\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\n        // and all promises with resolve with it regardless of the identifier.\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            try {\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n                const instance = this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n                instanceDeferred.resolve(instance);\n            }\n            catch (e) {\n                // when the instance factory throws an exception, it should not cause\n                // a fatal error. We just leave the promise unresolved.\n            }\n        }\n    }\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n        this.instancesDeferred.delete(identifier);\n        this.instancesOptions.delete(identifier);\n        this.instances.delete(identifier);\n    }\n    // app.delete() will call this method on every provider to delete the services\n    // TODO: should we mark the provider as deleted?\n    async delete() {\n        const services = Array.from(this.instances.values());\n        await Promise.all([\n            ...services\n                .filter(service => 'INTERNAL' in service) // legacy services\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .map(service => service.INTERNAL.delete()),\n            ...services\n                .filter(service => '_delete' in service) // modularized services\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .map(service => service._delete())\n        ]);\n    }\n    isComponentSet() {\n        return this.component != null;\n    }\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instances.has(identifier);\n    }\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instancesOptions.get(identifier) || {};\n    }\n    initialize(opts = {}) {\n        const { options = {} } = opts;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n        if (this.isInitialized(normalizedIdentifier)) {\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n        }\n        if (!this.isComponentSet()) {\n            throw Error(`Component ${this.name} has not been registered yet`);\n        }\n        const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier,\n            options\n        });\n        // resolve any pending promise waiting for the service instance\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\n                instanceDeferred.resolve(instance);\n            }\n        }\n        return instance;\n    }\n    /**\n     *\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\n     *\n     * @param identifier An optional instance identifier\n     * @returns a function to unregister the callback\n     */\n    onInit(callback, identifier) {\n        var _a;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n        existingCallbacks.add(callback);\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n        const existingInstance = this.instances.get(normalizedIdentifier);\n        if (existingInstance) {\n            callback(existingInstance, normalizedIdentifier);\n        }\n        return () => {\n            existingCallbacks.delete(callback);\n        };\n    }\n    /**\n     * Invoke onInit callbacks synchronously\n     * @param instance the service instance`\n     */\n    invokeOnInitCallbacks(instance, identifier) {\n        const callbacks = this.onInitCallbacks.get(identifier);\n        if (!callbacks) {\n            return;\n        }\n        for (const callback of callbacks) {\n            try {\n                callback(instance, identifier);\n            }\n            catch (_a) {\n                // ignore errors in the onInit callback\n            }\n        }\n    }\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\n        let instance = this.instances.get(instanceIdentifier);\n        if (!instance && this.component) {\n            instance = this.component.instanceFactory(this.container, {\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n                options\n            });\n            this.instances.set(instanceIdentifier, instance);\n            this.instancesOptions.set(instanceIdentifier, options);\n            /**\n             * Invoke onInit listeners.\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\n             * while onInit listeners are registered by consumers of the provider.\n             */\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\n            /**\n             * Order is important\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\n             * makes `isInitialized()` return true.\n             */\n            if (this.component.onInstanceCreated) {\n                try {\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n                }\n                catch (_a) {\n                    // ignore errors in the onInstanceCreatedCallback\n                }\n            }\n        }\n        return instance || null;\n    }\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n        if (this.component) {\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n        }\n        else {\n            return identifier; // assume multiple instances are supported before the component is provided.\n        }\n    }\n    shouldAutoInitialize() {\n        return (!!this.component &&\n            this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */);\n    }\n}\n// undefined should be passed to the service factory for the default instance\nfunction normalizeIdentifierForFactory(identifier) {\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\nfunction isComponentEager(component) {\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\n */\nclass ComponentContainer {\n    constructor(name) {\n        this.name = name;\n        this.providers = new Map();\n    }\n    /**\n     *\n     * @param component Component being added\n     * @param overwrite When a component with the same name has already been registered,\n     * if overwrite is true: overwrite the existing component with the new component and create a new\n     * provider with the new component. It can be useful in tests where you want to use different mocks\n     * for different tests.\n     * if overwrite is false: throw an exception\n     */\n    addComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n        }\n        provider.setComponent(component);\n    }\n    addOrOverwriteComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            // delete the existing provider from the container, so we can register the new component\n            this.providers.delete(component.name);\n        }\n        this.addComponent(component);\n    }\n    /**\n     * getProvider provides a type safe interface where it can only be called with a field name\n     * present in NameServiceMapping interface.\n     *\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\n     * themselves.\n     */\n    getProvider(name) {\n        if (this.providers.has(name)) {\n            return this.providers.get(name);\n        }\n        // create a Provider for a service that hasn't registered with Firebase\n        const provider = new Provider(name, this);\n        this.providers.set(name, provider);\n        return provider;\n    }\n    getProviders() {\n        return Array.from(this.providers.values());\n    }\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9jb21wb25lbnQvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9EQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0IsZUFBZSxVQUFVO0FBQzFGO0FBQ0E7QUFDQSx5Q0FBeUMsV0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0NBQXdDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBLDJCQUEyQixVQUFVLEdBQUcscUJBQXFCO0FBQzdEO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCLG1DQUFtQyxVQUFVO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtRDtBQUNuRCIsInNvdXJjZXMiOlsid2VicGFjazovL3RhbGtfdG9fdGV4dC8uLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzPzNjOWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVmZXJyZWQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbi8qKlxuICogQ29tcG9uZW50IGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiBgYXV0aGAsIGBhdXRoLWludGVybmFsYFxuICovXG5jbGFzcyBDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIHB1YmxpYyBzZXJ2aWNlIG5hbWUsIGUuZy4gYXBwLCBhdXRoLCBmaXJlc3RvcmUsIGRhdGFiYXNlXG4gICAgICogQHBhcmFtIGluc3RhbmNlRmFjdG9yeSBTZXJ2aWNlIGZhY3RvcnkgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoZSBwdWJsaWMgaW50ZXJmYWNlXG4gICAgICogQHBhcmFtIHR5cGUgd2hldGhlciB0aGUgc2VydmljZSBwcm92aWRlZCBieSB0aGUgY29tcG9uZW50IGlzIHB1YmxpYyBvciBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgaW5zdGFuY2VGYWN0b3J5LCB0eXBlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VGYWN0b3J5ID0gaW5zdGFuY2VGYWN0b3J5O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIHRvIGJlIGFkZGVkIHRvIHRoZSBzZXJ2aWNlIG5hbWVzcGFjZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXJ2aWNlUHJvcHMgPSB7fTtcbiAgICAgICAgdGhpcy5pbnN0YW50aWF0aW9uTW9kZSA9IFwiTEFaWVwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkxBWlkgKi87XG4gICAgICAgIHRoaXMub25JbnN0YW5jZUNyZWF0ZWQgPSBudWxsO1xuICAgIH1cbiAgICBzZXRJbnN0YW50aWF0aW9uTW9kZShtb2RlKSB7XG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBtb2RlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0TXVsdGlwbGVJbnN0YW5jZXMobXVsdGlwbGVJbnN0YW5jZXMpIHtcbiAgICAgICAgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyA9IG11bHRpcGxlSW5zdGFuY2VzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0U2VydmljZVByb3BzKHByb3BzKSB7XG4gICAgICAgIHRoaXMuc2VydmljZVByb3BzID0gcHJvcHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRJbnN0YW5jZUNyZWF0ZWRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9uSW5zdGFuY2VDcmVhdGVkID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERFRkFVTFRfRU5UUllfTkFNRSA9ICdbREVGQVVMVF0nO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlciBmb3IgaW5zdGFuY2UgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuICdhdXRoJywgJ2F1dGgtaW50ZXJuYWwnXG4gKiBOYW1lU2VydmljZU1hcHBpbmdbVF0gaXMgYW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIHRoZSBpbnN0YW5jZVxuICovXG5jbGFzcyBQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMub25Jbml0Q2FsbGJhY2tzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaWRlbnRpZmllciBBIHByb3ZpZGVyIGNhbiBwcm92aWRlIG11bHRpcGxlIGluc3RhbmNlcyBvZiBhIHNlcnZpY2VcbiAgICAgKiBpZiB0aGlzLmNvbXBvbmVudC5tdWx0aXBsZUluc3RhbmNlcyBpcyB0cnVlLlxuICAgICAqL1xuICAgIGdldChpZGVudGlmaWVyKSB7XG4gICAgICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgIGlmICghdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5oYXMobm9ybWFsaXplZElkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5zZXQobm9ybWFsaXplZElkZW50aWZpZXIsIGRlZmVycmVkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgc2VydmljZSBpZiBpdCBjYW4gYmUgYXV0by1pbml0aWFsaXplZFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSB0aHJvd3MgYW4gZXhjZXB0aW9uIGR1cmluZyBnZXQoKSwgaXQgc2hvdWxkIG5vdCBjYXVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IHJldHVybiB0aGUgdW5yZXNvbHZlZCBwcm9taXNlIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKS5wcm9taXNlO1xuICAgIH1cbiAgICBnZXRJbW1lZGlhdGUob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBvcHRpb25hbCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vcHRpb25hbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpIHx8XG4gICAgICAgICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIGEgY29tcG9uZW50IGlzIG5vdCBpbml0aWFsaXplZCBhbmQgc2hvdWxkL2Nhbm5vdCBiZSBhdXRvLWluaXRpYWxpemVkIGF0IHRoZSBtb21lbnQsIHJldHVybiBudWxsIGlmIHRoZSBvcHRpb25hbCBmbGFnIGlzIHNldCwgb3IgdGhyb3dcbiAgICAgICAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFNlcnZpY2UgJHt0aGlzLm5hbWV9IGlzIG5vdCBhdmFpbGFibGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudDtcbiAgICB9XG4gICAgc2V0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoY29tcG9uZW50Lm5hbWUgIT09IHRoaXMubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1pc21hdGNoaW5nIENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBmb3IgUHJvdmlkZXIgJHt0aGlzLm5hbWV9LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENvbXBvbmVudCBmb3IgJHt0aGlzLm5hbWV9IGhhcyBhbHJlYWR5IGJlZW4gcHJvdmlkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgLy8gcmV0dXJuIGVhcmx5IHdpdGhvdXQgYXR0ZW1wdGluZyB0byBpbml0aWFsaXplIHRoZSBjb21wb25lbnQgaWYgdGhlIGNvbXBvbmVudCByZXF1aXJlcyBleHBsaWNpdCBpbml0aWFsaXphdGlvbiAoY2FsbGluZyBgUHJvdmlkZXIuaW5pdGlhbGl6ZSgpYClcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgc2VydmljZSBpcyBlYWdlciwgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZVxuICAgICAgICBpZiAoaXNDb21wb25lbnRFYWdlcihjb21wb25lbnQpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7IGluc3RhbmNlSWRlbnRpZmllcjogREVGQVVMVF9FTlRSWV9OQU1FIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IGZvciBhbiBlYWdlciBDb21wb25lbnQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgdGhlIGVhZ2VyXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24sIGl0IHNob3VsZCBub3QgY2F1c2UgYSBmYXRhbCBlcnJvci5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB3ZSBuZWVkIHRvIG1ha2UgaXQgY29uZmlndXJhYmxlLCBiZWNhdXNlIHNvbWUgY29tcG9uZW50IG1heSB3YW50IHRvIGNhdXNlXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvciBpbiB0aGlzIGNhc2U/XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHNlcnZpY2UgaW5zdGFuY2VzIGZvciB0aGUgcGVuZGluZyBwcm9taXNlcyBhbmQgcmVzb2x2ZSB0aGVtXG4gICAgICAgIC8vIE5PVEU6IGlmIHRoaXMubXVsdGlwbGVJbnN0YW5jZXMgaXMgZmFsc2UsIG9ubHkgdGhlIGRlZmF1bHQgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkXG4gICAgICAgIC8vIGFuZCBhbGwgcHJvbWlzZXMgd2l0aCByZXNvbHZlIHdpdGggaXQgcmVnYXJkbGVzcyBvZiB0aGUgaWRlbnRpZmllci5cbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpbnN0YW5jZUlkZW50aWZpZXIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBgZ2V0T3JJbml0aWFsaXplU2VydmljZSgpYCBzaG91bGQgYWx3YXlzIHJldHVybiBhIHZhbGlkIGluc3RhbmNlIHNpbmNlIGEgY29tcG9uZW50IGlzIGd1YXJhbnRlZWQuIHVzZSAhIHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweS5cbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZURlZmVycmVkLnJlc29sdmUoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IHRocm93cyBhbiBleGNlcHRpb24sIGl0IHNob3VsZCBub3QgY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IGxlYXZlIHRoZSBwcm9taXNlIHVucmVzb2x2ZWQuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJJbnN0YW5jZShpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZGVsZXRlKGlkZW50aWZpZXIpO1xuICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuZGVsZXRlKGlkZW50aWZpZXIpO1xuICAgICAgICB0aGlzLmluc3RhbmNlcy5kZWxldGUoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIC8vIGFwcC5kZWxldGUoKSB3aWxsIGNhbGwgdGhpcyBtZXRob2Qgb24gZXZlcnkgcHJvdmlkZXIgdG8gZGVsZXRlIHRoZSBzZXJ2aWNlc1xuICAgIC8vIFRPRE86IHNob3VsZCB3ZSBtYXJrIHRoZSBwcm92aWRlciBhcyBkZWxldGVkP1xuICAgIGFzeW5jIGRlbGV0ZSgpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZXMgPSBBcnJheS5mcm9tKHRoaXMuaW5zdGFuY2VzLnZhbHVlcygpKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgLi4uc2VydmljZXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHNlcnZpY2UgPT4gJ0lOVEVSTkFMJyBpbiBzZXJ2aWNlKSAvLyBsZWdhY3kgc2VydmljZXNcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIC5tYXAoc2VydmljZSA9PiBzZXJ2aWNlLklOVEVSTkFMLmRlbGV0ZSgpKSxcbiAgICAgICAgICAgIC4uLnNlcnZpY2VzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdfZGVsZXRlJyBpbiBzZXJ2aWNlKSAvLyBtb2R1bGFyaXplZCBzZXJ2aWNlc1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgLm1hcChzZXJ2aWNlID0+IHNlcnZpY2UuX2RlbGV0ZSgpKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgaXNDb21wb25lbnRTZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudCAhPSBudWxsO1xuICAgIH1cbiAgICBpc0luaXRpYWxpemVkKGlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzLmhhcyhpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgZ2V0T3B0aW9ucyhpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlc09wdGlvbnMuZ2V0KGlkZW50aWZpZXIpIHx8IHt9O1xuICAgIH1cbiAgICBpbml0aWFsaXplKG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgPSB7fSB9ID0gb3B0cztcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihvcHRzLmluc3RhbmNlSWRlbnRpZmllcik7XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgJHt0aGlzLm5hbWV9KCR7bm9ybWFsaXplZElkZW50aWZpZXJ9KSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzQ29tcG9uZW50U2V0KCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgJHt0aGlzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcbiAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXIsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZXNvbHZlIGFueSBwZW5kaW5nIHByb21pc2Ugd2FpdGluZyBmb3IgdGhlIHNlcnZpY2UgaW5zdGFuY2VcbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZERlZmVycmVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZElkZW50aWZpZXIgPT09IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZURlZmVycmVkLnJlc29sdmUoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkICBhZnRlciB0aGUgcHJvdmlkZXIgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgYnkgY2FsbGluZyBwcm92aWRlci5pbml0aWFsaXplKCkuXG4gICAgICogVGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgU1lOQ0hST05PVVNMWSwgc28gaXQgc2hvdWxkIG5vdCBleGVjdXRlIGFueSBsb25ncnVubmluZyB0YXNrcyBpbiBvcmRlciB0byBub3QgYmxvY2sgdGhlIHByb2dyYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWRlbnRpZmllciBBbiBvcHRpb25hbCBpbnN0YW5jZSBpZGVudGlmaWVyXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0byB1bnJlZ2lzdGVyIHRoZSBjYWxsYmFja1xuICAgICAqL1xuICAgIG9uSW5pdChjYWxsYmFjaywgaWRlbnRpZmllcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FsbGJhY2tzID0gKF9hID0gdGhpcy5vbkluaXRDYWxsYmFja3MuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFNldCgpO1xuICAgICAgICBleGlzdGluZ0NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcy5zZXQobm9ybWFsaXplZElkZW50aWZpZXIsIGV4aXN0aW5nQ2FsbGJhY2tzKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VzLmdldChub3JtYWxpemVkSWRlbnRpZmllcik7XG4gICAgICAgIGlmIChleGlzdGluZ0luc3RhbmNlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhleGlzdGluZ0luc3RhbmNlLCBub3JtYWxpemVkSWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGV4aXN0aW5nQ2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZSBvbkluaXQgY2FsbGJhY2tzIHN5bmNocm9ub3VzbHlcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2UgdGhlIHNlcnZpY2UgaW5zdGFuY2VgXG4gICAgICovXG4gICAgaW52b2tlT25Jbml0Q2FsbGJhY2tzKGluc3RhbmNlLCBpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChpZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpbnN0YW5jZSwgaWRlbnRpZmllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluaXQgY2FsbGJhY2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRPckluaXRpYWxpemVTZXJ2aWNlKHsgaW5zdGFuY2VJZGVudGlmaWVyLCBvcHRpb25zID0ge30gfSkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQoaW5zdGFuY2VJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCFpbnN0YW5jZSAmJiB0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgaW5zdGFuY2UgPSB0aGlzLmNvbXBvbmVudC5pbnN0YW5jZUZhY3RvcnkodGhpcy5jb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZUlkZW50aWZpZXJGb3JGYWN0b3J5KGluc3RhbmNlSWRlbnRpZmllciksXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlcy5zZXQoaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgb3B0aW9ucyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEludm9rZSBvbkluaXQgbGlzdGVuZXJzLlxuICAgICAgICAgICAgICogTm90ZSB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCBpcyBkaWZmZXJlbnQsIHdoaWNoIGlzIHVzZWQgYnkgdGhlIGNvbXBvbmVudCBjcmVhdG9yLFxuICAgICAgICAgICAgICogd2hpbGUgb25Jbml0IGxpc3RlbmVycyBhcmUgcmVnaXN0ZXJlZCBieSBjb25zdW1lcnMgb2YgdGhlIHByb3ZpZGVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaW5zdGFuY2VJZGVudGlmaWVyKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3JkZXIgaXMgaW1wb3J0YW50XG4gICAgICAgICAgICAgKiBvbkluc3RhbmNlQ3JlYXRlZCgpIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpOyB3aGljaFxuICAgICAgICAgICAgICogbWFrZXMgYGlzSW5pdGlhbGl6ZWQoKWAgcmV0dXJuIHRydWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lm9uSW5zdGFuY2VDcmVhdGVkKHRoaXMuY29udGFpbmVyLCBpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvcnMgaW4gdGhlIG9uSW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlIHx8IG51bGw7XG4gICAgfVxuICAgIG5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50Lm11bHRpcGxlSW5zdGFuY2VzID8gaWRlbnRpZmllciA6IERFRkFVTFRfRU5UUllfTkFNRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyOyAvLyBhc3N1bWUgbXVsdGlwbGUgaW5zdGFuY2VzIGFyZSBzdXBwb3J0ZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgcHJvdmlkZWQuXG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdWxkQXV0b0luaXRpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiAoISF0aGlzLmNvbXBvbmVudCAmJlxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgIT09IFwiRVhQTElDSVRcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVCAqLyk7XG4gICAgfVxufVxuLy8gdW5kZWZpbmVkIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHNlcnZpY2UgZmFjdG9yeSBmb3IgdGhlIGRlZmF1bHQgaW5zdGFuY2VcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkZW50aWZpZXJGb3JGYWN0b3J5KGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllciA9PT0gREVGQVVMVF9FTlRSWV9OQU1FID8gdW5kZWZpbmVkIDogaWRlbnRpZmllcjtcbn1cbmZ1bmN0aW9uIGlzQ29tcG9uZW50RWFnZXIoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5pbnN0YW50aWF0aW9uTW9kZSA9PT0gXCJFQUdFUlwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkVBR0VSICovO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDb21wb25lbnRDb250YWluZXIgdGhhdCBwcm92aWRlcyBQcm92aWRlcnMgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuIGBhdXRoYCwgYGF1dGgtaW50ZXJuYWxgXG4gKi9cbmNsYXNzIENvbXBvbmVudENvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IENvbXBvbmVudCBiZWluZyBhZGRlZFxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgV2hlbiBhIGNvbXBvbmVudCB3aXRoIHRoZSBzYW1lIG5hbWUgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLFxuICAgICAqIGlmIG92ZXJ3cml0ZSBpcyB0cnVlOiBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGNvbXBvbmVudCB3aXRoIHRoZSBuZXcgY29tcG9uZW50IGFuZCBjcmVhdGUgYSBuZXdcbiAgICAgKiBwcm92aWRlciB3aXRoIHRoZSBuZXcgY29tcG9uZW50LiBJdCBjYW4gYmUgdXNlZnVsIGluIHRlc3RzIHdoZXJlIHlvdSB3YW50IHRvIHVzZSBkaWZmZXJlbnQgbW9ja3NcbiAgICAgKiBmb3IgZGlmZmVyZW50IHRlc3RzLlxuICAgICAqIGlmIG92ZXJ3cml0ZSBpcyBmYWxzZTogdGhyb3cgYW4gZXhjZXB0aW9uXG4gICAgICovXG4gICAgYWRkQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIoY29tcG9uZW50Lm5hbWUpO1xuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIHdpdGggJHt0aGlzLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvdmlkZXIuc2V0Q29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGFkZE9yT3ZlcndyaXRlQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIoY29tcG9uZW50Lm5hbWUpO1xuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xuICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSBleGlzdGluZyBwcm92aWRlciBmcm9tIHRoZSBjb250YWluZXIsIHNvIHdlIGNhbiByZWdpc3RlciB0aGUgbmV3IGNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuZGVsZXRlKGNvbXBvbmVudC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRQcm92aWRlciBwcm92aWRlcyBhIHR5cGUgc2FmZSBpbnRlcmZhY2Ugd2hlcmUgaXQgY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggYSBmaWVsZCBuYW1lXG4gICAgICogcHJlc2VudCBpbiBOYW1lU2VydmljZU1hcHBpbmcgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogRmlyZWJhc2UgU0RLcyBwcm92aWRpbmcgc2VydmljZXMgc2hvdWxkIGV4dGVuZCBOYW1lU2VydmljZU1hcHBpbmcgaW50ZXJmYWNlIHRvIHJlZ2lzdGVyXG4gICAgICogdGhlbXNlbHZlcy5cbiAgICAgKi9cbiAgICBnZXRQcm92aWRlcihuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3ZpZGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVycy5nZXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIGEgUHJvdmlkZXIgZm9yIGEgc2VydmljZSB0aGF0IGhhc24ndCByZWdpc3RlcmVkIHdpdGggRmlyZWJhc2VcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIobmFtZSwgdGhpcyk7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuYW1lLCBwcm92aWRlcik7XG4gICAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICB9XG4gICAgZ2V0UHJvdmlkZXJzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnByb3ZpZGVycy52YWx1ZXMoKSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBDb21wb25lbnQsIENvbXBvbmVudENvbnRhaW5lciwgUHJvdmlkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@firebase/component/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@firebase/firestore/dist/index.node.mjs":
/*!***************************************************************!*\
  !*** ../node_modules/@firebase/firestore/dist/index.node.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractUserDataWriter: () => (/* binding */ AbstractUserDataWriter),\n/* harmony export */   AggregateField: () => (/* binding */ AggregateField),\n/* harmony export */   AggregateQuerySnapshot: () => (/* binding */ AggregateQuerySnapshot),\n/* harmony export */   Bytes: () => (/* binding */ Bytes),\n/* harmony export */   CACHE_SIZE_UNLIMITED: () => (/* binding */ CACHE_SIZE_UNLIMITED),\n/* harmony export */   CollectionReference: () => (/* binding */ CollectionReference),\n/* harmony export */   DocumentReference: () => (/* binding */ DocumentReference),\n/* harmony export */   DocumentSnapshot: () => (/* binding */ DocumentSnapshot),\n/* harmony export */   FieldPath: () => (/* binding */ FieldPath),\n/* harmony export */   FieldValue: () => (/* binding */ FieldValue),\n/* harmony export */   Firestore: () => (/* binding */ Firestore),\n/* harmony export */   FirestoreError: () => (/* binding */ FirestoreError),\n/* harmony export */   GeoPoint: () => (/* binding */ GeoPoint),\n/* harmony export */   LoadBundleTask: () => (/* binding */ LoadBundleTask),\n/* harmony export */   PersistentCacheIndexManager: () => (/* binding */ PersistentCacheIndexManager),\n/* harmony export */   Query: () => (/* binding */ Query),\n/* harmony export */   QueryCompositeFilterConstraint: () => (/* binding */ QueryCompositeFilterConstraint),\n/* harmony export */   QueryConstraint: () => (/* binding */ QueryConstraint),\n/* harmony export */   QueryDocumentSnapshot: () => (/* binding */ QueryDocumentSnapshot),\n/* harmony export */   QueryEndAtConstraint: () => (/* binding */ QueryEndAtConstraint),\n/* harmony export */   QueryFieldFilterConstraint: () => (/* binding */ QueryFieldFilterConstraint),\n/* harmony export */   QueryLimitConstraint: () => (/* binding */ QueryLimitConstraint),\n/* harmony export */   QueryOrderByConstraint: () => (/* binding */ QueryOrderByConstraint),\n/* harmony export */   QuerySnapshot: () => (/* binding */ QuerySnapshot),\n/* harmony export */   QueryStartAtConstraint: () => (/* binding */ QueryStartAtConstraint),\n/* harmony export */   SnapshotMetadata: () => (/* binding */ SnapshotMetadata),\n/* harmony export */   Timestamp: () => (/* binding */ Timestamp),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   VectorValue: () => (/* binding */ VectorValue),\n/* harmony export */   WriteBatch: () => (/* binding */ WriteBatch),\n/* harmony export */   _AutoId: () => (/* binding */ AutoId),\n/* harmony export */   _ByteString: () => (/* binding */ ByteString),\n/* harmony export */   _DatabaseId: () => (/* binding */ DatabaseId),\n/* harmony export */   _DocumentKey: () => (/* binding */ DocumentKey),\n/* harmony export */   _EmptyAppCheckTokenProvider: () => (/* binding */ EmptyAppCheckTokenProvider),\n/* harmony export */   _EmptyAuthCredentialsProvider: () => (/* binding */ EmptyAuthCredentialsProvider),\n/* harmony export */   _FieldPath: () => (/* binding */ FieldPath$1),\n/* harmony export */   _TestingHooks: () => (/* binding */ TestingHooks),\n/* harmony export */   _cast: () => (/* binding */ cast),\n/* harmony export */   _debugAssert: () => (/* binding */ debugAssert),\n/* harmony export */   _internalAggregationQueryToProtoRunAggregationQueryRequest: () => (/* binding */ _internalAggregationQueryToProtoRunAggregationQueryRequest),\n/* harmony export */   _internalQueryToProtoQueryTarget: () => (/* binding */ _internalQueryToProtoQueryTarget),\n/* harmony export */   _isBase64Available: () => (/* binding */ isBase64Available),\n/* harmony export */   _logWarn: () => (/* binding */ logWarn),\n/* harmony export */   _validateIsNotUsedTogether: () => (/* binding */ validateIsNotUsedTogether),\n/* harmony export */   addDoc: () => (/* binding */ addDoc),\n/* harmony export */   aggregateFieldEqual: () => (/* binding */ aggregateFieldEqual),\n/* harmony export */   aggregateQuerySnapshotEqual: () => (/* binding */ aggregateQuerySnapshotEqual),\n/* harmony export */   and: () => (/* binding */ and),\n/* harmony export */   arrayRemove: () => (/* binding */ arrayRemove),\n/* harmony export */   arrayUnion: () => (/* binding */ arrayUnion),\n/* harmony export */   average: () => (/* binding */ average),\n/* harmony export */   clearIndexedDbPersistence: () => (/* binding */ clearIndexedDbPersistence),\n/* harmony export */   collection: () => (/* binding */ collection),\n/* harmony export */   collectionGroup: () => (/* binding */ collectionGroup),\n/* harmony export */   connectFirestoreEmulator: () => (/* binding */ connectFirestoreEmulator),\n/* harmony export */   count: () => (/* binding */ count),\n/* harmony export */   deleteAllPersistentCacheIndexes: () => (/* binding */ deleteAllPersistentCacheIndexes),\n/* harmony export */   deleteDoc: () => (/* binding */ deleteDoc),\n/* harmony export */   deleteField: () => (/* binding */ deleteField),\n/* harmony export */   disableNetwork: () => (/* binding */ disableNetwork),\n/* harmony export */   disablePersistentCacheIndexAutoCreation: () => (/* binding */ disablePersistentCacheIndexAutoCreation),\n/* harmony export */   doc: () => (/* binding */ doc),\n/* harmony export */   documentId: () => (/* binding */ documentId),\n/* harmony export */   enableIndexedDbPersistence: () => (/* binding */ enableIndexedDbPersistence),\n/* harmony export */   enableMultiTabIndexedDbPersistence: () => (/* binding */ enableMultiTabIndexedDbPersistence),\n/* harmony export */   enableNetwork: () => (/* binding */ enableNetwork),\n/* harmony export */   enablePersistentCacheIndexAutoCreation: () => (/* binding */ enablePersistentCacheIndexAutoCreation),\n/* harmony export */   endAt: () => (/* binding */ endAt),\n/* harmony export */   endBefore: () => (/* binding */ endBefore),\n/* harmony export */   ensureFirestoreConfigured: () => (/* binding */ ensureFirestoreConfigured),\n/* harmony export */   executeWrite: () => (/* binding */ executeWrite),\n/* harmony export */   getAggregateFromServer: () => (/* binding */ getAggregateFromServer),\n/* harmony export */   getCountFromServer: () => (/* binding */ getCountFromServer),\n/* harmony export */   getDoc: () => (/* binding */ getDoc),\n/* harmony export */   getDocFromCache: () => (/* binding */ getDocFromCache),\n/* harmony export */   getDocFromServer: () => (/* binding */ getDocFromServer),\n/* harmony export */   getDocs: () => (/* binding */ getDocs),\n/* harmony export */   getDocsFromCache: () => (/* binding */ getDocsFromCache),\n/* harmony export */   getDocsFromServer: () => (/* binding */ getDocsFromServer),\n/* harmony export */   getFirestore: () => (/* binding */ getFirestore),\n/* harmony export */   getPersistentCacheIndexManager: () => (/* binding */ getPersistentCacheIndexManager),\n/* harmony export */   increment: () => (/* binding */ increment),\n/* harmony export */   initializeFirestore: () => (/* binding */ initializeFirestore),\n/* harmony export */   limit: () => (/* binding */ limit),\n/* harmony export */   limitToLast: () => (/* binding */ limitToLast),\n/* harmony export */   loadBundle: () => (/* binding */ loadBundle),\n/* harmony export */   memoryEagerGarbageCollector: () => (/* binding */ memoryEagerGarbageCollector),\n/* harmony export */   memoryLocalCache: () => (/* binding */ memoryLocalCache),\n/* harmony export */   memoryLruGarbageCollector: () => (/* binding */ memoryLruGarbageCollector),\n/* harmony export */   namedQuery: () => (/* binding */ namedQuery),\n/* harmony export */   onSnapshot: () => (/* binding */ onSnapshot),\n/* harmony export */   onSnapshotsInSync: () => (/* binding */ onSnapshotsInSync),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   orderBy: () => (/* binding */ orderBy),\n/* harmony export */   persistentLocalCache: () => (/* binding */ persistentLocalCache),\n/* harmony export */   persistentMultipleTabManager: () => (/* binding */ persistentMultipleTabManager),\n/* harmony export */   persistentSingleTabManager: () => (/* binding */ persistentSingleTabManager),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   queryEqual: () => (/* binding */ queryEqual),\n/* harmony export */   refEqual: () => (/* binding */ refEqual),\n/* harmony export */   runTransaction: () => (/* binding */ runTransaction),\n/* harmony export */   serverTimestamp: () => (/* binding */ serverTimestamp),\n/* harmony export */   setDoc: () => (/* binding */ setDoc),\n/* harmony export */   setIndexConfiguration: () => (/* binding */ setIndexConfiguration),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   snapshotEqual: () => (/* binding */ snapshotEqual),\n/* harmony export */   startAfter: () => (/* binding */ startAfter),\n/* harmony export */   startAt: () => (/* binding */ startAt),\n/* harmony export */   sum: () => (/* binding */ sum),\n/* harmony export */   terminate: () => (/* binding */ terminate),\n/* harmony export */   updateDoc: () => (/* binding */ updateDoc),\n/* harmony export */   vector: () => (/* binding */ vector),\n/* harmony export */   waitForPendingWrites: () => (/* binding */ waitForPendingWrites),\n/* harmony export */   where: () => (/* binding */ where),\n/* harmony export */   writeBatch: () => (/* binding */ writeBatch)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/../node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/../node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/../node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/../node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @firebase/webchannel-wrapper/bloom-blob */ \"(ssr)/../node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js\");\n/* harmony import */ var _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @grpc/grpc-js */ \"(ssr)/../node_modules/@grpc/grpc-js/build/src/index.js\");\n/* harmony import */ var _grpc_proto_loader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @grpc/proto-loader */ \"(ssr)/../node_modules/@grpc/proto-loader/build/src/index.js\");\n\n\n\n\n\n\n\n\n\n\nconst name = \"@firebase/firestore\";\nconst version$1 = \"4.7.10\";\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Simple wrapper around a nullable UID. Mostly exists to make code more\n * readable.\n */\nclass User {\n    constructor(uid) {\n        this.uid = uid;\n    }\n    isAuthenticated() {\n        return this.uid != null;\n    }\n    /**\n     * Returns a key representing this user, suitable for inclusion in a\n     * dictionary.\n     */\n    toKey() {\n        if (this.isAuthenticated()) {\n            return 'uid:' + this.uid;\n        }\n        else {\n            return 'anonymous-user';\n        }\n    }\n    isEqual(otherUser) {\n        return otherUser.uid === this.uid;\n    }\n}\n/** A user with a null UID. */\nUser.UNAUTHENTICATED = new User(null);\n// TODO(mikelehen): Look into getting a proper uid-equivalent for\n// non-FirebaseAuth providers.\nUser.GOOGLE_CREDENTIALS = new User('google-credentials-uid');\nUser.FIRST_PARTY = new User('first-party-uid');\nUser.MOCK_USER = new User('mock-user');\n\nconst version = \"11.5.0\";\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet SDK_VERSION = version;\nfunction setSDKVersion(version) {\n    SDK_VERSION = version;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Formats an object as a JSON string, suitable for logging. */\nfunction formatJSON(value) {\n    // util.inspect() results in much more readable output than JSON.stringify()\n    return (0,util__WEBPACK_IMPORTED_MODULE_3__.inspect)(value, { depth: 100 });\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.Logger('@firebase/firestore');\n// Helper methods are needed because variables can't be exported as read/write\nfunction getLogLevel() {\n    return logClient.logLevel;\n}\n/**\n * Sets the verbosity of Cloud Firestore logs (debug, error, or silent).\n *\n * @param logLevel - The verbosity you set for activity and error logging. Can\n *   be any of the following values:\n *\n *   <ul>\n *     <li>`debug` for the most verbose logging level, primarily for\n *     debugging.</li>\n *     <li>`error` to log errors only.</li>\n *     <li><code>`silent` to turn off logging.</li>\n *   </ul>\n */\nfunction setLogLevel(logLevel) {\n    logClient.setLogLevel(logLevel);\n}\nfunction logDebug(msg, ...obj) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n        const args = obj.map(argToString);\n        logClient.debug(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n    }\n}\nfunction logError(msg, ...obj) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.ERROR) {\n        const args = obj.map(argToString);\n        logClient.error(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n    }\n}\n/**\n * @internal\n */\nfunction logWarn(msg, ...obj) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.WARN) {\n        const args = obj.map(argToString);\n        logClient.warn(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n    }\n}\n/**\n * Converts an additional log parameter to a string representation.\n */\nfunction argToString(obj) {\n    if (typeof obj === 'string') {\n        return obj;\n    }\n    else {\n        try {\n            return formatJSON(obj);\n        }\n        catch (e) {\n            // Converting to JSON failed, just log the object directly\n            return obj;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Unconditionally fails, throwing an Error with the given message.\n * Messages are stripped in production builds.\n *\n * Returns `never` and can be used in expressions:\n * @example\n * let futureVar = fail('not implemented yet');\n */\nfunction fail(failure = 'Unexpected state') {\n    // Log the failure in addition to throw an exception, just in case the\n    // exception is swallowed.\n    const message = `FIRESTORE (${SDK_VERSION}) INTERNAL ASSERTION FAILED: ` + failure;\n    logError(message);\n    // NOTE: We don't use FirestoreError here because these are internal failures\n    // that cannot be handled by the user. (Also it would create a circular\n    // dependency between the error and assert modules which doesn't work.)\n    throw new Error(message);\n}\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * Messages are stripped in production builds.\n */\nfunction hardAssert(assertion, message) {\n    if (!assertion) {\n        fail();\n    }\n}\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * The code of callsites invoking this function are stripped out in production\n * builds. Any side-effects of code within the debugAssert() invocation will not\n * happen in this case.\n *\n * @internal\n */\nfunction debugAssert(assertion, message) {\n    if (!assertion) {\n        fail();\n    }\n}\n/**\n * Casts `obj` to `T`. In non-production builds, verifies that `obj` is an\n * instance of `T` before casting.\n */\nfunction debugCast(obj, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconstructor) {\n    return obj;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst Code = {\n    // Causes are copied from:\n    // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n    /** Not an error; returned on success. */\n    OK: 'ok',\n    /** The operation was cancelled (typically by the caller). */\n    CANCELLED: 'cancelled',\n    /** Unknown error or an error from a different error domain. */\n    UNKNOWN: 'unknown',\n    /**\n     * Client specified an invalid argument. Note that this differs from\n     * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\n     * problematic regardless of the state of the system (e.g., a malformed file\n     * name).\n     */\n    INVALID_ARGUMENT: 'invalid-argument',\n    /**\n     * Deadline expired before operation could complete. For operations that\n     * change the state of the system, this error may be returned even if the\n     * operation has completed successfully. For example, a successful response\n     * from a server could have been delayed long enough for the deadline to\n     * expire.\n     */\n    DEADLINE_EXCEEDED: 'deadline-exceeded',\n    /** Some requested entity (e.g., file or directory) was not found. */\n    NOT_FOUND: 'not-found',\n    /**\n     * Some entity that we attempted to create (e.g., file or directory) already\n     * exists.\n     */\n    ALREADY_EXISTS: 'already-exists',\n    /**\n     * The caller does not have permission to execute the specified operation.\n     * PERMISSION_DENIED must not be used for rejections caused by exhausting\n     * some resource (use RESOURCE_EXHAUSTED instead for those errors).\n     * PERMISSION_DENIED must not be used if the caller cannot be identified\n     * (use UNAUTHENTICATED instead for those errors).\n     */\n    PERMISSION_DENIED: 'permission-denied',\n    /**\n     * The request does not have valid authentication credentials for the\n     * operation.\n     */\n    UNAUTHENTICATED: 'unauthenticated',\n    /**\n     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the\n     * entire file system is out of space.\n     */\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\n    /**\n     * Operation was rejected because the system is not in a state required for\n     * the operation's execution. For example, directory to be deleted may be\n     * non-empty, an rmdir operation is applied to a non-directory, etc.\n     *\n     * A litmus test that may help a service implementor in deciding\n     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n     *  (a) Use UNAVAILABLE if the client can retry just the failing call.\n     *  (b) Use ABORTED if the client should retry at a higher-level\n     *      (e.g., restarting a read-modify-write sequence).\n     *  (c) Use FAILED_PRECONDITION if the client should not retry until\n     *      the system state has been explicitly fixed. E.g., if an \"rmdir\"\n     *      fails because the directory is non-empty, FAILED_PRECONDITION\n     *      should be returned since the client should not retry unless\n     *      they have first fixed up the directory by deleting files from it.\n     *  (d) Use FAILED_PRECONDITION if the client performs conditional\n     *      REST Get/Update/Delete on a resource and the resource on the\n     *      server does not match the condition. E.g., conflicting\n     *      read-modify-write on the same resource.\n     */\n    FAILED_PRECONDITION: 'failed-precondition',\n    /**\n     * The operation was aborted, typically due to a concurrency issue like\n     * sequencer check failures, transaction aborts, etc.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    ABORTED: 'aborted',\n    /**\n     * Operation was attempted past the valid range. E.g., seeking or reading\n     * past end of file.\n     *\n     * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\n     * if the system state changes. For example, a 32-bit file system will\n     * generate INVALID_ARGUMENT if asked to read at an offset that is not in the\n     * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\n     * an offset past the current file size.\n     *\n     * There is a fair bit of overlap between FAILED_PRECONDITION and\n     * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n     * when it applies so that callers who are iterating through a space can\n     * easily look for an OUT_OF_RANGE error to detect when they are done.\n     */\n    OUT_OF_RANGE: 'out-of-range',\n    /** Operation is not implemented or not supported/enabled in this service. */\n    UNIMPLEMENTED: 'unimplemented',\n    /**\n     * Internal errors. Means some invariants expected by underlying System has\n     * been broken. If you see one of these errors, Something is very broken.\n     */\n    INTERNAL: 'internal',\n    /**\n     * The service is currently unavailable. This is a most likely a transient\n     * condition and may be corrected by retrying with a backoff.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    UNAVAILABLE: 'unavailable',\n    /** Unrecoverable data loss or corruption. */\n    DATA_LOSS: 'data-loss'\n};\n/** An error returned by a Firestore operation. */\nclass FirestoreError extends _firebase_util__WEBPACK_IMPORTED_MODULE_4__.FirebaseError {\n    /** @hideconstructor */\n    constructor(\n    /**\n     * The backend error code associated with this error.\n     */\n    code, \n    /**\n     * A custom error description.\n     */\n    message) {\n        super(code, message);\n        this.code = code;\n        this.message = message;\n        // HACK: We write a toString property directly because Error is not a real\n        // class and so inheritance does not work correctly. We could alternatively\n        // do the same \"back-door inheritance\" trick that FirebaseError does.\n        this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass OAuthToken {\n    constructor(value, user) {\n        this.user = user;\n        this.type = 'OAuth';\n        this.headers = new Map();\n        this.headers.set('Authorization', `Bearer ${value}`);\n    }\n}\n/**\n * A CredentialsProvider that always yields an empty token.\n * @internal\n */\nclass EmptyAuthCredentialsProvider {\n    getToken() {\n        return Promise.resolve(null);\n    }\n    invalidateToken() { }\n    start(asyncQueue, changeListener) {\n        // Fire with initial user.\n        asyncQueue.enqueueRetryable(() => changeListener(User.UNAUTHENTICATED));\n    }\n    shutdown() { }\n}\n/**\n * A CredentialsProvider that always returns a constant token. Used for\n * emulator token mocking.\n */\nclass EmulatorAuthCredentialsProvider {\n    constructor(token) {\n        this.token = token;\n        /**\n         * Stores the listener registered with setChangeListener()\n         * This isn't actually necessary since the UID never changes, but we use this\n         * to verify the listen contract is adhered to in tests.\n         */\n        this.changeListener = null;\n    }\n    getToken() {\n        return Promise.resolve(this.token);\n    }\n    invalidateToken() { }\n    start(asyncQueue, changeListener) {\n        this.changeListener = changeListener;\n        // Fire with initial user.\n        asyncQueue.enqueueRetryable(() => changeListener(this.token.user));\n    }\n    shutdown() {\n        this.changeListener = null;\n    }\n}\nclass FirebaseAuthCredentialsProvider {\n    constructor(authProvider) {\n        this.authProvider = authProvider;\n        /** Tracks the current User. */\n        this.currentUser = User.UNAUTHENTICATED;\n        /**\n         * Counter used to detect if the token changed while a getToken request was\n         * outstanding.\n         */\n        this.tokenCounter = 0;\n        this.forceRefresh = false;\n        this.auth = null;\n    }\n    start(asyncQueue, changeListener) {\n        hardAssert(this.tokenListener === undefined);\n        let lastTokenId = this.tokenCounter;\n        // A change listener that prevents double-firing for the same token change.\n        const guardedChangeListener = user => {\n            if (this.tokenCounter !== lastTokenId) {\n                lastTokenId = this.tokenCounter;\n                return changeListener(user);\n            }\n            else {\n                return Promise.resolve();\n            }\n        };\n        // A promise that can be waited on to block on the next token change.\n        // This promise is re-created after each change.\n        let nextToken = new Deferred();\n        this.tokenListener = () => {\n            this.tokenCounter++;\n            this.currentUser = this.getUser();\n            nextToken.resolve();\n            nextToken = new Deferred();\n            asyncQueue.enqueueRetryable(() => guardedChangeListener(this.currentUser));\n        };\n        const awaitNextToken = () => {\n            const currentTokenAttempt = nextToken;\n            asyncQueue.enqueueRetryable(async () => {\n                await currentTokenAttempt.promise;\n                await guardedChangeListener(this.currentUser);\n            });\n        };\n        const registerAuth = (auth) => {\n            logDebug('FirebaseAuthCredentialsProvider', 'Auth detected');\n            this.auth = auth;\n            if (this.tokenListener) {\n                this.auth.addAuthTokenListener(this.tokenListener);\n                awaitNextToken();\n            }\n        };\n        this.authProvider.onInit(auth => registerAuth(auth));\n        // Our users can initialize Auth right after Firestore, so we give it\n        // a chance to register itself with the component framework before we\n        // determine whether to start up in unauthenticated mode.\n        setTimeout(() => {\n            if (!this.auth) {\n                const auth = this.authProvider.getImmediate({ optional: true });\n                if (auth) {\n                    registerAuth(auth);\n                }\n                else {\n                    // If auth is still not available, proceed with `null` user\n                    logDebug('FirebaseAuthCredentialsProvider', 'Auth not yet detected');\n                    nextToken.resolve();\n                    nextToken = new Deferred();\n                }\n            }\n        }, 0);\n        awaitNextToken();\n    }\n    getToken() {\n        // Take note of the current value of the tokenCounter so that this method\n        // can fail (with an ABORTED error) if there is a token change while the\n        // request is outstanding.\n        const initialTokenCounter = this.tokenCounter;\n        const forceRefresh = this.forceRefresh;\n        this.forceRefresh = false;\n        if (!this.auth) {\n            return Promise.resolve(null);\n        }\n        return this.auth.getToken(forceRefresh).then(tokenData => {\n            // Cancel the request since the token changed while the request was\n            // outstanding so the response is potentially for a previous user (which\n            // user, we can't be sure).\n            if (this.tokenCounter !== initialTokenCounter) {\n                logDebug('FirebaseAuthCredentialsProvider', 'getToken aborted due to token change.');\n                return this.getToken();\n            }\n            else {\n                if (tokenData) {\n                    hardAssert(typeof tokenData.accessToken === 'string');\n                    return new OAuthToken(tokenData.accessToken, this.currentUser);\n                }\n                else {\n                    return null;\n                }\n            }\n        });\n    }\n    invalidateToken() {\n        this.forceRefresh = true;\n    }\n    shutdown() {\n        if (this.auth && this.tokenListener) {\n            this.auth.removeAuthTokenListener(this.tokenListener);\n        }\n        this.tokenListener = undefined;\n    }\n    // Auth.getUid() can return null even with a user logged in. It is because\n    // getUid() is synchronous, but the auth code populating Uid is asynchronous.\n    // This method should only be called in the AuthTokenListener callback\n    // to guarantee to get the actual user.\n    getUser() {\n        const currentUid = this.auth && this.auth.getUid();\n        hardAssert(currentUid === null || typeof currentUid === 'string');\n        return new User(currentUid);\n    }\n}\n/*\n * FirstPartyToken provides a fresh token each time its value\n * is requested, because if the token is too old, requests will be rejected.\n * Technically this may no longer be necessary since the SDK should gracefully\n * recover from unauthenticated errors (see b/33147818 for context), but it's\n * safer to keep the implementation as-is.\n */\nclass FirstPartyToken {\n    constructor(sessionIndex, iamToken, authTokenFactory) {\n        this.sessionIndex = sessionIndex;\n        this.iamToken = iamToken;\n        this.authTokenFactory = authTokenFactory;\n        this.type = 'FirstParty';\n        this.user = User.FIRST_PARTY;\n        this._headers = new Map();\n    }\n    /**\n     * Gets an authorization token, using a provided factory function, or return\n     * null.\n     */\n    getAuthToken() {\n        if (this.authTokenFactory) {\n            return this.authTokenFactory();\n        }\n        else {\n            return null;\n        }\n    }\n    get headers() {\n        this._headers.set('X-Goog-AuthUser', this.sessionIndex);\n        // Use array notation to prevent minification\n        const authHeaderTokenValue = this.getAuthToken();\n        if (authHeaderTokenValue) {\n            this._headers.set('Authorization', authHeaderTokenValue);\n        }\n        if (this.iamToken) {\n            this._headers.set('X-Goog-Iam-Authorization-Token', this.iamToken);\n        }\n        return this._headers;\n    }\n}\n/*\n * Provides user credentials required for the Firestore JavaScript SDK\n * to authenticate the user, using technique that is only available\n * to applications hosted by Google.\n */\nclass FirstPartyAuthCredentialsProvider {\n    constructor(sessionIndex, iamToken, authTokenFactory) {\n        this.sessionIndex = sessionIndex;\n        this.iamToken = iamToken;\n        this.authTokenFactory = authTokenFactory;\n    }\n    getToken() {\n        return Promise.resolve(new FirstPartyToken(this.sessionIndex, this.iamToken, this.authTokenFactory));\n    }\n    start(asyncQueue, changeListener) {\n        // Fire with initial uid.\n        asyncQueue.enqueueRetryable(() => changeListener(User.FIRST_PARTY));\n    }\n    shutdown() { }\n    invalidateToken() { }\n}\nclass AppCheckToken {\n    constructor(value) {\n        this.value = value;\n        this.type = 'AppCheck';\n        this.headers = new Map();\n        if (value && value.length > 0) {\n            this.headers.set('x-firebase-appcheck', this.value);\n        }\n    }\n}\nclass FirebaseAppCheckTokenProvider {\n    constructor(app, appCheckProvider) {\n        this.appCheckProvider = appCheckProvider;\n        this.forceRefresh = false;\n        this.appCheck = null;\n        this.latestAppCheckToken = null;\n        this.serverAppAppCheckToken = null;\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(app) && app.settings.appCheckToken) {\n            this.serverAppAppCheckToken = app.settings.appCheckToken;\n        }\n    }\n    start(asyncQueue, changeListener) {\n        hardAssert(this.tokenListener === undefined);\n        const onTokenChanged = tokenResult => {\n            if (tokenResult.error != null) {\n                logDebug('FirebaseAppCheckTokenProvider', `Error getting App Check token; using placeholder token instead. Error: ${tokenResult.error.message}`);\n            }\n            const tokenUpdated = tokenResult.token !== this.latestAppCheckToken;\n            this.latestAppCheckToken = tokenResult.token;\n            logDebug('FirebaseAppCheckTokenProvider', `Received ${tokenUpdated ? 'new' : 'existing'} token.`);\n            return tokenUpdated\n                ? changeListener(tokenResult.token)\n                : Promise.resolve();\n        };\n        this.tokenListener = (tokenResult) => {\n            asyncQueue.enqueueRetryable(() => onTokenChanged(tokenResult));\n        };\n        const registerAppCheck = (appCheck) => {\n            logDebug('FirebaseAppCheckTokenProvider', 'AppCheck detected');\n            this.appCheck = appCheck;\n            if (this.tokenListener) {\n                this.appCheck.addTokenListener(this.tokenListener);\n            }\n        };\n        this.appCheckProvider.onInit(appCheck => registerAppCheck(appCheck));\n        // Our users can initialize AppCheck after Firestore, so we give it\n        // a chance to register itself with the component framework.\n        setTimeout(() => {\n            if (!this.appCheck) {\n                const appCheck = this.appCheckProvider.getImmediate({ optional: true });\n                if (appCheck) {\n                    registerAppCheck(appCheck);\n                }\n                else {\n                    // If AppCheck is still not available, proceed without it.\n                    logDebug('FirebaseAppCheckTokenProvider', 'AppCheck not yet detected');\n                }\n            }\n        }, 0);\n    }\n    getToken() {\n        if (this.serverAppAppCheckToken) {\n            return Promise.resolve(new AppCheckToken(this.serverAppAppCheckToken));\n        }\n        const forceRefresh = this.forceRefresh;\n        this.forceRefresh = false;\n        if (!this.appCheck) {\n            return Promise.resolve(null);\n        }\n        return this.appCheck.getToken(forceRefresh).then(tokenResult => {\n            if (tokenResult) {\n                hardAssert(typeof tokenResult.token === 'string');\n                this.latestAppCheckToken = tokenResult.token;\n                return new AppCheckToken(tokenResult.token);\n            }\n            else {\n                return null;\n            }\n        });\n    }\n    invalidateToken() {\n        this.forceRefresh = true;\n    }\n    shutdown() {\n        if (this.appCheck && this.tokenListener) {\n            this.appCheck.removeTokenListener(this.tokenListener);\n        }\n        this.tokenListener = undefined;\n    }\n}\n/**\n * An AppCheck token provider that always yields an empty token.\n * @internal\n */\nclass EmptyAppCheckTokenProvider {\n    getToken() {\n        return Promise.resolve(new AppCheckToken(''));\n    }\n    invalidateToken() { }\n    start(asyncQueue, changeListener) { }\n    shutdown() { }\n}\n/**\n * Builds a CredentialsProvider depending on the type of\n * the credentials passed in.\n */\nfunction makeAuthCredentialsProvider(credentials) {\n    if (!credentials) {\n        return new EmptyAuthCredentialsProvider();\n    }\n    switch (credentials['type']) {\n        case 'firstParty':\n            return new FirstPartyAuthCredentialsProvider(credentials['sessionIndex'] || '0', credentials['iamToken'] || null, credentials['authTokenFactory'] || null);\n        case 'provider':\n            return credentials['client'];\n        default:\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeAuthCredentialsProvider failed due to invalid credential type');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Generates `nBytes` of random bytes.\n *\n * If `nBytes < 0` , an error will be thrown.\n */\nfunction randomBytes(nBytes) {\n    return (0,crypto__WEBPACK_IMPORTED_MODULE_5__.randomBytes)(nBytes);\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An instance of the Platform's 'TextEncoder' implementation.\n */\nfunction newTextEncoder() {\n    return new util__WEBPACK_IMPORTED_MODULE_3__.TextEncoder();\n}\n/**\n * An instance of the Platform's 'TextDecoder' implementation.\n */\nfunction newTextDecoder() {\n    return new util__WEBPACK_IMPORTED_MODULE_3__.TextDecoder('utf-8');\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A utility class for generating unique alphanumeric IDs of a specified length.\n *\n * @internal\n * Exported internally for testing purposes.\n */\nclass AutoId {\n    static newId() {\n        // Alphanumeric characters\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        // The largest byte value that is a multiple of `char.length`.\n        const maxMultiple = Math.floor(256 / chars.length) * chars.length;\n        let autoId = '';\n        const targetLength = 20;\n        while (autoId.length < targetLength) {\n            const bytes = randomBytes(40);\n            for (let i = 0; i < bytes.length; ++i) {\n                // Only accept values that are [0, maxMultiple), this ensures they can\n                // be evenly mapped to indices of `chars` via a modulo operation.\n                if (autoId.length < targetLength && bytes[i] < maxMultiple) {\n                    autoId += chars.charAt(bytes[i] % chars.length);\n                }\n            }\n        }\n        return autoId;\n    }\n}\nfunction primitiveComparator(left, right) {\n    if (left < right) {\n        return -1;\n    }\n    if (left > right) {\n        return 1;\n    }\n    return 0;\n}\n/** Compare strings in UTF-8 encoded byte order */\nfunction compareUtf8Strings(left, right) {\n    let i = 0;\n    while (i < left.length && i < right.length) {\n        const leftCodePoint = left.codePointAt(i);\n        const rightCodePoint = right.codePointAt(i);\n        if (leftCodePoint !== rightCodePoint) {\n            if (leftCodePoint < 128 && rightCodePoint < 128) {\n                // ASCII comparison\n                return primitiveComparator(leftCodePoint, rightCodePoint);\n            }\n            else {\n                // Lazy instantiate TextEncoder\n                const encoder = newTextEncoder();\n                // UTF-8 encode the character at index i for byte comparison.\n                const leftBytes = encoder.encode(getUtf8SafeSubstring(left, i));\n                const rightBytes = encoder.encode(getUtf8SafeSubstring(right, i));\n                const comp = compareByteArrays$1(leftBytes, rightBytes);\n                if (comp !== 0) {\n                    return comp;\n                }\n                else {\n                    // EXTREMELY RARE CASE: Code points differ, but their UTF-8 byte\n                    // representations are identical. This can happen with malformed input\n                    // (invalid surrogate pairs). The backend also actively prevents invalid\n                    // surrogates as INVALID_ARGUMENT errors, so we almost never receive\n                    // invalid strings from backend.\n                    // Fallback to code point comparison for graceful handling.\n                    return primitiveComparator(leftCodePoint, rightCodePoint);\n                }\n            }\n        }\n        // Increment by 2 for surrogate pairs, 1 otherwise\n        i += leftCodePoint > 0xffff ? 2 : 1;\n    }\n    // Compare lengths if all characters are equal\n    return primitiveComparator(left.length, right.length);\n}\nfunction getUtf8SafeSubstring(str, index) {\n    const firstCodePoint = str.codePointAt(index);\n    if (firstCodePoint > 0xffff) {\n        // It's a surrogate pair, return the whole pair\n        return str.substring(index, index + 2);\n    }\n    else {\n        // It's a single code point, return it\n        return str.substring(index, index + 1);\n    }\n}\nfunction compareByteArrays$1(left, right) {\n    for (let i = 0; i < left.length && i < right.length; ++i) {\n        if (left[i] !== right[i]) {\n            return primitiveComparator(left[i], right[i]);\n        }\n    }\n    return primitiveComparator(left.length, right.length);\n}\n/** Helper to compare arrays using isEqual(). */\nfunction arrayEquals(left, right, comparator) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    return left.every((value, index) => comparator(value, right[index]));\n}\n/**\n * Returns the immediate lexicographically-following string. This is useful to\n * construct an inclusive range for indexeddb iterators.\n */\nfunction immediateSuccessor(s) {\n    // Return the input string, with an additional NUL byte appended.\n    return s + '\\0';\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// The earliest date supported by Firestore timestamps (0001-01-01T00:00:00Z).\nconst MIN_SECONDS = -62135596800;\n// Number of nanoseconds in a millisecond.\nconst MS_TO_NANOS = 1e6;\n/**\n * A `Timestamp` represents a point in time independent of any time zone or\n * calendar, represented as seconds and fractions of seconds at nanosecond\n * resolution in UTC Epoch time.\n *\n * It is encoded using the Proleptic Gregorian Calendar which extends the\n * Gregorian calendar backwards to year one. It is encoded assuming all minutes\n * are 60 seconds long, i.e. leap seconds are \"smeared\" so that no leap second\n * table is needed for interpretation. Range is from 0001-01-01T00:00:00Z to\n * 9999-12-31T23:59:59.999999999Z.\n *\n * For examples and further specifications, refer to the\n * {@link https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto | Timestamp definition}.\n */\nclass Timestamp {\n    /**\n     * Creates a new timestamp with the current date, with millisecond precision.\n     *\n     * @returns a new timestamp representing the current date.\n     */\n    static now() {\n        return Timestamp.fromMillis(Date.now());\n    }\n    /**\n     * Creates a new timestamp from the given date.\n     *\n     * @param date - The date to initialize the `Timestamp` from.\n     * @returns A new `Timestamp` representing the same point in time as the given\n     *     date.\n     */\n    static fromDate(date) {\n        return Timestamp.fromMillis(date.getTime());\n    }\n    /**\n     * Creates a new timestamp from the given number of milliseconds.\n     *\n     * @param milliseconds - Number of milliseconds since Unix epoch\n     *     1970-01-01T00:00:00Z.\n     * @returns A new `Timestamp` representing the same point in time as the given\n     *     number of milliseconds.\n     */\n    static fromMillis(milliseconds) {\n        const seconds = Math.floor(milliseconds / 1000);\n        const nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);\n        return new Timestamp(seconds, nanos);\n    }\n    /**\n     * Creates a new timestamp.\n     *\n     * @param seconds - The number of seconds of UTC time since Unix epoch\n     *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     *     9999-12-31T23:59:59Z inclusive.\n     * @param nanoseconds - The non-negative fractions of a second at nanosecond\n     *     resolution. Negative second values with fractions must still have\n     *     non-negative nanoseconds values that count forward in time. Must be\n     *     from 0 to 999,999,999 inclusive.\n     */\n    constructor(\n    /**\n     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\n     */\n    seconds, \n    /**\n     * The fractions of a second at nanosecond resolution.*\n     */\n    nanoseconds) {\n        this.seconds = seconds;\n        this.nanoseconds = nanoseconds;\n        if (nanoseconds < 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);\n        }\n        if (nanoseconds >= 1e9) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);\n        }\n        if (seconds < MIN_SECONDS) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);\n        }\n        // This will break in the year 10,000.\n        if (seconds >= 253402300800) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);\n        }\n    }\n    /**\n     * Converts a `Timestamp` to a JavaScript `Date` object. This conversion\n     * causes a loss of precision since `Date` objects only support millisecond\n     * precision.\n     *\n     * @returns JavaScript `Date` object representing the same point in time as\n     *     this `Timestamp`, with millisecond precision.\n     */\n    toDate() {\n        return new Date(this.toMillis());\n    }\n    /**\n     * Converts a `Timestamp` to a numeric timestamp (in milliseconds since\n     * epoch). This operation causes a loss of precision.\n     *\n     * @returns The point in time corresponding to this timestamp, represented as\n     *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\n     */\n    toMillis() {\n        return this.seconds * 1000 + this.nanoseconds / MS_TO_NANOS;\n    }\n    _compareTo(other) {\n        if (this.seconds === other.seconds) {\n            return primitiveComparator(this.nanoseconds, other.nanoseconds);\n        }\n        return primitiveComparator(this.seconds, other.seconds);\n    }\n    /**\n     * Returns true if this `Timestamp` is equal to the provided one.\n     *\n     * @param other - The `Timestamp` to compare against.\n     * @returns true if this `Timestamp` is equal to the provided one.\n     */\n    isEqual(other) {\n        return (other.seconds === this.seconds && other.nanoseconds === this.nanoseconds);\n    }\n    /** Returns a textual representation of this `Timestamp`. */\n    toString() {\n        return ('Timestamp(seconds=' +\n            this.seconds +\n            ', nanoseconds=' +\n            this.nanoseconds +\n            ')');\n    }\n    /** Returns a JSON-serializable representation of this `Timestamp`. */\n    toJSON() {\n        return { seconds: this.seconds, nanoseconds: this.nanoseconds };\n    }\n    /**\n     * Converts this object to a primitive string, which allows `Timestamp` objects\n     * to be compared using the `>`, `<=`, `>=` and `>` operators.\n     */\n    valueOf() {\n        // This method returns a string of the form <seconds>.<nanoseconds> where\n        // <seconds> is translated to have a non-negative value and both <seconds>\n        // and <nanoseconds> are left-padded with zeroes to be a consistent length.\n        // Strings with this format then have a lexicographical ordering that matches\n        // the expected ordering. The <seconds> translation is done to avoid having\n        // a leading negative sign (i.e. a leading '-' character) in its string\n        // representation, which would affect its lexicographical ordering.\n        const adjustedSeconds = this.seconds - MIN_SECONDS;\n        // Note: Up to 12 decimal digits are required to represent all valid\n        // 'seconds' values.\n        const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\n        const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\n        return formattedSeconds + '.' + formattedNanoseconds;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A version of a document in Firestore. This corresponds to the version\n * timestamp, such as update_time or read_time.\n */\nclass SnapshotVersion {\n    static fromTimestamp(value) {\n        return new SnapshotVersion(value);\n    }\n    static min() {\n        return new SnapshotVersion(new Timestamp(0, 0));\n    }\n    static max() {\n        return new SnapshotVersion(new Timestamp(253402300799, 1e9 - 1));\n    }\n    constructor(timestamp) {\n        this.timestamp = timestamp;\n    }\n    compareTo(other) {\n        return this.timestamp._compareTo(other.timestamp);\n    }\n    isEqual(other) {\n        return this.timestamp.isEqual(other.timestamp);\n    }\n    /** Returns a number representation of the version for use in spec tests. */\n    toMicroseconds() {\n        // Convert to microseconds.\n        return this.timestamp.seconds * 1e6 + this.timestamp.nanoseconds / 1000;\n    }\n    toString() {\n        return 'SnapshotVersion(' + this.timestamp.toString() + ')';\n    }\n    toTimestamp() {\n        return this.timestamp;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DOCUMENT_KEY_NAME = '__name__';\n/**\n * Path represents an ordered sequence of string segments.\n */\nclass BasePath {\n    constructor(segments, offset, length) {\n        if (offset === undefined) {\n            offset = 0;\n        }\n        else if (offset > segments.length) {\n            fail();\n        }\n        if (length === undefined) {\n            length = segments.length - offset;\n        }\n        else if (length > segments.length - offset) {\n            fail();\n        }\n        this.segments = segments;\n        this.offset = offset;\n        this.len = length;\n    }\n    get length() {\n        return this.len;\n    }\n    isEqual(other) {\n        return BasePath.comparator(this, other) === 0;\n    }\n    child(nameOrPath) {\n        const segments = this.segments.slice(this.offset, this.limit());\n        if (nameOrPath instanceof BasePath) {\n            nameOrPath.forEach(segment => {\n                segments.push(segment);\n            });\n        }\n        else {\n            segments.push(nameOrPath);\n        }\n        return this.construct(segments);\n    }\n    /** The index of one past the last segment of the path. */\n    limit() {\n        return this.offset + this.length;\n    }\n    popFirst(size) {\n        size = size === undefined ? 1 : size;\n        return this.construct(this.segments, this.offset + size, this.length - size);\n    }\n    popLast() {\n        return this.construct(this.segments, this.offset, this.length - 1);\n    }\n    firstSegment() {\n        return this.segments[this.offset];\n    }\n    lastSegment() {\n        return this.get(this.length - 1);\n    }\n    get(index) {\n        return this.segments[this.offset + index];\n    }\n    isEmpty() {\n        return this.length === 0;\n    }\n    isPrefixOf(other) {\n        if (other.length < this.length) {\n            return false;\n        }\n        for (let i = 0; i < this.length; i++) {\n            if (this.get(i) !== other.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isImmediateParentOf(potentialChild) {\n        if (this.length + 1 !== potentialChild.length) {\n            return false;\n        }\n        for (let i = 0; i < this.length; i++) {\n            if (this.get(i) !== potentialChild.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    forEach(fn) {\n        for (let i = this.offset, end = this.limit(); i < end; i++) {\n            fn(this.segments[i]);\n        }\n    }\n    toArray() {\n        return this.segments.slice(this.offset, this.limit());\n    }\n    /**\n     * Compare 2 paths segment by segment, prioritizing numeric IDs\n     * (e.g., \"__id123__\") in numeric ascending order, followed by string\n     * segments in lexicographical order.\n     */\n    static comparator(p1, p2) {\n        const len = Math.min(p1.length, p2.length);\n        for (let i = 0; i < len; i++) {\n            const comparison = BasePath.compareSegments(p1.get(i), p2.get(i));\n            if (comparison !== 0) {\n                return comparison;\n            }\n        }\n        return primitiveComparator(p1.length, p2.length);\n    }\n    static compareSegments(lhs, rhs) {\n        const isLhsNumeric = BasePath.isNumericId(lhs);\n        const isRhsNumeric = BasePath.isNumericId(rhs);\n        if (isLhsNumeric && !isRhsNumeric) {\n            // Only lhs is numeric\n            return -1;\n        }\n        else if (!isLhsNumeric && isRhsNumeric) {\n            // Only rhs is numeric\n            return 1;\n        }\n        else if (isLhsNumeric && isRhsNumeric) {\n            // both numeric\n            return BasePath.extractNumericId(lhs).compare(BasePath.extractNumericId(rhs));\n        }\n        else {\n            // both non-numeric\n            return compareUtf8Strings(lhs, rhs);\n        }\n    }\n    // Checks if a segment is a numeric ID (starts with \"__id\" and ends with \"__\").\n    static isNumericId(segment) {\n        return segment.startsWith('__id') && segment.endsWith('__');\n    }\n    static extractNumericId(segment) {\n        return _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer.fromString(segment.substring(4, segment.length - 2));\n    }\n}\n/**\n * A slash-separated path for navigating resources (documents and collections)\n * within Firestore.\n *\n * @internal\n */\nclass ResourcePath extends BasePath {\n    construct(segments, offset, length) {\n        return new ResourcePath(segments, offset, length);\n    }\n    canonicalString() {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        return this.toArray().join('/');\n    }\n    toString() {\n        return this.canonicalString();\n    }\n    /**\n     * Returns a string representation of this path\n     * where each path segment has been encoded with\n     * `encodeURIComponent`.\n     */\n    toUriEncodedString() {\n        return this.toArray().map(encodeURIComponent).join('/');\n    }\n    /**\n     * Creates a resource path from the given slash-delimited string. If multiple\n     * arguments are provided, all components are combined. Leading and trailing\n     * slashes from all components are ignored.\n     */\n    static fromString(...pathComponents) {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        const segments = [];\n        for (const path of pathComponents) {\n            if (path.indexOf('//') >= 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid segment (${path}). Paths must not contain // in them.`);\n            }\n            // Strip leading and trailing slashed.\n            segments.push(...path.split('/').filter(segment => segment.length > 0));\n        }\n        return new ResourcePath(segments);\n    }\n    static emptyPath() {\n        return new ResourcePath([]);\n    }\n}\nconst identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n/**\n * A dot-separated path for navigating sub-objects within a document.\n * @internal\n */\nclass FieldPath$1 extends BasePath {\n    construct(segments, offset, length) {\n        return new FieldPath$1(segments, offset, length);\n    }\n    /**\n     * Returns true if the string could be used as a segment in a field path\n     * without escaping.\n     */\n    static isValidIdentifier(segment) {\n        return identifierRegExp.test(segment);\n    }\n    canonicalString() {\n        return this.toArray()\n            .map(str => {\n            str = str.replace(/\\\\/g, '\\\\\\\\').replace(/`/g, '\\\\`');\n            if (!FieldPath$1.isValidIdentifier(str)) {\n                str = '`' + str + '`';\n            }\n            return str;\n        })\n            .join('.');\n    }\n    toString() {\n        return this.canonicalString();\n    }\n    /**\n     * Returns true if this field references the key of a document.\n     */\n    isKeyField() {\n        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\n    }\n    /**\n     * The field designating the key of a document.\n     */\n    static keyField() {\n        return new FieldPath$1([DOCUMENT_KEY_NAME]);\n    }\n    /**\n     * Parses a field string from the given server-formatted string.\n     *\n     * - Splitting the empty string is not allowed (for now at least).\n     * - Empty segments within the string (e.g. if there are two consecutive\n     *   separators) are not allowed.\n     *\n     * TODO(b/37244157): we should make this more strict. Right now, it allows\n     * non-identifier path components, even if they aren't escaped.\n     */\n    static fromServerFormat(path) {\n        const segments = [];\n        let current = '';\n        let i = 0;\n        const addCurrentSegment = () => {\n            if (current.length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field path (${path}). Paths must not be empty, begin ` +\n                    `with '.', end with '.', or contain '..'`);\n            }\n            segments.push(current);\n            current = '';\n        };\n        let inBackticks = false;\n        while (i < path.length) {\n            const c = path[i];\n            if (c === '\\\\') {\n                if (i + 1 === path.length) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);\n                }\n                const next = path[i + 1];\n                if (!(next === '\\\\' || next === '.' || next === '`')) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);\n                }\n                current += next;\n                i += 2;\n            }\n            else if (c === '`') {\n                inBackticks = !inBackticks;\n                i++;\n            }\n            else if (c === '.' && !inBackticks) {\n                addCurrentSegment();\n                i++;\n            }\n            else {\n                current += c;\n                i++;\n            }\n        }\n        addCurrentSegment();\n        if (inBackticks) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);\n        }\n        return new FieldPath$1(segments);\n    }\n    static emptyPath() {\n        return new FieldPath$1([]);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @internal\n */\nclass DocumentKey {\n    constructor(path) {\n        this.path = path;\n    }\n    static fromPath(path) {\n        return new DocumentKey(ResourcePath.fromString(path));\n    }\n    static fromName(name) {\n        return new DocumentKey(ResourcePath.fromString(name).popFirst(5));\n    }\n    static empty() {\n        return new DocumentKey(ResourcePath.emptyPath());\n    }\n    get collectionGroup() {\n        return this.path.popLast().lastSegment();\n    }\n    /** Returns true if the document is in the specified collectionId. */\n    hasCollectionId(collectionId) {\n        return (this.path.length >= 2 &&\n            this.path.get(this.path.length - 2) === collectionId);\n    }\n    /** Returns the collection group (i.e. the name of the parent collection) for this key. */\n    getCollectionGroup() {\n        return this.path.get(this.path.length - 2);\n    }\n    /** Returns the fully qualified path to the parent collection. */\n    getCollectionPath() {\n        return this.path.popLast();\n    }\n    isEqual(other) {\n        return (other !== null && ResourcePath.comparator(this.path, other.path) === 0);\n    }\n    toString() {\n        return this.path.toString();\n    }\n    static comparator(k1, k2) {\n        return ResourcePath.comparator(k1.path, k2.path);\n    }\n    static isDocumentKey(path) {\n        return path.length % 2 === 0;\n    }\n    /**\n     * Creates and returns a new document key with the given segments.\n     *\n     * @param segments - The segments of the path to the document\n     * @returns A new instance of DocumentKey\n     */\n    static fromSegments(segments) {\n        return new DocumentKey(new ResourcePath(segments.slice()));\n    }\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The initial mutation batch id for each index. Gets updated during index\n * backfill.\n */\nconst INITIAL_LARGEST_BATCH_ID = -1;\n/**\n * The initial sequence number for each index. Gets updated during index\n * backfill.\n */\nconst INITIAL_SEQUENCE_NUMBER = 0;\n/**\n * An index definition for field indexes in Firestore.\n *\n * Every index is associated with a collection. The definition contains a list\n * of fields and their index kind (which can be `ASCENDING`, `DESCENDING` or\n * `CONTAINS` for ArrayContains/ArrayContainsAny queries).\n *\n * Unlike the backend, the SDK does not differentiate between collection or\n * collection group-scoped indices. Every index can be used for both single\n * collection and collection group queries.\n */\nclass FieldIndex {\n    constructor(\n    /**\n     * The index ID. Returns -1 if the index ID is not available (e.g. the index\n     * has not yet been persisted).\n     */\n    indexId, \n    /** The collection ID this index applies to. */\n    collectionGroup, \n    /** The field segments for this index. */\n    fields, \n    /** Shows how up-to-date the index is for the current user. */\n    indexState) {\n        this.indexId = indexId;\n        this.collectionGroup = collectionGroup;\n        this.fields = fields;\n        this.indexState = indexState;\n    }\n}\n/** An ID for an index that has not yet been added to persistence.  */\nFieldIndex.UNKNOWN_ID = -1;\n/** Returns the ArrayContains/ArrayContainsAny segment for this index. */\nfunction fieldIndexGetArraySegment(fieldIndex) {\n    return fieldIndex.fields.find(s => s.kind === 2 /* IndexKind.CONTAINS */);\n}\n/** Returns all directional (ascending/descending) segments for this index. */\nfunction fieldIndexGetDirectionalSegments(fieldIndex) {\n    return fieldIndex.fields.filter(s => s.kind !== 2 /* IndexKind.CONTAINS */);\n}\n/**\n * Returns the order of the document key component for the given index.\n *\n * PORTING NOTE: This is only used in the Web IndexedDb implementation.\n */\nfunction fieldIndexGetKeyOrder(fieldIndex) {\n    const directionalSegments = fieldIndexGetDirectionalSegments(fieldIndex);\n    return directionalSegments.length === 0\n        ? 0 /* IndexKind.ASCENDING */\n        : directionalSegments[directionalSegments.length - 1].kind;\n}\n/**\n * Compares indexes by collection group and segments. Ignores update time and\n * index ID.\n */\nfunction fieldIndexSemanticComparator(left, right) {\n    let cmp = primitiveComparator(left.collectionGroup, right.collectionGroup);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    for (let i = 0; i < Math.min(left.fields.length, right.fields.length); ++i) {\n        cmp = indexSegmentComparator(left.fields[i], right.fields[i]);\n        if (cmp !== 0) {\n            return cmp;\n        }\n    }\n    return primitiveComparator(left.fields.length, right.fields.length);\n}\n/** Returns a debug representation of the field index */\nfunction fieldIndexToString(fieldIndex) {\n    return `id=${fieldIndex.indexId}|cg=${fieldIndex.collectionGroup}|f=${fieldIndex.fields.map(f => `${f.fieldPath}:${f.kind}`).join(',')}`;\n}\n/** An index component consisting of field path and index type.  */\nclass IndexSegment {\n    constructor(\n    /** The field path of the component. */\n    fieldPath, \n    /** The fields sorting order. */\n    kind) {\n        this.fieldPath = fieldPath;\n        this.kind = kind;\n    }\n}\nfunction indexSegmentComparator(left, right) {\n    const cmp = FieldPath$1.comparator(left.fieldPath, right.fieldPath);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return primitiveComparator(left.kind, right.kind);\n}\n/**\n * Stores the \"high water mark\" that indicates how updated the Index is for the\n * current user.\n */\nclass IndexState {\n    constructor(\n    /**\n     * Indicates when the index was last updated (relative to other indexes).\n     */\n    sequenceNumber, \n    /** The the latest indexed read time, document and batch id. */\n    offset) {\n        this.sequenceNumber = sequenceNumber;\n        this.offset = offset;\n    }\n    /** The state of an index that has not yet been backfilled. */\n    static empty() {\n        return new IndexState(INITIAL_SEQUENCE_NUMBER, IndexOffset.min());\n    }\n}\n/**\n * Creates an offset that matches all documents with a read time higher than\n * `readTime`.\n */\nfunction newIndexOffsetSuccessorFromReadTime(readTime, largestBatchId) {\n    // We want to create an offset that matches all documents with a read time\n    // greater than the provided read time. To do so, we technically need to\n    // create an offset for `(readTime, MAX_DOCUMENT_KEY)`. While we could use\n    // Unicode codepoints to generate MAX_DOCUMENT_KEY, it is much easier to use\n    // `(readTime + 1, DocumentKey.empty())` since `> DocumentKey.empty()` matches\n    // all valid document IDs.\n    const successorSeconds = readTime.toTimestamp().seconds;\n    const successorNanos = readTime.toTimestamp().nanoseconds + 1;\n    const successor = SnapshotVersion.fromTimestamp(successorNanos === 1e9\n        ? new Timestamp(successorSeconds + 1, 0)\n        : new Timestamp(successorSeconds, successorNanos));\n    return new IndexOffset(successor, DocumentKey.empty(), largestBatchId);\n}\n/** Creates a new offset based on the provided document. */\nfunction newIndexOffsetFromDocument(document) {\n    return new IndexOffset(document.readTime, document.key, INITIAL_LARGEST_BATCH_ID);\n}\n/**\n * Stores the latest read time, document and batch ID that were processed for an\n * index.\n */\nclass IndexOffset {\n    constructor(\n    /**\n     * The latest read time version that has been indexed by Firestore for this\n     * field index.\n     */\n    readTime, \n    /**\n     * The key of the last document that was indexed for this query. Use\n     * `DocumentKey.empty()` if no document has been indexed.\n     */\n    documentKey, \n    /*\n     * The largest mutation batch id that's been processed by Firestore.\n     */\n    largestBatchId) {\n        this.readTime = readTime;\n        this.documentKey = documentKey;\n        this.largestBatchId = largestBatchId;\n    }\n    /** Returns an offset that sorts before all regular offsets. */\n    static min() {\n        return new IndexOffset(SnapshotVersion.min(), DocumentKey.empty(), INITIAL_LARGEST_BATCH_ID);\n    }\n    /** Returns an offset that sorts after all regular offsets. */\n    static max() {\n        return new IndexOffset(SnapshotVersion.max(), DocumentKey.empty(), INITIAL_LARGEST_BATCH_ID);\n    }\n}\nfunction indexOffsetComparator(left, right) {\n    let cmp = left.readTime.compareTo(right.readTime);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = DocumentKey.comparator(left.documentKey, right.documentKey);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return primitiveComparator(left.largestBatchId, right.largestBatchId);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst PRIMARY_LEASE_LOST_ERROR_MSG = 'The current tab is not in the required state to perform this operation. ' +\n    'It might be necessary to refresh the browser tab.';\n/**\n * A base class representing a persistence transaction, encapsulating both the\n * transaction's sequence numbers as well as a list of onCommitted listeners.\n *\n * When you call Persistence.runTransaction(), it will create a transaction and\n * pass it to your callback. You then pass it to any method that operates\n * on persistence.\n */\nclass PersistenceTransaction {\n    constructor() {\n        this.onCommittedListeners = [];\n    }\n    addOnCommittedListener(listener) {\n        this.onCommittedListeners.push(listener);\n    }\n    raiseOnCommittedEvent() {\n        this.onCommittedListeners.forEach(listener => listener());\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Verifies the error thrown by a LocalStore operation. If a LocalStore\n * operation fails because the primary lease has been taken by another client,\n * we ignore the error (the persistence layer will immediately call\n * `applyPrimaryLease` to propagate the primary state change). All other errors\n * are re-thrown.\n *\n * @param err - An error returned by a LocalStore operation.\n * @returns A Promise that resolves after we recovered, or the original error.\n */\nasync function ignoreIfPrimaryLeaseLoss(err) {\n    if (err.code === Code.FAILED_PRECONDITION &&\n        err.message === PRIMARY_LEASE_LOST_ERROR_MSG) {\n        logDebug('LocalStore', 'Unexpectedly lost primary lease');\n    }\n    else {\n        throw err;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * PersistencePromise is essentially a re-implementation of Promise except\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\n * are executed synchronously when a PersistencePromise resolves rather than\n * asynchronously (Promise implementations use setImmediate() or similar).\n *\n * This is necessary to interoperate with IndexedDB which will automatically\n * commit transactions if control is returned to the event loop without\n * synchronously initiating another operation on the transaction.\n *\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\n * Promises.\n */\nclass PersistencePromise {\n    constructor(callback) {\n        // NOTE: next/catchCallback will always point to our own wrapper functions,\n        // not the user's raw next() or catch() callbacks.\n        this.nextCallback = null;\n        this.catchCallback = null;\n        // When the operation resolves, we'll set result or error and mark isDone.\n        this.result = undefined;\n        this.error = undefined;\n        this.isDone = false;\n        // Set to true when .then() or .catch() are called and prevents additional\n        // chaining.\n        this.callbackAttached = false;\n        callback(value => {\n            this.isDone = true;\n            this.result = value;\n            if (this.nextCallback) {\n                // value should be defined unless T is Void, but we can't express\n                // that in the type system.\n                this.nextCallback(value);\n            }\n        }, error => {\n            this.isDone = true;\n            this.error = error;\n            if (this.catchCallback) {\n                this.catchCallback(error);\n            }\n        });\n    }\n    catch(fn) {\n        return this.next(undefined, fn);\n    }\n    next(nextFn, catchFn) {\n        if (this.callbackAttached) {\n            fail();\n        }\n        this.callbackAttached = true;\n        if (this.isDone) {\n            if (!this.error) {\n                return this.wrapSuccess(nextFn, this.result);\n            }\n            else {\n                return this.wrapFailure(catchFn, this.error);\n            }\n        }\n        else {\n            return new PersistencePromise((resolve, reject) => {\n                this.nextCallback = (value) => {\n                    this.wrapSuccess(nextFn, value).next(resolve, reject);\n                };\n                this.catchCallback = (error) => {\n                    this.wrapFailure(catchFn, error).next(resolve, reject);\n                };\n            });\n        }\n    }\n    toPromise() {\n        return new Promise((resolve, reject) => {\n            this.next(resolve, reject);\n        });\n    }\n    wrapUserFunction(fn) {\n        try {\n            const result = fn();\n            if (result instanceof PersistencePromise) {\n                return result;\n            }\n            else {\n                return PersistencePromise.resolve(result);\n            }\n        }\n        catch (e) {\n            return PersistencePromise.reject(e);\n        }\n    }\n    wrapSuccess(nextFn, value) {\n        if (nextFn) {\n            return this.wrapUserFunction(() => nextFn(value));\n        }\n        else {\n            // If there's no nextFn, then R must be the same as T\n            return PersistencePromise.resolve(value);\n        }\n    }\n    wrapFailure(catchFn, error) {\n        if (catchFn) {\n            return this.wrapUserFunction(() => catchFn(error));\n        }\n        else {\n            return PersistencePromise.reject(error);\n        }\n    }\n    static resolve(result) {\n        return new PersistencePromise((resolve, reject) => {\n            resolve(result);\n        });\n    }\n    static reject(error) {\n        return new PersistencePromise((resolve, reject) => {\n            reject(error);\n        });\n    }\n    static waitFor(\n    // Accept all Promise types in waitFor().\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    all) {\n        return new PersistencePromise((resolve, reject) => {\n            let expectedCount = 0;\n            let resolvedCount = 0;\n            let done = false;\n            all.forEach(element => {\n                ++expectedCount;\n                element.next(() => {\n                    ++resolvedCount;\n                    if (done && resolvedCount === expectedCount) {\n                        resolve();\n                    }\n                }, err => reject(err));\n            });\n            done = true;\n            if (resolvedCount === expectedCount) {\n                resolve();\n            }\n        });\n    }\n    /**\n     * Given an array of predicate functions that asynchronously evaluate to a\n     * boolean, implements a short-circuiting `or` between the results. Predicates\n     * will be evaluated until one of them returns `true`, then stop. The final\n     * result will be whether any of them returned `true`.\n     */\n    static or(predicates) {\n        let p = PersistencePromise.resolve(false);\n        for (const predicate of predicates) {\n            p = p.next(isTrue => {\n                if (isTrue) {\n                    return PersistencePromise.resolve(isTrue);\n                }\n                else {\n                    return predicate();\n                }\n            });\n        }\n        return p;\n    }\n    static forEach(collection, f) {\n        const promises = [];\n        collection.forEach((r, s) => {\n            promises.push(f.call(this, r, s));\n        });\n        return this.waitFor(promises);\n    }\n    /**\n     * Concurrently map all array elements through asynchronous function.\n     */\n    static mapArray(array, f) {\n        return new PersistencePromise((resolve, reject) => {\n            const expectedCount = array.length;\n            const results = new Array(expectedCount);\n            let resolvedCount = 0;\n            for (let i = 0; i < expectedCount; i++) {\n                const current = i;\n                f(array[current]).next(result => {\n                    results[current] = result;\n                    ++resolvedCount;\n                    if (resolvedCount === expectedCount) {\n                        resolve(results);\n                    }\n                }, err => reject(err));\n            }\n        });\n    }\n    /**\n     * An alternative to recursive PersistencePromise calls, that avoids\n     * potential memory problems from unbounded chains of promises.\n     *\n     * The `action` will be called repeatedly while `condition` is true.\n     */\n    static doWhile(condition, action) {\n        return new PersistencePromise((resolve, reject) => {\n            const process = () => {\n                if (condition() === true) {\n                    action().next(() => {\n                        process();\n                    }, reject);\n                }\n                else {\n                    resolve();\n                }\n            };\n            process();\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// References to `window` are guarded by SimpleDb.isAvailable()\n/* eslint-disable no-restricted-globals */\nconst LOG_TAG$i = 'SimpleDb';\n/**\n * The maximum number of retry attempts for an IndexedDb transaction that fails\n * with a DOMException.\n */\nconst TRANSACTION_RETRY_COUNT = 3;\n/**\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\n * specific object store.\n */\nclass SimpleDbTransaction {\n    static open(db, action, mode, objectStoreNames) {\n        try {\n            return new SimpleDbTransaction(action, db.transaction(objectStoreNames, mode));\n        }\n        catch (e) {\n            throw new IndexedDbTransactionError(action, e);\n        }\n    }\n    constructor(action, transaction) {\n        this.action = action;\n        this.transaction = transaction;\n        this.aborted = false;\n        /**\n         * A `Promise` that resolves with the result of the IndexedDb transaction.\n         */\n        this.completionDeferred = new Deferred();\n        this.transaction.oncomplete = () => {\n            this.completionDeferred.resolve();\n        };\n        this.transaction.onabort = () => {\n            if (transaction.error) {\n                this.completionDeferred.reject(new IndexedDbTransactionError(action, transaction.error));\n            }\n            else {\n                this.completionDeferred.resolve();\n            }\n        };\n        this.transaction.onerror = (event) => {\n            const error = checkForAndReportiOSError(event.target.error);\n            this.completionDeferred.reject(new IndexedDbTransactionError(action, error));\n        };\n    }\n    get completionPromise() {\n        return this.completionDeferred.promise;\n    }\n    abort(error) {\n        if (error) {\n            this.completionDeferred.reject(error);\n        }\n        if (!this.aborted) {\n            logDebug(LOG_TAG$i, 'Aborting transaction:', error ? error.message : 'Client-initiated abort');\n            this.aborted = true;\n            this.transaction.abort();\n        }\n    }\n    maybeCommit() {\n        // If the browser supports V3 IndexedDB, we invoke commit() explicitly to\n        // speed up index DB processing if the event loop remains blocks.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const maybeV3IndexedDb = this.transaction;\n        if (!this.aborted && typeof maybeV3IndexedDb.commit === 'function') {\n            maybeV3IndexedDb.commit();\n        }\n    }\n    /**\n     * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\n     * operations performed on the SimpleDbStore happen within the context of this\n     * transaction and it cannot be used anymore once the transaction is\n     * completed.\n     *\n     * Note that we can't actually enforce that the KeyType and ValueType are\n     * correct, but they allow type safety through the rest of the consuming code.\n     */\n    store(storeName) {\n        const store = this.transaction.objectStore(storeName);\n        return new SimpleDbStore(store);\n    }\n}\n/**\n * Provides a wrapper around IndexedDb with a simplified interface that uses\n * Promise-like return values to chain operations. Real promises cannot be used\n * since .then() continuations are executed asynchronously (e.g. via\n * .setImmediate), which would cause IndexedDB to end the transaction.\n * See PersistencePromise for more details.\n */\nclass SimpleDb {\n    /** Deletes the specified database. */\n    static delete(name) {\n        logDebug(LOG_TAG$i, 'Removing database:', name);\n        return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();\n    }\n    /** Returns true if IndexedDB is available in the current environment. */\n    static isAvailable() {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isIndexedDBAvailable)()) {\n            return false;\n        }\n        if (SimpleDb.isMockPersistence()) {\n            return true;\n        }\n        // We extensively use indexed array values and compound keys,\n        // which IE and Edge do not support. However, they still have indexedDB\n        // defined on the window, so we need to check for them here and make sure\n        // to return that persistence is not enabled for those browsers.\n        // For tracking support of this feature, see here:\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\n        // Check the UA string to find out the browser.\n        const ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)();\n        // IE 10\n        // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n        // IE 11\n        // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n        // Edge\n        // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\n        // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n        // iOS Safari: Disable for users running iOS version < 10.\n        const iOSVersion = SimpleDb.getIOSVersion(ua);\n        const isUnsupportedIOS = 0 < iOSVersion && iOSVersion < 10;\n        // Android browser: Disable for users running version < 4.5.\n        const androidVersion = getAndroidVersion(ua);\n        const isUnsupportedAndroid = 0 < androidVersion && androidVersion < 4.5;\n        if (ua.indexOf('MSIE ') > 0 ||\n            ua.indexOf('Trident/') > 0 ||\n            ua.indexOf('Edge/') > 0 ||\n            isUnsupportedIOS ||\n            isUnsupportedAndroid) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    /**\n     * Returns true if the backing IndexedDB store is the Node IndexedDBShim\n     * (see https://github.com/axemclion/IndexedDBShim).\n     */\n    static isMockPersistence() {\n        var _a;\n        return (typeof process !== 'undefined' &&\n            ((_a = process.env) === null || _a === void 0 ? void 0 : _a.USE_MOCK_PERSISTENCE) === 'YES');\n    }\n    /** Helper to get a typed SimpleDbStore from a transaction. */\n    static getStore(txn, store) {\n        return txn.store(store);\n    }\n    // visible for testing\n    /** Parse User Agent to determine iOS version. Returns -1 if not found. */\n    static getIOSVersion(ua) {\n        const iOSVersionRegex = ua.match(/i(?:phone|pad|pod) os ([\\d_]+)/i);\n        const version = iOSVersionRegex\n            ? iOSVersionRegex[1].split('_').slice(0, 2).join('.')\n            : '-1';\n        return Number(version);\n    }\n    /*\n     * Creates a new SimpleDb wrapper for IndexedDb database `name`.\n     *\n     * Note that `version` must not be a downgrade. IndexedDB does not support\n     * downgrading the schema version. We currently do not support any way to do\n     * versioning outside of IndexedDB's versioning mechanism, as only\n     * version-upgrade transactions are allowed to do things like create\n     * objectstores.\n     */\n    constructor(name, version, schemaConverter) {\n        this.name = name;\n        this.version = version;\n        this.schemaConverter = schemaConverter;\n        const iOSVersion = SimpleDb.getIOSVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)());\n        // NOTE: According to https://bugs.webkit.org/show_bug.cgi?id=197050, the\n        // bug we're checking for should exist in iOS >= 12.2 and < 13, but for\n        // whatever reason it's much harder to hit after 12.2 so we only proactively\n        // log on 12.2.\n        if (iOSVersion === 12.2) {\n            logError('Firestore persistence suffers from a bug in iOS 12.2 ' +\n                'Safari that may cause your app to stop working. See ' +\n                'https://stackoverflow.com/q/56496296/110915 for details ' +\n                'and a potential workaround.');\n        }\n    }\n    /**\n     * Opens the specified database, creating or upgrading it if necessary.\n     */\n    async ensureDb(action) {\n        if (!this.db) {\n            logDebug(LOG_TAG$i, 'Opening database:', this.name);\n            this.db = await new Promise((resolve, reject) => {\n                // TODO(mikelehen): Investigate browser compatibility.\n                // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\n                // suggests IE9 and older WebKit browsers handle upgrade\n                // differently. They expect setVersion, as described here:\n                // https://developer.mozilla.org/en-US/docs/Web/API/IDBVersionChangeRequest/setVersion\n                const request = indexedDB.open(this.name, this.version);\n                request.onsuccess = (event) => {\n                    const db = event.target.result;\n                    resolve(db);\n                };\n                request.onblocked = () => {\n                    reject(new IndexedDbTransactionError(action, 'Cannot upgrade IndexedDB schema while another tab is open. ' +\n                        'Close all tabs that access Firestore and reload this page to proceed.'));\n                };\n                request.onerror = (event) => {\n                    const error = event.target.error;\n                    if (error.name === 'VersionError') {\n                        reject(new FirestoreError(Code.FAILED_PRECONDITION, 'A newer version of the Firestore SDK was previously used and so the persisted ' +\n                            'data is not compatible with the version of the SDK you are now using. The SDK ' +\n                            'will operate with persistence disabled. If you need persistence, please ' +\n                            're-upgrade to a newer version of the SDK or else clear the persisted IndexedDB ' +\n                            'data for your app to start fresh.'));\n                    }\n                    else if (error.name === 'InvalidStateError') {\n                        reject(new FirestoreError(Code.FAILED_PRECONDITION, 'Unable to open an IndexedDB connection. This could be due to running in a ' +\n                            'private browsing session on a browser whose private browsing sessions do not ' +\n                            'support IndexedDB: ' +\n                            error));\n                    }\n                    else {\n                        reject(new IndexedDbTransactionError(action, error));\n                    }\n                };\n                request.onupgradeneeded = (event) => {\n                    logDebug(LOG_TAG$i, 'Database \"' + this.name + '\" requires upgrade from version:', event.oldVersion);\n                    const db = event.target.result;\n                    this.schemaConverter\n                        .createOrUpgrade(db, request.transaction, event.oldVersion, this.version)\n                        .next(() => {\n                        logDebug(LOG_TAG$i, 'Database upgrade to version ' + this.version + ' complete');\n                    });\n                };\n            });\n        }\n        if (this.versionchangelistener) {\n            this.db.onversionchange = event => this.versionchangelistener(event);\n        }\n        return this.db;\n    }\n    setVersionChangeListener(versionChangeListener) {\n        this.versionchangelistener = versionChangeListener;\n        if (this.db) {\n            this.db.onversionchange = (event) => {\n                return versionChangeListener(event);\n            };\n        }\n    }\n    async runTransaction(action, mode, objectStores, transactionFn) {\n        const readonly = mode === 'readonly';\n        let attemptNumber = 0;\n        while (true) {\n            ++attemptNumber;\n            try {\n                this.db = await this.ensureDb(action);\n                const transaction = SimpleDbTransaction.open(this.db, action, readonly ? 'readonly' : 'readwrite', objectStores);\n                const transactionFnResult = transactionFn(transaction)\n                    .next(result => {\n                    transaction.maybeCommit();\n                    return result;\n                })\n                    .catch(error => {\n                    // Abort the transaction if there was an error.\n                    transaction.abort(error);\n                    // We cannot actually recover, and calling `abort()` will cause the transaction's\n                    // completion promise to be rejected. This in turn means that we won't use\n                    // `transactionFnResult` below. We return a rejection here so that we don't add the\n                    // possibility of returning `void` to the type of `transactionFnResult`.\n                    return PersistencePromise.reject(error);\n                })\n                    .toPromise();\n                // As noted above, errors are propagated by aborting the transaction. So\n                // we swallow any error here to avoid the browser logging it as unhandled.\n                transactionFnResult.catch(() => { });\n                // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\n                // fire), but still return the original transactionFnResult back to the\n                // caller.\n                await transaction.completionPromise;\n                return transactionFnResult;\n            }\n            catch (e) {\n                const error = e;\n                // TODO(schmidt-sebastian): We could probably be smarter about this and\n                // not retry exceptions that are likely unrecoverable (such as quota\n                // exceeded errors).\n                // Note: We cannot use an instanceof check for FirestoreException, since the\n                // exception is wrapped in a generic error by our async/await handling.\n                const retryable = error.name !== 'FirebaseError' &&\n                    attemptNumber < TRANSACTION_RETRY_COUNT;\n                logDebug(LOG_TAG$i, 'Transaction failed with error:', error.message, 'Retrying:', retryable);\n                this.close();\n                if (!retryable) {\n                    return Promise.reject(error);\n                }\n            }\n        }\n    }\n    close() {\n        if (this.db) {\n            this.db.close();\n        }\n        this.db = undefined;\n    }\n}\n/** Parse User Agent to determine Android version. Returns -1 if not found. */\nfunction getAndroidVersion(ua) {\n    const androidVersionRegex = ua.match(/Android ([\\d.]+)/i);\n    const version = androidVersionRegex\n        ? androidVersionRegex[1].split('.').slice(0, 2).join('.')\n        : '-1';\n    return Number(version);\n}\n/**\n * A controller for iterating over a key range or index. It allows an iterate\n * callback to delete the currently-referenced object, or jump to a new key\n * within the key range or index.\n */\nclass IterationController {\n    constructor(dbCursor) {\n        this.dbCursor = dbCursor;\n        this.shouldStop = false;\n        this.nextKey = null;\n    }\n    get isDone() {\n        return this.shouldStop;\n    }\n    get skipToKey() {\n        return this.nextKey;\n    }\n    set cursor(value) {\n        this.dbCursor = value;\n    }\n    /**\n     * This function can be called to stop iteration at any point.\n     */\n    done() {\n        this.shouldStop = true;\n    }\n    /**\n     * This function can be called to skip to that next key, which could be\n     * an index or a primary key.\n     */\n    skip(key) {\n        this.nextKey = key;\n    }\n    /**\n     * Delete the current cursor value from the object store.\n     *\n     * NOTE: You CANNOT do this with a keysOnly query.\n     */\n    delete() {\n        return wrapRequest(this.dbCursor.delete());\n    }\n}\n/** An error that wraps exceptions that thrown during IndexedDB execution. */\nclass IndexedDbTransactionError extends FirestoreError {\n    constructor(actionName, cause) {\n        super(Code.UNAVAILABLE, `IndexedDB transaction '${actionName}' failed: ${cause}`);\n        this.name = 'IndexedDbTransactionError';\n    }\n}\n/** Verifies whether `e` is an IndexedDbTransactionError. */\nfunction isIndexedDbTransactionError(e) {\n    // Use name equality, as instanceof checks on errors don't work with errors\n    // that wrap other errors.\n    return e.name === 'IndexedDbTransactionError';\n}\n/**\n * A wrapper around an IDBObjectStore providing an API that:\n *\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\n * methods for acting against the object store.\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\n * method return a PersistencePromise instead.\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\n */\nclass SimpleDbStore {\n    constructor(store) {\n        this.store = store;\n    }\n    put(keyOrValue, value) {\n        let request;\n        if (value !== undefined) {\n            logDebug(LOG_TAG$i, 'PUT', this.store.name, keyOrValue, value);\n            request = this.store.put(value, keyOrValue);\n        }\n        else {\n            logDebug(LOG_TAG$i, 'PUT', this.store.name, '<auto-key>', keyOrValue);\n            request = this.store.put(keyOrValue);\n        }\n        return wrapRequest(request);\n    }\n    /**\n     * Adds a new value into an Object Store and returns the new key. Similar to\n     * IndexedDb's `add()`, this method will fail on primary key collisions.\n     *\n     * @param value - The object to write.\n     * @returns The key of the value to add.\n     */\n    add(value) {\n        logDebug(LOG_TAG$i, 'ADD', this.store.name, value, value);\n        const request = this.store.add(value);\n        return wrapRequest(request);\n    }\n    /**\n     * Gets the object with the specified key from the specified store, or null\n     * if no object exists with the specified key.\n     *\n     * @key The key of the object to get.\n     * @returns The object with the specified key or null if no object exists.\n     */\n    get(key) {\n        const request = this.store.get(key);\n        // We're doing an unsafe cast to ValueType.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return wrapRequest(request).next(result => {\n            // Normalize nonexistence to null.\n            if (result === undefined) {\n                result = null;\n            }\n            logDebug(LOG_TAG$i, 'GET', this.store.name, key, result);\n            return result;\n        });\n    }\n    delete(key) {\n        logDebug(LOG_TAG$i, 'DELETE', this.store.name, key);\n        const request = this.store.delete(key);\n        return wrapRequest(request);\n    }\n    /**\n     * If we ever need more of the count variants, we can add overloads. For now,\n     * all we need is to count everything in a store.\n     *\n     * Returns the number of rows in the store.\n     */\n    count() {\n        logDebug(LOG_TAG$i, 'COUNT', this.store.name);\n        const request = this.store.count();\n        return wrapRequest(request);\n    }\n    loadAll(indexOrRange, range) {\n        const iterateOptions = this.options(indexOrRange, range);\n        // Use `getAll()` if the browser supports IndexedDB v3, as it is roughly\n        // 20% faster.\n        const store = iterateOptions.index\n            ? this.store.index(iterateOptions.index)\n            : this.store;\n        if (typeof store.getAll === 'function') {\n            const request = store.getAll(iterateOptions.range);\n            return new PersistencePromise((resolve, reject) => {\n                request.onerror = (event) => {\n                    reject(event.target.error);\n                };\n                request.onsuccess = (event) => {\n                    resolve(event.target.result);\n                };\n            });\n        }\n        else {\n            const cursor = this.cursor(iterateOptions);\n            const results = [];\n            return this.iterateCursor(cursor, (key, value) => {\n                results.push(value);\n            }).next(() => {\n                return results;\n            });\n        }\n    }\n    /**\n     * Loads the first `count` elements from the provided index range. Loads all\n     * elements if no limit is provided.\n     */\n    loadFirst(range, count) {\n        const request = this.store.getAll(range, count === null ? undefined : count);\n        return new PersistencePromise((resolve, reject) => {\n            request.onerror = (event) => {\n                reject(event.target.error);\n            };\n            request.onsuccess = (event) => {\n                resolve(event.target.result);\n            };\n        });\n    }\n    deleteAll(indexOrRange, range) {\n        logDebug(LOG_TAG$i, 'DELETE ALL', this.store.name);\n        const options = this.options(indexOrRange, range);\n        options.keysOnly = false;\n        const cursor = this.cursor(options);\n        return this.iterateCursor(cursor, (key, value, control) => {\n            // NOTE: Calling delete() on a cursor is documented as more efficient than\n            // calling delete() on an object store with a single key\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\n            // however, this requires us *not* to use a keysOnly cursor\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\n            // may want to compare the performance of each method.\n            return control.delete();\n        });\n    }\n    iterate(optionsOrCallback, callback) {\n        let options;\n        if (!callback) {\n            options = {};\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        const cursor = this.cursor(options);\n        return this.iterateCursor(cursor, callback);\n    }\n    /**\n     * Iterates over a store, but waits for the given callback to complete for\n     * each entry before iterating the next entry. This allows the callback to do\n     * asynchronous work to determine if this iteration should continue.\n     *\n     * The provided callback should return `true` to continue iteration, and\n     * `false` otherwise.\n     */\n    iterateSerial(callback) {\n        const cursorRequest = this.cursor({});\n        return new PersistencePromise((resolve, reject) => {\n            cursorRequest.onerror = (event) => {\n                const error = checkForAndReportiOSError(event.target.error);\n                reject(error);\n            };\n            cursorRequest.onsuccess = (event) => {\n                const cursor = event.target.result;\n                if (!cursor) {\n                    resolve();\n                    return;\n                }\n                callback(cursor.primaryKey, cursor.value).next(shouldContinue => {\n                    if (shouldContinue) {\n                        cursor.continue();\n                    }\n                    else {\n                        resolve();\n                    }\n                });\n            };\n        });\n    }\n    iterateCursor(cursorRequest, fn) {\n        const results = [];\n        return new PersistencePromise((resolve, reject) => {\n            cursorRequest.onerror = (event) => {\n                reject(event.target.error);\n            };\n            cursorRequest.onsuccess = (event) => {\n                const cursor = event.target.result;\n                if (!cursor) {\n                    resolve();\n                    return;\n                }\n                const controller = new IterationController(cursor);\n                const userResult = fn(cursor.primaryKey, cursor.value, controller);\n                if (userResult instanceof PersistencePromise) {\n                    const userPromise = userResult.catch(err => {\n                        controller.done();\n                        return PersistencePromise.reject(err);\n                    });\n                    results.push(userPromise);\n                }\n                if (controller.isDone) {\n                    resolve();\n                }\n                else if (controller.skipToKey === null) {\n                    cursor.continue();\n                }\n                else {\n                    cursor.continue(controller.skipToKey);\n                }\n            };\n        }).next(() => PersistencePromise.waitFor(results));\n    }\n    options(indexOrRange, range) {\n        let indexName = undefined;\n        if (indexOrRange !== undefined) {\n            if (typeof indexOrRange === 'string') {\n                indexName = indexOrRange;\n            }\n            else {\n                range = indexOrRange;\n            }\n        }\n        return { index: indexName, range };\n    }\n    cursor(options) {\n        let direction = 'next';\n        if (options.reverse) {\n            direction = 'prev';\n        }\n        if (options.index) {\n            const index = this.store.index(options.index);\n            if (options.keysOnly) {\n                return index.openKeyCursor(options.range, direction);\n            }\n            else {\n                return index.openCursor(options.range, direction);\n            }\n        }\n        else {\n            return this.store.openCursor(options.range, direction);\n        }\n    }\n}\n/**\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\n * handlers to resolve / reject the PersistencePromise as appropriate.\n */\nfunction wrapRequest(request) {\n    return new PersistencePromise((resolve, reject) => {\n        request.onsuccess = (event) => {\n            const result = event.target.result;\n            resolve(result);\n        };\n        request.onerror = (event) => {\n            const error = checkForAndReportiOSError(event.target.error);\n            reject(error);\n        };\n    });\n}\n// Guard so we only report the error once.\nlet reportedIOSError = false;\nfunction checkForAndReportiOSError(error) {\n    const iOSVersion = SimpleDb.getIOSVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)());\n    if (iOSVersion >= 12.2 && iOSVersion < 13) {\n        const IOS_ERROR = 'An internal error was encountered in the Indexed Database server';\n        if (error.message.indexOf(IOS_ERROR) >= 0) {\n            // Wrap error in a more descriptive one.\n            const newError = new FirestoreError('internal', `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${IOS_ERROR}'. This is likely ` +\n                `due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 ` +\n                `for details and a potential workaround.`);\n            if (!reportedIOSError) {\n                reportedIOSError = true;\n                // Throw a global exception outside of this promise chain, for the user to\n                // potentially catch.\n                setTimeout(() => {\n                    throw newError;\n                }, 0);\n            }\n            return newError;\n        }\n    }\n    return error;\n}\n\nconst LOG_TAG$h = 'IndexBackfiller';\n/** How long we wait to try running index backfill after SDK initialization. */\nconst INITIAL_BACKFILL_DELAY_MS = 15 * 1000;\n/** Minimum amount of time between backfill checks, after the first one. */\nconst REGULAR_BACKFILL_DELAY_MS = 60 * 1000;\n/** The maximum number of documents to process each time backfill() is called. */\nconst MAX_DOCUMENTS_TO_PROCESS = 50;\n/** This class is responsible for the scheduling of Index Backfiller. */\nclass IndexBackfillerScheduler {\n    constructor(asyncQueue, backfiller) {\n        this.asyncQueue = asyncQueue;\n        this.backfiller = backfiller;\n        this.task = null;\n    }\n    start() {\n        this.schedule(INITIAL_BACKFILL_DELAY_MS);\n    }\n    stop() {\n        if (this.task) {\n            this.task.cancel();\n            this.task = null;\n        }\n    }\n    get started() {\n        return this.task !== null;\n    }\n    schedule(delay) {\n        logDebug(LOG_TAG$h, `Scheduled in ${delay}ms`);\n        this.task = this.asyncQueue.enqueueAfterDelay(\"index_backfill\" /* TimerId.IndexBackfill */, delay, async () => {\n            this.task = null;\n            try {\n                const documentsProcessed = await this.backfiller.backfill();\n                logDebug(LOG_TAG$h, `Documents written: ${documentsProcessed}`);\n            }\n            catch (e) {\n                if (isIndexedDbTransactionError(e)) {\n                    logDebug(LOG_TAG$h, 'Ignoring IndexedDB error during index backfill: ', e);\n                }\n                else {\n                    await ignoreIfPrimaryLeaseLoss(e);\n                }\n            }\n            await this.schedule(REGULAR_BACKFILL_DELAY_MS);\n        });\n    }\n}\n/** Implements the steps for backfilling indexes. */\nclass IndexBackfiller {\n    constructor(\n    /**\n     * LocalStore provides access to IndexManager and LocalDocumentView.\n     * These properties will update when the user changes. Consequently,\n     * making a local copy of IndexManager and LocalDocumentView will require\n     * updates over time. The simpler solution is to rely on LocalStore to have\n     * an up-to-date references to IndexManager and LocalDocumentStore.\n     */\n    localStore, persistence) {\n        this.localStore = localStore;\n        this.persistence = persistence;\n    }\n    async backfill(maxDocumentsToProcess = MAX_DOCUMENTS_TO_PROCESS) {\n        return this.persistence.runTransaction('Backfill Indexes', 'readwrite-primary', txn => this.writeIndexEntries(txn, maxDocumentsToProcess));\n    }\n    /** Writes index entries until the cap is reached. Returns the number of documents processed. */\n    writeIndexEntries(transaction, maxDocumentsToProcess) {\n        const processedCollectionGroups = new Set();\n        let documentsRemaining = maxDocumentsToProcess;\n        let continueLoop = true;\n        return PersistencePromise.doWhile(() => continueLoop === true && documentsRemaining > 0, () => {\n            return this.localStore.indexManager\n                .getNextCollectionGroupToUpdate(transaction)\n                .next((collectionGroup) => {\n                if (collectionGroup === null ||\n                    processedCollectionGroups.has(collectionGroup)) {\n                    continueLoop = false;\n                }\n                else {\n                    logDebug(LOG_TAG$h, `Processing collection: ${collectionGroup}`);\n                    return this.writeEntriesForCollectionGroup(transaction, collectionGroup, documentsRemaining).next(documentsProcessed => {\n                        documentsRemaining -= documentsProcessed;\n                        processedCollectionGroups.add(collectionGroup);\n                    });\n                }\n            });\n        }).next(() => maxDocumentsToProcess - documentsRemaining);\n    }\n    /**\n     * Writes entries for the provided collection group. Returns the number of documents processed.\n     */\n    writeEntriesForCollectionGroup(transaction, collectionGroup, documentsRemainingUnderCap) {\n        // Use the earliest offset of all field indexes to query the local cache.\n        return this.localStore.indexManager\n            .getMinOffsetFromCollectionGroup(transaction, collectionGroup)\n            .next(existingOffset => this.localStore.localDocuments\n            .getNextDocuments(transaction, collectionGroup, existingOffset, documentsRemainingUnderCap)\n            .next(nextBatch => {\n            const docs = nextBatch.changes;\n            return this.localStore.indexManager\n                .updateIndexEntries(transaction, docs)\n                .next(() => this.getNewOffset(existingOffset, nextBatch))\n                .next(newOffset => {\n                logDebug(LOG_TAG$h, `Updating offset: ${newOffset}`);\n                return this.localStore.indexManager.updateCollectionGroup(transaction, collectionGroup, newOffset);\n            })\n                .next(() => docs.size);\n        }));\n    }\n    /** Returns the next offset based on the provided documents. */\n    getNewOffset(existingOffset, lookupResult) {\n        let maxOffset = existingOffset;\n        lookupResult.changes.forEach((key, document) => {\n            const newOffset = newIndexOffsetFromDocument(document);\n            if (indexOffsetComparator(newOffset, maxOffset) > 0) {\n                maxOffset = newOffset;\n            }\n        });\n        return new IndexOffset(maxOffset.readTime, maxOffset.documentKey, Math.max(lookupResult.batchId, existingOffset.largestBatchId));\n    }\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * `ListenSequence` is a monotonic sequence. It is initialized with a minimum value to\n * exceed. All subsequent calls to next will return increasing values. If provided with a\n * `SequenceNumberSyncer`, it will additionally bump its next value when told of a new value, as\n * well as write out sequence numbers that it produces via `next()`.\n */\nclass ListenSequence {\n    constructor(previousValue, sequenceNumberSyncer) {\n        this.previousValue = previousValue;\n        if (sequenceNumberSyncer) {\n            sequenceNumberSyncer.sequenceNumberHandler = sequenceNumber => this.setPreviousValue(sequenceNumber);\n            this.writeNewSequenceNumber = sequenceNumber => sequenceNumberSyncer.writeSequenceNumber(sequenceNumber);\n        }\n    }\n    setPreviousValue(externalPreviousValue) {\n        this.previousValue = Math.max(externalPreviousValue, this.previousValue);\n        return this.previousValue;\n    }\n    next() {\n        const nextValue = ++this.previousValue;\n        if (this.writeNewSequenceNumber) {\n            this.writeNewSequenceNumber(nextValue);\n        }\n        return nextValue;\n    }\n}\nListenSequence.INVALID = -1;\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst escapeChar = '\\u0001';\nconst encodedSeparatorChar = '\\u0001';\nconst encodedNul = '\\u0010';\nconst encodedEscape = '\\u0011';\n/**\n * Encodes a resource path into a IndexedDb-compatible string form.\n */\nfunction encodeResourcePath(path) {\n    let result = '';\n    for (let i = 0; i < path.length; i++) {\n        if (result.length > 0) {\n            result = encodeSeparator(result);\n        }\n        result = encodeSegment(path.get(i), result);\n    }\n    return encodeSeparator(result);\n}\n/** Encodes a single segment of a resource path into the given result */\nfunction encodeSegment(segment, resultBuf) {\n    let result = resultBuf;\n    const length = segment.length;\n    for (let i = 0; i < length; i++) {\n        const c = segment.charAt(i);\n        switch (c) {\n            case '\\0':\n                result += escapeChar + encodedNul;\n                break;\n            case escapeChar:\n                result += escapeChar + encodedEscape;\n                break;\n            default:\n                result += c;\n        }\n    }\n    return result;\n}\n/** Encodes a path separator into the given result */\nfunction encodeSeparator(result) {\n    return result + escapeChar + encodedSeparatorChar;\n}\n/**\n * Decodes the given IndexedDb-compatible string form of a resource path into\n * a ResourcePath instance. Note that this method is not suitable for use with\n * decoding resource names from the server; those are One Platform format\n * strings.\n */\nfunction decodeResourcePath(path) {\n    // Event the empty path must encode as a path of at least length 2. A path\n    // with exactly 2 must be the empty path.\n    const length = path.length;\n    hardAssert(length >= 2);\n    if (length === 2) {\n        hardAssert(path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar);\n        return ResourcePath.emptyPath();\n    }\n    // Escape characters cannot exist past the second-to-last position in the\n    // source value.\n    const lastReasonableEscapeIndex = length - 2;\n    const segments = [];\n    let segmentBuilder = '';\n    for (let start = 0; start < length;) {\n        // The last two characters of a valid encoded path must be a separator, so\n        // there must be an end to this segment.\n        const end = path.indexOf(escapeChar, start);\n        if (end < 0 || end > lastReasonableEscapeIndex) {\n            fail();\n        }\n        const next = path.charAt(end + 1);\n        switch (next) {\n            case encodedSeparatorChar:\n                const currentPiece = path.substring(start, end);\n                let segment;\n                if (segmentBuilder.length === 0) {\n                    // Avoid copying for the common case of a segment that excludes \\0\n                    // and \\001\n                    segment = currentPiece;\n                }\n                else {\n                    segmentBuilder += currentPiece;\n                    segment = segmentBuilder;\n                    segmentBuilder = '';\n                }\n                segments.push(segment);\n                break;\n            case encodedNul:\n                segmentBuilder += path.substring(start, end);\n                segmentBuilder += '\\0';\n                break;\n            case encodedEscape:\n                // The escape character can be used in the output to encode itself.\n                segmentBuilder += path.substring(start, end + 1);\n                break;\n            default:\n                fail();\n        }\n        start = end + 2;\n    }\n    return new ResourcePath(segments);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DbRemoteDocumentStore$1 = 'remoteDocuments';\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Name of the IndexedDb object store.\n *\n * Note that the name 'owner' is chosen to ensure backwards compatibility with\n * older clients that only supported single locked access to the persistence\n * layer.\n */\nconst DbPrimaryClientStore = 'owner';\n/**\n * The key string used for the single object that exists in the\n * DbPrimaryClient store.\n */\nconst DbPrimaryClientKey = 'owner';\n/** Name of the IndexedDb object store.  */\nconst DbMutationQueueStore = 'mutationQueues';\n/** Keys are automatically assigned via the userId property. */\nconst DbMutationQueueKeyPath = 'userId';\n/** Name of the IndexedDb object store.  */\nconst DbMutationBatchStore = 'mutations';\n/** Keys are automatically assigned via the userId, batchId properties. */\nconst DbMutationBatchKeyPath = 'batchId';\n/** The index name for lookup of mutations by user. */\nconst DbMutationBatchUserMutationsIndex = 'userMutationsIndex';\n/** The user mutations index is keyed by [userId, batchId] pairs. */\nconst DbMutationBatchUserMutationsKeyPath = ['userId', 'batchId'];\n/**\n * Creates a [userId] key for use in the DbDocumentMutations index to iterate\n * over all of a user's document mutations.\n */\nfunction newDbDocumentMutationPrefixForUser(userId) {\n    return [userId];\n}\n/**\n * Creates a [userId, encodedPath] key for use in the DbDocumentMutations\n * index to iterate over all at document mutations for a given path or lower.\n */\nfunction newDbDocumentMutationPrefixForPath(userId, path) {\n    return [userId, encodeResourcePath(path)];\n}\n/**\n * Creates a full index key of [userId, encodedPath, batchId] for inserting\n * and deleting into the DbDocumentMutations index.\n */\nfunction newDbDocumentMutationKey(userId, path, batchId) {\n    return [userId, encodeResourcePath(path), batchId];\n}\n/**\n * Because we store all the useful information for this store in the key,\n * there is no useful information to store as the value. The raw (unencoded)\n * path cannot be stored because IndexedDb doesn't store prototype\n * information.\n */\nconst DbDocumentMutationPlaceholder = {};\nconst DbDocumentMutationStore = 'documentMutations';\nconst DbRemoteDocumentStore = 'remoteDocumentsV14';\n/**\n * The primary key of the remote documents store, which allows for efficient\n * access by collection path and read time.\n */\nconst DbRemoteDocumentKeyPath = [\n    'prefixPath',\n    'collectionGroup',\n    'readTime',\n    'documentId'\n];\n/** An index that provides access to documents by key. */\nconst DbRemoteDocumentDocumentKeyIndex = 'documentKeyIndex';\nconst DbRemoteDocumentDocumentKeyIndexPath = [\n    'prefixPath',\n    'collectionGroup',\n    'documentId'\n];\n/**\n * An index that provides access to documents by collection group and read\n * time.\n *\n * This index is used by the index backfiller.\n */\nconst DbRemoteDocumentCollectionGroupIndex = 'collectionGroupIndex';\nconst DbRemoteDocumentCollectionGroupIndexPath = [\n    'collectionGroup',\n    'readTime',\n    'prefixPath',\n    'documentId'\n];\nconst DbRemoteDocumentGlobalStore = 'remoteDocumentGlobal';\nconst DbRemoteDocumentGlobalKey = 'remoteDocumentGlobalKey';\nconst DbTargetStore = 'targets';\n/** Keys are automatically assigned via the targetId property. */\nconst DbTargetKeyPath = 'targetId';\n/** The name of the queryTargets index. */\nconst DbTargetQueryTargetsIndexName = 'queryTargetsIndex';\n/**\n * The index of all canonicalIds to the targets that they match. This is not\n * a unique mapping because canonicalId does not promise a unique name for all\n * possible queries, so we append the targetId to make the mapping unique.\n */\nconst DbTargetQueryTargetsKeyPath = ['canonicalId', 'targetId'];\n/** Name of the IndexedDb object store.  */\nconst DbTargetDocumentStore = 'targetDocuments';\n/** Keys are automatically assigned via the targetId, path properties. */\nconst DbTargetDocumentKeyPath = ['targetId', 'path'];\n/** The index name for the reverse index. */\nconst DbTargetDocumentDocumentTargetsIndex = 'documentTargetsIndex';\n/** We also need to create the reverse index for these properties. */\nconst DbTargetDocumentDocumentTargetsKeyPath = ['path', 'targetId'];\n/**\n * The key string used for the single object that exists in the\n * DbTargetGlobal store.\n */\nconst DbTargetGlobalKey = 'targetGlobalKey';\nconst DbTargetGlobalStore = 'targetGlobal';\n/** Name of the IndexedDb object store. */\nconst DbCollectionParentStore = 'collectionParents';\n/** Keys are automatically assigned via the collectionId, parent properties. */\nconst DbCollectionParentKeyPath = ['collectionId', 'parent'];\n/** Name of the IndexedDb object store. */\nconst DbClientMetadataStore = 'clientMetadata';\n/** Keys are automatically assigned via the clientId properties. */\nconst DbClientMetadataKeyPath = 'clientId';\n/** Name of the IndexedDb object store. */\nconst DbBundleStore = 'bundles';\nconst DbBundleKeyPath = 'bundleId';\n/** Name of the IndexedDb object store. */\nconst DbNamedQueryStore = 'namedQueries';\nconst DbNamedQueryKeyPath = 'name';\n/** Name of the IndexedDb object store. */\nconst DbIndexConfigurationStore = 'indexConfiguration';\nconst DbIndexConfigurationKeyPath = 'indexId';\n/**\n * An index that provides access to the index configurations by collection\n * group.\n *\n * PORTING NOTE: iOS and Android maintain this index in-memory, but this is\n * not possible here as the Web client supports concurrent access to\n * persistence via multi-tab.\n */\nconst DbIndexConfigurationCollectionGroupIndex = 'collectionGroupIndex';\nconst DbIndexConfigurationCollectionGroupIndexPath = 'collectionGroup';\n/** Name of the IndexedDb object store. */\nconst DbIndexStateStore = 'indexState';\nconst DbIndexStateKeyPath = ['indexId', 'uid'];\n/**\n * An index that provides access to documents in a collection sorted by last\n * update time. Used by the backfiller.\n *\n * PORTING NOTE: iOS and Android maintain this index in-memory, but this is\n * not possible here as the Web client supports concurrent access to\n * persistence via multi-tab.\n */\nconst DbIndexStateSequenceNumberIndex = 'sequenceNumberIndex';\nconst DbIndexStateSequenceNumberIndexPath = ['uid', 'sequenceNumber'];\n/** Name of the IndexedDb object store. */\nconst DbIndexEntryStore = 'indexEntries';\nconst DbIndexEntryKeyPath = [\n    'indexId',\n    'uid',\n    'arrayValue',\n    'directionalValue',\n    'orderedDocumentKey',\n    'documentKey'\n];\nconst DbIndexEntryDocumentKeyIndex = 'documentKeyIndex';\nconst DbIndexEntryDocumentKeyIndexPath = [\n    'indexId',\n    'uid',\n    'orderedDocumentKey'\n];\n/** Name of the IndexedDb object store. */\nconst DbDocumentOverlayStore = 'documentOverlays';\nconst DbDocumentOverlayKeyPath = [\n    'userId',\n    'collectionPath',\n    'documentId'\n];\nconst DbDocumentOverlayCollectionPathOverlayIndex = 'collectionPathOverlayIndex';\nconst DbDocumentOverlayCollectionPathOverlayIndexPath = [\n    'userId',\n    'collectionPath',\n    'largestBatchId'\n];\nconst DbDocumentOverlayCollectionGroupOverlayIndex = 'collectionGroupOverlayIndex';\nconst DbDocumentOverlayCollectionGroupOverlayIndexPath = [\n    'userId',\n    'collectionGroup',\n    'largestBatchId'\n];\n/** Name of the IndexedDb object store. */\nconst DbGlobalsStore = 'globals';\nconst DbGlobalsKeyPath = 'name';\n// Visible for testing\nconst V1_STORES = [\n    DbMutationQueueStore,\n    DbMutationBatchStore,\n    DbDocumentMutationStore,\n    DbRemoteDocumentStore$1,\n    DbTargetStore,\n    DbPrimaryClientStore,\n    DbTargetGlobalStore,\n    DbTargetDocumentStore\n];\n// Visible for testing\nconst V3_STORES = V1_STORES;\n// Note: DbRemoteDocumentChanges is no longer used and dropped with v9.\nconst V4_STORES = [...V3_STORES, DbClientMetadataStore];\nconst V6_STORES = [...V4_STORES, DbRemoteDocumentGlobalStore];\nconst V8_STORES = [...V6_STORES, DbCollectionParentStore];\nconst V11_STORES = [...V8_STORES, DbBundleStore, DbNamedQueryStore];\nconst V12_STORES = [...V11_STORES, DbDocumentOverlayStore];\nconst V13_STORES = [\n    DbMutationQueueStore,\n    DbMutationBatchStore,\n    DbDocumentMutationStore,\n    DbRemoteDocumentStore,\n    DbTargetStore,\n    DbPrimaryClientStore,\n    DbTargetGlobalStore,\n    DbTargetDocumentStore,\n    DbClientMetadataStore,\n    DbRemoteDocumentGlobalStore,\n    DbCollectionParentStore,\n    DbBundleStore,\n    DbNamedQueryStore,\n    DbDocumentOverlayStore\n];\nconst V14_STORES = V13_STORES;\nconst V15_STORES = [\n    ...V14_STORES,\n    DbIndexConfigurationStore,\n    DbIndexStateStore,\n    DbIndexEntryStore\n];\nconst V16_STORES = V15_STORES;\nconst V17_STORES = [...V15_STORES, DbGlobalsStore];\n/** Returns the object stores for the provided schema. */\nfunction getObjectStores(schemaVersion) {\n    if (schemaVersion === 17) {\n        return V17_STORES;\n    }\n    else if (schemaVersion === 16) {\n        return V16_STORES;\n    }\n    else if (schemaVersion === 15) {\n        return V15_STORES;\n    }\n    else if (schemaVersion === 14) {\n        return V14_STORES;\n    }\n    else if (schemaVersion === 13) {\n        return V13_STORES;\n    }\n    else if (schemaVersion === 12) {\n        return V12_STORES;\n    }\n    else if (schemaVersion === 11) {\n        return V11_STORES;\n    }\n    else {\n        fail();\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass IndexedDbTransaction extends PersistenceTransaction {\n    constructor(simpleDbTransaction, currentSequenceNumber) {\n        super();\n        this.simpleDbTransaction = simpleDbTransaction;\n        this.currentSequenceNumber = currentSequenceNumber;\n    }\n}\nfunction getStore(txn, store) {\n    const indexedDbTransaction = debugCast(txn);\n    return SimpleDb.getStore(indexedDbTransaction.simpleDbTransaction, store);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction objectSize(obj) {\n    let count = 0;\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            count++;\n        }\n    }\n    return count;\n}\nfunction forEach(obj, fn) {\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            fn(key, obj[key]);\n        }\n    }\n}\nfunction mapToArray(obj, fn) {\n    const result = [];\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            result.push(fn(obj[key], key, obj));\n        }\n    }\n    return result;\n}\nfunction isEmpty(obj) {\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\n// tree.\nclass SortedMap {\n    constructor(comparator, root) {\n        this.comparator = comparator;\n        this.root = root ? root : LLRBNode.EMPTY;\n    }\n    // Returns a copy of the map, with the specified key/value added or replaced.\n    insert(key, value) {\n        return new SortedMap(this.comparator, this.root\n            .insert(key, value, this.comparator)\n            .copy(null, null, LLRBNode.BLACK, null, null));\n    }\n    // Returns a copy of the map, with the specified key removed.\n    remove(key) {\n        return new SortedMap(this.comparator, this.root\n            .remove(key, this.comparator)\n            .copy(null, null, LLRBNode.BLACK, null, null));\n    }\n    // Returns the value of the node with the given key, or null.\n    get(key) {\n        let node = this.root;\n        while (!node.isEmpty()) {\n            const cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return node.value;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else if (cmp > 0) {\n                node = node.right;\n            }\n        }\n        return null;\n    }\n    // Returns the index of the element in this sorted map, or -1 if it doesn't\n    // exist.\n    indexOf(key) {\n        // Number of nodes that were pruned when descending right\n        let prunedNodes = 0;\n        let node = this.root;\n        while (!node.isEmpty()) {\n            const cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return prunedNodes + node.left.size;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else {\n                // Count all nodes left of the node plus the node itself\n                prunedNodes += node.left.size + 1;\n                node = node.right;\n            }\n        }\n        // Node not found\n        return -1;\n    }\n    isEmpty() {\n        return this.root.isEmpty();\n    }\n    // Returns the total number of nodes in the map.\n    get size() {\n        return this.root.size;\n    }\n    // Returns the minimum key in the map.\n    minKey() {\n        return this.root.minKey();\n    }\n    // Returns the maximum key in the map.\n    maxKey() {\n        return this.root.maxKey();\n    }\n    // Traverses the map in key order and calls the specified action function\n    // for each key/value pair. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    inorderTraversal(action) {\n        return this.root.inorderTraversal(action);\n    }\n    forEach(fn) {\n        this.inorderTraversal((k, v) => {\n            fn(k, v);\n            return false;\n        });\n    }\n    toString() {\n        const descriptions = [];\n        this.inorderTraversal((k, v) => {\n            descriptions.push(`${k}:${v}`);\n            return false;\n        });\n        return `{${descriptions.join(', ')}}`;\n    }\n    // Traverses the map in reverse key order and calls the specified action\n    // function for each key/value pair. If action returns true, traversal is\n    // aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    reverseTraversal(action) {\n        return this.root.reverseTraversal(action);\n    }\n    // Returns an iterator over the SortedMap.\n    getIterator() {\n        return new SortedMapIterator(this.root, null, this.comparator, false);\n    }\n    getIteratorFrom(key) {\n        return new SortedMapIterator(this.root, key, this.comparator, false);\n    }\n    getReverseIterator() {\n        return new SortedMapIterator(this.root, null, this.comparator, true);\n    }\n    getReverseIteratorFrom(key) {\n        return new SortedMapIterator(this.root, key, this.comparator, true);\n    }\n} // end SortedMap\n// An iterator over an LLRBNode.\nclass SortedMapIterator {\n    constructor(node, startKey, comparator, isReverse) {\n        this.isReverse = isReverse;\n        this.nodeStack = [];\n        let cmp = 1;\n        while (!node.isEmpty()) {\n            cmp = startKey ? comparator(node.key, startKey) : 1;\n            // flip the comparison if we're going in reverse\n            if (startKey && isReverse) {\n                cmp *= -1;\n            }\n            if (cmp < 0) {\n                // This node is less than our start key. ignore it\n                if (this.isReverse) {\n                    node = node.left;\n                }\n                else {\n                    node = node.right;\n                }\n            }\n            else if (cmp === 0) {\n                // This node is exactly equal to our start key. Push it on the stack,\n                // but stop iterating;\n                this.nodeStack.push(node);\n                break;\n            }\n            else {\n                // This node is greater than our start key, add it to the stack and move\n                // to the next one\n                this.nodeStack.push(node);\n                if (this.isReverse) {\n                    node = node.right;\n                }\n                else {\n                    node = node.left;\n                }\n            }\n        }\n    }\n    getNext() {\n        let node = this.nodeStack.pop();\n        const result = { key: node.key, value: node.value };\n        if (this.isReverse) {\n            node = node.left;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.right;\n            }\n        }\n        else {\n            node = node.right;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.left;\n            }\n        }\n        return result;\n    }\n    hasNext() {\n        return this.nodeStack.length > 0;\n    }\n    peek() {\n        if (this.nodeStack.length === 0) {\n            return null;\n        }\n        const node = this.nodeStack[this.nodeStack.length - 1];\n        return { key: node.key, value: node.value };\n    }\n} // end SortedMapIterator\n// Represents a node in a Left-leaning Red-Black tree.\nclass LLRBNode {\n    constructor(key, value, color, left, right) {\n        this.key = key;\n        this.value = value;\n        this.color = color != null ? color : LLRBNode.RED;\n        this.left = left != null ? left : LLRBNode.EMPTY;\n        this.right = right != null ? right : LLRBNode.EMPTY;\n        this.size = this.left.size + 1 + this.right.size;\n    }\n    // Returns a copy of the current node, optionally replacing pieces of it.\n    copy(key, value, color, left, right) {\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\n    }\n    isEmpty() {\n        return false;\n    }\n    // Traverses the tree in key order and calls the specified action function\n    // for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    inorderTraversal(action) {\n        return (this.left.inorderTraversal(action) ||\n            action(this.key, this.value) ||\n            this.right.inorderTraversal(action));\n    }\n    // Traverses the tree in reverse key order and calls the specified action\n    // function for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    reverseTraversal(action) {\n        return (this.right.reverseTraversal(action) ||\n            action(this.key, this.value) ||\n            this.left.reverseTraversal(action));\n    }\n    // Returns the minimum node in the tree.\n    min() {\n        if (this.left.isEmpty()) {\n            return this;\n        }\n        else {\n            return this.left.min();\n        }\n    }\n    // Returns the maximum key in the tree.\n    minKey() {\n        return this.min().key;\n    }\n    // Returns the maximum key in the tree.\n    maxKey() {\n        if (this.right.isEmpty()) {\n            return this.key;\n        }\n        else {\n            return this.right.maxKey();\n        }\n    }\n    // Returns new tree, with the key/value added.\n    insert(key, value, comparator) {\n        let n = this;\n        const cmp = comparator(key, n.key);\n        if (cmp < 0) {\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n        }\n        else if (cmp === 0) {\n            n = n.copy(null, value, null, null, null);\n        }\n        else {\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\n        }\n        return n.fixUp();\n    }\n    removeMin() {\n        if (this.left.isEmpty()) {\n            return LLRBNode.EMPTY;\n        }\n        let n = this;\n        if (!n.left.isRed() && !n.left.left.isRed()) {\n            n = n.moveRedLeft();\n        }\n        n = n.copy(null, null, null, n.left.removeMin(), null);\n        return n.fixUp();\n    }\n    // Returns new tree, with the specified item removed.\n    remove(key, comparator) {\n        let smallest;\n        let n = this;\n        if (comparator(key, n.key) < 0) {\n            if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\n                n = n.moveRedLeft();\n            }\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n        }\n        else {\n            if (n.left.isRed()) {\n                n = n.rotateRight();\n            }\n            if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\n                n = n.moveRedRight();\n            }\n            if (comparator(key, n.key) === 0) {\n                if (n.right.isEmpty()) {\n                    return LLRBNode.EMPTY;\n                }\n                else {\n                    smallest = n.right.min();\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());\n                }\n            }\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n        }\n        return n.fixUp();\n    }\n    isRed() {\n        return this.color;\n    }\n    // Returns new tree after performing any needed rotations.\n    fixUp() {\n        let n = this;\n        if (n.right.isRed() && !n.left.isRed()) {\n            n = n.rotateLeft();\n        }\n        if (n.left.isRed() && n.left.left.isRed()) {\n            n = n.rotateRight();\n        }\n        if (n.left.isRed() && n.right.isRed()) {\n            n = n.colorFlip();\n        }\n        return n;\n    }\n    moveRedLeft() {\n        let n = this.colorFlip();\n        if (n.right.left.isRed()) {\n            n = n.copy(null, null, null, null, n.right.rotateRight());\n            n = n.rotateLeft();\n            n = n.colorFlip();\n        }\n        return n;\n    }\n    moveRedRight() {\n        let n = this.colorFlip();\n        if (n.left.left.isRed()) {\n            n = n.rotateRight();\n            n = n.colorFlip();\n        }\n        return n;\n    }\n    rotateLeft() {\n        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n        return this.right.copy(null, null, this.color, nl, null);\n    }\n    rotateRight() {\n        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n        return this.left.copy(null, null, this.color, null, nr);\n    }\n    colorFlip() {\n        const left = this.left.copy(null, null, !this.left.color, null, null);\n        const right = this.right.copy(null, null, !this.right.color, null, null);\n        return this.copy(null, null, !this.color, left, right);\n    }\n    // For testing.\n    checkMaxDepth() {\n        const blackDepth = this.check();\n        if (Math.pow(2.0, blackDepth) <= this.size + 1) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    // In a balanced RB tree, the black-depth (number of black nodes) from root to\n    // leaves is equal on both sides.  This function verifies that or asserts.\n    check() {\n        if (this.isRed() && this.left.isRed()) {\n            throw fail();\n        }\n        if (this.right.isRed()) {\n            throw fail();\n        }\n        const blackDepth = this.left.check();\n        if (blackDepth !== this.right.check()) {\n            throw fail();\n        }\n        else {\n            return blackDepth + (this.isRed() ? 0 : 1);\n        }\n    }\n} // end LLRBNode\n// Empty node is shared between all LLRB trees.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nLLRBNode.EMPTY = null;\nLLRBNode.RED = true;\nLLRBNode.BLACK = false;\n// Represents an empty node (a leaf node in the Red-Black Tree).\nclass LLRBEmptyNode {\n    constructor() {\n        this.size = 0;\n    }\n    get key() {\n        throw fail();\n    }\n    get value() {\n        throw fail();\n    }\n    get color() {\n        throw fail();\n    }\n    get left() {\n        throw fail();\n    }\n    get right() {\n        throw fail();\n    }\n    // Returns a copy of the current node.\n    copy(key, value, color, left, right) {\n        return this;\n    }\n    // Returns a copy of the tree, with the specified key/value added.\n    insert(key, value, comparator) {\n        return new LLRBNode(key, value);\n    }\n    // Returns a copy of the tree, with the specified key removed.\n    remove(key, comparator) {\n        return this;\n    }\n    isEmpty() {\n        return true;\n    }\n    inorderTraversal(action) {\n        return false;\n    }\n    reverseTraversal(action) {\n        return false;\n    }\n    minKey() {\n        return null;\n    }\n    maxKey() {\n        return null;\n    }\n    isRed() {\n        return false;\n    }\n    // For testing.\n    checkMaxDepth() {\n        return true;\n    }\n    check() {\n        return 0;\n    }\n} // end LLRBEmptyNode\nLLRBNode.EMPTY = new LLRBEmptyNode();\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * SortedSet is an immutable (copy-on-write) collection that holds elements\n * in order specified by the provided comparator.\n *\n * NOTE: if provided comparator returns 0 for two elements, we consider them to\n * be equal!\n */\nclass SortedSet {\n    constructor(comparator) {\n        this.comparator = comparator;\n        this.data = new SortedMap(this.comparator);\n    }\n    has(elem) {\n        return this.data.get(elem) !== null;\n    }\n    first() {\n        return this.data.minKey();\n    }\n    last() {\n        return this.data.maxKey();\n    }\n    get size() {\n        return this.data.size;\n    }\n    indexOf(elem) {\n        return this.data.indexOf(elem);\n    }\n    /** Iterates elements in order defined by \"comparator\" */\n    forEach(cb) {\n        this.data.inorderTraversal((k, v) => {\n            cb(k);\n            return false;\n        });\n    }\n    /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */\n    forEachInRange(range, cb) {\n        const iter = this.data.getIteratorFrom(range[0]);\n        while (iter.hasNext()) {\n            const elem = iter.getNext();\n            if (this.comparator(elem.key, range[1]) >= 0) {\n                return;\n            }\n            cb(elem.key);\n        }\n    }\n    /**\n     * Iterates over `elem`s such that: start &lt;= elem until false is returned.\n     */\n    forEachWhile(cb, start) {\n        let iter;\n        if (start !== undefined) {\n            iter = this.data.getIteratorFrom(start);\n        }\n        else {\n            iter = this.data.getIterator();\n        }\n        while (iter.hasNext()) {\n            const elem = iter.getNext();\n            const result = cb(elem.key);\n            if (!result) {\n                return;\n            }\n        }\n    }\n    /** Finds the least element greater than or equal to `elem`. */\n    firstAfterOrEqual(elem) {\n        const iter = this.data.getIteratorFrom(elem);\n        return iter.hasNext() ? iter.getNext().key : null;\n    }\n    getIterator() {\n        return new SortedSetIterator(this.data.getIterator());\n    }\n    getIteratorFrom(key) {\n        return new SortedSetIterator(this.data.getIteratorFrom(key));\n    }\n    /** Inserts or updates an element */\n    add(elem) {\n        return this.copy(this.data.remove(elem).insert(elem, true));\n    }\n    /** Deletes an element */\n    delete(elem) {\n        if (!this.has(elem)) {\n            return this;\n        }\n        return this.copy(this.data.remove(elem));\n    }\n    isEmpty() {\n        return this.data.isEmpty();\n    }\n    unionWith(other) {\n        let result = this;\n        // Make sure `result` always refers to the larger one of the two sets.\n        if (result.size < other.size) {\n            result = other;\n            other = this;\n        }\n        other.forEach(elem => {\n            result = result.add(elem);\n        });\n        return result;\n    }\n    isEqual(other) {\n        if (!(other instanceof SortedSet)) {\n            return false;\n        }\n        if (this.size !== other.size) {\n            return false;\n        }\n        const thisIt = this.data.getIterator();\n        const otherIt = other.data.getIterator();\n        while (thisIt.hasNext()) {\n            const thisElem = thisIt.getNext().key;\n            const otherElem = otherIt.getNext().key;\n            if (this.comparator(thisElem, otherElem) !== 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    toArray() {\n        const res = [];\n        this.forEach(targetId => {\n            res.push(targetId);\n        });\n        return res;\n    }\n    toString() {\n        const result = [];\n        this.forEach(elem => result.push(elem));\n        return 'SortedSet(' + result.toString() + ')';\n    }\n    copy(data) {\n        const result = new SortedSet(this.comparator);\n        result.data = data;\n        return result;\n    }\n}\nclass SortedSetIterator {\n    constructor(iter) {\n        this.iter = iter;\n    }\n    getNext() {\n        return this.iter.getNext().key;\n    }\n    hasNext() {\n        return this.iter.hasNext();\n    }\n}\n/**\n * Compares two sorted sets for equality using their natural ordering. The\n * method computes the intersection and invokes `onAdd` for every element that\n * is in `after` but not `before`. `onRemove` is invoked for every element in\n * `before` but missing from `after`.\n *\n * The method creates a copy of both `before` and `after` and runs in O(n log\n * n), where n is the size of the two lists.\n *\n * @param before - The elements that exist in the original set.\n * @param after - The elements to diff against the original set.\n * @param comparator - The comparator for the elements in before and after.\n * @param onAdd - A function to invoke for every element that is part of `\n * after` but not `before`.\n * @param onRemove - A function to invoke for every element that is part of\n * `before` but not `after`.\n */\nfunction diffSortedSets(before, after, comparator, onAdd, onRemove) {\n    const beforeIt = before.getIterator();\n    const afterIt = after.getIterator();\n    let beforeValue = advanceIterator(beforeIt);\n    let afterValue = advanceIterator(afterIt);\n    // Walk through the two sets at the same time, using the ordering defined by\n    // `comparator`.\n    while (beforeValue || afterValue) {\n        let added = false;\n        let removed = false;\n        if (beforeValue && afterValue) {\n            const cmp = comparator(beforeValue, afterValue);\n            if (cmp < 0) {\n                // The element was removed if the next element in our ordered\n                // walkthrough is only in `before`.\n                removed = true;\n            }\n            else if (cmp > 0) {\n                // The element was added if the next element in our ordered walkthrough\n                // is only in `after`.\n                added = true;\n            }\n        }\n        else if (beforeValue != null) {\n            removed = true;\n        }\n        else {\n            added = true;\n        }\n        if (added) {\n            onAdd(afterValue);\n            afterValue = advanceIterator(afterIt);\n        }\n        else if (removed) {\n            onRemove(beforeValue);\n            beforeValue = advanceIterator(beforeIt);\n        }\n        else {\n            beforeValue = advanceIterator(beforeIt);\n            afterValue = advanceIterator(afterIt);\n        }\n    }\n}\n/**\n * Returns the next element from the iterator or `undefined` if none available.\n */\nfunction advanceIterator(it) {\n    return it.hasNext() ? it.getNext() : undefined;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides a set of fields that can be used to partially patch a document.\n * FieldMask is used in conjunction with ObjectValue.\n * Examples:\n *   foo - Overwrites foo entirely with the provided value. If foo is not\n *         present in the companion ObjectValue, the field is deleted.\n *   foo.bar - Overwrites only the field bar of the object foo.\n *             If foo is not an object, foo is replaced with an object\n *             containing foo\n */\nclass FieldMask {\n    constructor(fields) {\n        this.fields = fields;\n        // TODO(dimond): validation of FieldMask\n        // Sort the field mask to support `FieldMask.isEqual()` and assert below.\n        fields.sort(FieldPath$1.comparator);\n    }\n    static empty() {\n        return new FieldMask([]);\n    }\n    /**\n     * Returns a new FieldMask object that is the result of adding all the given\n     * fields paths to this field mask.\n     */\n    unionWith(extraFields) {\n        let mergedMaskSet = new SortedSet(FieldPath$1.comparator);\n        for (const fieldPath of this.fields) {\n            mergedMaskSet = mergedMaskSet.add(fieldPath);\n        }\n        for (const fieldPath of extraFields) {\n            mergedMaskSet = mergedMaskSet.add(fieldPath);\n        }\n        return new FieldMask(mergedMaskSet.toArray());\n    }\n    /**\n     * Verifies that `fieldPath` is included by at least one field in this field\n     * mask.\n     *\n     * This is an O(n) operation, where `n` is the size of the field mask.\n     */\n    covers(fieldPath) {\n        for (const fieldMaskPath of this.fields) {\n            if (fieldMaskPath.isPrefixOf(fieldPath)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isEqual(other) {\n        return arrayEquals(this.fields, other.fields, (l, r) => l.isEqual(r));\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Converts a Base64 encoded string to a binary string. */\nfunction decodeBase64(encoded) {\n    // Note: We used to validate the base64 string here via a regular expression.\n    // This was removed to improve the performance of indexing.\n    return Buffer.from(encoded, 'base64').toString('binary');\n}\n/** Converts a binary string to a Base64 encoded string. */\nfunction encodeBase64(raw) {\n    return Buffer.from(raw, 'binary').toString('base64');\n}\n/** True if and only if the Base64 conversion functions are available. */\nfunction isBase64Available() {\n    return true;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Immutable class that represents a \"proto\" byte string.\n *\n * Proto byte strings can either be Base64-encoded strings or Uint8Arrays when\n * sent on the wire. This class abstracts away this differentiation by holding\n * the proto byte string in a common class that must be converted into a string\n * before being sent as a proto.\n * @internal\n */\nclass ByteString {\n    constructor(binaryString) {\n        this.binaryString = binaryString;\n    }\n    static fromBase64String(base64) {\n        const binaryString = decodeBase64(base64);\n        return new ByteString(binaryString);\n    }\n    static fromUint8Array(array) {\n        // TODO(indexing); Remove the copy of the byte string here as this method\n        // is frequently called during indexing.\n        const binaryString = binaryStringFromUint8Array(array);\n        return new ByteString(binaryString);\n    }\n    [Symbol.iterator]() {\n        let i = 0;\n        return {\n            next: () => {\n                if (i < this.binaryString.length) {\n                    return { value: this.binaryString.charCodeAt(i++), done: false };\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n    }\n    toBase64() {\n        return encodeBase64(this.binaryString);\n    }\n    toUint8Array() {\n        return uint8ArrayFromBinaryString(this.binaryString);\n    }\n    approximateByteSize() {\n        return this.binaryString.length * 2;\n    }\n    compareTo(other) {\n        return primitiveComparator(this.binaryString, other.binaryString);\n    }\n    isEqual(other) {\n        return this.binaryString === other.binaryString;\n    }\n}\nByteString.EMPTY_BYTE_STRING = new ByteString('');\n/**\n * Helper function to convert an Uint8array to a binary string.\n */\nfunction binaryStringFromUint8Array(array) {\n    let binaryString = '';\n    for (let i = 0; i < array.length; ++i) {\n        binaryString += String.fromCharCode(array[i]);\n    }\n    return binaryString;\n}\n/**\n * Helper function to convert a binary string to an Uint8Array.\n */\nfunction uint8ArrayFromBinaryString(binaryString) {\n    const buffer = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n        buffer[i] = binaryString.charCodeAt(i);\n    }\n    return buffer;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// A RegExp matching ISO 8601 UTC timestamps with optional fraction.\nconst ISO_TIMESTAMP_REG_EXP = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\n/**\n * Converts the possible Proto values for a timestamp value into a \"seconds and\n * nanos\" representation.\n */\nfunction normalizeTimestamp(date) {\n    hardAssert(!!date);\n    // The json interface (for the browser) will return an iso timestamp string,\n    // while the proto js library (for node) will return a\n    // google.protobuf.Timestamp instance.\n    if (typeof date === 'string') {\n        // The date string can have higher precision (nanos) than the Date class\n        // (millis), so we do some custom parsing here.\n        // Parse the nanos right out of the string.\n        let nanos = 0;\n        const fraction = ISO_TIMESTAMP_REG_EXP.exec(date);\n        hardAssert(!!fraction);\n        if (fraction[1]) {\n            // Pad the fraction out to 9 digits (nanos).\n            let nanoStr = fraction[1];\n            nanoStr = (nanoStr + '000000000').substr(0, 9);\n            nanos = Number(nanoStr);\n        }\n        // Parse the date to get the seconds.\n        const parsedDate = new Date(date);\n        const seconds = Math.floor(parsedDate.getTime() / 1000);\n        return { seconds, nanos };\n    }\n    else {\n        // TODO(b/37282237): Use strings for Proto3 timestamps\n        // assert(!this.options.useProto3Json,\n        //   'The timestamp instance format requires Proto JS.');\n        const seconds = normalizeNumber(date.seconds);\n        const nanos = normalizeNumber(date.nanos);\n        return { seconds, nanos };\n    }\n}\n/**\n * Converts the possible Proto types for numbers into a JavaScript number.\n * Returns 0 if the value is not numeric.\n */\nfunction normalizeNumber(value) {\n    // TODO(bjornick): Handle int64 greater than 53 bits.\n    if (typeof value === 'number') {\n        return value;\n    }\n    else if (typeof value === 'string') {\n        return Number(value);\n    }\n    else {\n        return 0;\n    }\n}\n/** Converts the possible Proto types for Blobs into a ByteString. */\nfunction normalizeByteString(blob) {\n    if (typeof blob === 'string') {\n        return ByteString.fromBase64String(blob);\n    }\n    else {\n        return ByteString.fromUint8Array(blob);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a locally-applied ServerTimestamp.\n *\n * Server Timestamps are backed by MapValues that contain an internal field\n * `__type__` with a value of `server_timestamp`. The previous value and local\n * write time are stored in its `__previous_value__` and `__local_write_time__`\n * fields respectively.\n *\n * Notes:\n * - ServerTimestampValue instances are created as the result of applying a\n *   transform. They can only exist in the local view of a document. Therefore\n *   they do not need to be parsed or serialized.\n * - When evaluated locally (e.g. for snapshot.data()), they by default\n *   evaluate to `null`. This behavior can be configured by passing custom\n *   FieldValueOptions to value().\n * - With respect to other ServerTimestampValues, they sort by their\n *   localWriteTime.\n */\nconst SERVER_TIMESTAMP_SENTINEL = 'server_timestamp';\nconst TYPE_KEY$1 = '__type__';\nconst PREVIOUS_VALUE_KEY = '__previous_value__';\nconst LOCAL_WRITE_TIME_KEY = '__local_write_time__';\nfunction isServerTimestamp(value) {\n    var _a, _b;\n    const type = (_b = (((_a = value === null || value === void 0 ? void 0 : value.mapValue) === null || _a === void 0 ? void 0 : _a.fields) || {})[TYPE_KEY$1]) === null || _b === void 0 ? void 0 : _b.stringValue;\n    return type === SERVER_TIMESTAMP_SENTINEL;\n}\n/**\n * Creates a new ServerTimestamp proto value (using the internal format).\n */\nfunction serverTimestamp$1(localWriteTime, previousValue) {\n    const mapValue = {\n        fields: {\n            [TYPE_KEY$1]: {\n                stringValue: SERVER_TIMESTAMP_SENTINEL\n            },\n            [LOCAL_WRITE_TIME_KEY]: {\n                timestampValue: {\n                    seconds: localWriteTime.seconds,\n                    nanos: localWriteTime.nanoseconds\n                }\n            }\n        }\n    };\n    // We should avoid storing deeply nested server timestamp map values\n    // because we never use the intermediate \"previous values\".\n    // For example:\n    // previous: 42L, add: t1, result: t1 -> 42L\n    // previous: t1,  add: t2, result: t2 -> 42L (NOT t2 -> t1 -> 42L)\n    // previous: t2,  add: t3, result: t3 -> 42L (NOT t3 -> t2 -> t1 -> 42L)\n    // `getPreviousValue` recursively traverses server timestamps to find the\n    // least recent Value.\n    if (previousValue && isServerTimestamp(previousValue)) {\n        previousValue = getPreviousValue(previousValue);\n    }\n    if (previousValue) {\n        mapValue.fields[PREVIOUS_VALUE_KEY] = previousValue;\n    }\n    return { mapValue };\n}\n/**\n * Returns the value of the field before this ServerTimestamp was set.\n *\n * Preserving the previous values allows the user to display the last resoled\n * value until the backend responds with the timestamp.\n */\nfunction getPreviousValue(value) {\n    const previousValue = value.mapValue.fields[PREVIOUS_VALUE_KEY];\n    if (isServerTimestamp(previousValue)) {\n        return getPreviousValue(previousValue);\n    }\n    return previousValue;\n}\n/**\n * Returns the local time at which this timestamp was first set.\n */\nfunction getLocalWriteTime(value) {\n    const localWriteTime = normalizeTimestamp(value.mapValue.fields[LOCAL_WRITE_TIME_KEY].timestampValue);\n    return new Timestamp(localWriteTime.seconds, localWriteTime.nanos);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass DatabaseInfo {\n    /**\n     * Constructs a DatabaseInfo using the provided host, databaseId and\n     * persistenceKey.\n     *\n     * @param databaseId - The database to use.\n     * @param appId - The Firebase App Id.\n     * @param persistenceKey - A unique identifier for this Firestore's local\n     * storage (used in conjunction with the databaseId).\n     * @param host - The Firestore backend host to connect to.\n     * @param ssl - Whether to use SSL when connecting.\n     * @param forceLongPolling - Whether to use the forceLongPolling option\n     * when using WebChannel as the network transport.\n     * @param autoDetectLongPolling - Whether to use the detectBufferingProxy\n     * option when using WebChannel as the network transport.\n     * @param longPollingOptions Options that configure long-polling.\n     * @param useFetchStreams Whether to use the Fetch API instead of\n     * XMLHTTPRequest\n     */\n    constructor(databaseId, appId, persistenceKey, host, ssl, forceLongPolling, autoDetectLongPolling, longPollingOptions, useFetchStreams) {\n        this.databaseId = databaseId;\n        this.appId = appId;\n        this.persistenceKey = persistenceKey;\n        this.host = host;\n        this.ssl = ssl;\n        this.forceLongPolling = forceLongPolling;\n        this.autoDetectLongPolling = autoDetectLongPolling;\n        this.longPollingOptions = longPollingOptions;\n        this.useFetchStreams = useFetchStreams;\n    }\n}\n/** The default database name for a project. */\nconst DEFAULT_DATABASE_NAME = '(default)';\n/**\n * Represents the database ID a Firestore client is associated with.\n * @internal\n */\nclass DatabaseId {\n    constructor(projectId, database) {\n        this.projectId = projectId;\n        this.database = database ? database : DEFAULT_DATABASE_NAME;\n    }\n    static empty() {\n        return new DatabaseId('', '');\n    }\n    get isDefaultDatabase() {\n        return this.database === DEFAULT_DATABASE_NAME;\n    }\n    isEqual(other) {\n        return (other instanceof DatabaseId &&\n            other.projectId === this.projectId &&\n            other.database === this.database);\n    }\n}\nfunction databaseIdFromApp(app, database) {\n    if (!Object.prototype.hasOwnProperty.apply(app.options, ['projectId'])) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\n    }\n    return new DatabaseId(app.options.projectId, database);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Sentinel value that sorts before any Mutation Batch ID. */\nconst BATCHID_UNKNOWN = -1;\n/**\n * Returns whether a variable is either undefined or null.\n */\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/** Returns whether the value represents -0. */\nfunction isNegativeZero(value) {\n    // Detect if the value is -0.0. Based on polyfill from\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n    return value === 0 && 1 / value === 1 / -0;\n}\n/**\n * Returns whether a value is an integer and in the safe integer range\n * @param value - The value to test for being an integer and in the safe range\n */\nfunction isSafeInteger(value) {\n    return (typeof value === 'number' &&\n        Number.isInteger(value) &&\n        !isNegativeZero(value) &&\n        value <= Number.MAX_SAFE_INTEGER &&\n        value >= Number.MIN_SAFE_INTEGER);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst TYPE_KEY = '__type__';\nconst MAX_VALUE_TYPE = '__max__';\nconst MAX_VALUE = {\n    mapValue: {\n        fields: {\n            '__type__': { stringValue: MAX_VALUE_TYPE }\n        }\n    }\n};\nconst VECTOR_VALUE_SENTINEL = '__vector__';\nconst VECTOR_MAP_VECTORS_KEY = 'value';\nconst MIN_VALUE = {\n    nullValue: 'NULL_VALUE'\n};\n/** Extracts the backend's type order for the provided value. */\nfunction typeOrder(value) {\n    if ('nullValue' in value) {\n        return 0 /* TypeOrder.NullValue */;\n    }\n    else if ('booleanValue' in value) {\n        return 1 /* TypeOrder.BooleanValue */;\n    }\n    else if ('integerValue' in value || 'doubleValue' in value) {\n        return 2 /* TypeOrder.NumberValue */;\n    }\n    else if ('timestampValue' in value) {\n        return 3 /* TypeOrder.TimestampValue */;\n    }\n    else if ('stringValue' in value) {\n        return 5 /* TypeOrder.StringValue */;\n    }\n    else if ('bytesValue' in value) {\n        return 6 /* TypeOrder.BlobValue */;\n    }\n    else if ('referenceValue' in value) {\n        return 7 /* TypeOrder.RefValue */;\n    }\n    else if ('geoPointValue' in value) {\n        return 8 /* TypeOrder.GeoPointValue */;\n    }\n    else if ('arrayValue' in value) {\n        return 9 /* TypeOrder.ArrayValue */;\n    }\n    else if ('mapValue' in value) {\n        if (isServerTimestamp(value)) {\n            return 4 /* TypeOrder.ServerTimestampValue */;\n        }\n        else if (isMaxValue(value)) {\n            return 9007199254740991 /* TypeOrder.MaxValue */;\n        }\n        else if (isVectorValue(value)) {\n            return 10 /* TypeOrder.VectorValue */;\n        }\n        return 11 /* TypeOrder.ObjectValue */;\n    }\n    else {\n        return fail();\n    }\n}\n/** Tests `left` and `right` for equality based on the backend semantics. */\nfunction valueEquals(left, right) {\n    if (left === right) {\n        return true;\n    }\n    const leftType = typeOrder(left);\n    const rightType = typeOrder(right);\n    if (leftType !== rightType) {\n        return false;\n    }\n    switch (leftType) {\n        case 0 /* TypeOrder.NullValue */:\n            return true;\n        case 1 /* TypeOrder.BooleanValue */:\n            return left.booleanValue === right.booleanValue;\n        case 4 /* TypeOrder.ServerTimestampValue */:\n            return getLocalWriteTime(left).isEqual(getLocalWriteTime(right));\n        case 3 /* TypeOrder.TimestampValue */:\n            return timestampEquals(left, right);\n        case 5 /* TypeOrder.StringValue */:\n            return left.stringValue === right.stringValue;\n        case 6 /* TypeOrder.BlobValue */:\n            return blobEquals(left, right);\n        case 7 /* TypeOrder.RefValue */:\n            return left.referenceValue === right.referenceValue;\n        case 8 /* TypeOrder.GeoPointValue */:\n            return geoPointEquals(left, right);\n        case 2 /* TypeOrder.NumberValue */:\n            return numberEquals(left, right);\n        case 9 /* TypeOrder.ArrayValue */:\n            return arrayEquals(left.arrayValue.values || [], right.arrayValue.values || [], valueEquals);\n        case 10 /* TypeOrder.VectorValue */:\n        case 11 /* TypeOrder.ObjectValue */:\n            return objectEquals(left, right);\n        case 9007199254740991 /* TypeOrder.MaxValue */:\n            return true;\n        default:\n            return fail();\n    }\n}\nfunction timestampEquals(left, right) {\n    if (typeof left.timestampValue === 'string' &&\n        typeof right.timestampValue === 'string' &&\n        left.timestampValue.length === right.timestampValue.length) {\n        // Use string equality for ISO 8601 timestamps\n        return left.timestampValue === right.timestampValue;\n    }\n    const leftTimestamp = normalizeTimestamp(left.timestampValue);\n    const rightTimestamp = normalizeTimestamp(right.timestampValue);\n    return (leftTimestamp.seconds === rightTimestamp.seconds &&\n        leftTimestamp.nanos === rightTimestamp.nanos);\n}\nfunction geoPointEquals(left, right) {\n    return (normalizeNumber(left.geoPointValue.latitude) ===\n        normalizeNumber(right.geoPointValue.latitude) &&\n        normalizeNumber(left.geoPointValue.longitude) ===\n            normalizeNumber(right.geoPointValue.longitude));\n}\nfunction blobEquals(left, right) {\n    return normalizeByteString(left.bytesValue).isEqual(normalizeByteString(right.bytesValue));\n}\nfunction numberEquals(left, right) {\n    if ('integerValue' in left && 'integerValue' in right) {\n        return (normalizeNumber(left.integerValue) === normalizeNumber(right.integerValue));\n    }\n    else if ('doubleValue' in left && 'doubleValue' in right) {\n        const n1 = normalizeNumber(left.doubleValue);\n        const n2 = normalizeNumber(right.doubleValue);\n        if (n1 === n2) {\n            return isNegativeZero(n1) === isNegativeZero(n2);\n        }\n        else {\n            return isNaN(n1) && isNaN(n2);\n        }\n    }\n    return false;\n}\nfunction objectEquals(left, right) {\n    const leftMap = left.mapValue.fields || {};\n    const rightMap = right.mapValue.fields || {};\n    if (objectSize(leftMap) !== objectSize(rightMap)) {\n        return false;\n    }\n    for (const key in leftMap) {\n        if (leftMap.hasOwnProperty(key)) {\n            if (rightMap[key] === undefined ||\n                !valueEquals(leftMap[key], rightMap[key])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/** Returns true if the ArrayValue contains the specified element. */\nfunction arrayValueContains(haystack, needle) {\n    return ((haystack.values || []).find(v => valueEquals(v, needle)) !== undefined);\n}\nfunction valueCompare(left, right) {\n    if (left === right) {\n        return 0;\n    }\n    const leftType = typeOrder(left);\n    const rightType = typeOrder(right);\n    if (leftType !== rightType) {\n        return primitiveComparator(leftType, rightType);\n    }\n    switch (leftType) {\n        case 0 /* TypeOrder.NullValue */:\n        case 9007199254740991 /* TypeOrder.MaxValue */:\n            return 0;\n        case 1 /* TypeOrder.BooleanValue */:\n            return primitiveComparator(left.booleanValue, right.booleanValue);\n        case 2 /* TypeOrder.NumberValue */:\n            return compareNumbers(left, right);\n        case 3 /* TypeOrder.TimestampValue */:\n            return compareTimestamps(left.timestampValue, right.timestampValue);\n        case 4 /* TypeOrder.ServerTimestampValue */:\n            return compareTimestamps(getLocalWriteTime(left), getLocalWriteTime(right));\n        case 5 /* TypeOrder.StringValue */:\n            return compareUtf8Strings(left.stringValue, right.stringValue);\n        case 6 /* TypeOrder.BlobValue */:\n            return compareBlobs(left.bytesValue, right.bytesValue);\n        case 7 /* TypeOrder.RefValue */:\n            return compareReferences(left.referenceValue, right.referenceValue);\n        case 8 /* TypeOrder.GeoPointValue */:\n            return compareGeoPoints(left.geoPointValue, right.geoPointValue);\n        case 9 /* TypeOrder.ArrayValue */:\n            return compareArrays(left.arrayValue, right.arrayValue);\n        case 10 /* TypeOrder.VectorValue */:\n            return compareVectors(left.mapValue, right.mapValue);\n        case 11 /* TypeOrder.ObjectValue */:\n            return compareMaps(left.mapValue, right.mapValue);\n        default:\n            throw fail();\n    }\n}\nfunction compareNumbers(left, right) {\n    const leftNumber = normalizeNumber(left.integerValue || left.doubleValue);\n    const rightNumber = normalizeNumber(right.integerValue || right.doubleValue);\n    if (leftNumber < rightNumber) {\n        return -1;\n    }\n    else if (leftNumber > rightNumber) {\n        return 1;\n    }\n    else if (leftNumber === rightNumber) {\n        return 0;\n    }\n    else {\n        // one or both are NaN.\n        if (isNaN(leftNumber)) {\n            return isNaN(rightNumber) ? 0 : -1;\n        }\n        else {\n            return 1;\n        }\n    }\n}\nfunction compareTimestamps(left, right) {\n    if (typeof left === 'string' &&\n        typeof right === 'string' &&\n        left.length === right.length) {\n        return primitiveComparator(left, right);\n    }\n    const leftTimestamp = normalizeTimestamp(left);\n    const rightTimestamp = normalizeTimestamp(right);\n    const comparison = primitiveComparator(leftTimestamp.seconds, rightTimestamp.seconds);\n    if (comparison !== 0) {\n        return comparison;\n    }\n    return primitiveComparator(leftTimestamp.nanos, rightTimestamp.nanos);\n}\nfunction compareReferences(leftPath, rightPath) {\n    const leftSegments = leftPath.split('/');\n    const rightSegments = rightPath.split('/');\n    for (let i = 0; i < leftSegments.length && i < rightSegments.length; i++) {\n        const comparison = primitiveComparator(leftSegments[i], rightSegments[i]);\n        if (comparison !== 0) {\n            return comparison;\n        }\n    }\n    return primitiveComparator(leftSegments.length, rightSegments.length);\n}\nfunction compareGeoPoints(left, right) {\n    const comparison = primitiveComparator(normalizeNumber(left.latitude), normalizeNumber(right.latitude));\n    if (comparison !== 0) {\n        return comparison;\n    }\n    return primitiveComparator(normalizeNumber(left.longitude), normalizeNumber(right.longitude));\n}\nfunction compareBlobs(left, right) {\n    const leftBytes = normalizeByteString(left);\n    const rightBytes = normalizeByteString(right);\n    return leftBytes.compareTo(rightBytes);\n}\nfunction compareArrays(left, right) {\n    const leftArray = left.values || [];\n    const rightArray = right.values || [];\n    for (let i = 0; i < leftArray.length && i < rightArray.length; ++i) {\n        const compare = valueCompare(leftArray[i], rightArray[i]);\n        if (compare) {\n            return compare;\n        }\n    }\n    return primitiveComparator(leftArray.length, rightArray.length);\n}\nfunction compareVectors(left, right) {\n    var _a, _b, _c, _d;\n    const leftMap = left.fields || {};\n    const rightMap = right.fields || {};\n    // The vector is a map, but only vector value is compared.\n    const leftArrayValue = (_a = leftMap[VECTOR_MAP_VECTORS_KEY]) === null || _a === void 0 ? void 0 : _a.arrayValue;\n    const rightArrayValue = (_b = rightMap[VECTOR_MAP_VECTORS_KEY]) === null || _b === void 0 ? void 0 : _b.arrayValue;\n    const lengthCompare = primitiveComparator(((_c = leftArrayValue === null || leftArrayValue === void 0 ? void 0 : leftArrayValue.values) === null || _c === void 0 ? void 0 : _c.length) || 0, ((_d = rightArrayValue === null || rightArrayValue === void 0 ? void 0 : rightArrayValue.values) === null || _d === void 0 ? void 0 : _d.length) || 0);\n    if (lengthCompare !== 0) {\n        return lengthCompare;\n    }\n    return compareArrays(leftArrayValue, rightArrayValue);\n}\nfunction compareMaps(left, right) {\n    if (left === MAX_VALUE.mapValue && right === MAX_VALUE.mapValue) {\n        return 0;\n    }\n    else if (left === MAX_VALUE.mapValue) {\n        return 1;\n    }\n    else if (right === MAX_VALUE.mapValue) {\n        return -1;\n    }\n    const leftMap = left.fields || {};\n    const leftKeys = Object.keys(leftMap);\n    const rightMap = right.fields || {};\n    const rightKeys = Object.keys(rightMap);\n    // Even though MapValues are likely sorted correctly based on their insertion\n    // order (e.g. when received from the backend), local modifications can bring\n    // elements out of order. We need to re-sort the elements to ensure that\n    // canonical IDs are independent of insertion order.\n    leftKeys.sort();\n    rightKeys.sort();\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; ++i) {\n        const keyCompare = compareUtf8Strings(leftKeys[i], rightKeys[i]);\n        if (keyCompare !== 0) {\n            return keyCompare;\n        }\n        const compare = valueCompare(leftMap[leftKeys[i]], rightMap[rightKeys[i]]);\n        if (compare !== 0) {\n            return compare;\n        }\n    }\n    return primitiveComparator(leftKeys.length, rightKeys.length);\n}\n/**\n * Generates the canonical ID for the provided field value (as used in Target\n * serialization).\n */\nfunction canonicalId(value) {\n    return canonifyValue(value);\n}\nfunction canonifyValue(value) {\n    if ('nullValue' in value) {\n        return 'null';\n    }\n    else if ('booleanValue' in value) {\n        return '' + value.booleanValue;\n    }\n    else if ('integerValue' in value) {\n        return '' + value.integerValue;\n    }\n    else if ('doubleValue' in value) {\n        return '' + value.doubleValue;\n    }\n    else if ('timestampValue' in value) {\n        return canonifyTimestamp(value.timestampValue);\n    }\n    else if ('stringValue' in value) {\n        return value.stringValue;\n    }\n    else if ('bytesValue' in value) {\n        return canonifyByteString(value.bytesValue);\n    }\n    else if ('referenceValue' in value) {\n        return canonifyReference(value.referenceValue);\n    }\n    else if ('geoPointValue' in value) {\n        return canonifyGeoPoint(value.geoPointValue);\n    }\n    else if ('arrayValue' in value) {\n        return canonifyArray(value.arrayValue);\n    }\n    else if ('mapValue' in value) {\n        return canonifyMap(value.mapValue);\n    }\n    else {\n        return fail();\n    }\n}\nfunction canonifyByteString(byteString) {\n    return normalizeByteString(byteString).toBase64();\n}\nfunction canonifyTimestamp(timestamp) {\n    const normalizedTimestamp = normalizeTimestamp(timestamp);\n    return `time(${normalizedTimestamp.seconds},${normalizedTimestamp.nanos})`;\n}\nfunction canonifyGeoPoint(geoPoint) {\n    return `geo(${geoPoint.latitude},${geoPoint.longitude})`;\n}\nfunction canonifyReference(referenceValue) {\n    return DocumentKey.fromName(referenceValue).toString();\n}\nfunction canonifyMap(mapValue) {\n    // Iteration order in JavaScript is not guaranteed. To ensure that we generate\n    // matching canonical IDs for identical maps, we need to sort the keys.\n    const sortedKeys = Object.keys(mapValue.fields || {}).sort();\n    let result = '{';\n    let first = true;\n    for (const key of sortedKeys) {\n        if (!first) {\n            result += ',';\n        }\n        else {\n            first = false;\n        }\n        result += `${key}:${canonifyValue(mapValue.fields[key])}`;\n    }\n    return result + '}';\n}\nfunction canonifyArray(arrayValue) {\n    let result = '[';\n    let first = true;\n    for (const value of arrayValue.values || []) {\n        if (!first) {\n            result += ',';\n        }\n        else {\n            first = false;\n        }\n        result += canonifyValue(value);\n    }\n    return result + ']';\n}\n/**\n * Returns an approximate (and wildly inaccurate) in-memory size for the field\n * value.\n *\n * The memory size takes into account only the actual user data as it resides\n * in memory and ignores object overhead.\n */\nfunction estimateByteSize(value) {\n    switch (typeOrder(value)) {\n        case 0 /* TypeOrder.NullValue */:\n            return 4;\n        case 1 /* TypeOrder.BooleanValue */:\n            return 4;\n        case 2 /* TypeOrder.NumberValue */:\n            return 8;\n        case 3 /* TypeOrder.TimestampValue */:\n            // Timestamps are made up of two distinct numbers (seconds + nanoseconds)\n            return 16;\n        case 4 /* TypeOrder.ServerTimestampValue */:\n            const previousValue = getPreviousValue(value);\n            return previousValue ? 16 + estimateByteSize(previousValue) : 16;\n        case 5 /* TypeOrder.StringValue */:\n            // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures:\n            // \"JavaScript's String type is [...] a set of elements of 16-bit unsigned\n            // integer values\"\n            return value.stringValue.length * 2;\n        case 6 /* TypeOrder.BlobValue */:\n            return normalizeByteString(value.bytesValue).approximateByteSize();\n        case 7 /* TypeOrder.RefValue */:\n            return value.referenceValue.length;\n        case 8 /* TypeOrder.GeoPointValue */:\n            // GeoPoints are made up of two distinct numbers (latitude + longitude)\n            return 16;\n        case 9 /* TypeOrder.ArrayValue */:\n            return estimateArrayByteSize(value.arrayValue);\n        case 10 /* TypeOrder.VectorValue */:\n        case 11 /* TypeOrder.ObjectValue */:\n            return estimateMapByteSize(value.mapValue);\n        default:\n            throw fail();\n    }\n}\nfunction estimateMapByteSize(mapValue) {\n    let size = 0;\n    forEach(mapValue.fields, (key, val) => {\n        size += key.length + estimateByteSize(val);\n    });\n    return size;\n}\nfunction estimateArrayByteSize(arrayValue) {\n    return (arrayValue.values || []).reduce((previousSize, value) => previousSize + estimateByteSize(value), 0);\n}\n/** Returns a reference value for the provided database and key. */\nfunction refValue(databaseId, key) {\n    return {\n        referenceValue: `projects/${databaseId.projectId}/databases/${databaseId.database}/documents/${key.path.canonicalString()}`\n    };\n}\n/** Returns true if `value` is an IntegerValue . */\nfunction isInteger(value) {\n    return !!value && 'integerValue' in value;\n}\n/** Returns true if `value` is a DoubleValue. */\nfunction isDouble(value) {\n    return !!value && 'doubleValue' in value;\n}\n/** Returns true if `value` is either an IntegerValue or a DoubleValue. */\nfunction isNumber(value) {\n    return isInteger(value) || isDouble(value);\n}\n/** Returns true if `value` is an ArrayValue. */\nfunction isArray(value) {\n    return !!value && 'arrayValue' in value;\n}\n/** Returns true if `value` is a NullValue. */\nfunction isNullValue(value) {\n    return !!value && 'nullValue' in value;\n}\n/** Returns true if `value` is NaN. */\nfunction isNanValue(value) {\n    return !!value && 'doubleValue' in value && isNaN(Number(value.doubleValue));\n}\n/** Returns true if `value` is a MapValue. */\nfunction isMapValue(value) {\n    return !!value && 'mapValue' in value;\n}\n/** Returns true if `value` is a VetorValue. */\nfunction isVectorValue(value) {\n    var _a, _b;\n    const type = (_b = (((_a = value === null || value === void 0 ? void 0 : value.mapValue) === null || _a === void 0 ? void 0 : _a.fields) || {})[TYPE_KEY]) === null || _b === void 0 ? void 0 : _b.stringValue;\n    return type === VECTOR_VALUE_SENTINEL;\n}\n/** Creates a deep copy of `source`. */\nfunction deepClone(source) {\n    if (source.geoPointValue) {\n        return { geoPointValue: Object.assign({}, source.geoPointValue) };\n    }\n    else if (source.timestampValue &&\n        typeof source.timestampValue === 'object') {\n        return { timestampValue: Object.assign({}, source.timestampValue) };\n    }\n    else if (source.mapValue) {\n        const target = { mapValue: { fields: {} } };\n        forEach(source.mapValue.fields, (key, val) => (target.mapValue.fields[key] = deepClone(val)));\n        return target;\n    }\n    else if (source.arrayValue) {\n        const target = { arrayValue: { values: [] } };\n        for (let i = 0; i < (source.arrayValue.values || []).length; ++i) {\n            target.arrayValue.values[i] = deepClone(source.arrayValue.values[i]);\n        }\n        return target;\n    }\n    else {\n        return Object.assign({}, source);\n    }\n}\n/** Returns true if the Value represents the canonical {@link #MAX_VALUE} . */\nfunction isMaxValue(value) {\n    return ((((value.mapValue || {}).fields || {})['__type__'] || {}).stringValue ===\n        MAX_VALUE_TYPE);\n}\nconst MIN_VECTOR_VALUE = {\n    mapValue: {\n        fields: {\n            [TYPE_KEY]: { stringValue: VECTOR_VALUE_SENTINEL },\n            [VECTOR_MAP_VECTORS_KEY]: {\n                arrayValue: {}\n            }\n        }\n    }\n};\n/** Returns the lowest value for the given value type (inclusive). */\nfunction valuesGetLowerBound(value) {\n    if ('nullValue' in value) {\n        return MIN_VALUE;\n    }\n    else if ('booleanValue' in value) {\n        return { booleanValue: false };\n    }\n    else if ('integerValue' in value || 'doubleValue' in value) {\n        return { doubleValue: NaN };\n    }\n    else if ('timestampValue' in value) {\n        return { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } };\n    }\n    else if ('stringValue' in value) {\n        return { stringValue: '' };\n    }\n    else if ('bytesValue' in value) {\n        return { bytesValue: '' };\n    }\n    else if ('referenceValue' in value) {\n        return refValue(DatabaseId.empty(), DocumentKey.empty());\n    }\n    else if ('geoPointValue' in value) {\n        return { geoPointValue: { latitude: -90, longitude: -180 } };\n    }\n    else if ('arrayValue' in value) {\n        return { arrayValue: {} };\n    }\n    else if ('mapValue' in value) {\n        if (isVectorValue(value)) {\n            return MIN_VECTOR_VALUE;\n        }\n        return { mapValue: {} };\n    }\n    else {\n        return fail();\n    }\n}\n/** Returns the largest value for the given value type (exclusive). */\nfunction valuesGetUpperBound(value) {\n    if ('nullValue' in value) {\n        return { booleanValue: false };\n    }\n    else if ('booleanValue' in value) {\n        return { doubleValue: NaN };\n    }\n    else if ('integerValue' in value || 'doubleValue' in value) {\n        return { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } };\n    }\n    else if ('timestampValue' in value) {\n        return { stringValue: '' };\n    }\n    else if ('stringValue' in value) {\n        return { bytesValue: '' };\n    }\n    else if ('bytesValue' in value) {\n        return refValue(DatabaseId.empty(), DocumentKey.empty());\n    }\n    else if ('referenceValue' in value) {\n        return { geoPointValue: { latitude: -90, longitude: -180 } };\n    }\n    else if ('geoPointValue' in value) {\n        return { arrayValue: {} };\n    }\n    else if ('arrayValue' in value) {\n        return MIN_VECTOR_VALUE;\n    }\n    else if ('mapValue' in value) {\n        if (isVectorValue(value)) {\n            return { mapValue: {} };\n        }\n        return MAX_VALUE;\n    }\n    else {\n        return fail();\n    }\n}\nfunction lowerBoundCompare(left, right) {\n    const cmp = valueCompare(left.value, right.value);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    if (left.inclusive && !right.inclusive) {\n        return -1;\n    }\n    else if (!left.inclusive && right.inclusive) {\n        return 1;\n    }\n    return 0;\n}\nfunction upperBoundCompare(left, right) {\n    const cmp = valueCompare(left.value, right.value);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    if (left.inclusive && !right.inclusive) {\n        return 1;\n    }\n    else if (!left.inclusive && right.inclusive) {\n        return -1;\n    }\n    return 0;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An ObjectValue represents a MapValue in the Firestore Proto and offers the\n * ability to add and remove fields (via the ObjectValueBuilder).\n */\nclass ObjectValue {\n    constructor(value) {\n        this.value = value;\n    }\n    static empty() {\n        return new ObjectValue({ mapValue: {} });\n    }\n    /**\n     * Returns the value at the given path or null.\n     *\n     * @param path - the path to search\n     * @returns The value at the path or null if the path is not set.\n     */\n    field(path) {\n        if (path.isEmpty()) {\n            return this.value;\n        }\n        else {\n            let currentLevel = this.value;\n            for (let i = 0; i < path.length - 1; ++i) {\n                currentLevel = (currentLevel.mapValue.fields || {})[path.get(i)];\n                if (!isMapValue(currentLevel)) {\n                    return null;\n                }\n            }\n            currentLevel = (currentLevel.mapValue.fields || {})[path.lastSegment()];\n            return currentLevel || null;\n        }\n    }\n    /**\n     * Sets the field to the provided value.\n     *\n     * @param path - The field path to set.\n     * @param value - The value to set.\n     */\n    set(path, value) {\n        const fieldsMap = this.getFieldsMap(path.popLast());\n        fieldsMap[path.lastSegment()] = deepClone(value);\n    }\n    /**\n     * Sets the provided fields to the provided values.\n     *\n     * @param data - A map of fields to values (or null for deletes).\n     */\n    setAll(data) {\n        let parent = FieldPath$1.emptyPath();\n        let upserts = {};\n        let deletes = [];\n        data.forEach((value, path) => {\n            if (!parent.isImmediateParentOf(path)) {\n                // Insert the accumulated changes at this parent location\n                const fieldsMap = this.getFieldsMap(parent);\n                this.applyChanges(fieldsMap, upserts, deletes);\n                upserts = {};\n                deletes = [];\n                parent = path.popLast();\n            }\n            if (value) {\n                upserts[path.lastSegment()] = deepClone(value);\n            }\n            else {\n                deletes.push(path.lastSegment());\n            }\n        });\n        const fieldsMap = this.getFieldsMap(parent);\n        this.applyChanges(fieldsMap, upserts, deletes);\n    }\n    /**\n     * Removes the field at the specified path. If there is no field at the\n     * specified path, nothing is changed.\n     *\n     * @param path - The field path to remove.\n     */\n    delete(path) {\n        const nestedValue = this.field(path.popLast());\n        if (isMapValue(nestedValue) && nestedValue.mapValue.fields) {\n            delete nestedValue.mapValue.fields[path.lastSegment()];\n        }\n    }\n    isEqual(other) {\n        return valueEquals(this.value, other.value);\n    }\n    /**\n     * Returns the map that contains the leaf element of `path`. If the parent\n     * entry does not yet exist, or if it is not a map, a new map will be created.\n     */\n    getFieldsMap(path) {\n        let current = this.value;\n        if (!current.mapValue.fields) {\n            current.mapValue = { fields: {} };\n        }\n        for (let i = 0; i < path.length; ++i) {\n            let next = current.mapValue.fields[path.get(i)];\n            if (!isMapValue(next) || !next.mapValue.fields) {\n                next = { mapValue: { fields: {} } };\n                current.mapValue.fields[path.get(i)] = next;\n            }\n            current = next;\n        }\n        return current.mapValue.fields;\n    }\n    /**\n     * Modifies `fieldsMap` by adding, replacing or deleting the specified\n     * entries.\n     */\n    applyChanges(fieldsMap, inserts, deletes) {\n        forEach(inserts, (key, val) => (fieldsMap[key] = val));\n        for (const field of deletes) {\n            delete fieldsMap[field];\n        }\n    }\n    clone() {\n        return new ObjectValue(deepClone(this.value));\n    }\n}\n/**\n * Returns a FieldMask built from all fields in a MapValue.\n */\nfunction extractFieldMask(value) {\n    const fields = [];\n    forEach(value.fields, (key, value) => {\n        const currentPath = new FieldPath$1([key]);\n        if (isMapValue(value)) {\n            const nestedMask = extractFieldMask(value.mapValue);\n            const nestedFields = nestedMask.fields;\n            if (nestedFields.length === 0) {\n                // Preserve the empty map by adding it to the FieldMask.\n                fields.push(currentPath);\n            }\n            else {\n                // For nested and non-empty ObjectValues, add the FieldPath of the\n                // leaf nodes.\n                for (const nestedPath of nestedFields) {\n                    fields.push(currentPath.child(nestedPath));\n                }\n            }\n        }\n        else {\n            // For nested and non-empty ObjectValues, add the FieldPath of the leaf\n            // nodes.\n            fields.push(currentPath);\n        }\n    });\n    return new FieldMask(fields);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a document in Firestore with a key, version, data and whether it\n * has local mutations applied to it.\n *\n * Documents can transition between states via `convertToFoundDocument()`,\n * `convertToNoDocument()` and `convertToUnknownDocument()`. If a document does\n * not transition to one of these states even after all mutations have been\n * applied, `isValidDocument()` returns false and the document should be removed\n * from all views.\n */\nclass MutableDocument {\n    constructor(key, documentType, version, readTime, createTime, data, documentState) {\n        this.key = key;\n        this.documentType = documentType;\n        this.version = version;\n        this.readTime = readTime;\n        this.createTime = createTime;\n        this.data = data;\n        this.documentState = documentState;\n    }\n    /**\n     * Creates a document with no known version or data, but which can serve as\n     * base document for mutations.\n     */\n    static newInvalidDocument(documentKey) {\n        return new MutableDocument(documentKey, 0 /* DocumentType.INVALID */, \n        /* version */ SnapshotVersion.min(), \n        /* readTime */ SnapshotVersion.min(), \n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 0 /* DocumentState.SYNCED */);\n    }\n    /**\n     * Creates a new document that is known to exist with the given data at the\n     * given version.\n     */\n    static newFoundDocument(documentKey, version, createTime, value) {\n        return new MutableDocument(documentKey, 1 /* DocumentType.FOUND_DOCUMENT */, \n        /* version */ version, \n        /* readTime */ SnapshotVersion.min(), \n        /* createTime */ createTime, value, 0 /* DocumentState.SYNCED */);\n    }\n    /** Creates a new document that is known to not exist at the given version. */\n    static newNoDocument(documentKey, version) {\n        return new MutableDocument(documentKey, 2 /* DocumentType.NO_DOCUMENT */, \n        /* version */ version, \n        /* readTime */ SnapshotVersion.min(), \n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 0 /* DocumentState.SYNCED */);\n    }\n    /**\n     * Creates a new document that is known to exist at the given version but\n     * whose data is not known (e.g. a document that was updated without a known\n     * base document).\n     */\n    static newUnknownDocument(documentKey, version) {\n        return new MutableDocument(documentKey, 3 /* DocumentType.UNKNOWN_DOCUMENT */, \n        /* version */ version, \n        /* readTime */ SnapshotVersion.min(), \n        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */);\n    }\n    /**\n     * Changes the document type to indicate that it exists and that its version\n     * and data are known.\n     */\n    convertToFoundDocument(version, value) {\n        // If a document is switching state from being an invalid or deleted\n        // document to a valid (FOUND_DOCUMENT) document, either due to receiving an\n        // update from Watch or due to applying a local set mutation on top\n        // of a deleted document, our best guess about its createTime would be the\n        // version at which the document transitioned to a FOUND_DOCUMENT.\n        if (this.createTime.isEqual(SnapshotVersion.min()) &&\n            (this.documentType === 2 /* DocumentType.NO_DOCUMENT */ ||\n                this.documentType === 0 /* DocumentType.INVALID */)) {\n            this.createTime = version;\n        }\n        this.version = version;\n        this.documentType = 1 /* DocumentType.FOUND_DOCUMENT */;\n        this.data = value;\n        this.documentState = 0 /* DocumentState.SYNCED */;\n        return this;\n    }\n    /**\n     * Changes the document type to indicate that it doesn't exist at the given\n     * version.\n     */\n    convertToNoDocument(version) {\n        this.version = version;\n        this.documentType = 2 /* DocumentType.NO_DOCUMENT */;\n        this.data = ObjectValue.empty();\n        this.documentState = 0 /* DocumentState.SYNCED */;\n        return this;\n    }\n    /**\n     * Changes the document type to indicate that it exists at a given version but\n     * that its data is not known (e.g. a document that was updated without a known\n     * base document).\n     */\n    convertToUnknownDocument(version) {\n        this.version = version;\n        this.documentType = 3 /* DocumentType.UNKNOWN_DOCUMENT */;\n        this.data = ObjectValue.empty();\n        this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\n        return this;\n    }\n    setHasCommittedMutations() {\n        this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\n        return this;\n    }\n    setHasLocalMutations() {\n        this.documentState = 1 /* DocumentState.HAS_LOCAL_MUTATIONS */;\n        this.version = SnapshotVersion.min();\n        return this;\n    }\n    setReadTime(readTime) {\n        this.readTime = readTime;\n        return this;\n    }\n    get hasLocalMutations() {\n        return this.documentState === 1 /* DocumentState.HAS_LOCAL_MUTATIONS */;\n    }\n    get hasCommittedMutations() {\n        return this.documentState === 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;\n    }\n    get hasPendingWrites() {\n        return this.hasLocalMutations || this.hasCommittedMutations;\n    }\n    isValidDocument() {\n        return this.documentType !== 0 /* DocumentType.INVALID */;\n    }\n    isFoundDocument() {\n        return this.documentType === 1 /* DocumentType.FOUND_DOCUMENT */;\n    }\n    isNoDocument() {\n        return this.documentType === 2 /* DocumentType.NO_DOCUMENT */;\n    }\n    isUnknownDocument() {\n        return this.documentType === 3 /* DocumentType.UNKNOWN_DOCUMENT */;\n    }\n    isEqual(other) {\n        return (other instanceof MutableDocument &&\n            this.key.isEqual(other.key) &&\n            this.version.isEqual(other.version) &&\n            this.documentType === other.documentType &&\n            this.documentState === other.documentState &&\n            this.data.isEqual(other.data));\n    }\n    mutableCopy() {\n        return new MutableDocument(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);\n    }\n    toString() {\n        return (`Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, ` +\n            `{createTime: ${this.createTime}}), ` +\n            `{documentType: ${this.documentType}}), ` +\n            `{documentState: ${this.documentState}})`);\n    }\n}\n/**\n * Compares the value for field `field` in the provided documents. Throws if\n * the field does not exist in both documents.\n */\nfunction compareDocumentsByField(field, d1, d2) {\n    const v1 = d1.data.field(field);\n    const v2 = d2.data.field(field);\n    if (v1 !== null && v2 !== null) {\n        return valueCompare(v1, v2);\n    }\n    else {\n        return fail();\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a bound of a query.\n *\n * The bound is specified with the given components representing a position and\n * whether it's just before or just after the position (relative to whatever the\n * query order is).\n *\n * The position represents a logical index position for a query. It's a prefix\n * of values for the (potentially implicit) order by clauses of a query.\n *\n * Bound provides a function to determine whether a document comes before or\n * after a bound. This is influenced by whether the position is just before or\n * just after the provided values.\n */\nclass Bound {\n    constructor(position, inclusive) {\n        this.position = position;\n        this.inclusive = inclusive;\n    }\n}\nfunction boundCompareToDocument(bound, orderBy, doc) {\n    let comparison = 0;\n    for (let i = 0; i < bound.position.length; i++) {\n        const orderByComponent = orderBy[i];\n        const component = bound.position[i];\n        if (orderByComponent.field.isKeyField()) {\n            comparison = DocumentKey.comparator(DocumentKey.fromName(component.referenceValue), doc.key);\n        }\n        else {\n            const docValue = doc.data.field(orderByComponent.field);\n            comparison = valueCompare(component, docValue);\n        }\n        if (orderByComponent.dir === \"desc\" /* Direction.DESCENDING */) {\n            comparison = comparison * -1;\n        }\n        if (comparison !== 0) {\n            break;\n        }\n    }\n    return comparison;\n}\n/**\n * Returns true if a document sorts after a bound using the provided sort\n * order.\n */\nfunction boundSortsAfterDocument(bound, orderBy, doc) {\n    const comparison = boundCompareToDocument(bound, orderBy, doc);\n    return bound.inclusive ? comparison >= 0 : comparison > 0;\n}\n/**\n * Returns true if a document sorts before a bound using the provided sort\n * order.\n */\nfunction boundSortsBeforeDocument(bound, orderBy, doc) {\n    const comparison = boundCompareToDocument(bound, orderBy, doc);\n    return bound.inclusive ? comparison <= 0 : comparison < 0;\n}\nfunction boundEquals(left, right) {\n    if (left === null) {\n        return right === null;\n    }\n    else if (right === null) {\n        return false;\n    }\n    if (left.inclusive !== right.inclusive ||\n        left.position.length !== right.position.length) {\n        return false;\n    }\n    for (let i = 0; i < left.position.length; i++) {\n        const leftPosition = left.position[i];\n        const rightPosition = right.position[i];\n        if (!valueEquals(leftPosition, rightPosition)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\n */\nclass OrderBy {\n    constructor(field, dir = \"asc\" /* Direction.ASCENDING */) {\n        this.field = field;\n        this.dir = dir;\n    }\n}\nfunction canonifyOrderBy(orderBy) {\n    // TODO(b/29183165): Make this collision robust.\n    return orderBy.field.canonicalString() + orderBy.dir;\n}\nfunction stringifyOrderBy(orderBy) {\n    return `${orderBy.field.canonicalString()} (${orderBy.dir})`;\n}\nfunction orderByEquals(left, right) {\n    return left.dir === right.dir && left.field.isEqual(right.field);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Filter {\n}\nclass FieldFilter extends Filter {\n    constructor(field, op, value) {\n        super();\n        this.field = field;\n        this.op = op;\n        this.value = value;\n    }\n    /**\n     * Creates a filter based on the provided arguments.\n     */\n    static create(field, op, value) {\n        if (field.isKeyField()) {\n            if (op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */) {\n                return this.createKeyFieldInFilter(field, op, value);\n            }\n            else {\n                return new KeyFieldFilter(field, op, value);\n            }\n        }\n        else if (op === \"array-contains\" /* Operator.ARRAY_CONTAINS */) {\n            return new ArrayContainsFilter(field, value);\n        }\n        else if (op === \"in\" /* Operator.IN */) {\n            return new InFilter(field, value);\n        }\n        else if (op === \"not-in\" /* Operator.NOT_IN */) {\n            return new NotInFilter(field, value);\n        }\n        else if (op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\n            return new ArrayContainsAnyFilter(field, value);\n        }\n        else {\n            return new FieldFilter(field, op, value);\n        }\n    }\n    static createKeyFieldInFilter(field, op, value) {\n        return op === \"in\" /* Operator.IN */\n            ? new KeyFieldInFilter(field, value)\n            : new KeyFieldNotInFilter(field, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        // Types do not have to match in NOT_EQUAL filters.\n        if (this.op === \"!=\" /* Operator.NOT_EQUAL */) {\n            return (other !== null &&\n                this.matchesComparison(valueCompare(other, this.value)));\n        }\n        // Only compare types with matching backend order (such as double and int).\n        return (other !== null &&\n            typeOrder(this.value) === typeOrder(other) &&\n            this.matchesComparison(valueCompare(other, this.value)));\n    }\n    matchesComparison(comparison) {\n        switch (this.op) {\n            case \"<\" /* Operator.LESS_THAN */:\n                return comparison < 0;\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\n                return comparison <= 0;\n            case \"==\" /* Operator.EQUAL */:\n                return comparison === 0;\n            case \"!=\" /* Operator.NOT_EQUAL */:\n                return comparison !== 0;\n            case \">\" /* Operator.GREATER_THAN */:\n                return comparison > 0;\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\n                return comparison >= 0;\n            default:\n                return fail();\n        }\n    }\n    isInequality() {\n        return ([\n            \"<\" /* Operator.LESS_THAN */,\n            \"<=\" /* Operator.LESS_THAN_OR_EQUAL */,\n            \">\" /* Operator.GREATER_THAN */,\n            \">=\" /* Operator.GREATER_THAN_OR_EQUAL */,\n            \"!=\" /* Operator.NOT_EQUAL */,\n            \"not-in\" /* Operator.NOT_IN */\n        ].indexOf(this.op) >= 0);\n    }\n    getFlattenedFilters() {\n        return [this];\n    }\n    getFilters() {\n        return [this];\n    }\n}\nclass CompositeFilter extends Filter {\n    constructor(filters, op) {\n        super();\n        this.filters = filters;\n        this.op = op;\n        this.memoizedFlattenedFilters = null;\n    }\n    /**\n     * Creates a filter based on the provided arguments.\n     */\n    static create(filters, op) {\n        return new CompositeFilter(filters, op);\n    }\n    matches(doc) {\n        if (compositeFilterIsConjunction(this)) {\n            // For conjunctions, all filters must match, so return false if any filter doesn't match.\n            return this.filters.find(filter => !filter.matches(doc)) === undefined;\n        }\n        else {\n            // For disjunctions, at least one filter should match.\n            return this.filters.find(filter => filter.matches(doc)) !== undefined;\n        }\n    }\n    getFlattenedFilters() {\n        if (this.memoizedFlattenedFilters !== null) {\n            return this.memoizedFlattenedFilters;\n        }\n        this.memoizedFlattenedFilters = this.filters.reduce((result, subfilter) => {\n            return result.concat(subfilter.getFlattenedFilters());\n        }, []);\n        return this.memoizedFlattenedFilters;\n    }\n    // Returns a mutable copy of `this.filters`\n    getFilters() {\n        return Object.assign([], this.filters);\n    }\n}\nfunction compositeFilterIsConjunction(compositeFilter) {\n    return compositeFilter.op === \"and\" /* CompositeOperator.AND */;\n}\nfunction compositeFilterIsDisjunction(compositeFilter) {\n    return compositeFilter.op === \"or\" /* CompositeOperator.OR */;\n}\n/**\n * Returns true if this filter is a conjunction of field filters only. Returns false otherwise.\n */\nfunction compositeFilterIsFlatConjunction(compositeFilter) {\n    return (compositeFilterIsFlat(compositeFilter) &&\n        compositeFilterIsConjunction(compositeFilter));\n}\n/**\n * Returns true if this filter does not contain any composite filters. Returns false otherwise.\n */\nfunction compositeFilterIsFlat(compositeFilter) {\n    for (const filter of compositeFilter.filters) {\n        if (filter instanceof CompositeFilter) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction canonifyFilter(filter) {\n    if (filter instanceof FieldFilter) {\n        // TODO(b/29183165): Technically, this won't be unique if two values have\n        // the same description, such as the int 3 and the string \"3\". So we should\n        // add the types in here somehow, too.\n        return (filter.field.canonicalString() +\n            filter.op.toString() +\n            canonicalId(filter.value));\n    }\n    else if (compositeFilterIsFlatConjunction(filter)) {\n        // Older SDK versions use an implicit AND operation between their filters.\n        // In the new SDK versions, the developer may use an explicit AND filter.\n        // To stay consistent with the old usages, we add a special case to ensure\n        // the canonical ID for these two are the same. For example:\n        // `col.whereEquals(\"a\", 1).whereEquals(\"b\", 2)` should have the same\n        // canonical ID as `col.where(and(equals(\"a\",1), equals(\"b\",2)))`.\n        return filter.filters.map(filter => canonifyFilter(filter)).join(',');\n    }\n    else {\n        // filter instanceof CompositeFilter\n        const canonicalIdsString = filter.filters\n            .map(filter => canonifyFilter(filter))\n            .join(',');\n        return `${filter.op}(${canonicalIdsString})`;\n    }\n}\nfunction filterEquals(f1, f2) {\n    if (f1 instanceof FieldFilter) {\n        return fieldFilterEquals(f1, f2);\n    }\n    else if (f1 instanceof CompositeFilter) {\n        return compositeFilterEquals(f1, f2);\n    }\n    else {\n        fail();\n    }\n}\nfunction fieldFilterEquals(f1, f2) {\n    return (f2 instanceof FieldFilter &&\n        f1.op === f2.op &&\n        f1.field.isEqual(f2.field) &&\n        valueEquals(f1.value, f2.value));\n}\nfunction compositeFilterEquals(f1, f2) {\n    if (f2 instanceof CompositeFilter &&\n        f1.op === f2.op &&\n        f1.filters.length === f2.filters.length) {\n        const subFiltersMatch = f1.filters.reduce((result, f1Filter, index) => result && filterEquals(f1Filter, f2.filters[index]), true);\n        return subFiltersMatch;\n    }\n    return false;\n}\n/**\n * Returns a new composite filter that contains all filter from\n * `compositeFilter` plus all the given filters in `otherFilters`.\n */\nfunction compositeFilterWithAddedFilters(compositeFilter, otherFilters) {\n    const mergedFilters = compositeFilter.filters.concat(otherFilters);\n    return CompositeFilter.create(mergedFilters, compositeFilter.op);\n}\n/** Returns a debug description for `filter`. */\nfunction stringifyFilter(filter) {\n    if (filter instanceof FieldFilter) {\n        return stringifyFieldFilter(filter);\n    }\n    else if (filter instanceof CompositeFilter) {\n        return stringifyCompositeFilter(filter);\n    }\n    else {\n        return 'Filter';\n    }\n}\nfunction stringifyCompositeFilter(filter) {\n    return (filter.op.toString() +\n        ` {` +\n        filter.getFilters().map(stringifyFilter).join(' ,') +\n        '}');\n}\nfunction stringifyFieldFilter(filter) {\n    return `${filter.field.canonicalString()} ${filter.op} ${canonicalId(filter.value)}`;\n}\n/** Filter that matches on key fields (i.e. '__name__'). */\nclass KeyFieldFilter extends FieldFilter {\n    constructor(field, op, value) {\n        super(field, op, value);\n        this.key = DocumentKey.fromName(value.referenceValue);\n    }\n    matches(doc) {\n        const comparison = DocumentKey.comparator(doc.key, this.key);\n        return this.matchesComparison(comparison);\n    }\n}\n/** Filter that matches on key fields within an array. */\nclass KeyFieldInFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"in\" /* Operator.IN */, value);\n        this.keys = extractDocumentKeysFromArrayValue(\"in\" /* Operator.IN */, value);\n    }\n    matches(doc) {\n        return this.keys.some(key => key.isEqual(doc.key));\n    }\n}\n/** Filter that matches on key fields not present within an array. */\nclass KeyFieldNotInFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"not-in\" /* Operator.NOT_IN */, value);\n        this.keys = extractDocumentKeysFromArrayValue(\"not-in\" /* Operator.NOT_IN */, value);\n    }\n    matches(doc) {\n        return !this.keys.some(key => key.isEqual(doc.key));\n    }\n}\nfunction extractDocumentKeysFromArrayValue(op, value) {\n    var _a;\n    return (((_a = value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) || []).map(v => {\n        return DocumentKey.fromName(v.referenceValue);\n    });\n}\n/** A Filter that implements the array-contains operator. */\nclass ArrayContainsFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"array-contains\" /* Operator.ARRAY_CONTAINS */, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        return isArray(other) && arrayValueContains(other.arrayValue, this.value);\n    }\n}\n/** A Filter that implements the IN operator. */\nclass InFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"in\" /* Operator.IN */, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        return other !== null && arrayValueContains(this.value.arrayValue, other);\n    }\n}\n/** A Filter that implements the not-in operator. */\nclass NotInFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"not-in\" /* Operator.NOT_IN */, value);\n    }\n    matches(doc) {\n        if (arrayValueContains(this.value.arrayValue, { nullValue: 'NULL_VALUE' })) {\n            return false;\n        }\n        const other = doc.data.field(this.field);\n        return other !== null && !arrayValueContains(this.value.arrayValue, other);\n    }\n}\n/** A Filter that implements the array-contains-any operator. */\nclass ArrayContainsAnyFilter extends FieldFilter {\n    constructor(field, value) {\n        super(field, \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */, value);\n    }\n    matches(doc) {\n        const other = doc.data.field(this.field);\n        if (!isArray(other) || !other.arrayValue.values) {\n            return false;\n        }\n        return other.arrayValue.values.some(val => arrayValueContains(this.value.arrayValue, val));\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Visible for testing\nclass TargetImpl {\n    constructor(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) {\n        this.path = path;\n        this.collectionGroup = collectionGroup;\n        this.orderBy = orderBy;\n        this.filters = filters;\n        this.limit = limit;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.memoizedCanonicalId = null;\n    }\n}\n/**\n * Initializes a Target with a path and optional additional query constraints.\n * Path must currently be empty if this is a collection group query.\n *\n * NOTE: you should always construct `Target` from `Query.toTarget` instead of\n * using this factory method, because `Query` provides an implicit `orderBy`\n * property.\n */\nfunction newTarget(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) {\n    return new TargetImpl(path, collectionGroup, orderBy, filters, limit, startAt, endAt);\n}\nfunction canonifyTarget(target) {\n    const targetImpl = debugCast(target);\n    if (targetImpl.memoizedCanonicalId === null) {\n        let str = targetImpl.path.canonicalString();\n        if (targetImpl.collectionGroup !== null) {\n            str += '|cg:' + targetImpl.collectionGroup;\n        }\n        str += '|f:';\n        str += targetImpl.filters.map(f => canonifyFilter(f)).join(',');\n        str += '|ob:';\n        str += targetImpl.orderBy.map(o => canonifyOrderBy(o)).join(',');\n        if (!isNullOrUndefined(targetImpl.limit)) {\n            str += '|l:';\n            str += targetImpl.limit;\n        }\n        if (targetImpl.startAt) {\n            str += '|lb:';\n            str += targetImpl.startAt.inclusive ? 'b:' : 'a:';\n            str += targetImpl.startAt.position.map(p => canonicalId(p)).join(',');\n        }\n        if (targetImpl.endAt) {\n            str += '|ub:';\n            str += targetImpl.endAt.inclusive ? 'a:' : 'b:';\n            str += targetImpl.endAt.position.map(p => canonicalId(p)).join(',');\n        }\n        targetImpl.memoizedCanonicalId = str;\n    }\n    return targetImpl.memoizedCanonicalId;\n}\nfunction stringifyTarget(target) {\n    let str = target.path.canonicalString();\n    if (target.collectionGroup !== null) {\n        str += ' collectionGroup=' + target.collectionGroup;\n    }\n    if (target.filters.length > 0) {\n        str += `, filters: [${target.filters\n            .map(f => stringifyFilter(f))\n            .join(', ')}]`;\n    }\n    if (!isNullOrUndefined(target.limit)) {\n        str += ', limit: ' + target.limit;\n    }\n    if (target.orderBy.length > 0) {\n        str += `, orderBy: [${target.orderBy\n            .map(o => stringifyOrderBy(o))\n            .join(', ')}]`;\n    }\n    if (target.startAt) {\n        str += ', startAt: ';\n        str += target.startAt.inclusive ? 'b:' : 'a:';\n        str += target.startAt.position.map(p => canonicalId(p)).join(',');\n    }\n    if (target.endAt) {\n        str += ', endAt: ';\n        str += target.endAt.inclusive ? 'a:' : 'b:';\n        str += target.endAt.position.map(p => canonicalId(p)).join(',');\n    }\n    return `Target(${str})`;\n}\nfunction targetEquals(left, right) {\n    if (left.limit !== right.limit) {\n        return false;\n    }\n    if (left.orderBy.length !== right.orderBy.length) {\n        return false;\n    }\n    for (let i = 0; i < left.orderBy.length; i++) {\n        if (!orderByEquals(left.orderBy[i], right.orderBy[i])) {\n            return false;\n        }\n    }\n    if (left.filters.length !== right.filters.length) {\n        return false;\n    }\n    for (let i = 0; i < left.filters.length; i++) {\n        if (!filterEquals(left.filters[i], right.filters[i])) {\n            return false;\n        }\n    }\n    if (left.collectionGroup !== right.collectionGroup) {\n        return false;\n    }\n    if (!left.path.isEqual(right.path)) {\n        return false;\n    }\n    if (!boundEquals(left.startAt, right.startAt)) {\n        return false;\n    }\n    return boundEquals(left.endAt, right.endAt);\n}\nfunction targetIsDocumentTarget(target) {\n    return (DocumentKey.isDocumentKey(target.path) &&\n        target.collectionGroup === null &&\n        target.filters.length === 0);\n}\n/** Returns the field filters that target the given field path. */\nfunction targetGetFieldFiltersForPath(target, path) {\n    return target.filters.filter(f => f instanceof FieldFilter && f.field.isEqual(path));\n}\n/**\n * Returns the values that are used in ARRAY_CONTAINS or ARRAY_CONTAINS_ANY\n * filters. Returns `null` if there are no such filters.\n */\nfunction targetGetArrayValues(target, fieldIndex) {\n    const segment = fieldIndexGetArraySegment(fieldIndex);\n    if (segment === undefined) {\n        return null;\n    }\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, segment.fieldPath)) {\n        switch (fieldFilter.op) {\n            case \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */:\n                return fieldFilter.value.arrayValue.values || [];\n            case \"array-contains\" /* Operator.ARRAY_CONTAINS */:\n                return [fieldFilter.value];\n            // Remaining filters are not array filters.\n        }\n    }\n    return null;\n}\n/**\n * Returns the list of values that are used in != or NOT_IN filters. Returns\n * `null` if there are no such filters.\n */\nfunction targetGetNotInValues(target, fieldIndex) {\n    const values = new Map();\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n        for (const fieldFilter of targetGetFieldFiltersForPath(target, segment.fieldPath)) {\n            switch (fieldFilter.op) {\n                case \"==\" /* Operator.EQUAL */:\n                case \"in\" /* Operator.IN */:\n                    // Encode equality prefix, which is encoded in the index value before\n                    // the inequality (e.g. `a == 'a' && b != 'b'` is encoded to\n                    // `value != 'ab'`).\n                    values.set(segment.fieldPath.canonicalString(), fieldFilter.value);\n                    break;\n                case \"not-in\" /* Operator.NOT_IN */:\n                case \"!=\" /* Operator.NOT_EQUAL */:\n                    // NotIn/NotEqual is always a suffix. There cannot be any remaining\n                    // segments and hence we can return early here.\n                    values.set(segment.fieldPath.canonicalString(), fieldFilter.value);\n                    return Array.from(values.values());\n                // Remaining filters cannot be used as notIn bounds.\n            }\n        }\n    }\n    return null;\n}\n/**\n * Returns a lower bound of field values that can be used as a starting point to\n * scan the index defined by `fieldIndex`. Returns `MIN_VALUE` if no lower bound\n * exists.\n */\nfunction targetGetLowerBound(target, fieldIndex) {\n    const values = [];\n    let inclusive = true;\n    // For each segment, retrieve a lower bound if there is a suitable filter or\n    // startAt.\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n        const segmentBound = segment.kind === 0 /* IndexKind.ASCENDING */\n            ? targetGetAscendingBound(target, segment.fieldPath, target.startAt)\n            : targetGetDescendingBound(target, segment.fieldPath, target.startAt);\n        values.push(segmentBound.value);\n        inclusive && (inclusive = segmentBound.inclusive);\n    }\n    return new Bound(values, inclusive);\n}\n/**\n * Returns an upper bound of field values that can be used as an ending point\n * when scanning the index defined by `fieldIndex`. Returns `MAX_VALUE` if no\n * upper bound exists.\n */\nfunction targetGetUpperBound(target, fieldIndex) {\n    const values = [];\n    let inclusive = true;\n    // For each segment, retrieve an upper bound if there is a suitable filter or\n    // endAt.\n    for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n        const segmentBound = segment.kind === 0 /* IndexKind.ASCENDING */\n            ? targetGetDescendingBound(target, segment.fieldPath, target.endAt)\n            : targetGetAscendingBound(target, segment.fieldPath, target.endAt);\n        values.push(segmentBound.value);\n        inclusive && (inclusive = segmentBound.inclusive);\n    }\n    return new Bound(values, inclusive);\n}\n/**\n * Returns the value to use as the lower bound for ascending index segment at\n * the provided `fieldPath` (or the upper bound for an descending segment).\n */\nfunction targetGetAscendingBound(target, fieldPath, bound) {\n    let value = MIN_VALUE;\n    let inclusive = true;\n    // Process all filters to find a value for the current field segment\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, fieldPath)) {\n        let filterValue = MIN_VALUE;\n        let filterInclusive = true;\n        switch (fieldFilter.op) {\n            case \"<\" /* Operator.LESS_THAN */:\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\n                filterValue = valuesGetLowerBound(fieldFilter.value);\n                break;\n            case \"==\" /* Operator.EQUAL */:\n            case \"in\" /* Operator.IN */:\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\n                filterValue = fieldFilter.value;\n                break;\n            case \">\" /* Operator.GREATER_THAN */:\n                filterValue = fieldFilter.value;\n                filterInclusive = false;\n                break;\n            case \"!=\" /* Operator.NOT_EQUAL */:\n            case \"not-in\" /* Operator.NOT_IN */:\n                filterValue = MIN_VALUE;\n                break;\n            // Remaining filters cannot be used as lower bounds.\n        }\n        if (lowerBoundCompare({ value, inclusive }, { value: filterValue, inclusive: filterInclusive }) < 0) {\n            value = filterValue;\n            inclusive = filterInclusive;\n        }\n    }\n    // If there is an additional bound, compare the values against the existing\n    // range to see if we can narrow the scope.\n    if (bound !== null) {\n        for (let i = 0; i < target.orderBy.length; ++i) {\n            const orderBy = target.orderBy[i];\n            if (orderBy.field.isEqual(fieldPath)) {\n                const cursorValue = bound.position[i];\n                if (lowerBoundCompare({ value, inclusive }, { value: cursorValue, inclusive: bound.inclusive }) < 0) {\n                    value = cursorValue;\n                    inclusive = bound.inclusive;\n                }\n                break;\n            }\n        }\n    }\n    return { value, inclusive };\n}\n/**\n * Returns the value to use as the upper bound for ascending index segment at\n * the provided `fieldPath` (or the lower bound for a descending segment).\n */\nfunction targetGetDescendingBound(target, fieldPath, bound) {\n    let value = MAX_VALUE;\n    let inclusive = true;\n    // Process all filters to find a value for the current field segment\n    for (const fieldFilter of targetGetFieldFiltersForPath(target, fieldPath)) {\n        let filterValue = MAX_VALUE;\n        let filterInclusive = true;\n        switch (fieldFilter.op) {\n            case \">=\" /* Operator.GREATER_THAN_OR_EQUAL */:\n            case \">\" /* Operator.GREATER_THAN */:\n                filterValue = valuesGetUpperBound(fieldFilter.value);\n                filterInclusive = false;\n                break;\n            case \"==\" /* Operator.EQUAL */:\n            case \"in\" /* Operator.IN */:\n            case \"<=\" /* Operator.LESS_THAN_OR_EQUAL */:\n                filterValue = fieldFilter.value;\n                break;\n            case \"<\" /* Operator.LESS_THAN */:\n                filterValue = fieldFilter.value;\n                filterInclusive = false;\n                break;\n            case \"!=\" /* Operator.NOT_EQUAL */:\n            case \"not-in\" /* Operator.NOT_IN */:\n                filterValue = MAX_VALUE;\n                break;\n            // Remaining filters cannot be used as upper bounds.\n        }\n        if (upperBoundCompare({ value, inclusive }, { value: filterValue, inclusive: filterInclusive }) > 0) {\n            value = filterValue;\n            inclusive = filterInclusive;\n        }\n    }\n    // If there is an additional bound, compare the values against the existing\n    // range to see if we can narrow the scope.\n    if (bound !== null) {\n        for (let i = 0; i < target.orderBy.length; ++i) {\n            const orderBy = target.orderBy[i];\n            if (orderBy.field.isEqual(fieldPath)) {\n                const cursorValue = bound.position[i];\n                if (upperBoundCompare({ value, inclusive }, { value: cursorValue, inclusive: bound.inclusive }) > 0) {\n                    value = cursorValue;\n                    inclusive = bound.inclusive;\n                }\n                break;\n            }\n        }\n    }\n    return { value, inclusive };\n}\n/** Returns the number of segments of a perfect index for this target. */\nfunction targetGetSegmentCount(target) {\n    let fields = new SortedSet(FieldPath$1.comparator);\n    let hasArraySegment = false;\n    for (const filter of target.filters) {\n        for (const subFilter of filter.getFlattenedFilters()) {\n            // __name__ is not an explicit segment of any index, so we don't need to\n            // count it.\n            if (subFilter.field.isKeyField()) {\n                continue;\n            }\n            // ARRAY_CONTAINS or ARRAY_CONTAINS_ANY filters must be counted separately.\n            // For instance, it is possible to have an index for \"a ARRAY a ASC\". Even\n            // though these are on the same field, they should be counted as two\n            // separate segments in an index.\n            if (subFilter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\n                subFilter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\n                hasArraySegment = true;\n            }\n            else {\n                fields = fields.add(subFilter.field);\n            }\n        }\n    }\n    for (const orderBy of target.orderBy) {\n        // __name__ is not an explicit segment of any index, so we don't need to\n        // count it.\n        if (!orderBy.field.isKeyField()) {\n            fields = fields.add(orderBy.field);\n        }\n    }\n    return fields.size + (hasArraySegment ? 1 : 0);\n}\nfunction targetHasLimit(target) {\n    return target.limit !== null;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Query encapsulates all the query attributes we support in the SDK. It can\n * be run against the LocalStore, as well as be converted to a `Target` to\n * query the RemoteStore results.\n *\n * Visible for testing.\n */\nclass QueryImpl {\n    /**\n     * Initializes a Query with a path and optional additional query constraints.\n     * Path must currently be empty if this is a collection group query.\n     */\n    constructor(path, collectionGroup = null, explicitOrderBy = [], filters = [], limit = null, limitType = \"F\" /* LimitType.First */, startAt = null, endAt = null) {\n        this.path = path;\n        this.collectionGroup = collectionGroup;\n        this.explicitOrderBy = explicitOrderBy;\n        this.filters = filters;\n        this.limit = limit;\n        this.limitType = limitType;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.memoizedNormalizedOrderBy = null;\n        // The corresponding `Target` of this `Query` instance, for use with\n        // non-aggregate queries.\n        this.memoizedTarget = null;\n        // The corresponding `Target` of this `Query` instance, for use with\n        // aggregate queries. Unlike targets for non-aggregate queries,\n        // aggregate query targets do not contain normalized order-bys, they only\n        // contain explicit order-bys.\n        this.memoizedAggregateTarget = null;\n        if (this.startAt) ;\n        if (this.endAt) ;\n    }\n}\n/** Creates a new Query instance with the options provided. */\nfunction newQuery(path, collectionGroup, explicitOrderBy, filters, limit, limitType, startAt, endAt) {\n    return new QueryImpl(path, collectionGroup, explicitOrderBy, filters, limit, limitType, startAt, endAt);\n}\n/** Creates a new Query for a query that matches all documents at `path` */\nfunction newQueryForPath(path) {\n    return new QueryImpl(path);\n}\n/**\n * Helper to convert a collection group query into a collection query at a\n * specific path. This is used when executing collection group queries, since\n * we have to split the query into a set of collection queries at multiple\n * paths.\n */\nfunction asCollectionQueryAtPath(query, path) {\n    return new QueryImpl(path, \n    /*collectionGroup=*/ null, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, query.startAt, query.endAt);\n}\n/**\n * Returns true if this query does not specify any query constraints that\n * could remove results.\n */\nfunction queryMatchesAllDocuments(query) {\n    return (query.filters.length === 0 &&\n        query.limit === null &&\n        query.startAt == null &&\n        query.endAt == null &&\n        (query.explicitOrderBy.length === 0 ||\n            (query.explicitOrderBy.length === 1 &&\n                query.explicitOrderBy[0].field.isKeyField())));\n}\n// Returns the sorted set of inequality filter fields used in this query.\nfunction getInequalityFilterFields(query) {\n    let result = new SortedSet(FieldPath$1.comparator);\n    query.filters.forEach((filter) => {\n        const subFilters = filter.getFlattenedFilters();\n        subFilters.forEach((filter) => {\n            if (filter.isInequality()) {\n                result = result.add(filter.field);\n            }\n        });\n    });\n    return result;\n}\n/**\n * Creates a new Query for a collection group query that matches all documents\n * within the provided collection group.\n */\nfunction newQueryForCollectionGroup(collectionId) {\n    return new QueryImpl(ResourcePath.emptyPath(), collectionId);\n}\n/**\n * Returns whether the query matches a single document by path (rather than a\n * collection).\n */\nfunction isDocumentQuery$1(query) {\n    return (DocumentKey.isDocumentKey(query.path) &&\n        query.collectionGroup === null &&\n        query.filters.length === 0);\n}\n/**\n * Returns whether the query matches a collection group rather than a specific\n * collection.\n */\nfunction isCollectionGroupQuery(query) {\n    return query.collectionGroup !== null;\n}\n/**\n * Returns the normalized order-by constraint that is used to execute the Query,\n * which can be different from the order-by constraints the user provided (e.g.\n * the SDK and backend always orders by `__name__`). The normalized order-by\n * includes implicit order-bys in addition to the explicit user provided\n * order-bys.\n */\nfunction queryNormalizedOrderBy(query) {\n    const queryImpl = debugCast(query);\n    if (queryImpl.memoizedNormalizedOrderBy === null) {\n        queryImpl.memoizedNormalizedOrderBy = [];\n        const fieldsNormalized = new Set();\n        // Any explicit order by fields should be added as is.\n        for (const orderBy of queryImpl.explicitOrderBy) {\n            queryImpl.memoizedNormalizedOrderBy.push(orderBy);\n            fieldsNormalized.add(orderBy.field.canonicalString());\n        }\n        // The order of the implicit ordering always matches the last explicit order by.\n        const lastDirection = queryImpl.explicitOrderBy.length > 0\n            ? queryImpl.explicitOrderBy[queryImpl.explicitOrderBy.length - 1].dir\n            : \"asc\" /* Direction.ASCENDING */;\n        // Any inequality fields not explicitly ordered should be implicitly ordered in a lexicographical\n        // order. When there are multiple inequality filters on the same field, the field should be added\n        // only once.\n        // Note: `SortedSet<FieldPath>` sorts the key field before other fields. However, we want the key\n        // field to be sorted last.\n        const inequalityFields = getInequalityFilterFields(queryImpl);\n        inequalityFields.forEach(field => {\n            if (!fieldsNormalized.has(field.canonicalString()) &&\n                !field.isKeyField()) {\n                queryImpl.memoizedNormalizedOrderBy.push(new OrderBy(field, lastDirection));\n            }\n        });\n        // Add the document key field to the last if it is not explicitly ordered.\n        if (!fieldsNormalized.has(FieldPath$1.keyField().canonicalString())) {\n            queryImpl.memoizedNormalizedOrderBy.push(new OrderBy(FieldPath$1.keyField(), lastDirection));\n        }\n    }\n    return queryImpl.memoizedNormalizedOrderBy;\n}\n/**\n * Converts this `Query` instance to its corresponding `Target` representation.\n */\nfunction queryToTarget(query) {\n    const queryImpl = debugCast(query);\n    if (!queryImpl.memoizedTarget) {\n        queryImpl.memoizedTarget = _queryToTarget(queryImpl, queryNormalizedOrderBy(query));\n    }\n    return queryImpl.memoizedTarget;\n}\n/**\n * Converts this `Query` instance to its corresponding `Target` representation,\n * for use within an aggregate query. Unlike targets for non-aggregate queries,\n * aggregate query targets do not contain normalized order-bys, they only\n * contain explicit order-bys.\n */\nfunction queryToAggregateTarget(query) {\n    const queryImpl = debugCast(query);\n    if (!queryImpl.memoizedAggregateTarget) {\n        // Do not include implicit order-bys for aggregate queries.\n        queryImpl.memoizedAggregateTarget = _queryToTarget(queryImpl, query.explicitOrderBy);\n    }\n    return queryImpl.memoizedAggregateTarget;\n}\nfunction _queryToTarget(queryImpl, orderBys) {\n    if (queryImpl.limitType === \"F\" /* LimitType.First */) {\n        return newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, queryImpl.startAt, queryImpl.endAt);\n    }\n    else {\n        // Flip the orderBy directions since we want the last results\n        orderBys = orderBys.map(orderBy => {\n            const dir = orderBy.dir === \"desc\" /* Direction.DESCENDING */\n                ? \"asc\" /* Direction.ASCENDING */\n                : \"desc\" /* Direction.DESCENDING */;\n            return new OrderBy(orderBy.field, dir);\n        });\n        // We need to swap the cursors to match the now-flipped query ordering.\n        const startAt = queryImpl.endAt\n            ? new Bound(queryImpl.endAt.position, queryImpl.endAt.inclusive)\n            : null;\n        const endAt = queryImpl.startAt\n            ? new Bound(queryImpl.startAt.position, queryImpl.startAt.inclusive)\n            : null;\n        // Now return as a LimitType.First query.\n        return newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, startAt, endAt);\n    }\n}\nfunction queryWithAddedFilter(query, filter) {\n    const newFilters = query.filters.concat([filter]);\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), newFilters, query.limit, query.limitType, query.startAt, query.endAt);\n}\nfunction queryWithAddedOrderBy(query, orderBy) {\n    // TODO(dimond): validate that orderBy does not list the same key twice.\n    const newOrderBy = query.explicitOrderBy.concat([orderBy]);\n    return new QueryImpl(query.path, query.collectionGroup, newOrderBy, query.filters.slice(), query.limit, query.limitType, query.startAt, query.endAt);\n}\nfunction queryWithLimit(query, limit, limitType) {\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), limit, limitType, query.startAt, query.endAt);\n}\nfunction queryWithStartAt(query, bound) {\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, bound, query.endAt);\n}\nfunction queryWithEndAt(query, bound) {\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, query.startAt, bound);\n}\nfunction queryEquals(left, right) {\n    return (targetEquals(queryToTarget(left), queryToTarget(right)) &&\n        left.limitType === right.limitType);\n}\n// TODO(b/29183165): This is used to get a unique string from a query to, for\n// example, use as a dictionary key, but the implementation is subject to\n// collisions. Make it collision-free.\nfunction canonifyQuery(query) {\n    return `${canonifyTarget(queryToTarget(query))}|lt:${query.limitType}`;\n}\nfunction stringifyQuery(query) {\n    return `Query(target=${stringifyTarget(queryToTarget(query))}; limitType=${query.limitType})`;\n}\n/** Returns whether `doc` matches the constraints of `query`. */\nfunction queryMatches(query, doc) {\n    return (doc.isFoundDocument() &&\n        queryMatchesPathAndCollectionGroup(query, doc) &&\n        queryMatchesOrderBy(query, doc) &&\n        queryMatchesFilters(query, doc) &&\n        queryMatchesBounds(query, doc));\n}\nfunction queryMatchesPathAndCollectionGroup(query, doc) {\n    const docPath = doc.key.path;\n    if (query.collectionGroup !== null) {\n        // NOTE: this.path is currently always empty since we don't expose Collection\n        // Group queries rooted at a document path yet.\n        return (doc.key.hasCollectionId(query.collectionGroup) &&\n            query.path.isPrefixOf(docPath));\n    }\n    else if (DocumentKey.isDocumentKey(query.path)) {\n        // exact match for document queries\n        return query.path.isEqual(docPath);\n    }\n    else {\n        // shallow ancestor queries by default\n        return query.path.isImmediateParentOf(docPath);\n    }\n}\n/**\n * A document must have a value for every ordering clause in order to show up\n * in the results.\n */\nfunction queryMatchesOrderBy(query, doc) {\n    // We must use `queryNormalizedOrderBy()` to get the list of all orderBys (both implicit and explicit).\n    // Note that for OR queries, orderBy applies to all disjunction terms and implicit orderBys must\n    // be taken into account. For example, the query \"a > 1 || b==1\" has an implicit \"orderBy a\" due\n    // to the inequality, and is evaluated as \"a > 1 orderBy a || b==1 orderBy a\".\n    // A document with content of {b:1} matches the filters, but does not match the orderBy because\n    // it's missing the field 'a'.\n    for (const orderBy of queryNormalizedOrderBy(query)) {\n        // order-by key always matches\n        if (!orderBy.field.isKeyField() && doc.data.field(orderBy.field) === null) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction queryMatchesFilters(query, doc) {\n    for (const filter of query.filters) {\n        if (!filter.matches(doc)) {\n            return false;\n        }\n    }\n    return true;\n}\n/** Makes sure a document is within the bounds, if provided. */\nfunction queryMatchesBounds(query, doc) {\n    if (query.startAt &&\n        !boundSortsBeforeDocument(query.startAt, queryNormalizedOrderBy(query), doc)) {\n        return false;\n    }\n    if (query.endAt &&\n        !boundSortsAfterDocument(query.endAt, queryNormalizedOrderBy(query), doc)) {\n        return false;\n    }\n    return true;\n}\n/**\n * Returns the collection group that this query targets.\n *\n * PORTING NOTE: This is only used in the Web SDK to facilitate multi-tab\n * synchronization for query results.\n */\nfunction queryCollectionGroup(query) {\n    return (query.collectionGroup ||\n        (query.path.length % 2 === 1\n            ? query.path.lastSegment()\n            : query.path.get(query.path.length - 2)));\n}\n/**\n * Returns a new comparator function that can be used to compare two documents\n * based on the Query's ordering constraint.\n */\nfunction newQueryComparator(query) {\n    return (d1, d2) => {\n        let comparedOnKeyField = false;\n        for (const orderBy of queryNormalizedOrderBy(query)) {\n            const comp = compareDocs(orderBy, d1, d2);\n            if (comp !== 0) {\n                return comp;\n            }\n            comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();\n        }\n        return 0;\n    };\n}\nfunction compareDocs(orderBy, d1, d2) {\n    const comparison = orderBy.field.isKeyField()\n        ? DocumentKey.comparator(d1.key, d2.key)\n        : compareDocumentsByField(orderBy.field, d1, d2);\n    switch (orderBy.dir) {\n        case \"asc\" /* Direction.ASCENDING */:\n            return comparison;\n        case \"desc\" /* Direction.DESCENDING */:\n            return -1 * comparison;\n        default:\n            return fail();\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A map implementation that uses objects as keys. Objects must have an\n * associated equals function and must be immutable. Entries in the map are\n * stored together with the key being produced from the mapKeyFn. This map\n * automatically handles collisions of keys.\n */\nclass ObjectMap {\n    constructor(mapKeyFn, equalsFn) {\n        this.mapKeyFn = mapKeyFn;\n        this.equalsFn = equalsFn;\n        /**\n         * The inner map for a key/value pair. Due to the possibility of collisions we\n         * keep a list of entries that we do a linear search through to find an actual\n         * match. Note that collisions should be rare, so we still expect near\n         * constant time lookups in practice.\n         */\n        this.inner = {};\n        /** The number of entries stored in the map */\n        this.innerSize = 0;\n    }\n    /** Get a value for this key, or undefined if it does not exist. */\n    get(key) {\n        const id = this.mapKeyFn(key);\n        const matches = this.inner[id];\n        if (matches === undefined) {\n            return undefined;\n        }\n        for (const [otherKey, value] of matches) {\n            if (this.equalsFn(otherKey, key)) {\n                return value;\n            }\n        }\n        return undefined;\n    }\n    has(key) {\n        return this.get(key) !== undefined;\n    }\n    /** Put this key and value in the map. */\n    set(key, value) {\n        const id = this.mapKeyFn(key);\n        const matches = this.inner[id];\n        if (matches === undefined) {\n            this.inner[id] = [[key, value]];\n            this.innerSize++;\n            return;\n        }\n        for (let i = 0; i < matches.length; i++) {\n            if (this.equalsFn(matches[i][0], key)) {\n                // This is updating an existing entry and does not increase `innerSize`.\n                matches[i] = [key, value];\n                return;\n            }\n        }\n        matches.push([key, value]);\n        this.innerSize++;\n    }\n    /**\n     * Remove this key from the map. Returns a boolean if anything was deleted.\n     */\n    delete(key) {\n        const id = this.mapKeyFn(key);\n        const matches = this.inner[id];\n        if (matches === undefined) {\n            return false;\n        }\n        for (let i = 0; i < matches.length; i++) {\n            if (this.equalsFn(matches[i][0], key)) {\n                if (matches.length === 1) {\n                    delete this.inner[id];\n                }\n                else {\n                    matches.splice(i, 1);\n                }\n                this.innerSize--;\n                return true;\n            }\n        }\n        return false;\n    }\n    forEach(fn) {\n        forEach(this.inner, (_, entries) => {\n            for (const [k, v] of entries) {\n                fn(k, v);\n            }\n        });\n    }\n    isEmpty() {\n        return isEmpty(this.inner);\n    }\n    size() {\n        return this.innerSize;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EMPTY_MUTABLE_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\nfunction mutableDocumentMap() {\n    return EMPTY_MUTABLE_DOCUMENT_MAP;\n}\nconst EMPTY_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\nfunction documentMap(...docs) {\n    let map = EMPTY_DOCUMENT_MAP;\n    for (const doc of docs) {\n        map = map.insert(doc.key, doc);\n    }\n    return map;\n}\nfunction newOverlayedDocumentMap() {\n    return newDocumentKeyMap();\n}\nfunction convertOverlayedDocumentMapToDocumentMap(collection) {\n    let documents = EMPTY_DOCUMENT_MAP;\n    collection.forEach((k, v) => (documents = documents.insert(k, v.overlayedDocument)));\n    return documents;\n}\nfunction newOverlayMap() {\n    return newDocumentKeyMap();\n}\nfunction newMutationMap() {\n    return newDocumentKeyMap();\n}\nfunction newDocumentKeyMap() {\n    return new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\n}\nconst EMPTY_DOCUMENT_VERSION_MAP = new SortedMap(DocumentKey.comparator);\nfunction documentVersionMap() {\n    return EMPTY_DOCUMENT_VERSION_MAP;\n}\nconst EMPTY_DOCUMENT_KEY_SET = new SortedSet(DocumentKey.comparator);\nfunction documentKeySet(...keys) {\n    let set = EMPTY_DOCUMENT_KEY_SET;\n    for (const key of keys) {\n        set = set.add(key);\n    }\n    return set;\n}\nconst EMPTY_TARGET_ID_SET = new SortedSet(primitiveComparator);\nfunction targetIdSet() {\n    return EMPTY_TARGET_ID_SET;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns an DoubleValue for `value` that is encoded based the serializer's\n * `useProto3Json` setting.\n */\nfunction toDouble(serializer, value) {\n    if (serializer.useProto3Json) {\n        if (isNaN(value)) {\n            return { doubleValue: 'NaN' };\n        }\n        else if (value === Infinity) {\n            return { doubleValue: 'Infinity' };\n        }\n        else if (value === -Infinity) {\n            return { doubleValue: '-Infinity' };\n        }\n    }\n    return { doubleValue: isNegativeZero(value) ? '-0' : value };\n}\n/**\n * Returns an IntegerValue for `value`.\n */\nfunction toInteger(value) {\n    return { integerValue: '' + value };\n}\n/**\n * Returns a value for a number that's appropriate to put into a proto.\n * The return value is an IntegerValue if it can safely represent the value,\n * otherwise a DoubleValue is returned.\n */\nfunction toNumber(serializer, value) {\n    return isSafeInteger(value) ? toInteger(value) : toDouble(serializer, value);\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Used to represent a field transform on a mutation. */\nclass TransformOperation {\n    constructor() {\n        // Make sure that the structural type of `TransformOperation` is unique.\n        // See https://github.com/microsoft/TypeScript/issues/5451\n        this._ = undefined;\n    }\n}\n/**\n * Computes the local transform result against the provided `previousValue`,\n * optionally using the provided localWriteTime.\n */\nfunction applyTransformOperationToLocalView(transform, previousValue, localWriteTime) {\n    if (transform instanceof ServerTimestampTransform) {\n        return serverTimestamp$1(localWriteTime, previousValue);\n    }\n    else if (transform instanceof ArrayUnionTransformOperation) {\n        return applyArrayUnionTransformOperation(transform, previousValue);\n    }\n    else if (transform instanceof ArrayRemoveTransformOperation) {\n        return applyArrayRemoveTransformOperation(transform, previousValue);\n    }\n    else {\n        return applyNumericIncrementTransformOperationToLocalView(transform, previousValue);\n    }\n}\n/**\n * Computes a final transform result after the transform has been acknowledged\n * by the server, potentially using the server-provided transformResult.\n */\nfunction applyTransformOperationToRemoteDocument(transform, previousValue, transformResult) {\n    // The server just sends null as the transform result for array operations,\n    // so we have to calculate a result the same as we do for local\n    // applications.\n    if (transform instanceof ArrayUnionTransformOperation) {\n        return applyArrayUnionTransformOperation(transform, previousValue);\n    }\n    else if (transform instanceof ArrayRemoveTransformOperation) {\n        return applyArrayRemoveTransformOperation(transform, previousValue);\n    }\n    return transformResult;\n}\n/**\n * If this transform operation is not idempotent, returns the base value to\n * persist for this transform. If a base value is returned, the transform\n * operation is always applied to this base value, even if document has\n * already been updated.\n *\n * Base values provide consistent behavior for non-idempotent transforms and\n * allow us to return the same latency-compensated value even if the backend\n * has already applied the transform operation. The base value is null for\n * idempotent transforms, as they can be re-played even if the backend has\n * already applied them.\n *\n * @returns a base value to store along with the mutation, or null for\n * idempotent transforms.\n */\nfunction computeTransformOperationBaseValue(transform, previousValue) {\n    if (transform instanceof NumericIncrementTransformOperation) {\n        return isNumber(previousValue) ? previousValue : { integerValue: 0 };\n    }\n    return null;\n}\nfunction transformOperationEquals(left, right) {\n    if (left instanceof ArrayUnionTransformOperation &&\n        right instanceof ArrayUnionTransformOperation) {\n        return arrayEquals(left.elements, right.elements, valueEquals);\n    }\n    else if (left instanceof ArrayRemoveTransformOperation &&\n        right instanceof ArrayRemoveTransformOperation) {\n        return arrayEquals(left.elements, right.elements, valueEquals);\n    }\n    else if (left instanceof NumericIncrementTransformOperation &&\n        right instanceof NumericIncrementTransformOperation) {\n        return valueEquals(left.operand, right.operand);\n    }\n    return (left instanceof ServerTimestampTransform &&\n        right instanceof ServerTimestampTransform);\n}\n/** Transforms a value into a server-generated timestamp. */\nclass ServerTimestampTransform extends TransformOperation {\n}\n/** Transforms an array value via a union operation. */\nclass ArrayUnionTransformOperation extends TransformOperation {\n    constructor(elements) {\n        super();\n        this.elements = elements;\n    }\n}\nfunction applyArrayUnionTransformOperation(transform, previousValue) {\n    const values = coercedFieldValuesArray(previousValue);\n    for (const toUnion of transform.elements) {\n        if (!values.some(element => valueEquals(element, toUnion))) {\n            values.push(toUnion);\n        }\n    }\n    return { arrayValue: { values } };\n}\n/** Transforms an array value via a remove operation. */\nclass ArrayRemoveTransformOperation extends TransformOperation {\n    constructor(elements) {\n        super();\n        this.elements = elements;\n    }\n}\nfunction applyArrayRemoveTransformOperation(transform, previousValue) {\n    let values = coercedFieldValuesArray(previousValue);\n    for (const toRemove of transform.elements) {\n        values = values.filter(element => !valueEquals(element, toRemove));\n    }\n    return { arrayValue: { values } };\n}\n/**\n * Implements the backend semantics for locally computed NUMERIC_ADD (increment)\n * transforms. Converts all field values to integers or doubles, but unlike the\n * backend does not cap integer values at 2^63. Instead, JavaScript number\n * arithmetic is used and precision loss can occur for values greater than 2^53.\n */\nclass NumericIncrementTransformOperation extends TransformOperation {\n    constructor(serializer, operand) {\n        super();\n        this.serializer = serializer;\n        this.operand = operand;\n    }\n}\nfunction applyNumericIncrementTransformOperationToLocalView(transform, previousValue) {\n    // PORTING NOTE: Since JavaScript's integer arithmetic is limited to 53 bit\n    // precision and resolves overflows by reducing precision, we do not\n    // manually cap overflows at 2^63.\n    const baseValue = computeTransformOperationBaseValue(transform, previousValue);\n    const sum = asNumber(baseValue) + asNumber(transform.operand);\n    if (isInteger(baseValue) && isInteger(transform.operand)) {\n        return toInteger(sum);\n    }\n    else {\n        return toDouble(transform.serializer, sum);\n    }\n}\nfunction asNumber(value) {\n    return normalizeNumber(value.integerValue || value.doubleValue);\n}\nfunction coercedFieldValuesArray(value) {\n    return isArray(value) && value.arrayValue.values\n        ? value.arrayValue.values.slice()\n        : [];\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** A field path and the TransformOperation to perform upon it. */\nclass FieldTransform {\n    constructor(field, transform) {\n        this.field = field;\n        this.transform = transform;\n    }\n}\nfunction fieldTransformEquals(left, right) {\n    return (left.field.isEqual(right.field) &&\n        transformOperationEquals(left.transform, right.transform));\n}\nfunction fieldTransformsAreEqual(left, right) {\n    if (left === undefined && right === undefined) {\n        return true;\n    }\n    if (left && right) {\n        return arrayEquals(left, right, (l, r) => fieldTransformEquals(l, r));\n    }\n    return false;\n}\n/** The result of successfully applying a mutation to the backend. */\nclass MutationResult {\n    constructor(\n    /**\n     * The version at which the mutation was committed:\n     *\n     * - For most operations, this is the updateTime in the WriteResult.\n     * - For deletes, the commitTime of the WriteResponse (because deletes are\n     *   not stored and have no updateTime).\n     *\n     * Note that these versions can be different: No-op writes will not change\n     * the updateTime even though the commitTime advances.\n     */\n    version, \n    /**\n     * The resulting fields returned from the backend after a mutation\n     * containing field transforms has been committed. Contains one FieldValue\n     * for each FieldTransform that was in the mutation.\n     *\n     * Will be empty if the mutation did not contain any field transforms.\n     */\n    transformResults) {\n        this.version = version;\n        this.transformResults = transformResults;\n    }\n}\n/**\n * Encodes a precondition for a mutation. This follows the model that the\n * backend accepts with the special case of an explicit \"empty\" precondition\n * (meaning no precondition).\n */\nclass Precondition {\n    constructor(updateTime, exists) {\n        this.updateTime = updateTime;\n        this.exists = exists;\n    }\n    /** Creates a new empty Precondition. */\n    static none() {\n        return new Precondition();\n    }\n    /** Creates a new Precondition with an exists flag. */\n    static exists(exists) {\n        return new Precondition(undefined, exists);\n    }\n    /** Creates a new Precondition based on a version a document exists at. */\n    static updateTime(version) {\n        return new Precondition(version);\n    }\n    /** Returns whether this Precondition is empty. */\n    get isNone() {\n        return this.updateTime === undefined && this.exists === undefined;\n    }\n    isEqual(other) {\n        return (this.exists === other.exists &&\n            (this.updateTime\n                ? !!other.updateTime && this.updateTime.isEqual(other.updateTime)\n                : !other.updateTime));\n    }\n}\n/** Returns true if the preconditions is valid for the given document. */\nfunction preconditionIsValidForDocument(precondition, document) {\n    if (precondition.updateTime !== undefined) {\n        return (document.isFoundDocument() &&\n            document.version.isEqual(precondition.updateTime));\n    }\n    else if (precondition.exists !== undefined) {\n        return precondition.exists === document.isFoundDocument();\n    }\n    else {\n        return true;\n    }\n}\n/**\n * A mutation describes a self-contained change to a document. Mutations can\n * create, replace, delete, and update subsets of documents.\n *\n * Mutations not only act on the value of the document but also its version.\n *\n * For local mutations (mutations that haven't been committed yet), we preserve\n * the existing version for Set and Patch mutations. For Delete mutations, we\n * reset the version to 0.\n *\n * Here's the expected transition table.\n *\n * MUTATION           APPLIED TO            RESULTS IN\n *\n * SetMutation        Document(v3)          Document(v3)\n * SetMutation        NoDocument(v3)        Document(v0)\n * SetMutation        InvalidDocument(v0)   Document(v0)\n * PatchMutation      Document(v3)          Document(v3)\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\n * PatchMutation      InvalidDocument(v0)   UnknownDocument(v3)\n * DeleteMutation     Document(v3)          NoDocument(v0)\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\n * DeleteMutation     InvalidDocument(v0)   NoDocument(v0)\n *\n * For acknowledged mutations, we use the updateTime of the WriteResponse as\n * the resulting version for Set and Patch mutations. As deletes have no\n * explicit update time, we use the commitTime of the WriteResponse for\n * Delete mutations.\n *\n * If a mutation is acknowledged by the backend but fails the precondition check\n * locally, we transition to an `UnknownDocument` and rely on Watch to send us\n * the updated version.\n *\n * Field transforms are used only with Patch and Set Mutations. We use the\n * `updateTransforms` message to store transforms, rather than the `transforms`s\n * messages.\n *\n * ## Subclassing Notes\n *\n * Every type of mutation needs to implement its own applyToRemoteDocument() and\n * applyToLocalView() to implement the actual behavior of applying the mutation\n * to some source document (see `setMutationApplyToRemoteDocument()` for an\n * example).\n */\nclass Mutation {\n}\n/**\n * A utility method to calculate a `Mutation` representing the overlay from the\n * final state of the document, and a `FieldMask` representing the fields that\n * are mutated by the local mutations.\n */\nfunction calculateOverlayMutation(doc, mask) {\n    if (!doc.hasLocalMutations || (mask && mask.fields.length === 0)) {\n        return null;\n    }\n    // mask is null when sets or deletes are applied to the current document.\n    if (mask === null) {\n        if (doc.isNoDocument()) {\n            return new DeleteMutation(doc.key, Precondition.none());\n        }\n        else {\n            return new SetMutation(doc.key, doc.data, Precondition.none());\n        }\n    }\n    else {\n        const docValue = doc.data;\n        const patchValue = ObjectValue.empty();\n        let maskSet = new SortedSet(FieldPath$1.comparator);\n        for (let path of mask.fields) {\n            if (!maskSet.has(path)) {\n                let value = docValue.field(path);\n                // If we are deleting a nested field, we take the immediate parent as\n                // the mask used to construct the resulting mutation.\n                // Justification: Nested fields can create parent fields implicitly. If\n                // only a leaf entry is deleted in later mutations, the parent field\n                // should still remain, but we may have lost this information.\n                // Consider mutation (foo.bar 1), then mutation (foo.bar delete()).\n                // This leaves the final result (foo, {}). Despite the fact that `doc`\n                // has the correct result, `foo` is not in `mask`, and the resulting\n                // mutation would miss `foo`.\n                if (value === null && path.length > 1) {\n                    path = path.popLast();\n                    value = docValue.field(path);\n                }\n                if (value === null) {\n                    patchValue.delete(path);\n                }\n                else {\n                    patchValue.set(path, value);\n                }\n                maskSet = maskSet.add(path);\n            }\n        }\n        return new PatchMutation(doc.key, patchValue, new FieldMask(maskSet.toArray()), Precondition.none());\n    }\n}\n/**\n * Applies this mutation to the given document for the purposes of computing a\n * new remote document. If the input document doesn't match the expected state\n * (e.g. it is invalid or outdated), the document type may transition to\n * unknown.\n *\n * @param mutation - The mutation to apply.\n * @param document - The document to mutate. The input document can be an\n *     invalid document if the client has no knowledge of the pre-mutation state\n *     of the document.\n * @param mutationResult - The result of applying the mutation from the backend.\n */\nfunction mutationApplyToRemoteDocument(mutation, document, mutationResult) {\n    if (mutation instanceof SetMutation) {\n        setMutationApplyToRemoteDocument(mutation, document, mutationResult);\n    }\n    else if (mutation instanceof PatchMutation) {\n        patchMutationApplyToRemoteDocument(mutation, document, mutationResult);\n    }\n    else {\n        deleteMutationApplyToRemoteDocument(mutation, document, mutationResult);\n    }\n}\n/**\n * Applies this mutation to the given document for the purposes of computing\n * the new local view of a document. If the input document doesn't match the\n * expected state, the document is not modified.\n *\n * @param mutation - The mutation to apply.\n * @param document - The document to mutate. The input document can be an\n *     invalid document if the client has no knowledge of the pre-mutation state\n *     of the document.\n * @param previousMask - The fields that have been updated before applying this mutation.\n * @param localWriteTime - A timestamp indicating the local write time of the\n *     batch this mutation is a part of.\n * @returns A `FieldMask` representing the fields that are changed by applying this mutation.\n */\nfunction mutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\n    if (mutation instanceof SetMutation) {\n        return setMutationApplyToLocalView(mutation, document, previousMask, localWriteTime);\n    }\n    else if (mutation instanceof PatchMutation) {\n        return patchMutationApplyToLocalView(mutation, document, previousMask, localWriteTime);\n    }\n    else {\n        return deleteMutationApplyToLocalView(mutation, document, previousMask);\n    }\n}\n/**\n * If this mutation is not idempotent, returns the base value to persist with\n * this mutation. If a base value is returned, the mutation is always applied\n * to this base value, even if document has already been updated.\n *\n * The base value is a sparse object that consists of only the document\n * fields for which this mutation contains a non-idempotent transformation\n * (e.g. a numeric increment). The provided value guarantees consistent\n * behavior for non-idempotent transforms and allow us to return the same\n * latency-compensated value even if the backend has already applied the\n * mutation. The base value is null for idempotent mutations, as they can be\n * re-played even if the backend has already applied them.\n *\n * @returns a base value to store along with the mutation, or null for\n * idempotent mutations.\n */\nfunction mutationExtractBaseValue(mutation, document) {\n    let baseObject = null;\n    for (const fieldTransform of mutation.fieldTransforms) {\n        const existingValue = document.data.field(fieldTransform.field);\n        const coercedValue = computeTransformOperationBaseValue(fieldTransform.transform, existingValue || null);\n        if (coercedValue != null) {\n            if (baseObject === null) {\n                baseObject = ObjectValue.empty();\n            }\n            baseObject.set(fieldTransform.field, coercedValue);\n        }\n    }\n    return baseObject ? baseObject : null;\n}\nfunction mutationEquals(left, right) {\n    if (left.type !== right.type) {\n        return false;\n    }\n    if (!left.key.isEqual(right.key)) {\n        return false;\n    }\n    if (!left.precondition.isEqual(right.precondition)) {\n        return false;\n    }\n    if (!fieldTransformsAreEqual(left.fieldTransforms, right.fieldTransforms)) {\n        return false;\n    }\n    if (left.type === 0 /* MutationType.Set */) {\n        return left.value.isEqual(right.value);\n    }\n    if (left.type === 1 /* MutationType.Patch */) {\n        return (left.data.isEqual(right.data) &&\n            left.fieldMask.isEqual(right.fieldMask));\n    }\n    return true;\n}\n/**\n * A mutation that creates or replaces the document at the given key with the\n * object value contents.\n */\nclass SetMutation extends Mutation {\n    constructor(key, value, precondition, fieldTransforms = []) {\n        super();\n        this.key = key;\n        this.value = value;\n        this.precondition = precondition;\n        this.fieldTransforms = fieldTransforms;\n        this.type = 0 /* MutationType.Set */;\n    }\n    getFieldMask() {\n        return null;\n    }\n}\nfunction setMutationApplyToRemoteDocument(mutation, document, mutationResult) {\n    // Unlike setMutationApplyToLocalView, if we're applying a mutation to a\n    // remote document the server has accepted the mutation so the precondition\n    // must have held.\n    const newData = mutation.value.clone();\n    const transformResults = serverTransformResults(mutation.fieldTransforms, document, mutationResult.transformResults);\n    newData.setAll(transformResults);\n    document\n        .convertToFoundDocument(mutationResult.version, newData)\n        .setHasCommittedMutations();\n}\nfunction setMutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\n        // The mutation failed to apply (e.g. a document ID created with add()\n        // caused a name collision).\n        return previousMask;\n    }\n    const newData = mutation.value.clone();\n    const transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document);\n    newData.setAll(transformResults);\n    document\n        .convertToFoundDocument(document.version, newData)\n        .setHasLocalMutations();\n    return null; // SetMutation overwrites all fields.\n}\n/**\n * A mutation that modifies fields of the document at the given key with the\n * given values. The values are applied through a field mask:\n *\n *  * When a field is in both the mask and the values, the corresponding field\n *    is updated.\n *  * When a field is in neither the mask nor the values, the corresponding\n *    field is unmodified.\n *  * When a field is in the mask but not in the values, the corresponding field\n *    is deleted.\n *  * When a field is not in the mask but is in the values, the values map is\n *    ignored.\n */\nclass PatchMutation extends Mutation {\n    constructor(key, data, fieldMask, precondition, fieldTransforms = []) {\n        super();\n        this.key = key;\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.precondition = precondition;\n        this.fieldTransforms = fieldTransforms;\n        this.type = 1 /* MutationType.Patch */;\n    }\n    getFieldMask() {\n        return this.fieldMask;\n    }\n}\nfunction patchMutationApplyToRemoteDocument(mutation, document, mutationResult) {\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\n        // Since the mutation was not rejected, we know that the precondition\n        // matched on the backend. We therefore must not have the expected version\n        // of the document in our cache and convert to an UnknownDocument with a\n        // known updateTime.\n        document.convertToUnknownDocument(mutationResult.version);\n        return;\n    }\n    const transformResults = serverTransformResults(mutation.fieldTransforms, document, mutationResult.transformResults);\n    const newData = document.data;\n    newData.setAll(getPatch(mutation));\n    newData.setAll(transformResults);\n    document\n        .convertToFoundDocument(mutationResult.version, newData)\n        .setHasCommittedMutations();\n}\nfunction patchMutationApplyToLocalView(mutation, document, previousMask, localWriteTime) {\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\n        return previousMask;\n    }\n    const transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document);\n    const newData = document.data;\n    newData.setAll(getPatch(mutation));\n    newData.setAll(transformResults);\n    document\n        .convertToFoundDocument(document.version, newData)\n        .setHasLocalMutations();\n    if (previousMask === null) {\n        return null;\n    }\n    return previousMask\n        .unionWith(mutation.fieldMask.fields)\n        .unionWith(mutation.fieldTransforms.map(transform => transform.field));\n}\n/**\n * Returns a FieldPath/Value map with the content of the PatchMutation.\n */\nfunction getPatch(mutation) {\n    const result = new Map();\n    mutation.fieldMask.fields.forEach(fieldPath => {\n        if (!fieldPath.isEmpty()) {\n            const newValue = mutation.data.field(fieldPath);\n            result.set(fieldPath, newValue);\n        }\n    });\n    return result;\n}\n/**\n * Creates a list of \"transform results\" (a transform result is a field value\n * representing the result of applying a transform) for use after a mutation\n * containing transforms has been acknowledged by the server.\n *\n * @param fieldTransforms - The field transforms to apply the result to.\n * @param mutableDocument - The current state of the document after applying all\n * previous mutations.\n * @param serverTransformResults - The transform results received by the server.\n * @returns The transform results list.\n */\nfunction serverTransformResults(fieldTransforms, mutableDocument, serverTransformResults) {\n    const transformResults = new Map();\n    hardAssert(fieldTransforms.length === serverTransformResults.length);\n    for (let i = 0; i < serverTransformResults.length; i++) {\n        const fieldTransform = fieldTransforms[i];\n        const transform = fieldTransform.transform;\n        const previousValue = mutableDocument.data.field(fieldTransform.field);\n        transformResults.set(fieldTransform.field, applyTransformOperationToRemoteDocument(transform, previousValue, serverTransformResults[i]));\n    }\n    return transformResults;\n}\n/**\n * Creates a list of \"transform results\" (a transform result is a field value\n * representing the result of applying a transform) for use when applying a\n * transform locally.\n *\n * @param fieldTransforms - The field transforms to apply the result to.\n * @param localWriteTime - The local time of the mutation (used to\n *     generate ServerTimestampValues).\n * @param mutableDocument - The document to apply transforms on.\n * @returns The transform results list.\n */\nfunction localTransformResults(fieldTransforms, localWriteTime, mutableDocument) {\n    const transformResults = new Map();\n    for (const fieldTransform of fieldTransforms) {\n        const transform = fieldTransform.transform;\n        const previousValue = mutableDocument.data.field(fieldTransform.field);\n        transformResults.set(fieldTransform.field, applyTransformOperationToLocalView(transform, previousValue, localWriteTime));\n    }\n    return transformResults;\n}\n/** A mutation that deletes the document at the given key. */\nclass DeleteMutation extends Mutation {\n    constructor(key, precondition) {\n        super();\n        this.key = key;\n        this.precondition = precondition;\n        this.type = 2 /* MutationType.Delete */;\n        this.fieldTransforms = [];\n    }\n    getFieldMask() {\n        return null;\n    }\n}\nfunction deleteMutationApplyToRemoteDocument(mutation, document, mutationResult) {\n    // Unlike applyToLocalView, if we're applying a mutation to a remote\n    // document the server has accepted the mutation so the precondition must\n    // have held.\n    document\n        .convertToNoDocument(mutationResult.version)\n        .setHasCommittedMutations();\n}\nfunction deleteMutationApplyToLocalView(mutation, document, previousMask) {\n    if (preconditionIsValidForDocument(mutation.precondition, document)) {\n        document.convertToNoDocument(document.version).setHasLocalMutations();\n        return null;\n    }\n    return previousMask;\n}\n/**\n * A mutation that verifies the existence of the document at the given key with\n * the provided precondition.\n *\n * The `verify` operation is only used in Transactions, and this class serves\n * primarily to facilitate serialization into protos.\n */\nclass VerifyMutation extends Mutation {\n    constructor(key, precondition) {\n        super();\n        this.key = key;\n        this.precondition = precondition;\n        this.type = 3 /* MutationType.Verify */;\n        this.fieldTransforms = [];\n    }\n    getFieldMask() {\n        return null;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A batch of mutations that will be sent as one unit to the backend.\n */\nclass MutationBatch {\n    /**\n     * @param batchId - The unique ID of this mutation batch.\n     * @param localWriteTime - The original write time of this mutation.\n     * @param baseMutations - Mutations that are used to populate the base\n     * values when this mutation is applied locally. This can be used to locally\n     * overwrite values that are persisted in the remote document cache. Base\n     * mutations are never sent to the backend.\n     * @param mutations - The user-provided mutations in this mutation batch.\n     * User-provided mutations are applied both locally and remotely on the\n     * backend.\n     */\n    constructor(batchId, localWriteTime, baseMutations, mutations) {\n        this.batchId = batchId;\n        this.localWriteTime = localWriteTime;\n        this.baseMutations = baseMutations;\n        this.mutations = mutations;\n    }\n    /**\n     * Applies all the mutations in this MutationBatch to the specified document\n     * to compute the state of the remote document\n     *\n     * @param document - The document to apply mutations to.\n     * @param batchResult - The result of applying the MutationBatch to the\n     * backend.\n     */\n    applyToRemoteDocument(document, batchResult) {\n        const mutationResults = batchResult.mutationResults;\n        for (let i = 0; i < this.mutations.length; i++) {\n            const mutation = this.mutations[i];\n            if (mutation.key.isEqual(document.key)) {\n                const mutationResult = mutationResults[i];\n                mutationApplyToRemoteDocument(mutation, document, mutationResult);\n            }\n        }\n    }\n    /**\n     * Computes the local view of a document given all the mutations in this\n     * batch.\n     *\n     * @param document - The document to apply mutations to.\n     * @param mutatedFields - Fields that have been updated before applying this mutation batch.\n     * @returns A `FieldMask` representing all the fields that are mutated.\n     */\n    applyToLocalView(document, mutatedFields) {\n        // First, apply the base state. This allows us to apply non-idempotent\n        // transform against a consistent set of values.\n        for (const mutation of this.baseMutations) {\n            if (mutation.key.isEqual(document.key)) {\n                mutatedFields = mutationApplyToLocalView(mutation, document, mutatedFields, this.localWriteTime);\n            }\n        }\n        // Second, apply all user-provided mutations.\n        for (const mutation of this.mutations) {\n            if (mutation.key.isEqual(document.key)) {\n                mutatedFields = mutationApplyToLocalView(mutation, document, mutatedFields, this.localWriteTime);\n            }\n        }\n        return mutatedFields;\n    }\n    /**\n     * Computes the local view for all provided documents given the mutations in\n     * this batch. Returns a `DocumentKey` to `Mutation` map which can be used to\n     * replace all the mutation applications.\n     */\n    applyToLocalDocumentSet(documentMap, documentsWithoutRemoteVersion) {\n        // TODO(mrschmidt): This implementation is O(n^2). If we apply the mutations\n        // directly (as done in `applyToLocalView()`), we can reduce the complexity\n        // to O(n).\n        const overlays = newMutationMap();\n        this.mutations.forEach(m => {\n            const overlayedDocument = documentMap.get(m.key);\n            // TODO(mutabledocuments): This method should take a MutableDocumentMap\n            // and we should remove this cast.\n            const mutableDocument = overlayedDocument.overlayedDocument;\n            let mutatedFields = this.applyToLocalView(mutableDocument, overlayedDocument.mutatedFields);\n            // Set mutatedFields to null if the document is only from local mutations.\n            // This creates a Set or Delete mutation, instead of trying to create a\n            // patch mutation as the overlay.\n            mutatedFields = documentsWithoutRemoteVersion.has(m.key)\n                ? null\n                : mutatedFields;\n            const overlay = calculateOverlayMutation(mutableDocument, mutatedFields);\n            if (overlay !== null) {\n                overlays.set(m.key, overlay);\n            }\n            if (!mutableDocument.isValidDocument()) {\n                mutableDocument.convertToNoDocument(SnapshotVersion.min());\n            }\n        });\n        return overlays;\n    }\n    keys() {\n        return this.mutations.reduce((keys, m) => keys.add(m.key), documentKeySet());\n    }\n    isEqual(other) {\n        return (this.batchId === other.batchId &&\n            arrayEquals(this.mutations, other.mutations, (l, r) => mutationEquals(l, r)) &&\n            arrayEquals(this.baseMutations, other.baseMutations, (l, r) => mutationEquals(l, r)));\n    }\n}\n/** The result of applying a mutation batch to the backend. */\nclass MutationBatchResult {\n    constructor(batch, commitVersion, mutationResults, \n    /**\n     * A pre-computed mapping from each mutated document to the resulting\n     * version.\n     */\n    docVersions) {\n        this.batch = batch;\n        this.commitVersion = commitVersion;\n        this.mutationResults = mutationResults;\n        this.docVersions = docVersions;\n    }\n    /**\n     * Creates a new MutationBatchResult for the given batch and results. There\n     * must be one result for each mutation in the batch. This static factory\n     * caches a document=&gt;version mapping (docVersions).\n     */\n    static from(batch, commitVersion, results) {\n        hardAssert(batch.mutations.length === results.length);\n        let versionMap = documentVersionMap();\n        const mutations = batch.mutations;\n        for (let i = 0; i < mutations.length; i++) {\n            versionMap = versionMap.insert(mutations[i].key, results[i].version);\n        }\n        return new MutationBatchResult(batch, commitVersion, results, versionMap);\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Representation of an overlay computed by Firestore.\n *\n * Holds information about a mutation and the largest batch id in Firestore when\n * the mutation was created.\n */\nclass Overlay {\n    constructor(largestBatchId, mutation) {\n        this.largestBatchId = largestBatchId;\n        this.mutation = mutation;\n    }\n    getKey() {\n        return this.mutation.key;\n    }\n    isEqual(other) {\n        return other !== null && this.mutation === other.mutation;\n    }\n    toString() {\n        return `Overlay{\n      largestBatchId: ${this.largestBatchId},\n      mutation: ${this.mutation.toString()}\n    }`;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass ExistenceFilter {\n    constructor(count, unchangedNames) {\n        this.count = count;\n        this.unchangedNames = unchangedNames;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Error Codes describing the different ways GRPC can fail. These are copied\n * directly from GRPC's sources here:\n *\n * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n *\n * Important! The names of these identifiers matter because the string forms\n * are used for reverse lookups from the webchannel stream. Do NOT change the\n * names of these identifiers or change this into a const enum.\n */\nvar RpcCode;\n(function (RpcCode) {\n    RpcCode[RpcCode[\"OK\"] = 0] = \"OK\";\n    RpcCode[RpcCode[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    RpcCode[RpcCode[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    RpcCode[RpcCode[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    RpcCode[RpcCode[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    RpcCode[RpcCode[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    RpcCode[RpcCode[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    RpcCode[RpcCode[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    RpcCode[RpcCode[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n    RpcCode[RpcCode[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    RpcCode[RpcCode[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    RpcCode[RpcCode[\"ABORTED\"] = 10] = \"ABORTED\";\n    RpcCode[RpcCode[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    RpcCode[RpcCode[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    RpcCode[RpcCode[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    RpcCode[RpcCode[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    RpcCode[RpcCode[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n})(RpcCode || (RpcCode = {}));\n/**\n * Determines whether an error code represents a permanent error when received\n * in response to a non-write operation.\n *\n * See isPermanentWriteError for classifying write errors.\n */\nfunction isPermanentError(code) {\n    switch (code) {\n        case Code.OK:\n            return fail();\n        case Code.CANCELLED:\n        case Code.UNKNOWN:\n        case Code.DEADLINE_EXCEEDED:\n        case Code.RESOURCE_EXHAUSTED:\n        case Code.INTERNAL:\n        case Code.UNAVAILABLE:\n        // Unauthenticated means something went wrong with our token and we need\n        // to retry with new credentials which will happen automatically.\n        case Code.UNAUTHENTICATED:\n            return false;\n        case Code.INVALID_ARGUMENT:\n        case Code.NOT_FOUND:\n        case Code.ALREADY_EXISTS:\n        case Code.PERMISSION_DENIED:\n        case Code.FAILED_PRECONDITION:\n        // Aborted might be retried in some scenarios, but that is dependent on\n        // the context and should handled individually by the calling code.\n        // See https://cloud.google.com/apis/design/errors.\n        case Code.ABORTED:\n        case Code.OUT_OF_RANGE:\n        case Code.UNIMPLEMENTED:\n        case Code.DATA_LOSS:\n            return true;\n        default:\n            return fail();\n    }\n}\n/**\n * Determines whether an error code represents a permanent error when received\n * in response to a write operation.\n *\n * Write operations must be handled specially because as of b/119437764, ABORTED\n * errors on the write stream should be retried too (even though ABORTED errors\n * are not generally retryable).\n *\n * Note that during the initial handshake on the write stream an ABORTED error\n * signals that we should discard our stream token (i.e. it is permanent). This\n * means a handshake error should be classified with isPermanentError, above.\n */\nfunction isPermanentWriteError(code) {\n    return isPermanentError(code) && code !== Code.ABORTED;\n}\n/**\n * Maps an error Code from GRPC status code number, like 0, 1, or 14. These\n * are not the same as HTTP status codes.\n *\n * @returns The Code equivalent to the given GRPC status code. Fails if there\n *     is no match.\n */\nfunction mapCodeFromRpcCode(code) {\n    if (code === undefined) {\n        // This shouldn't normally happen, but in certain error cases (like trying\n        // to send invalid proto messages) we may get an error with no GRPC code.\n        logError('GRPC error has no .code');\n        return Code.UNKNOWN;\n    }\n    switch (code) {\n        case RpcCode.OK:\n            return Code.OK;\n        case RpcCode.CANCELLED:\n            return Code.CANCELLED;\n        case RpcCode.UNKNOWN:\n            return Code.UNKNOWN;\n        case RpcCode.DEADLINE_EXCEEDED:\n            return Code.DEADLINE_EXCEEDED;\n        case RpcCode.RESOURCE_EXHAUSTED:\n            return Code.RESOURCE_EXHAUSTED;\n        case RpcCode.INTERNAL:\n            return Code.INTERNAL;\n        case RpcCode.UNAVAILABLE:\n            return Code.UNAVAILABLE;\n        case RpcCode.UNAUTHENTICATED:\n            return Code.UNAUTHENTICATED;\n        case RpcCode.INVALID_ARGUMENT:\n            return Code.INVALID_ARGUMENT;\n        case RpcCode.NOT_FOUND:\n            return Code.NOT_FOUND;\n        case RpcCode.ALREADY_EXISTS:\n            return Code.ALREADY_EXISTS;\n        case RpcCode.PERMISSION_DENIED:\n            return Code.PERMISSION_DENIED;\n        case RpcCode.FAILED_PRECONDITION:\n            return Code.FAILED_PRECONDITION;\n        case RpcCode.ABORTED:\n            return Code.ABORTED;\n        case RpcCode.OUT_OF_RANGE:\n            return Code.OUT_OF_RANGE;\n        case RpcCode.UNIMPLEMENTED:\n            return Code.UNIMPLEMENTED;\n        case RpcCode.DATA_LOSS:\n            return Code.DATA_LOSS;\n        default:\n            return fail();\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An error encountered while decoding base64 string.\n */\nclass Base64DecodeError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'Base64DecodeError';\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The global, singleton instance of TestingHooksSpi.\n *\n * This variable will be `null` in all cases _except_ when running from\n * integration tests that have registered callbacks to be notified of events\n * that happen during the test execution.\n */\nlet testingHooksSpi = null;\n/**\n * Sets the value of the `testingHooksSpi` object.\n * @param instance the instance to set.\n */\nfunction setTestingHooksSpi(instance) {\n    if (testingHooksSpi) {\n        throw new Error('a TestingHooksSpi instance is already set');\n    }\n    testingHooksSpi = instance;\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst MAX_64_BIT_UNSIGNED_INTEGER = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer([0xffffffff, 0xffffffff], 0);\n// Hash a string using md5 hashing algorithm.\nfunction getMd5HashValue(value) {\n    const encodedValue = newTextEncoder().encode(value);\n    const md5 = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Md5();\n    md5.update(encodedValue);\n    return new Uint8Array(md5.digest());\n}\n// Interpret the 16 bytes array as two 64-bit unsigned integers, encoded using\n// 2’s complement using little endian.\nfunction get64BitUints(Bytes) {\n    const dataView = new DataView(Bytes.buffer);\n    const chunk1 = dataView.getUint32(0, /* littleEndian= */ true);\n    const chunk2 = dataView.getUint32(4, /* littleEndian= */ true);\n    const chunk3 = dataView.getUint32(8, /* littleEndian= */ true);\n    const chunk4 = dataView.getUint32(12, /* littleEndian= */ true);\n    const integer1 = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer([chunk1, chunk2], 0);\n    const integer2 = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer([chunk3, chunk4], 0);\n    return [integer1, integer2];\n}\nclass BloomFilter {\n    constructor(bitmap, padding, hashCount) {\n        this.bitmap = bitmap;\n        this.padding = padding;\n        this.hashCount = hashCount;\n        if (padding < 0 || padding >= 8) {\n            throw new BloomFilterError(`Invalid padding: ${padding}`);\n        }\n        if (hashCount < 0) {\n            throw new BloomFilterError(`Invalid hash count: ${hashCount}`);\n        }\n        if (bitmap.length > 0 && this.hashCount === 0) {\n            // Only empty bloom filter can have 0 hash count.\n            throw new BloomFilterError(`Invalid hash count: ${hashCount}`);\n        }\n        if (bitmap.length === 0 && padding !== 0) {\n            // Empty bloom filter should have 0 padding.\n            throw new BloomFilterError(`Invalid padding when bitmap length is 0: ${padding}`);\n        }\n        this.bitCount = bitmap.length * 8 - padding;\n        // Set the bit count in Integer to avoid repetition in mightContain().\n        this.bitCountInInteger = _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer.fromNumber(this.bitCount);\n    }\n    // Calculate the ith hash value based on the hashed 64bit integers,\n    // and calculate its corresponding bit index in the bitmap to be checked.\n    getBitIndex(num1, num2, hashIndex) {\n        // Calculate hashed value h(i) = h1 + (i * h2).\n        let hashValue = num1.add(num2.multiply(_firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer.fromNumber(hashIndex)));\n        // Wrap if hash value overflow 64bit.\n        if (hashValue.compare(MAX_64_BIT_UNSIGNED_INTEGER) === 1) {\n            hashValue = new _firebase_webchannel_wrapper_bloom_blob__WEBPACK_IMPORTED_MODULE_6__.Integer([hashValue.getBits(0), hashValue.getBits(1)], 0);\n        }\n        return hashValue.modulo(this.bitCountInInteger).toNumber();\n    }\n    // Return whether the bit on the given index in the bitmap is set to 1.\n    isBitSet(index) {\n        // To retrieve bit n, calculate: (bitmap[n / 8] & (0x01 << (n % 8))).\n        const byte = this.bitmap[Math.floor(index / 8)];\n        const offset = index % 8;\n        return (byte & (0x01 << offset)) !== 0;\n    }\n    mightContain(value) {\n        // Empty bitmap should always return false on membership check.\n        if (this.bitCount === 0) {\n            return false;\n        }\n        const md5HashedValue = getMd5HashValue(value);\n        const [hash1, hash2] = get64BitUints(md5HashedValue);\n        for (let i = 0; i < this.hashCount; i++) {\n            const index = this.getBitIndex(hash1, hash2, i);\n            if (!this.isBitSet(index)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** Create bloom filter for testing purposes only. */\n    static create(bitCount, hashCount, contains) {\n        const padding = bitCount % 8 === 0 ? 0 : 8 - (bitCount % 8);\n        const bitmap = new Uint8Array(Math.ceil(bitCount / 8));\n        const bloomFilter = new BloomFilter(bitmap, padding, hashCount);\n        contains.forEach(item => bloomFilter.insert(item));\n        return bloomFilter;\n    }\n    insert(value) {\n        if (this.bitCount === 0) {\n            return;\n        }\n        const md5HashedValue = getMd5HashValue(value);\n        const [hash1, hash2] = get64BitUints(md5HashedValue);\n        for (let i = 0; i < this.hashCount; i++) {\n            const index = this.getBitIndex(hash1, hash2, i);\n            this.setBit(index);\n        }\n    }\n    setBit(index) {\n        const indexOfByte = Math.floor(index / 8);\n        const offset = index % 8;\n        this.bitmap[indexOfByte] |= 0x01 << offset;\n    }\n}\nclass BloomFilterError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'BloomFilterError';\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An event from the RemoteStore. It is split into targetChanges (changes to the\n * state or the set of documents in our watched targets) and documentUpdates\n * (changes to the actual documents).\n */\nclass RemoteEvent {\n    constructor(\n    /**\n     * The snapshot version this event brings us up to, or MIN if not set.\n     */\n    snapshotVersion, \n    /**\n     * A map from target to changes to the target. See TargetChange.\n     */\n    targetChanges, \n    /**\n     * A map of targets that is known to be inconsistent, and the purpose for\n     * re-listening. Listens for these targets should be re-established without\n     * resume tokens.\n     */\n    targetMismatches, \n    /**\n     * A set of which documents have changed or been deleted, along with the\n     * doc's new values (if not deleted).\n     */\n    documentUpdates, \n    /**\n     * A set of which document updates are due only to limbo resolution targets.\n     */\n    resolvedLimboDocuments) {\n        this.snapshotVersion = snapshotVersion;\n        this.targetChanges = targetChanges;\n        this.targetMismatches = targetMismatches;\n        this.documentUpdates = documentUpdates;\n        this.resolvedLimboDocuments = resolvedLimboDocuments;\n    }\n    /**\n     * HACK: Views require RemoteEvents in order to determine whether the view is\n     * CURRENT, but secondary tabs don't receive remote events. So this method is\n     * used to create a synthesized RemoteEvent that can be used to apply a\n     * CURRENT status change to a View, for queries executed in a different tab.\n     */\n    // PORTING NOTE: Multi-tab only\n    static createSynthesizedRemoteEventForCurrentChange(targetId, current, resumeToken) {\n        const targetChanges = new Map();\n        targetChanges.set(targetId, TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current, resumeToken));\n        return new RemoteEvent(SnapshotVersion.min(), targetChanges, new SortedMap(primitiveComparator), mutableDocumentMap(), documentKeySet());\n    }\n}\n/**\n * A TargetChange specifies the set of changes for a specific target as part of\n * a RemoteEvent. These changes track which documents are added, modified or\n * removed, as well as the target's resume token and whether the target is\n * marked CURRENT.\n * The actual changes *to* documents are not part of the TargetChange since\n * documents may be part of multiple targets.\n */\nclass TargetChange {\n    constructor(\n    /**\n     * An opaque, server-assigned token that allows watching a query to be resumed\n     * after disconnecting without retransmitting all the data that matches the\n     * query. The resume token essentially identifies a point in time from which\n     * the server should resume sending results.\n     */\n    resumeToken, \n    /**\n     * The \"current\" (synced) status of this target. Note that \"current\"\n     * has special meaning in the RPC protocol that implies that a target is\n     * both up-to-date and consistent with the rest of the watch stream.\n     */\n    current, \n    /**\n     * The set of documents that were newly assigned to this target as part of\n     * this remote event.\n     */\n    addedDocuments, \n    /**\n     * The set of documents that were already assigned to this target but received\n     * an update during this remote event.\n     */\n    modifiedDocuments, \n    /**\n     * The set of documents that were removed from this target as part of this\n     * remote event.\n     */\n    removedDocuments) {\n        this.resumeToken = resumeToken;\n        this.current = current;\n        this.addedDocuments = addedDocuments;\n        this.modifiedDocuments = modifiedDocuments;\n        this.removedDocuments = removedDocuments;\n    }\n    /**\n     * This method is used to create a synthesized TargetChanges that can be used to\n     * apply a CURRENT status change to a View (for queries executed in a different\n     * tab) or for new queries (to raise snapshots with correct CURRENT status).\n     */\n    static createSynthesizedTargetChangeForCurrentChange(targetId, current, resumeToken) {\n        return new TargetChange(resumeToken, current, documentKeySet(), documentKeySet(), documentKeySet());\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a changed document and a list of target ids to which this change\n * applies.\n *\n * If document has been deleted NoDocument will be provided.\n */\nclass DocumentWatchChange {\n    constructor(\n    /** The new document applies to all of these targets. */\n    updatedTargetIds, \n    /** The new document is removed from all of these targets. */\n    removedTargetIds, \n    /** The key of the document for this change. */\n    key, \n    /**\n     * The new document or NoDocument if it was deleted. Is null if the\n     * document went out of view without the server sending a new document.\n     */\n    newDoc) {\n        this.updatedTargetIds = updatedTargetIds;\n        this.removedTargetIds = removedTargetIds;\n        this.key = key;\n        this.newDoc = newDoc;\n    }\n}\nclass ExistenceFilterChange {\n    constructor(targetId, existenceFilter) {\n        this.targetId = targetId;\n        this.existenceFilter = existenceFilter;\n    }\n}\nclass WatchTargetChange {\n    constructor(\n    /** What kind of change occurred to the watch target. */\n    state, \n    /** The target IDs that were added/removed/set. */\n    targetIds, \n    /**\n     * An opaque, server-assigned token that allows watching a target to be\n     * resumed after disconnecting without retransmitting all the data that\n     * matches the target. The resume token essentially identifies a point in\n     * time from which the server should resume sending results.\n     */\n    resumeToken = ByteString.EMPTY_BYTE_STRING, \n    /** An RPC error indicating why the watch failed. */\n    cause = null) {\n        this.state = state;\n        this.targetIds = targetIds;\n        this.resumeToken = resumeToken;\n        this.cause = cause;\n    }\n}\n/** Tracks the internal state of a Watch target. */\nclass TargetState {\n    constructor() {\n        /**\n         * The number of pending responses (adds or removes) that we are waiting on.\n         * We only consider targets active that have no pending responses.\n         */\n        this.pendingResponses = 0;\n        /**\n         * Keeps track of the document changes since the last raised snapshot.\n         *\n         * These changes are continuously updated as we receive document updates and\n         * always reflect the current set of changes against the last issued snapshot.\n         */\n        this.documentChanges = snapshotChangesMap();\n        /** See public getters for explanations of these fields. */\n        this._resumeToken = ByteString.EMPTY_BYTE_STRING;\n        this._current = false;\n        /**\n         * Whether this target state should be included in the next snapshot. We\n         * initialize to true so that newly-added targets are included in the next\n         * RemoteEvent.\n         */\n        this._hasPendingChanges = true;\n    }\n    /**\n     * Whether this target has been marked 'current'.\n     *\n     * 'Current' has special meaning in the RPC protocol: It implies that the\n     * Watch backend has sent us all changes up to the point at which the target\n     * was added and that the target is consistent with the rest of the watch\n     * stream.\n     */\n    get current() {\n        return this._current;\n    }\n    /** The last resume token sent to us for this target. */\n    get resumeToken() {\n        return this._resumeToken;\n    }\n    /** Whether this target has pending target adds or target removes. */\n    get isPending() {\n        return this.pendingResponses !== 0;\n    }\n    /** Whether we have modified any state that should trigger a snapshot. */\n    get hasPendingChanges() {\n        return this._hasPendingChanges;\n    }\n    /**\n     * Applies the resume token to the TargetChange, but only when it has a new\n     * value. Empty resumeTokens are discarded.\n     */\n    updateResumeToken(resumeToken) {\n        if (resumeToken.approximateByteSize() > 0) {\n            this._hasPendingChanges = true;\n            this._resumeToken = resumeToken;\n        }\n    }\n    /**\n     * Creates a target change from the current set of changes.\n     *\n     * To reset the document changes after raising this snapshot, call\n     * `clearPendingChanges()`.\n     */\n    toTargetChange() {\n        let addedDocuments = documentKeySet();\n        let modifiedDocuments = documentKeySet();\n        let removedDocuments = documentKeySet();\n        this.documentChanges.forEach((key, changeType) => {\n            switch (changeType) {\n                case 0 /* ChangeType.Added */:\n                    addedDocuments = addedDocuments.add(key);\n                    break;\n                case 2 /* ChangeType.Modified */:\n                    modifiedDocuments = modifiedDocuments.add(key);\n                    break;\n                case 1 /* ChangeType.Removed */:\n                    removedDocuments = removedDocuments.add(key);\n                    break;\n                default:\n                    fail();\n            }\n        });\n        return new TargetChange(this._resumeToken, this._current, addedDocuments, modifiedDocuments, removedDocuments);\n    }\n    /**\n     * Resets the document changes and sets `hasPendingChanges` to false.\n     */\n    clearPendingChanges() {\n        this._hasPendingChanges = false;\n        this.documentChanges = snapshotChangesMap();\n    }\n    addDocumentChange(key, changeType) {\n        this._hasPendingChanges = true;\n        this.documentChanges = this.documentChanges.insert(key, changeType);\n    }\n    removeDocumentChange(key) {\n        this._hasPendingChanges = true;\n        this.documentChanges = this.documentChanges.remove(key);\n    }\n    recordPendingTargetRequest() {\n        this.pendingResponses += 1;\n    }\n    recordTargetResponse() {\n        this.pendingResponses -= 1;\n        hardAssert(this.pendingResponses >= 0);\n    }\n    markCurrent() {\n        this._hasPendingChanges = true;\n        this._current = true;\n    }\n}\nconst LOG_TAG$g = 'WatchChangeAggregator';\n/**\n * A helper class to accumulate watch changes into a RemoteEvent.\n */\nclass WatchChangeAggregator {\n    constructor(metadataProvider) {\n        this.metadataProvider = metadataProvider;\n        /** The internal state of all tracked targets. */\n        this.targetStates = new Map();\n        /** Keeps track of the documents to update since the last raised snapshot. */\n        this.pendingDocumentUpdates = mutableDocumentMap();\n        this.pendingDocumentUpdatesByTarget = documentTargetMap();\n        /** A mapping of document keys to their set of target IDs. */\n        this.pendingDocumentTargetMapping = documentTargetMap();\n        /**\n         * A map of targets with existence filter mismatches. These targets are\n         * known to be inconsistent and their listens needs to be re-established by\n         * RemoteStore.\n         */\n        this.pendingTargetResets = new SortedMap(primitiveComparator);\n    }\n    /**\n     * Processes and adds the DocumentWatchChange to the current set of changes.\n     */\n    handleDocumentChange(docChange) {\n        for (const targetId of docChange.updatedTargetIds) {\n            if (docChange.newDoc && docChange.newDoc.isFoundDocument()) {\n                this.addDocumentToTarget(targetId, docChange.newDoc);\n            }\n            else {\n                this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);\n            }\n        }\n        for (const targetId of docChange.removedTargetIds) {\n            this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);\n        }\n    }\n    /** Processes and adds the WatchTargetChange to the current set of changes. */\n    handleTargetChange(targetChange) {\n        this.forEachTarget(targetChange, targetId => {\n            const targetState = this.ensureTargetState(targetId);\n            switch (targetChange.state) {\n                case 0 /* WatchTargetChangeState.NoChange */:\n                    if (this.isActiveTarget(targetId)) {\n                        targetState.updateResumeToken(targetChange.resumeToken);\n                    }\n                    break;\n                case 1 /* WatchTargetChangeState.Added */:\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    targetState.recordTargetResponse();\n                    if (!targetState.isPending) {\n                        // We have a freshly added target, so we need to reset any state\n                        // that we had previously. This can happen e.g. when remove and add\n                        // back a target for existence filter mismatches.\n                        targetState.clearPendingChanges();\n                    }\n                    targetState.updateResumeToken(targetChange.resumeToken);\n                    break;\n                case 2 /* WatchTargetChangeState.Removed */:\n                    // We need to keep track of removed targets to we can post-filter and\n                    // remove any target changes.\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    targetState.recordTargetResponse();\n                    if (!targetState.isPending) {\n                        this.removeTarget(targetId);\n                    }\n                    break;\n                case 3 /* WatchTargetChangeState.Current */:\n                    if (this.isActiveTarget(targetId)) {\n                        targetState.markCurrent();\n                        targetState.updateResumeToken(targetChange.resumeToken);\n                    }\n                    break;\n                case 4 /* WatchTargetChangeState.Reset */:\n                    if (this.isActiveTarget(targetId)) {\n                        // Reset the target and synthesizes removes for all existing\n                        // documents. The backend will re-add any documents that still\n                        // match the target before it sends the next global snapshot.\n                        this.resetTarget(targetId);\n                        targetState.updateResumeToken(targetChange.resumeToken);\n                    }\n                    break;\n                default:\n                    fail();\n            }\n        });\n    }\n    /**\n     * Iterates over all targetIds that the watch change applies to: either the\n     * targetIds explicitly listed in the change or the targetIds of all currently\n     * active targets.\n     */\n    forEachTarget(targetChange, fn) {\n        if (targetChange.targetIds.length > 0) {\n            targetChange.targetIds.forEach(fn);\n        }\n        else {\n            this.targetStates.forEach((_, targetId) => {\n                if (this.isActiveTarget(targetId)) {\n                    fn(targetId);\n                }\n            });\n        }\n    }\n    /**\n     * Handles existence filters and synthesizes deletes for filter mismatches.\n     * Targets that are invalidated by filter mismatches are added to\n     * `pendingTargetResets`.\n     */\n    handleExistenceFilter(watchChange) {\n        const targetId = watchChange.targetId;\n        const expectedCount = watchChange.existenceFilter.count;\n        const targetData = this.targetDataForActiveTarget(targetId);\n        if (targetData) {\n            const target = targetData.target;\n            if (targetIsDocumentTarget(target)) {\n                if (expectedCount === 0) {\n                    // The existence filter told us the document does not exist. We deduce\n                    // that this document does not exist and apply a deleted document to\n                    // our updates. Without applying this deleted document there might be\n                    // another query that will raise this document as part of a snapshot\n                    // until it is resolved, essentially exposing inconsistency between\n                    // queries.\n                    const key = new DocumentKey(target.path);\n                    this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, SnapshotVersion.min()));\n                }\n                else {\n                    hardAssert(expectedCount === 1);\n                }\n            }\n            else {\n                const currentSize = this.getCurrentDocumentCountForTarget(targetId);\n                // Existence filter mismatch. Mark the documents as being in limbo, and\n                // raise a snapshot with `isFromCache:true`.\n                if (currentSize !== expectedCount) {\n                    // Apply bloom filter to identify and mark removed documents.\n                    const bloomFilter = this.parseBloomFilter(watchChange);\n                    const status = bloomFilter\n                        ? this.applyBloomFilter(bloomFilter, watchChange, currentSize)\n                        : 1 /* BloomFilterApplicationStatus.Skipped */;\n                    if (status !== 0 /* BloomFilterApplicationStatus.Success */) {\n                        // If bloom filter application fails, we reset the mapping and\n                        // trigger re-run of the query.\n                        this.resetTarget(targetId);\n                        const purpose = status === 2 /* BloomFilterApplicationStatus.FalsePositive */\n                            ? \"TargetPurposeExistenceFilterMismatchBloom\" /* TargetPurpose.ExistenceFilterMismatchBloom */\n                            : \"TargetPurposeExistenceFilterMismatch\" /* TargetPurpose.ExistenceFilterMismatch */;\n                        this.pendingTargetResets = this.pendingTargetResets.insert(targetId, purpose);\n                    }\n                    testingHooksSpi === null || testingHooksSpi === void 0 ? void 0 : testingHooksSpi.notifyOnExistenceFilterMismatch(createExistenceFilterMismatchInfoForTestingHooks(currentSize, watchChange.existenceFilter, this.metadataProvider.getDatabaseId(), bloomFilter, status));\n                }\n            }\n        }\n    }\n    /**\n     * Parse the bloom filter from the \"unchanged_names\" field of an existence\n     * filter.\n     */\n    parseBloomFilter(watchChange) {\n        const unchangedNames = watchChange.existenceFilter.unchangedNames;\n        if (!unchangedNames || !unchangedNames.bits) {\n            return null;\n        }\n        const { bits: { bitmap = '', padding = 0 }, hashCount = 0 } = unchangedNames;\n        let normalizedBitmap;\n        try {\n            normalizedBitmap = normalizeByteString(bitmap).toUint8Array();\n        }\n        catch (err) {\n            if (err instanceof Base64DecodeError) {\n                logWarn('Decoding the base64 bloom filter in existence filter failed (' +\n                    err.message +\n                    '); ignoring the bloom filter and falling back to full re-query.');\n                return null;\n            }\n            else {\n                throw err;\n            }\n        }\n        let bloomFilter;\n        try {\n            // BloomFilter throws error if the inputs are invalid.\n            bloomFilter = new BloomFilter(normalizedBitmap, padding, hashCount);\n        }\n        catch (err) {\n            if (err instanceof BloomFilterError) {\n                logWarn('BloomFilter error: ', err);\n            }\n            else {\n                logWarn('Applying bloom filter failed: ', err);\n            }\n            return null;\n        }\n        if (bloomFilter.bitCount === 0) {\n            return null;\n        }\n        return bloomFilter;\n    }\n    /**\n     * Apply bloom filter to remove the deleted documents, and return the\n     * application status.\n     */\n    applyBloomFilter(bloomFilter, watchChange, currentCount) {\n        const expectedCount = watchChange.existenceFilter.count;\n        const removedDocumentCount = this.filterRemovedDocuments(bloomFilter, watchChange.targetId);\n        return expectedCount === currentCount - removedDocumentCount\n            ? 0 /* BloomFilterApplicationStatus.Success */\n            : 2 /* BloomFilterApplicationStatus.FalsePositive */;\n    }\n    /**\n     * Filter out removed documents based on bloom filter membership result and\n     * return number of documents removed.\n     */\n    filterRemovedDocuments(bloomFilter, targetId) {\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\n        let removalCount = 0;\n        existingKeys.forEach(key => {\n            const databaseId = this.metadataProvider.getDatabaseId();\n            const documentPath = `projects/${databaseId.projectId}` +\n                `/databases/${databaseId.database}` +\n                `/documents/${key.path.canonicalString()}`;\n            if (!bloomFilter.mightContain(documentPath)) {\n                this.removeDocumentFromTarget(targetId, key, /*updatedDocument=*/ null);\n                removalCount++;\n            }\n        });\n        return removalCount;\n    }\n    /**\n     * Converts the currently accumulated state into a remote event at the\n     * provided snapshot version. Resets the accumulated changes before returning.\n     */\n    createRemoteEvent(snapshotVersion) {\n        const targetChanges = new Map();\n        this.targetStates.forEach((targetState, targetId) => {\n            const targetData = this.targetDataForActiveTarget(targetId);\n            if (targetData) {\n                if (targetState.current && targetIsDocumentTarget(targetData.target)) {\n                    // Document queries for document that don't exist can produce an empty\n                    // result set. To update our local cache, we synthesize a document\n                    // delete if we have not previously received the document for this\n                    // target. This resolves the limbo state of the document, removing it\n                    // from limboDocumentRefs.\n                    //\n                    // TODO(dimond): Ideally we would have an explicit lookup target\n                    // instead resulting in an explicit delete message and we could\n                    // remove this special logic.\n                    const key = new DocumentKey(targetData.target.path);\n                    if (!this.ensureDocumentUpdateByTarget(key).has(targetId) &&\n                        !this.targetContainsDocument(targetId, key)) {\n                        this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, snapshotVersion));\n                    }\n                }\n                if (targetState.hasPendingChanges) {\n                    targetChanges.set(targetId, targetState.toTargetChange());\n                    targetState.clearPendingChanges();\n                }\n            }\n        });\n        let resolvedLimboDocuments = documentKeySet();\n        // We extract the set of limbo-only document updates as the GC logic\n        // special-cases documents that do not appear in the target cache.\n        //\n        // TODO(gsoltis): Expand on this comment once GC is available in the JS\n        // client.\n        this.pendingDocumentTargetMapping.forEach((key, targets) => {\n            let isOnlyLimboTarget = true;\n            targets.forEachWhile(targetId => {\n                const targetData = this.targetDataForActiveTarget(targetId);\n                if (targetData &&\n                    targetData.purpose !== \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */) {\n                    isOnlyLimboTarget = false;\n                    return false;\n                }\n                return true;\n            });\n            if (isOnlyLimboTarget) {\n                resolvedLimboDocuments = resolvedLimboDocuments.add(key);\n            }\n        });\n        this.pendingDocumentUpdates.forEach((_, doc) => doc.setReadTime(snapshotVersion));\n        const remoteEvent = new RemoteEvent(snapshotVersion, targetChanges, this.pendingTargetResets, this.pendingDocumentUpdates, resolvedLimboDocuments);\n        this.pendingDocumentUpdates = mutableDocumentMap();\n        this.pendingDocumentUpdatesByTarget = documentTargetMap();\n        this.pendingDocumentTargetMapping = documentTargetMap();\n        this.pendingTargetResets = new SortedMap(primitiveComparator);\n        return remoteEvent;\n    }\n    /**\n     * Adds the provided document to the internal list of document updates and\n     * its document key to the given target's mapping.\n     */\n    // Visible for testing.\n    addDocumentToTarget(targetId, document) {\n        if (!this.isActiveTarget(targetId)) {\n            return;\n        }\n        const changeType = this.targetContainsDocument(targetId, document.key)\n            ? 2 /* ChangeType.Modified */\n            : 0 /* ChangeType.Added */;\n        const targetState = this.ensureTargetState(targetId);\n        targetState.addDocumentChange(document.key, changeType);\n        this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(document.key, document);\n        this.pendingDocumentUpdatesByTarget =\n            this.pendingDocumentUpdatesByTarget.insert(document.key, this.ensureDocumentUpdateByTarget(document.key).add(targetId));\n        this.pendingDocumentTargetMapping =\n            this.pendingDocumentTargetMapping.insert(document.key, this.ensureDocumentTargetMapping(document.key).add(targetId));\n    }\n    /**\n     * Removes the provided document from the target mapping. If the\n     * document no longer matches the target, but the document's state is still\n     * known (e.g. we know that the document was deleted or we received the change\n     * that caused the filter mismatch), the new document can be provided\n     * to update the remote document cache.\n     */\n    // Visible for testing.\n    removeDocumentFromTarget(targetId, key, updatedDocument) {\n        if (!this.isActiveTarget(targetId)) {\n            return;\n        }\n        const targetState = this.ensureTargetState(targetId);\n        if (this.targetContainsDocument(targetId, key)) {\n            targetState.addDocumentChange(key, 1 /* ChangeType.Removed */);\n        }\n        else {\n            // The document may have entered and left the target before we raised a\n            // snapshot, so we can just ignore the change.\n            targetState.removeDocumentChange(key);\n        }\n        this.pendingDocumentTargetMapping =\n            this.pendingDocumentTargetMapping.insert(key, this.ensureDocumentTargetMapping(key).delete(targetId));\n        this.pendingDocumentTargetMapping =\n            this.pendingDocumentTargetMapping.insert(key, this.ensureDocumentTargetMapping(key).add(targetId));\n        if (updatedDocument) {\n            this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(key, updatedDocument);\n        }\n    }\n    removeTarget(targetId) {\n        this.targetStates.delete(targetId);\n    }\n    /**\n     * Returns the current count of documents in the target. This includes both\n     * the number of documents that the LocalStore considers to be part of the\n     * target as well as any accumulated changes.\n     */\n    getCurrentDocumentCountForTarget(targetId) {\n        const targetState = this.ensureTargetState(targetId);\n        const targetChange = targetState.toTargetChange();\n        return (this.metadataProvider.getRemoteKeysForTarget(targetId).size +\n            targetChange.addedDocuments.size -\n            targetChange.removedDocuments.size);\n    }\n    /**\n     * Increment the number of acks needed from watch before we can consider the\n     * server to be 'in-sync' with the client's active targets.\n     */\n    recordPendingTargetRequest(targetId) {\n        // For each request we get we need to record we need a response for it.\n        const targetState = this.ensureTargetState(targetId);\n        targetState.recordPendingTargetRequest();\n    }\n    ensureTargetState(targetId) {\n        let result = this.targetStates.get(targetId);\n        if (!result) {\n            result = new TargetState();\n            this.targetStates.set(targetId, result);\n        }\n        return result;\n    }\n    ensureDocumentTargetMapping(key) {\n        let targetMapping = this.pendingDocumentTargetMapping.get(key);\n        if (!targetMapping) {\n            targetMapping = new SortedSet(primitiveComparator);\n            this.pendingDocumentTargetMapping =\n                this.pendingDocumentTargetMapping.insert(key, targetMapping);\n        }\n        return targetMapping;\n    }\n    ensureDocumentUpdateByTarget(key) {\n        let targetMapping = this.pendingDocumentUpdatesByTarget.get(key);\n        if (!targetMapping) {\n            targetMapping = new SortedSet(primitiveComparator);\n            this.pendingDocumentUpdatesByTarget =\n                this.pendingDocumentUpdatesByTarget.insert(key, targetMapping);\n        }\n        return targetMapping;\n    }\n    /**\n     * Verifies that the user is still interested in this target (by calling\n     * `getTargetDataForTarget()`) and that we are not waiting for pending ADDs\n     * from watch.\n     */\n    isActiveTarget(targetId) {\n        const targetActive = this.targetDataForActiveTarget(targetId) !== null;\n        if (!targetActive) {\n            logDebug(LOG_TAG$g, 'Detected inactive target', targetId);\n        }\n        return targetActive;\n    }\n    /**\n     * Returns the TargetData for an active target (i.e. a target that the user\n     * is still interested in that has no outstanding target change requests).\n     */\n    targetDataForActiveTarget(targetId) {\n        const targetState = this.targetStates.get(targetId);\n        return targetState && targetState.isPending\n            ? null\n            : this.metadataProvider.getTargetDataForTarget(targetId);\n    }\n    /**\n     * Resets the state of a Watch target to its initial state (e.g. sets\n     * 'current' to false, clears the resume token and removes its target mapping\n     * from all documents).\n     */\n    resetTarget(targetId) {\n        this.targetStates.set(targetId, new TargetState());\n        // Trigger removal for any documents currently mapped to this target.\n        // These removals will be part of the initial snapshot if Watch does not\n        // resend these documents.\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\n        existingKeys.forEach(key => {\n            this.removeDocumentFromTarget(targetId, key, /*updatedDocument=*/ null);\n        });\n    }\n    /**\n     * Returns whether the LocalStore considers the document to be part of the\n     * specified target.\n     */\n    targetContainsDocument(targetId, key) {\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\n        return existingKeys.has(key);\n    }\n}\nfunction documentTargetMap() {\n    return new SortedMap(DocumentKey.comparator);\n}\nfunction snapshotChangesMap() {\n    return new SortedMap(DocumentKey.comparator);\n}\nfunction createExistenceFilterMismatchInfoForTestingHooks(localCacheCount, existenceFilter, databaseId, bloomFilter, bloomFilterStatus) {\n    var _a, _b, _c, _d, _e, _f;\n    const result = {\n        localCacheCount,\n        existenceFilterCount: existenceFilter.count,\n        databaseId: databaseId.database,\n        projectId: databaseId.projectId\n    };\n    const unchangedNames = existenceFilter.unchangedNames;\n    if (unchangedNames) {\n        result.bloomFilter = {\n            applied: bloomFilterStatus === 0 /* BloomFilterApplicationStatus.Success */,\n            hashCount: (_a = unchangedNames === null || unchangedNames === void 0 ? void 0 : unchangedNames.hashCount) !== null && _a !== void 0 ? _a : 0,\n            bitmapLength: (_d = (_c = (_b = unchangedNames === null || unchangedNames === void 0 ? void 0 : unchangedNames.bits) === null || _b === void 0 ? void 0 : _b.bitmap) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0,\n            padding: (_f = (_e = unchangedNames === null || unchangedNames === void 0 ? void 0 : unchangedNames.bits) === null || _e === void 0 ? void 0 : _e.padding) !== null && _f !== void 0 ? _f : 0,\n            mightContain: (value) => { var _a; return (_a = bloomFilter === null || bloomFilter === void 0 ? void 0 : bloomFilter.mightContain(value)) !== null && _a !== void 0 ? _a : false; }\n        };\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DIRECTIONS = (() => {\n    const dirs = {};\n    dirs[\"asc\" /* Direction.ASCENDING */] = 'ASCENDING';\n    dirs[\"desc\" /* Direction.DESCENDING */] = 'DESCENDING';\n    return dirs;\n})();\nconst OPERATORS = (() => {\n    const ops = {};\n    ops[\"<\" /* Operator.LESS_THAN */] = 'LESS_THAN';\n    ops[\"<=\" /* Operator.LESS_THAN_OR_EQUAL */] = 'LESS_THAN_OR_EQUAL';\n    ops[\">\" /* Operator.GREATER_THAN */] = 'GREATER_THAN';\n    ops[\">=\" /* Operator.GREATER_THAN_OR_EQUAL */] = 'GREATER_THAN_OR_EQUAL';\n    ops[\"==\" /* Operator.EQUAL */] = 'EQUAL';\n    ops[\"!=\" /* Operator.NOT_EQUAL */] = 'NOT_EQUAL';\n    ops[\"array-contains\" /* Operator.ARRAY_CONTAINS */] = 'ARRAY_CONTAINS';\n    ops[\"in\" /* Operator.IN */] = 'IN';\n    ops[\"not-in\" /* Operator.NOT_IN */] = 'NOT_IN';\n    ops[\"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */] = 'ARRAY_CONTAINS_ANY';\n    return ops;\n})();\nconst COMPOSITE_OPERATORS = (() => {\n    const ops = {};\n    ops[\"and\" /* CompositeOperator.AND */] = 'AND';\n    ops[\"or\" /* CompositeOperator.OR */] = 'OR';\n    return ops;\n})();\nfunction assertPresent(value, description) {\n}\n/**\n * This class generates JsonObject values for the Datastore API suitable for\n * sending to either GRPC stub methods or via the JSON/HTTP REST API.\n *\n * The serializer supports both Protobuf.js and Proto3 JSON formats. By\n * setting `useProto3Json` to true, the serializer will use the Proto3 JSON\n * format.\n *\n * For a description of the Proto3 JSON format check\n * https://developers.google.com/protocol-buffers/docs/proto3#json\n *\n * TODO(klimt): We can remove the databaseId argument if we keep the full\n * resource name in documents.\n */\nclass JsonProtoSerializer {\n    constructor(databaseId, useProto3Json) {\n        this.databaseId = databaseId;\n        this.useProto3Json = useProto3Json;\n    }\n}\nfunction fromRpcStatus(status) {\n    const code = status.code === undefined ? Code.UNKNOWN : mapCodeFromRpcCode(status.code);\n    return new FirestoreError(code, status.message || '');\n}\n/**\n * Returns a value for a number (or null) that's appropriate to put into\n * a google.protobuf.Int32Value proto.\n * DO NOT USE THIS FOR ANYTHING ELSE.\n * This method cheats. It's typed as returning \"number\" because that's what\n * our generated proto interfaces say Int32Value must be. But GRPC actually\n * expects a { value: <number> } struct.\n */\nfunction toInt32Proto(serializer, val) {\n    if (serializer.useProto3Json || isNullOrUndefined(val)) {\n        return val;\n    }\n    else {\n        return { value: val };\n    }\n}\n/**\n * Returns a number (or null) from a google.protobuf.Int32Value proto.\n */\nfunction fromInt32Proto(val) {\n    let result;\n    if (typeof val === 'object') {\n        result = val.value;\n    }\n    else {\n        result = val;\n    }\n    return isNullOrUndefined(result) ? null : result;\n}\n/**\n * Returns a value for a Date that's appropriate to put into a proto.\n */\nfunction toTimestamp(serializer, timestamp) {\n    if (serializer.useProto3Json) {\n        // Serialize to ISO-8601 date format, but with full nano resolution.\n        // Since JS Date has only millis, let's only use it for the seconds and\n        // then manually add the fractions to the end.\n        const jsDateStr = new Date(timestamp.seconds * 1000).toISOString();\n        // Remove .xxx frac part and Z in the end.\n        const strUntilSeconds = jsDateStr.replace(/\\.\\d*/, '').replace('Z', '');\n        // Pad the fraction out to 9 digits (nanos).\n        const nanoStr = ('000000000' + timestamp.nanoseconds).slice(-9);\n        return `${strUntilSeconds}.${nanoStr}Z`;\n    }\n    else {\n        return {\n            seconds: '' + timestamp.seconds,\n            nanos: timestamp.nanoseconds\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        };\n    }\n}\nfunction fromTimestamp(date) {\n    const timestamp = normalizeTimestamp(date);\n    return new Timestamp(timestamp.seconds, timestamp.nanos);\n}\n/**\n * Returns a value for bytes that's appropriate to put in a proto.\n *\n * Visible for testing.\n */\nfunction toBytes(serializer, bytes) {\n    if (serializer.useProto3Json) {\n        return bytes.toBase64();\n    }\n    else {\n        return bytes.toUint8Array();\n    }\n}\n/**\n * Returns a ByteString based on the proto string value.\n */\nfunction fromBytes(serializer, value) {\n    if (serializer.useProto3Json) {\n        hardAssert(value === undefined || typeof value === 'string');\n        return ByteString.fromBase64String(value ? value : '');\n    }\n    else {\n        hardAssert(value === undefined ||\n            // Check if the value is an instance of both Buffer and Uint8Array,\n            // despite the fact that Buffer extends Uint8Array. In some\n            // environments, such as jsdom, the prototype chain of Buffer\n            // does not indicate that it extends Uint8Array.\n            value instanceof Buffer ||\n            value instanceof Uint8Array);\n        return ByteString.fromUint8Array(value ? value : new Uint8Array());\n    }\n}\nfunction toVersion(serializer, version) {\n    return toTimestamp(serializer, version.toTimestamp());\n}\nfunction fromVersion(version) {\n    hardAssert(!!version);\n    return SnapshotVersion.fromTimestamp(fromTimestamp(version));\n}\nfunction toResourceName(databaseId, path) {\n    return toResourcePath(databaseId, path).canonicalString();\n}\nfunction toResourcePath(databaseId, path) {\n    const resourcePath = fullyQualifiedPrefixPath(databaseId).child('documents');\n    return path === undefined ? resourcePath : resourcePath.child(path);\n}\nfunction fromResourceName(name) {\n    const resource = ResourcePath.fromString(name);\n    hardAssert(isValidResourceName(resource));\n    return resource;\n}\nfunction toName(serializer, key) {\n    return toResourceName(serializer.databaseId, key.path);\n}\nfunction fromName(serializer, name) {\n    const resource = fromResourceName(name);\n    if (resource.get(1) !== serializer.databaseId.projectId) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Tried to deserialize key from different project: ' +\n            resource.get(1) +\n            ' vs ' +\n            serializer.databaseId.projectId);\n    }\n    if (resource.get(3) !== serializer.databaseId.database) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Tried to deserialize key from different database: ' +\n            resource.get(3) +\n            ' vs ' +\n            serializer.databaseId.database);\n    }\n    return new DocumentKey(extractLocalPathFromResourceName(resource));\n}\nfunction toQueryPath(serializer, path) {\n    return toResourceName(serializer.databaseId, path);\n}\nfunction fromQueryPath(name) {\n    const resourceName = fromResourceName(name);\n    // In v1beta1 queries for collections at the root did not have a trailing\n    // \"/documents\". In v1 all resource paths contain \"/documents\". Preserve the\n    // ability to read the v1beta1 form for compatibility with queries persisted\n    // in the local target cache.\n    if (resourceName.length === 4) {\n        return ResourcePath.emptyPath();\n    }\n    return extractLocalPathFromResourceName(resourceName);\n}\nfunction getEncodedDatabaseId(serializer) {\n    const path = new ResourcePath([\n        'projects',\n        serializer.databaseId.projectId,\n        'databases',\n        serializer.databaseId.database\n    ]);\n    return path.canonicalString();\n}\nfunction fullyQualifiedPrefixPath(databaseId) {\n    return new ResourcePath([\n        'projects',\n        databaseId.projectId,\n        'databases',\n        databaseId.database\n    ]);\n}\nfunction extractLocalPathFromResourceName(resourceName) {\n    hardAssert(resourceName.length > 4 && resourceName.get(4) === 'documents');\n    return resourceName.popFirst(5);\n}\n/** Creates a Document proto from key and fields (but no create/update time) */\nfunction toMutationDocument(serializer, key, fields) {\n    return {\n        name: toName(serializer, key),\n        fields: fields.value.mapValue.fields\n    };\n}\nfunction toDocument(serializer, document) {\n    return {\n        name: toName(serializer, document.key),\n        fields: document.data.value.mapValue.fields,\n        updateTime: toTimestamp(serializer, document.version.toTimestamp()),\n        createTime: toTimestamp(serializer, document.createTime.toTimestamp())\n    };\n}\nfunction fromDocument(serializer, document, hasCommittedMutations) {\n    const key = fromName(serializer, document.name);\n    const version = fromVersion(document.updateTime);\n    // If we read a document from persistence that is missing createTime, it's due\n    // to older SDK versions not storing this information. In such cases, we'll\n    // set the createTime to zero. This can be removed in the long term.\n    const createTime = document.createTime\n        ? fromVersion(document.createTime)\n        : SnapshotVersion.min();\n    const data = new ObjectValue({ mapValue: { fields: document.fields } });\n    const result = MutableDocument.newFoundDocument(key, version, createTime, data);\n    if (hasCommittedMutations) {\n        result.setHasCommittedMutations();\n    }\n    return hasCommittedMutations ? result.setHasCommittedMutations() : result;\n}\nfunction fromFound(serializer, doc) {\n    hardAssert(!!doc.found);\n    assertPresent(doc.found.name);\n    assertPresent(doc.found.updateTime);\n    const key = fromName(serializer, doc.found.name);\n    const version = fromVersion(doc.found.updateTime);\n    const createTime = doc.found.createTime\n        ? fromVersion(doc.found.createTime)\n        : SnapshotVersion.min();\n    const data = new ObjectValue({ mapValue: { fields: doc.found.fields } });\n    return MutableDocument.newFoundDocument(key, version, createTime, data);\n}\nfunction fromMissing(serializer, result) {\n    hardAssert(!!result.missing);\n    hardAssert(!!result.readTime);\n    const key = fromName(serializer, result.missing);\n    const version = fromVersion(result.readTime);\n    return MutableDocument.newNoDocument(key, version);\n}\nfunction fromBatchGetDocumentsResponse(serializer, result) {\n    if ('found' in result) {\n        return fromFound(serializer, result);\n    }\n    else if ('missing' in result) {\n        return fromMissing(serializer, result);\n    }\n    return fail();\n}\nfunction fromWatchChange(serializer, change) {\n    let watchChange;\n    if ('targetChange' in change) {\n        assertPresent(change.targetChange);\n        // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'\n        // if unset\n        const state = fromWatchTargetChangeState(change.targetChange.targetChangeType || 'NO_CHANGE');\n        const targetIds = change.targetChange.targetIds || [];\n        const resumeToken = fromBytes(serializer, change.targetChange.resumeToken);\n        const causeProto = change.targetChange.cause;\n        const cause = causeProto && fromRpcStatus(causeProto);\n        watchChange = new WatchTargetChange(state, targetIds, resumeToken, cause || null);\n    }\n    else if ('documentChange' in change) {\n        assertPresent(change.documentChange);\n        const entityChange = change.documentChange;\n        assertPresent(entityChange.document);\n        assertPresent(entityChange.document.name);\n        assertPresent(entityChange.document.updateTime);\n        const key = fromName(serializer, entityChange.document.name);\n        const version = fromVersion(entityChange.document.updateTime);\n        const createTime = entityChange.document.createTime\n            ? fromVersion(entityChange.document.createTime)\n            : SnapshotVersion.min();\n        const data = new ObjectValue({\n            mapValue: { fields: entityChange.document.fields }\n        });\n        const doc = MutableDocument.newFoundDocument(key, version, createTime, data);\n        const updatedTargetIds = entityChange.targetIds || [];\n        const removedTargetIds = entityChange.removedTargetIds || [];\n        watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);\n    }\n    else if ('documentDelete' in change) {\n        assertPresent(change.documentDelete);\n        const docDelete = change.documentDelete;\n        assertPresent(docDelete.document);\n        const key = fromName(serializer, docDelete.document);\n        const version = docDelete.readTime\n            ? fromVersion(docDelete.readTime)\n            : SnapshotVersion.min();\n        const doc = MutableDocument.newNoDocument(key, version);\n        const removedTargetIds = docDelete.removedTargetIds || [];\n        watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);\n    }\n    else if ('documentRemove' in change) {\n        assertPresent(change.documentRemove);\n        const docRemove = change.documentRemove;\n        assertPresent(docRemove.document);\n        const key = fromName(serializer, docRemove.document);\n        const removedTargetIds = docRemove.removedTargetIds || [];\n        watchChange = new DocumentWatchChange([], removedTargetIds, key, null);\n    }\n    else if ('filter' in change) {\n        // TODO(dimond): implement existence filter parsing with strategy.\n        assertPresent(change.filter);\n        const filter = change.filter;\n        assertPresent(filter.targetId);\n        const { count = 0, unchangedNames } = filter;\n        const existenceFilter = new ExistenceFilter(count, unchangedNames);\n        const targetId = filter.targetId;\n        watchChange = new ExistenceFilterChange(targetId, existenceFilter);\n    }\n    else {\n        return fail();\n    }\n    return watchChange;\n}\nfunction fromWatchTargetChangeState(state) {\n    if (state === 'NO_CHANGE') {\n        return 0 /* WatchTargetChangeState.NoChange */;\n    }\n    else if (state === 'ADD') {\n        return 1 /* WatchTargetChangeState.Added */;\n    }\n    else if (state === 'REMOVE') {\n        return 2 /* WatchTargetChangeState.Removed */;\n    }\n    else if (state === 'CURRENT') {\n        return 3 /* WatchTargetChangeState.Current */;\n    }\n    else if (state === 'RESET') {\n        return 4 /* WatchTargetChangeState.Reset */;\n    }\n    else {\n        return fail();\n    }\n}\nfunction versionFromListenResponse(change) {\n    // We have only reached a consistent snapshot for the entire stream if there\n    // is a read_time set and it applies to all targets (i.e. the list of\n    // targets is empty). The backend is guaranteed to send such responses.\n    if (!('targetChange' in change)) {\n        return SnapshotVersion.min();\n    }\n    const targetChange = change.targetChange;\n    if (targetChange.targetIds && targetChange.targetIds.length) {\n        return SnapshotVersion.min();\n    }\n    if (!targetChange.readTime) {\n        return SnapshotVersion.min();\n    }\n    return fromVersion(targetChange.readTime);\n}\nfunction toMutation(serializer, mutation) {\n    let result;\n    if (mutation instanceof SetMutation) {\n        result = {\n            update: toMutationDocument(serializer, mutation.key, mutation.value)\n        };\n    }\n    else if (mutation instanceof DeleteMutation) {\n        result = { delete: toName(serializer, mutation.key) };\n    }\n    else if (mutation instanceof PatchMutation) {\n        result = {\n            update: toMutationDocument(serializer, mutation.key, mutation.data),\n            updateMask: toDocumentMask(mutation.fieldMask)\n        };\n    }\n    else if (mutation instanceof VerifyMutation) {\n        result = {\n            verify: toName(serializer, mutation.key)\n        };\n    }\n    else {\n        return fail();\n    }\n    if (mutation.fieldTransforms.length > 0) {\n        result.updateTransforms = mutation.fieldTransforms.map(transform => toFieldTransform(serializer, transform));\n    }\n    if (!mutation.precondition.isNone) {\n        result.currentDocument = toPrecondition(serializer, mutation.precondition);\n    }\n    return result;\n}\nfunction fromMutation(serializer, proto) {\n    const precondition = proto.currentDocument\n        ? fromPrecondition(proto.currentDocument)\n        : Precondition.none();\n    const fieldTransforms = proto.updateTransforms\n        ? proto.updateTransforms.map(transform => fromFieldTransform(serializer, transform))\n        : [];\n    if (proto.update) {\n        assertPresent(proto.update.name);\n        const key = fromName(serializer, proto.update.name);\n        const value = new ObjectValue({\n            mapValue: { fields: proto.update.fields }\n        });\n        if (proto.updateMask) {\n            const fieldMask = fromDocumentMask(proto.updateMask);\n            return new PatchMutation(key, value, fieldMask, precondition, fieldTransforms);\n        }\n        else {\n            return new SetMutation(key, value, precondition, fieldTransforms);\n        }\n    }\n    else if (proto.delete) {\n        const key = fromName(serializer, proto.delete);\n        return new DeleteMutation(key, precondition);\n    }\n    else if (proto.verify) {\n        const key = fromName(serializer, proto.verify);\n        return new VerifyMutation(key, precondition);\n    }\n    else {\n        return fail();\n    }\n}\nfunction toPrecondition(serializer, precondition) {\n    if (precondition.updateTime !== undefined) {\n        return {\n            updateTime: toVersion(serializer, precondition.updateTime)\n        };\n    }\n    else if (precondition.exists !== undefined) {\n        return { exists: precondition.exists };\n    }\n    else {\n        return fail();\n    }\n}\nfunction fromPrecondition(precondition) {\n    if (precondition.updateTime !== undefined) {\n        return Precondition.updateTime(fromVersion(precondition.updateTime));\n    }\n    else if (precondition.exists !== undefined) {\n        return Precondition.exists(precondition.exists);\n    }\n    else {\n        return Precondition.none();\n    }\n}\nfunction fromWriteResult(proto, commitTime) {\n    // NOTE: Deletes don't have an updateTime.\n    let version = proto.updateTime\n        ? fromVersion(proto.updateTime)\n        : fromVersion(commitTime);\n    if (version.isEqual(SnapshotVersion.min())) {\n        // The Firestore Emulator currently returns an update time of 0 for\n        // deletes of non-existing documents (rather than null). This breaks the\n        // test \"get deleted doc while offline with source=cache\" as NoDocuments\n        // with version 0 are filtered by IndexedDb's RemoteDocumentCache.\n        // TODO(#2149): Remove this when Emulator is fixed\n        version = fromVersion(commitTime);\n    }\n    return new MutationResult(version, proto.transformResults || []);\n}\nfunction fromWriteResults(protos, commitTime) {\n    if (protos && protos.length > 0) {\n        hardAssert(commitTime !== undefined);\n        return protos.map(proto => fromWriteResult(proto, commitTime));\n    }\n    else {\n        return [];\n    }\n}\nfunction toFieldTransform(serializer, fieldTransform) {\n    const transform = fieldTransform.transform;\n    if (transform instanceof ServerTimestampTransform) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            setToServerValue: 'REQUEST_TIME'\n        };\n    }\n    else if (transform instanceof ArrayUnionTransformOperation) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            appendMissingElements: {\n                values: transform.elements\n            }\n        };\n    }\n    else if (transform instanceof ArrayRemoveTransformOperation) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            removeAllFromArray: {\n                values: transform.elements\n            }\n        };\n    }\n    else if (transform instanceof NumericIncrementTransformOperation) {\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            increment: transform.operand\n        };\n    }\n    else {\n        throw fail();\n    }\n}\nfunction fromFieldTransform(serializer, proto) {\n    let transform = null;\n    if ('setToServerValue' in proto) {\n        hardAssert(proto.setToServerValue === 'REQUEST_TIME');\n        transform = new ServerTimestampTransform();\n    }\n    else if ('appendMissingElements' in proto) {\n        const values = proto.appendMissingElements.values || [];\n        transform = new ArrayUnionTransformOperation(values);\n    }\n    else if ('removeAllFromArray' in proto) {\n        const values = proto.removeAllFromArray.values || [];\n        transform = new ArrayRemoveTransformOperation(values);\n    }\n    else if ('increment' in proto) {\n        transform = new NumericIncrementTransformOperation(serializer, proto.increment);\n    }\n    else {\n        fail();\n    }\n    const fieldPath = FieldPath$1.fromServerFormat(proto.fieldPath);\n    return new FieldTransform(fieldPath, transform);\n}\nfunction toDocumentsTarget(serializer, target) {\n    return { documents: [toQueryPath(serializer, target.path)] };\n}\nfunction fromDocumentsTarget(documentsTarget) {\n    const count = documentsTarget.documents.length;\n    hardAssert(count === 1);\n    const name = documentsTarget.documents[0];\n    return queryToTarget(newQueryForPath(fromQueryPath(name)));\n}\nfunction toQueryTarget(serializer, target) {\n    // Dissect the path into parent, collectionId, and optional key filter.\n    const queryTarget = { structuredQuery: {} };\n    const path = target.path;\n    let parent;\n    if (target.collectionGroup !== null) {\n        parent = path;\n        queryTarget.structuredQuery.from = [\n            {\n                collectionId: target.collectionGroup,\n                allDescendants: true\n            }\n        ];\n    }\n    else {\n        parent = path.popLast();\n        queryTarget.structuredQuery.from = [{ collectionId: path.lastSegment() }];\n    }\n    queryTarget.parent = toQueryPath(serializer, parent);\n    const where = toFilters(target.filters);\n    if (where) {\n        queryTarget.structuredQuery.where = where;\n    }\n    const orderBy = toOrder(target.orderBy);\n    if (orderBy) {\n        queryTarget.structuredQuery.orderBy = orderBy;\n    }\n    const limit = toInt32Proto(serializer, target.limit);\n    if (limit !== null) {\n        queryTarget.structuredQuery.limit = limit;\n    }\n    if (target.startAt) {\n        queryTarget.structuredQuery.startAt = toStartAtCursor(target.startAt);\n    }\n    if (target.endAt) {\n        queryTarget.structuredQuery.endAt = toEndAtCursor(target.endAt);\n    }\n    return { queryTarget, parent };\n}\nfunction toRunAggregationQueryRequest(serializer, target, aggregates, skipAliasing) {\n    const { queryTarget, parent } = toQueryTarget(serializer, target);\n    const aliasMap = {};\n    const aggregations = [];\n    let aggregationNum = 0;\n    aggregates.forEach(aggregate => {\n        // Map all client-side aliases to a unique short-form\n        // alias. This avoids issues with client-side aliases that\n        // exceed the 1500-byte string size limit.\n        const serverAlias = skipAliasing\n            ? aggregate.alias\n            : `aggregate_${aggregationNum++}`;\n        aliasMap[serverAlias] = aggregate.alias;\n        if (aggregate.aggregateType === 'count') {\n            aggregations.push({\n                alias: serverAlias,\n                count: {}\n            });\n        }\n        else if (aggregate.aggregateType === 'avg') {\n            aggregations.push({\n                alias: serverAlias,\n                avg: {\n                    field: toFieldPathReference(aggregate.fieldPath)\n                }\n            });\n        }\n        else if (aggregate.aggregateType === 'sum') {\n            aggregations.push({\n                alias: serverAlias,\n                sum: {\n                    field: toFieldPathReference(aggregate.fieldPath)\n                }\n            });\n        }\n    });\n    return {\n        request: {\n            structuredAggregationQuery: {\n                aggregations,\n                structuredQuery: queryTarget.structuredQuery\n            },\n            parent: queryTarget.parent\n        },\n        aliasMap,\n        parent\n    };\n}\nfunction convertQueryTargetToQuery(target) {\n    let path = fromQueryPath(target.parent);\n    const query = target.structuredQuery;\n    const fromCount = query.from ? query.from.length : 0;\n    let collectionGroup = null;\n    if (fromCount > 0) {\n        hardAssert(fromCount === 1);\n        const from = query.from[0];\n        if (from.allDescendants) {\n            collectionGroup = from.collectionId;\n        }\n        else {\n            path = path.child(from.collectionId);\n        }\n    }\n    let filterBy = [];\n    if (query.where) {\n        filterBy = fromFilters(query.where);\n    }\n    let orderBy = [];\n    if (query.orderBy) {\n        orderBy = fromOrder(query.orderBy);\n    }\n    let limit = null;\n    if (query.limit) {\n        limit = fromInt32Proto(query.limit);\n    }\n    let startAt = null;\n    if (query.startAt) {\n        startAt = fromStartAtCursor(query.startAt);\n    }\n    let endAt = null;\n    if (query.endAt) {\n        endAt = fromEndAtCursor(query.endAt);\n    }\n    return newQuery(path, collectionGroup, orderBy, filterBy, limit, \"F\" /* LimitType.First */, startAt, endAt);\n}\nfunction fromQueryTarget(target) {\n    return queryToTarget(convertQueryTargetToQuery(target));\n}\nfunction toListenRequestLabels(serializer, targetData) {\n    const value = toLabel(targetData.purpose);\n    if (value == null) {\n        return null;\n    }\n    else {\n        return {\n            'goog-listen-tags': value\n        };\n    }\n}\nfunction toLabel(purpose) {\n    switch (purpose) {\n        case \"TargetPurposeListen\" /* TargetPurpose.Listen */:\n            return null;\n        case \"TargetPurposeExistenceFilterMismatch\" /* TargetPurpose.ExistenceFilterMismatch */:\n            return 'existence-filter-mismatch';\n        case \"TargetPurposeExistenceFilterMismatchBloom\" /* TargetPurpose.ExistenceFilterMismatchBloom */:\n            return 'existence-filter-mismatch-bloom';\n        case \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */:\n            return 'limbo-document';\n        default:\n            return fail();\n    }\n}\nfunction toTarget(serializer, targetData) {\n    let result;\n    const target = targetData.target;\n    if (targetIsDocumentTarget(target)) {\n        result = { documents: toDocumentsTarget(serializer, target) };\n    }\n    else {\n        result = { query: toQueryTarget(serializer, target).queryTarget };\n    }\n    result.targetId = targetData.targetId;\n    if (targetData.resumeToken.approximateByteSize() > 0) {\n        result.resumeToken = toBytes(serializer, targetData.resumeToken);\n        const expectedCount = toInt32Proto(serializer, targetData.expectedCount);\n        if (expectedCount !== null) {\n            result.expectedCount = expectedCount;\n        }\n    }\n    else if (targetData.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {\n        // TODO(wuandy): Consider removing above check because it is most likely true.\n        // Right now, many tests depend on this behaviour though (leaving min() out\n        // of serialization).\n        result.readTime = toTimestamp(serializer, targetData.snapshotVersion.toTimestamp());\n        const expectedCount = toInt32Proto(serializer, targetData.expectedCount);\n        if (expectedCount !== null) {\n            result.expectedCount = expectedCount;\n        }\n    }\n    return result;\n}\nfunction toFilters(filters) {\n    if (filters.length === 0) {\n        return;\n    }\n    return toFilter(CompositeFilter.create(filters, \"and\" /* CompositeOperator.AND */));\n}\nfunction fromFilters(filter) {\n    const result = fromFilter(filter);\n    if (result instanceof CompositeFilter &&\n        compositeFilterIsFlatConjunction(result)) {\n        return result.getFilters();\n    }\n    return [result];\n}\nfunction fromFilter(filter) {\n    if (filter.unaryFilter !== undefined) {\n        return fromUnaryFilter(filter);\n    }\n    else if (filter.fieldFilter !== undefined) {\n        return fromFieldFilter(filter);\n    }\n    else if (filter.compositeFilter !== undefined) {\n        return fromCompositeFilter(filter);\n    }\n    else {\n        return fail();\n    }\n}\nfunction toOrder(orderBys) {\n    if (orderBys.length === 0) {\n        return;\n    }\n    return orderBys.map(order => toPropertyOrder(order));\n}\nfunction fromOrder(orderBys) {\n    return orderBys.map(order => fromPropertyOrder(order));\n}\nfunction toStartAtCursor(cursor) {\n    return {\n        before: cursor.inclusive,\n        values: cursor.position\n    };\n}\nfunction toEndAtCursor(cursor) {\n    return {\n        before: !cursor.inclusive,\n        values: cursor.position\n    };\n}\nfunction fromStartAtCursor(cursor) {\n    const inclusive = !!cursor.before;\n    const position = cursor.values || [];\n    return new Bound(position, inclusive);\n}\nfunction fromEndAtCursor(cursor) {\n    const inclusive = !cursor.before;\n    const position = cursor.values || [];\n    return new Bound(position, inclusive);\n}\n// visible for testing\nfunction toDirection(dir) {\n    return DIRECTIONS[dir];\n}\n// visible for testing\nfunction fromDirection(dir) {\n    switch (dir) {\n        case 'ASCENDING':\n            return \"asc\" /* Direction.ASCENDING */;\n        case 'DESCENDING':\n            return \"desc\" /* Direction.DESCENDING */;\n        default:\n            return undefined;\n    }\n}\n// visible for testing\nfunction toOperatorName(op) {\n    return OPERATORS[op];\n}\nfunction toCompositeOperatorName(op) {\n    return COMPOSITE_OPERATORS[op];\n}\nfunction fromOperatorName(op) {\n    switch (op) {\n        case 'EQUAL':\n            return \"==\" /* Operator.EQUAL */;\n        case 'NOT_EQUAL':\n            return \"!=\" /* Operator.NOT_EQUAL */;\n        case 'GREATER_THAN':\n            return \">\" /* Operator.GREATER_THAN */;\n        case 'GREATER_THAN_OR_EQUAL':\n            return \">=\" /* Operator.GREATER_THAN_OR_EQUAL */;\n        case 'LESS_THAN':\n            return \"<\" /* Operator.LESS_THAN */;\n        case 'LESS_THAN_OR_EQUAL':\n            return \"<=\" /* Operator.LESS_THAN_OR_EQUAL */;\n        case 'ARRAY_CONTAINS':\n            return \"array-contains\" /* Operator.ARRAY_CONTAINS */;\n        case 'IN':\n            return \"in\" /* Operator.IN */;\n        case 'NOT_IN':\n            return \"not-in\" /* Operator.NOT_IN */;\n        case 'ARRAY_CONTAINS_ANY':\n            return \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\n        case 'OPERATOR_UNSPECIFIED':\n            return fail();\n        default:\n            return fail();\n    }\n}\nfunction fromCompositeOperatorName(op) {\n    switch (op) {\n        case 'AND':\n            return \"and\" /* CompositeOperator.AND */;\n        case 'OR':\n            return \"or\" /* CompositeOperator.OR */;\n        default:\n            return fail();\n    }\n}\nfunction toFieldPathReference(path) {\n    return { fieldPath: path.canonicalString() };\n}\nfunction fromFieldPathReference(fieldReference) {\n    return FieldPath$1.fromServerFormat(fieldReference.fieldPath);\n}\n// visible for testing\nfunction toPropertyOrder(orderBy) {\n    return {\n        field: toFieldPathReference(orderBy.field),\n        direction: toDirection(orderBy.dir)\n    };\n}\nfunction fromPropertyOrder(orderBy) {\n    return new OrderBy(fromFieldPathReference(orderBy.field), fromDirection(orderBy.direction));\n}\n// visible for testing\nfunction toFilter(filter) {\n    if (filter instanceof FieldFilter) {\n        return toUnaryOrFieldFilter(filter);\n    }\n    else if (filter instanceof CompositeFilter) {\n        return toCompositeFilter(filter);\n    }\n    else {\n        return fail();\n    }\n}\nfunction toCompositeFilter(filter) {\n    const protos = filter.getFilters().map(filter => toFilter(filter));\n    if (protos.length === 1) {\n        return protos[0];\n    }\n    return {\n        compositeFilter: {\n            op: toCompositeOperatorName(filter.op),\n            filters: protos\n        }\n    };\n}\nfunction toUnaryOrFieldFilter(filter) {\n    if (filter.op === \"==\" /* Operator.EQUAL */) {\n        if (isNanValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: 'IS_NAN'\n                }\n            };\n        }\n        else if (isNullValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: 'IS_NULL'\n                }\n            };\n        }\n    }\n    else if (filter.op === \"!=\" /* Operator.NOT_EQUAL */) {\n        if (isNanValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: 'IS_NOT_NAN'\n                }\n            };\n        }\n        else if (isNullValue(filter.value)) {\n            return {\n                unaryFilter: {\n                    field: toFieldPathReference(filter.field),\n                    op: 'IS_NOT_NULL'\n                }\n            };\n        }\n    }\n    return {\n        fieldFilter: {\n            field: toFieldPathReference(filter.field),\n            op: toOperatorName(filter.op),\n            value: filter.value\n        }\n    };\n}\nfunction fromUnaryFilter(filter) {\n    switch (filter.unaryFilter.op) {\n        case 'IS_NAN':\n            const nanField = fromFieldPathReference(filter.unaryFilter.field);\n            return FieldFilter.create(nanField, \"==\" /* Operator.EQUAL */, {\n                doubleValue: NaN\n            });\n        case 'IS_NULL':\n            const nullField = fromFieldPathReference(filter.unaryFilter.field);\n            return FieldFilter.create(nullField, \"==\" /* Operator.EQUAL */, {\n                nullValue: 'NULL_VALUE'\n            });\n        case 'IS_NOT_NAN':\n            const notNanField = fromFieldPathReference(filter.unaryFilter.field);\n            return FieldFilter.create(notNanField, \"!=\" /* Operator.NOT_EQUAL */, {\n                doubleValue: NaN\n            });\n        case 'IS_NOT_NULL':\n            const notNullField = fromFieldPathReference(filter.unaryFilter.field);\n            return FieldFilter.create(notNullField, \"!=\" /* Operator.NOT_EQUAL */, {\n                nullValue: 'NULL_VALUE'\n            });\n        case 'OPERATOR_UNSPECIFIED':\n            return fail();\n        default:\n            return fail();\n    }\n}\nfunction fromFieldFilter(filter) {\n    return FieldFilter.create(fromFieldPathReference(filter.fieldFilter.field), fromOperatorName(filter.fieldFilter.op), filter.fieldFilter.value);\n}\nfunction fromCompositeFilter(filter) {\n    return CompositeFilter.create(filter.compositeFilter.filters.map(filter => fromFilter(filter)), fromCompositeOperatorName(filter.compositeFilter.op));\n}\nfunction toDocumentMask(fieldMask) {\n    const canonicalFields = [];\n    fieldMask.fields.forEach(field => canonicalFields.push(field.canonicalString()));\n    return {\n        fieldPaths: canonicalFields\n    };\n}\nfunction fromDocumentMask(proto) {\n    const paths = proto.fieldPaths || [];\n    return new FieldMask(paths.map(path => FieldPath$1.fromServerFormat(path)));\n}\nfunction isValidResourceName(path) {\n    // Resource names have at least 4 components (project ID, database ID)\n    return (path.length >= 4 &&\n        path.get(0) === 'projects' &&\n        path.get(2) === 'databases');\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An immutable set of metadata that the local store tracks for each target.\n */\nclass TargetData {\n    constructor(\n    /** The target being listened to. */\n    target, \n    /**\n     * The target ID to which the target corresponds; Assigned by the\n     * LocalStore for user listens and by the SyncEngine for limbo watches.\n     */\n    targetId, \n    /** The purpose of the target. */\n    purpose, \n    /**\n     * The sequence number of the last transaction during which this target data\n     * was modified.\n     */\n    sequenceNumber, \n    /** The latest snapshot version seen for this target. */\n    snapshotVersion = SnapshotVersion.min(), \n    /**\n     * The maximum snapshot version at which the associated view\n     * contained no limbo documents.\n     */\n    lastLimboFreeSnapshotVersion = SnapshotVersion.min(), \n    /**\n     * An opaque, server-assigned token that allows watching a target to be\n     * resumed after disconnecting without retransmitting all the data that\n     * matches the target. The resume token essentially identifies a point in\n     * time from which the server should resume sending results.\n     */\n    resumeToken = ByteString.EMPTY_BYTE_STRING, \n    /**\n     * The number of documents that last matched the query at the resume token or\n     * read time. Documents are counted only when making a listen request with\n     * resume token or read time, otherwise, keep it null.\n     */\n    expectedCount = null) {\n        this.target = target;\n        this.targetId = targetId;\n        this.purpose = purpose;\n        this.sequenceNumber = sequenceNumber;\n        this.snapshotVersion = snapshotVersion;\n        this.lastLimboFreeSnapshotVersion = lastLimboFreeSnapshotVersion;\n        this.resumeToken = resumeToken;\n        this.expectedCount = expectedCount;\n    }\n    /** Creates a new target data instance with an updated sequence number. */\n    withSequenceNumber(sequenceNumber) {\n        return new TargetData(this.target, this.targetId, this.purpose, sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);\n    }\n    /**\n     * Creates a new target data instance with an updated resume token and\n     * snapshot version.\n     */\n    withResumeToken(resumeToken, snapshotVersion) {\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, snapshotVersion, this.lastLimboFreeSnapshotVersion, resumeToken, \n        /* expectedCount= */ null);\n    }\n    /**\n     * Creates a new target data instance with an updated expected count.\n     */\n    withExpectedCount(expectedCount) {\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, expectedCount);\n    }\n    /**\n     * Creates a new target data instance with an updated last limbo free\n     * snapshot version number.\n     */\n    withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion) {\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Serializer for values stored in the LocalStore. */\nclass LocalSerializer {\n    constructor(remoteSerializer) {\n        this.remoteSerializer = remoteSerializer;\n    }\n}\n/** Decodes a remote document from storage locally to a Document. */\nfunction fromDbRemoteDocument(localSerializer, remoteDoc) {\n    let doc;\n    if (remoteDoc.document) {\n        doc = fromDocument(localSerializer.remoteSerializer, remoteDoc.document, !!remoteDoc.hasCommittedMutations);\n    }\n    else if (remoteDoc.noDocument) {\n        const key = DocumentKey.fromSegments(remoteDoc.noDocument.path);\n        const version = fromDbTimestamp(remoteDoc.noDocument.readTime);\n        doc = MutableDocument.newNoDocument(key, version);\n        if (remoteDoc.hasCommittedMutations) {\n            doc.setHasCommittedMutations();\n        }\n    }\n    else if (remoteDoc.unknownDocument) {\n        const key = DocumentKey.fromSegments(remoteDoc.unknownDocument.path);\n        const version = fromDbTimestamp(remoteDoc.unknownDocument.version);\n        doc = MutableDocument.newUnknownDocument(key, version);\n    }\n    else {\n        return fail();\n    }\n    if (remoteDoc.readTime) {\n        doc.setReadTime(fromDbTimestampKey(remoteDoc.readTime));\n    }\n    return doc;\n}\n/** Encodes a document for storage locally. */\nfunction toDbRemoteDocument(localSerializer, document) {\n    const key = document.key;\n    const remoteDoc = {\n        prefixPath: key.getCollectionPath().popLast().toArray(),\n        collectionGroup: key.collectionGroup,\n        documentId: key.path.lastSegment(),\n        readTime: toDbTimestampKey(document.readTime),\n        hasCommittedMutations: document.hasCommittedMutations\n    };\n    if (document.isFoundDocument()) {\n        remoteDoc.document = toDocument(localSerializer.remoteSerializer, document);\n    }\n    else if (document.isNoDocument()) {\n        remoteDoc.noDocument = {\n            path: key.path.toArray(),\n            readTime: toDbTimestamp(document.version)\n        };\n    }\n    else if (document.isUnknownDocument()) {\n        remoteDoc.unknownDocument = {\n            path: key.path.toArray(),\n            version: toDbTimestamp(document.version)\n        };\n    }\n    else {\n        return fail();\n    }\n    return remoteDoc;\n}\nfunction toDbTimestampKey(snapshotVersion) {\n    const timestamp = snapshotVersion.toTimestamp();\n    return [timestamp.seconds, timestamp.nanoseconds];\n}\nfunction fromDbTimestampKey(dbTimestampKey) {\n    const timestamp = new Timestamp(dbTimestampKey[0], dbTimestampKey[1]);\n    return SnapshotVersion.fromTimestamp(timestamp);\n}\nfunction toDbTimestamp(snapshotVersion) {\n    const timestamp = snapshotVersion.toTimestamp();\n    return { seconds: timestamp.seconds, nanoseconds: timestamp.nanoseconds };\n}\nfunction fromDbTimestamp(dbTimestamp) {\n    const timestamp = new Timestamp(dbTimestamp.seconds, dbTimestamp.nanoseconds);\n    return SnapshotVersion.fromTimestamp(timestamp);\n}\n/** Encodes a batch of mutations into a DbMutationBatch for local storage. */\nfunction toDbMutationBatch(localSerializer, userId, batch) {\n    const serializedBaseMutations = batch.baseMutations.map(m => toMutation(localSerializer.remoteSerializer, m));\n    const serializedMutations = batch.mutations.map(m => toMutation(localSerializer.remoteSerializer, m));\n    return {\n        userId,\n        batchId: batch.batchId,\n        localWriteTimeMs: batch.localWriteTime.toMillis(),\n        baseMutations: serializedBaseMutations,\n        mutations: serializedMutations\n    };\n}\n/** Decodes a DbMutationBatch into a MutationBatch */\nfunction fromDbMutationBatch(localSerializer, dbBatch) {\n    const baseMutations = (dbBatch.baseMutations || []).map(m => fromMutation(localSerializer.remoteSerializer, m));\n    // Squash old transform mutations into existing patch or set mutations.\n    // The replacement of representing `transforms` with `update_transforms`\n    // on the SDK means that old `transform` mutations stored in IndexedDB need\n    // to be updated to `update_transforms`.\n    // TODO(b/174608374): Remove this code once we perform a schema migration.\n    for (let i = 0; i < dbBatch.mutations.length - 1; ++i) {\n        const currentMutation = dbBatch.mutations[i];\n        const hasTransform = i + 1 < dbBatch.mutations.length &&\n            dbBatch.mutations[i + 1].transform !== undefined;\n        if (hasTransform) {\n            const transformMutation = dbBatch.mutations[i + 1];\n            currentMutation.updateTransforms =\n                transformMutation.transform.fieldTransforms;\n            dbBatch.mutations.splice(i + 1, 1);\n            ++i;\n        }\n    }\n    const mutations = dbBatch.mutations.map(m => fromMutation(localSerializer.remoteSerializer, m));\n    const timestamp = Timestamp.fromMillis(dbBatch.localWriteTimeMs);\n    return new MutationBatch(dbBatch.batchId, timestamp, baseMutations, mutations);\n}\n/** Decodes a DbTarget into TargetData */\nfunction fromDbTarget(dbTarget) {\n    const version = fromDbTimestamp(dbTarget.readTime);\n    const lastLimboFreeSnapshotVersion = dbTarget.lastLimboFreeSnapshotVersion !== undefined\n        ? fromDbTimestamp(dbTarget.lastLimboFreeSnapshotVersion)\n        : SnapshotVersion.min();\n    let target;\n    if (isDocumentQuery(dbTarget.query)) {\n        target = fromDocumentsTarget(dbTarget.query);\n    }\n    else {\n        target = fromQueryTarget(dbTarget.query);\n    }\n    return new TargetData(target, dbTarget.targetId, \"TargetPurposeListen\" /* TargetPurpose.Listen */, dbTarget.lastListenSequenceNumber, version, lastLimboFreeSnapshotVersion, ByteString.fromBase64String(dbTarget.resumeToken));\n}\n/** Encodes TargetData into a DbTarget for storage locally. */\nfunction toDbTarget(localSerializer, targetData) {\n    const dbTimestamp = toDbTimestamp(targetData.snapshotVersion);\n    const dbLastLimboFreeTimestamp = toDbTimestamp(targetData.lastLimboFreeSnapshotVersion);\n    let queryProto;\n    if (targetIsDocumentTarget(targetData.target)) {\n        queryProto = toDocumentsTarget(localSerializer.remoteSerializer, targetData.target);\n    }\n    else {\n        queryProto = toQueryTarget(localSerializer.remoteSerializer, targetData.target).queryTarget;\n    }\n    // We can't store the resumeToken as a ByteString in IndexedDb, so we\n    // convert it to a base64 string for storage.\n    const resumeToken = targetData.resumeToken.toBase64();\n    // lastListenSequenceNumber is always 0 until we do real GC.\n    return {\n        targetId: targetData.targetId,\n        canonicalId: canonifyTarget(targetData.target),\n        readTime: dbTimestamp,\n        resumeToken,\n        lastListenSequenceNumber: targetData.sequenceNumber,\n        lastLimboFreeSnapshotVersion: dbLastLimboFreeTimestamp,\n        query: queryProto\n    };\n}\n/**\n * A helper function for figuring out what kind of query has been stored.\n */\nfunction isDocumentQuery(dbQuery) {\n    return dbQuery.documents !== undefined;\n}\n/** Encodes a DbBundle to a BundleMetadata object. */\nfunction fromDbBundle(dbBundle) {\n    return {\n        id: dbBundle.bundleId,\n        createTime: fromDbTimestamp(dbBundle.createTime),\n        version: dbBundle.version\n    };\n}\n/** Encodes a BundleMetadata to a DbBundle. */\nfunction toDbBundle(metadata) {\n    return {\n        bundleId: metadata.id,\n        createTime: toDbTimestamp(fromVersion(metadata.createTime)),\n        version: metadata.version\n    };\n}\n/** Encodes a DbNamedQuery to a NamedQuery. */\nfunction fromDbNamedQuery(dbNamedQuery) {\n    return {\n        name: dbNamedQuery.name,\n        query: fromBundledQuery(dbNamedQuery.bundledQuery),\n        readTime: fromDbTimestamp(dbNamedQuery.readTime)\n    };\n}\n/** Encodes a NamedQuery from a bundle proto to a DbNamedQuery. */\nfunction toDbNamedQuery(query) {\n    return {\n        name: query.name,\n        readTime: toDbTimestamp(fromVersion(query.readTime)),\n        bundledQuery: query.bundledQuery\n    };\n}\n/**\n * Encodes a `BundledQuery` from bundle proto to a Query object.\n *\n * This reconstructs the original query used to build the bundle being loaded,\n * including features exists only in SDKs (for example: limit-to-last).\n */\nfunction fromBundledQuery(bundledQuery) {\n    const query = convertQueryTargetToQuery({\n        parent: bundledQuery.parent,\n        structuredQuery: bundledQuery.structuredQuery\n    });\n    if (bundledQuery.limitType === 'LAST') {\n        return queryWithLimit(query, query.limit, \"L\" /* LimitType.Last */);\n    }\n    return query;\n}\n/** Encodes a NamedQuery proto object to a NamedQuery model object. */\nfunction fromProtoNamedQuery(namedQuery) {\n    return {\n        name: namedQuery.name,\n        query: fromBundledQuery(namedQuery.bundledQuery),\n        readTime: fromVersion(namedQuery.readTime)\n    };\n}\n/** Decodes a BundleMetadata proto into a BundleMetadata object. */\nfunction fromBundleMetadata(metadata) {\n    return {\n        id: metadata.id,\n        version: metadata.version,\n        createTime: fromVersion(metadata.createTime)\n    };\n}\n/** Encodes a DbDocumentOverlay object to an Overlay model object. */\nfunction fromDbDocumentOverlay(localSerializer, dbDocumentOverlay) {\n    return new Overlay(dbDocumentOverlay.largestBatchId, fromMutation(localSerializer.remoteSerializer, dbDocumentOverlay.overlayMutation));\n}\n/** Decodes an Overlay model object into a DbDocumentOverlay object. */\nfunction toDbDocumentOverlay(localSerializer, userId, overlay) {\n    const [_, collectionPath, documentId] = toDbDocumentOverlayKey(userId, overlay.mutation.key);\n    return {\n        userId,\n        collectionPath,\n        documentId,\n        collectionGroup: overlay.mutation.key.getCollectionGroup(),\n        largestBatchId: overlay.largestBatchId,\n        overlayMutation: toMutation(localSerializer.remoteSerializer, overlay.mutation)\n    };\n}\n/**\n * Returns the DbDocumentOverlayKey corresponding to the given user and\n * document key.\n */\nfunction toDbDocumentOverlayKey(userId, docKey) {\n    const docId = docKey.path.lastSegment();\n    const collectionPath = encodeResourcePath(docKey.path.popLast());\n    return [userId, collectionPath, docId];\n}\nfunction toDbIndexConfiguration(index) {\n    return {\n        indexId: index.indexId,\n        collectionGroup: index.collectionGroup,\n        fields: index.fields.map(s => [s.fieldPath.canonicalString(), s.kind])\n    };\n}\nfunction fromDbIndexConfiguration(index, state) {\n    const decodedState = state\n        ? new IndexState(state.sequenceNumber, new IndexOffset(fromDbTimestamp(state.readTime), new DocumentKey(decodeResourcePath(state.documentKey)), state.largestBatchId))\n        : IndexState.empty();\n    const decodedSegments = index.fields.map(([fieldPath, kind]) => new IndexSegment(FieldPath$1.fromServerFormat(fieldPath), kind));\n    return new FieldIndex(index.indexId, index.collectionGroup, decodedSegments, decodedState);\n}\nfunction toDbIndexState(indexId, uid, sequenceNumber, offset) {\n    return {\n        indexId,\n        uid,\n        sequenceNumber,\n        readTime: toDbTimestamp(offset.readTime),\n        documentKey: encodeResourcePath(offset.documentKey.path),\n        largestBatchId: offset.largestBatchId\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass IndexedDbBundleCache {\n    getBundleMetadata(transaction, bundleId) {\n        return bundlesStore(transaction)\n            .get(bundleId)\n            .next(bundle => {\n            if (bundle) {\n                return fromDbBundle(bundle);\n            }\n            return undefined;\n        });\n    }\n    saveBundleMetadata(transaction, bundleMetadata) {\n        return bundlesStore(transaction).put(toDbBundle(bundleMetadata));\n    }\n    getNamedQuery(transaction, queryName) {\n        return namedQueriesStore(transaction)\n            .get(queryName)\n            .next(query => {\n            if (query) {\n                return fromDbNamedQuery(query);\n            }\n            return undefined;\n        });\n    }\n    saveNamedQuery(transaction, query) {\n        return namedQueriesStore(transaction).put(toDbNamedQuery(query));\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the bundles object store.\n */\nfunction bundlesStore(txn) {\n    return getStore(txn, DbBundleStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the namedQueries object store.\n */\nfunction namedQueriesStore(txn) {\n    return getStore(txn, DbNamedQueryStore);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Implementation of DocumentOverlayCache using IndexedDb.\n */\nclass IndexedDbDocumentOverlayCache {\n    /**\n     * @param serializer - The document serializer.\n     * @param userId - The userId for which we are accessing overlays.\n     */\n    constructor(serializer, userId) {\n        this.serializer = serializer;\n        this.userId = userId;\n    }\n    static forUser(serializer, user) {\n        const userId = user.uid || '';\n        return new IndexedDbDocumentOverlayCache(serializer, userId);\n    }\n    getOverlay(transaction, key) {\n        return documentOverlayStore(transaction)\n            .get(toDbDocumentOverlayKey(this.userId, key))\n            .next(dbOverlay => {\n            if (dbOverlay) {\n                return fromDbDocumentOverlay(this.serializer, dbOverlay);\n            }\n            return null;\n        });\n    }\n    getOverlays(transaction, keys) {\n        const result = newOverlayMap();\n        return PersistencePromise.forEach(keys, (key) => {\n            return this.getOverlay(transaction, key).next(overlay => {\n                if (overlay !== null) {\n                    result.set(key, overlay);\n                }\n            });\n        }).next(() => result);\n    }\n    saveOverlays(transaction, largestBatchId, overlays) {\n        const promises = [];\n        overlays.forEach((_, mutation) => {\n            const overlay = new Overlay(largestBatchId, mutation);\n            promises.push(this.saveOverlay(transaction, overlay));\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    removeOverlaysForBatchId(transaction, documentKeys, batchId) {\n        const collectionPaths = new Set();\n        // Get the set of unique collection paths.\n        documentKeys.forEach(key => collectionPaths.add(encodeResourcePath(key.getCollectionPath())));\n        const promises = [];\n        collectionPaths.forEach(collectionPath => {\n            const range = IDBKeyRange.bound([this.userId, collectionPath, batchId], [this.userId, collectionPath, batchId + 1], \n            /*lowerOpen=*/ false, \n            /*upperOpen=*/ true);\n            promises.push(documentOverlayStore(transaction).deleteAll(DbDocumentOverlayCollectionPathOverlayIndex, range));\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    getOverlaysForCollection(transaction, collection, sinceBatchId) {\n        const result = newOverlayMap();\n        const collectionPath = encodeResourcePath(collection);\n        // We want batch IDs larger than `sinceBatchId`, and so the lower bound\n        // is not inclusive.\n        const range = IDBKeyRange.bound([this.userId, collectionPath, sinceBatchId], [this.userId, collectionPath, Number.POSITIVE_INFINITY], \n        /*lowerOpen=*/ true);\n        return documentOverlayStore(transaction)\n            .loadAll(DbDocumentOverlayCollectionPathOverlayIndex, range)\n            .next(dbOverlays => {\n            for (const dbOverlay of dbOverlays) {\n                const overlay = fromDbDocumentOverlay(this.serializer, dbOverlay);\n                result.set(overlay.getKey(), overlay);\n            }\n            return result;\n        });\n    }\n    getOverlaysForCollectionGroup(transaction, collectionGroup, sinceBatchId, count) {\n        const result = newOverlayMap();\n        let currentBatchId = undefined;\n        // We want batch IDs larger than `sinceBatchId`, and so the lower bound\n        // is not inclusive.\n        const range = IDBKeyRange.bound([this.userId, collectionGroup, sinceBatchId], [this.userId, collectionGroup, Number.POSITIVE_INFINITY], \n        /*lowerOpen=*/ true);\n        return documentOverlayStore(transaction)\n            .iterate({\n            index: DbDocumentOverlayCollectionGroupOverlayIndex,\n            range\n        }, (_, dbOverlay, control) => {\n            // We do not want to return partial batch overlays, even if the size\n            // of the result set exceeds the given `count` argument. Therefore, we\n            // continue to aggregate results even after the result size exceeds\n            // `count` if there are more overlays from the `currentBatchId`.\n            const overlay = fromDbDocumentOverlay(this.serializer, dbOverlay);\n            if (result.size() < count ||\n                overlay.largestBatchId === currentBatchId) {\n                result.set(overlay.getKey(), overlay);\n                currentBatchId = overlay.largestBatchId;\n            }\n            else {\n                control.done();\n            }\n        })\n            .next(() => result);\n    }\n    saveOverlay(transaction, overlay) {\n        return documentOverlayStore(transaction).put(toDbDocumentOverlay(this.serializer, this.userId, overlay));\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the document overlay object store.\n */\nfunction documentOverlayStore(txn) {\n    return getStore(txn, DbDocumentOverlayStore);\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass IndexedDbGlobalsCache {\n    globalsStore(txn) {\n        return getStore(txn, DbGlobalsStore);\n    }\n    getSessionToken(txn) {\n        const globals = this.globalsStore(txn);\n        return globals.get('sessionToken').next(global => {\n            const value = global === null || global === void 0 ? void 0 : global.value;\n            return value\n                ? ByteString.fromUint8Array(value)\n                : ByteString.EMPTY_BYTE_STRING;\n        });\n    }\n    setSessionToken(txn, sessionToken) {\n        const globals = this.globalsStore(txn);\n        return globals.put({\n            name: 'sessionToken',\n            value: sessionToken.toUint8Array()\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Note: This code is copied from the backend. Code that is not used by\n// Firestore was removed.\nconst INDEX_TYPE_NULL = 5;\nconst INDEX_TYPE_BOOLEAN = 10;\nconst INDEX_TYPE_NAN = 13;\nconst INDEX_TYPE_NUMBER = 15;\nconst INDEX_TYPE_TIMESTAMP = 20;\nconst INDEX_TYPE_STRING = 25;\nconst INDEX_TYPE_BLOB = 30;\nconst INDEX_TYPE_REFERENCE = 37;\nconst INDEX_TYPE_GEOPOINT = 45;\nconst INDEX_TYPE_ARRAY = 50;\nconst INDEX_TYPE_VECTOR = 53;\nconst INDEX_TYPE_MAP = 55;\nconst INDEX_TYPE_REFERENCE_SEGMENT = 60;\n// A terminator that indicates that a truncatable value was not truncated.\n// This must be smaller than all other type labels.\nconst NOT_TRUNCATED = 2;\n/** Firestore index value writer.  */\nclass FirestoreIndexValueWriter {\n    constructor() { }\n    // The write methods below short-circuit writing terminators for values\n    // containing a (terminating) truncated value.\n    //\n    // As an example, consider the resulting encoding for:\n    //\n    // [\"bar\", [2, \"foo\"]] -> (STRING, \"bar\", TERM, ARRAY, NUMBER, 2, STRING, \"foo\", TERM, TERM, TERM)\n    // [\"bar\", [2, truncated(\"foo\")]] -> (STRING, \"bar\", TERM, ARRAY, NUMBER, 2, STRING, \"foo\", TRUNC)\n    // [\"bar\", truncated([\"foo\"])] -> (STRING, \"bar\", TERM, ARRAY. STRING, \"foo\", TERM, TRUNC)\n    /** Writes an index value.  */\n    writeIndexValue(value, encoder) {\n        this.writeIndexValueAux(value, encoder);\n        // Write separator to split index values\n        // (see go/firestore-storage-format#encodings).\n        encoder.writeInfinity();\n    }\n    writeIndexValueAux(indexValue, encoder) {\n        if ('nullValue' in indexValue) {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_NULL);\n        }\n        else if ('booleanValue' in indexValue) {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_BOOLEAN);\n            encoder.writeNumber(indexValue.booleanValue ? 1 : 0);\n        }\n        else if ('integerValue' in indexValue) {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\n            encoder.writeNumber(normalizeNumber(indexValue.integerValue));\n        }\n        else if ('doubleValue' in indexValue) {\n            const n = normalizeNumber(indexValue.doubleValue);\n            if (isNaN(n)) {\n                this.writeValueTypeLabel(encoder, INDEX_TYPE_NAN);\n            }\n            else {\n                this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\n                if (isNegativeZero(n)) {\n                    // -0.0, 0 and 0.0 are all considered the same\n                    encoder.writeNumber(0.0);\n                }\n                else {\n                    encoder.writeNumber(n);\n                }\n            }\n        }\n        else if ('timestampValue' in indexValue) {\n            let timestamp = indexValue.timestampValue;\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_TIMESTAMP);\n            if (typeof timestamp === 'string') {\n                timestamp = normalizeTimestamp(timestamp);\n            }\n            encoder.writeString(`${timestamp.seconds || ''}`);\n            encoder.writeNumber(timestamp.nanos || 0);\n        }\n        else if ('stringValue' in indexValue) {\n            this.writeIndexString(indexValue.stringValue, encoder);\n            this.writeTruncationMarker(encoder);\n        }\n        else if ('bytesValue' in indexValue) {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_BLOB);\n            encoder.writeBytes(normalizeByteString(indexValue.bytesValue));\n            this.writeTruncationMarker(encoder);\n        }\n        else if ('referenceValue' in indexValue) {\n            this.writeIndexEntityRef(indexValue.referenceValue, encoder);\n        }\n        else if ('geoPointValue' in indexValue) {\n            const geoPoint = indexValue.geoPointValue;\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_GEOPOINT);\n            encoder.writeNumber(geoPoint.latitude || 0);\n            encoder.writeNumber(geoPoint.longitude || 0);\n        }\n        else if ('mapValue' in indexValue) {\n            if (isMaxValue(indexValue)) {\n                this.writeValueTypeLabel(encoder, Number.MAX_SAFE_INTEGER);\n            }\n            else if (isVectorValue(indexValue)) {\n                this.writeIndexVector(indexValue.mapValue, encoder);\n            }\n            else {\n                this.writeIndexMap(indexValue.mapValue, encoder);\n                this.writeTruncationMarker(encoder);\n            }\n        }\n        else if ('arrayValue' in indexValue) {\n            this.writeIndexArray(indexValue.arrayValue, encoder);\n            this.writeTruncationMarker(encoder);\n        }\n        else {\n            fail();\n        }\n    }\n    writeIndexString(stringIndexValue, encoder) {\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_STRING);\n        this.writeUnlabeledIndexString(stringIndexValue, encoder);\n    }\n    writeUnlabeledIndexString(stringIndexValue, encoder) {\n        encoder.writeString(stringIndexValue);\n    }\n    writeIndexMap(mapIndexValue, encoder) {\n        const map = mapIndexValue.fields || {};\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_MAP);\n        for (const key of Object.keys(map)) {\n            this.writeIndexString(key, encoder);\n            this.writeIndexValueAux(map[key], encoder);\n        }\n    }\n    writeIndexVector(mapIndexValue, encoder) {\n        var _a, _b;\n        const map = mapIndexValue.fields || {};\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_VECTOR);\n        // Vectors sort first by length\n        const key = VECTOR_MAP_VECTORS_KEY;\n        const length = ((_b = (_a = map[key].arrayValue) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b.length) || 0;\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\n        encoder.writeNumber(normalizeNumber(length));\n        // Vectors then sort by position value\n        this.writeIndexString(key, encoder);\n        this.writeIndexValueAux(map[key], encoder);\n    }\n    writeIndexArray(arrayIndexValue, encoder) {\n        const values = arrayIndexValue.values || [];\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_ARRAY);\n        for (const element of values) {\n            this.writeIndexValueAux(element, encoder);\n        }\n    }\n    writeIndexEntityRef(referenceValue, encoder) {\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_REFERENCE);\n        const path = DocumentKey.fromName(referenceValue).path;\n        path.forEach(segment => {\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_REFERENCE_SEGMENT);\n            this.writeUnlabeledIndexString(segment, encoder);\n        });\n    }\n    writeValueTypeLabel(encoder, typeOrder) {\n        encoder.writeNumber(typeOrder);\n    }\n    writeTruncationMarker(encoder) {\n        // While the SDK does not implement truncation, the truncation marker is\n        // used to terminate all variable length values (which are strings, bytes,\n        // references, arrays and maps).\n        encoder.writeNumber(NOT_TRUNCATED);\n    }\n}\nFirestoreIndexValueWriter.INSTANCE = new FirestoreIndexValueWriter();\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law | agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES | CONDITIONS OF ANY KIND, either express | implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** These constants are taken from the backend. */\nconst MIN_SURROGATE = '\\uD800';\nconst MAX_SURROGATE = '\\uDBFF';\nconst ESCAPE1 = 0x00;\nconst NULL_BYTE = 0xff; // Combined with ESCAPE1\nconst SEPARATOR = 0x01; // Combined with ESCAPE1\nconst ESCAPE2 = 0xff;\nconst INFINITY = 0xff; // Combined with ESCAPE2\nconst FF_BYTE = 0x00; // Combined with ESCAPE2\nconst LONG_SIZE = 64;\nconst BYTE_SIZE = 8;\n/**\n * The default size of the buffer. This is arbitrary, but likely larger than\n * most index values so that less copies of the underlying buffer will be made.\n * For large values, a single copy will made to double the buffer length.\n */\nconst DEFAULT_BUFFER_SIZE = 1024;\n/** Converts a JavaScript number to a byte array (using big endian encoding). */\nfunction doubleToLongBits(value) {\n    const dv = new DataView(new ArrayBuffer(8));\n    dv.setFloat64(0, value, /* littleEndian= */ false);\n    return new Uint8Array(dv.buffer);\n}\n/**\n * Counts the number of zeros in a byte.\n *\n * Visible for testing.\n */\nfunction numberOfLeadingZerosInByte(x) {\n    if (x === 0) {\n        return 8;\n    }\n    let zeros = 0;\n    if (x >> 4 === 0) {\n        // Test if the first four bits are zero.\n        zeros += 4;\n        x = x << 4;\n    }\n    if (x >> 6 === 0) {\n        // Test if the first two (or next two) bits are zero.\n        zeros += 2;\n        x = x << 2;\n    }\n    if (x >> 7 === 0) {\n        // Test if the remaining bit is zero.\n        zeros += 1;\n    }\n    return zeros;\n}\n/** Counts the number of leading zeros in the given byte array. */\nfunction numberOfLeadingZeros(bytes) {\n    let leadingZeros = 0;\n    for (let i = 0; i < 8; ++i) {\n        const zeros = numberOfLeadingZerosInByte(bytes[i] & 0xff);\n        leadingZeros += zeros;\n        if (zeros !== 8) {\n            break;\n        }\n    }\n    return leadingZeros;\n}\n/**\n * Returns the number of bytes required to store \"value\". Leading zero bytes\n * are skipped.\n */\nfunction unsignedNumLength(value) {\n    // This is just the number of bytes for the unsigned representation of the number.\n    const numBits = LONG_SIZE - numberOfLeadingZeros(value);\n    return Math.ceil(numBits / BYTE_SIZE);\n}\n/**\n * OrderedCodeWriter is a minimal-allocation implementation of the writing\n * behavior defined by the backend.\n *\n * The code is ported from its Java counterpart.\n */\nclass OrderedCodeWriter {\n    constructor() {\n        this.buffer = new Uint8Array(DEFAULT_BUFFER_SIZE);\n        this.position = 0;\n    }\n    writeBytesAscending(value) {\n        const it = value[Symbol.iterator]();\n        let byte = it.next();\n        while (!byte.done) {\n            this.writeByteAscending(byte.value);\n            byte = it.next();\n        }\n        this.writeSeparatorAscending();\n    }\n    writeBytesDescending(value) {\n        const it = value[Symbol.iterator]();\n        let byte = it.next();\n        while (!byte.done) {\n            this.writeByteDescending(byte.value);\n            byte = it.next();\n        }\n        this.writeSeparatorDescending();\n    }\n    /** Writes utf8 bytes into this byte sequence, ascending. */\n    writeUtf8Ascending(sequence) {\n        for (const c of sequence) {\n            const charCode = c.charCodeAt(0);\n            if (charCode < 0x80) {\n                this.writeByteAscending(charCode);\n            }\n            else if (charCode < 0x800) {\n                this.writeByteAscending((0x0f << 6) | (charCode >>> 6));\n                this.writeByteAscending(0x80 | (0x3f & charCode));\n            }\n            else if (c < MIN_SURROGATE || MAX_SURROGATE < c) {\n                this.writeByteAscending((0x0f << 5) | (charCode >>> 12));\n                this.writeByteAscending(0x80 | (0x3f & (charCode >>> 6)));\n                this.writeByteAscending(0x80 | (0x3f & charCode));\n            }\n            else {\n                const codePoint = c.codePointAt(0);\n                this.writeByteAscending((0x0f << 4) | (codePoint >>> 18));\n                this.writeByteAscending(0x80 | (0x3f & (codePoint >>> 12)));\n                this.writeByteAscending(0x80 | (0x3f & (codePoint >>> 6)));\n                this.writeByteAscending(0x80 | (0x3f & codePoint));\n            }\n        }\n        this.writeSeparatorAscending();\n    }\n    /** Writes utf8 bytes into this byte sequence, descending */\n    writeUtf8Descending(sequence) {\n        for (const c of sequence) {\n            const charCode = c.charCodeAt(0);\n            if (charCode < 0x80) {\n                this.writeByteDescending(charCode);\n            }\n            else if (charCode < 0x800) {\n                this.writeByteDescending((0x0f << 6) | (charCode >>> 6));\n                this.writeByteDescending(0x80 | (0x3f & charCode));\n            }\n            else if (c < MIN_SURROGATE || MAX_SURROGATE < c) {\n                this.writeByteDescending((0x0f << 5) | (charCode >>> 12));\n                this.writeByteDescending(0x80 | (0x3f & (charCode >>> 6)));\n                this.writeByteDescending(0x80 | (0x3f & charCode));\n            }\n            else {\n                const codePoint = c.codePointAt(0);\n                this.writeByteDescending((0x0f << 4) | (codePoint >>> 18));\n                this.writeByteDescending(0x80 | (0x3f & (codePoint >>> 12)));\n                this.writeByteDescending(0x80 | (0x3f & (codePoint >>> 6)));\n                this.writeByteDescending(0x80 | (0x3f & codePoint));\n            }\n        }\n        this.writeSeparatorDescending();\n    }\n    writeNumberAscending(val) {\n        // Values are encoded with a single byte length prefix, followed by the\n        // actual value in big-endian format with leading 0 bytes dropped.\n        const value = this.toOrderedBits(val);\n        const len = unsignedNumLength(value);\n        this.ensureAvailable(1 + len);\n        this.buffer[this.position++] = len & 0xff; // Write the length\n        for (let i = value.length - len; i < value.length; ++i) {\n            this.buffer[this.position++] = value[i] & 0xff;\n        }\n    }\n    writeNumberDescending(val) {\n        // Values are encoded with a single byte length prefix, followed by the\n        // inverted value in big-endian format with leading 0 bytes dropped.\n        const value = this.toOrderedBits(val);\n        const len = unsignedNumLength(value);\n        this.ensureAvailable(1 + len);\n        this.buffer[this.position++] = ~(len & 0xff); // Write the length\n        for (let i = value.length - len; i < value.length; ++i) {\n            this.buffer[this.position++] = ~(value[i] & 0xff);\n        }\n    }\n    /**\n     * Writes the \"infinity\" byte sequence that sorts after all other byte\n     * sequences written in ascending order.\n     */\n    writeInfinityAscending() {\n        this.writeEscapedByteAscending(ESCAPE2);\n        this.writeEscapedByteAscending(INFINITY);\n    }\n    /**\n     * Writes the \"infinity\" byte sequence that sorts before all other byte\n     * sequences written in descending order.\n     */\n    writeInfinityDescending() {\n        this.writeEscapedByteDescending(ESCAPE2);\n        this.writeEscapedByteDescending(INFINITY);\n    }\n    /**\n     * Resets the buffer such that it is the same as when it was newly\n     * constructed.\n     */\n    reset() {\n        this.position = 0;\n    }\n    seed(encodedBytes) {\n        this.ensureAvailable(encodedBytes.length);\n        this.buffer.set(encodedBytes, this.position);\n        this.position += encodedBytes.length;\n    }\n    /** Makes a copy of the encoded bytes in this buffer.  */\n    encodedBytes() {\n        return this.buffer.slice(0, this.position);\n    }\n    /**\n     * Encodes `val` into an encoding so that the order matches the IEEE 754\n     * floating-point comparison results with the following exceptions:\n     *   -0.0 < 0.0\n     *   all non-NaN < NaN\n     *   NaN = NaN\n     */\n    toOrderedBits(val) {\n        const value = doubleToLongBits(val);\n        // Check if the first bit is set. We use a bit mask since value[0] is\n        // encoded as a number from 0 to 255.\n        const isNegative = (value[0] & 0x80) !== 0;\n        // Revert the two complement to get natural ordering\n        value[0] ^= isNegative ? 0xff : 0x80;\n        for (let i = 1; i < value.length; ++i) {\n            value[i] ^= isNegative ? 0xff : 0x00;\n        }\n        return value;\n    }\n    /** Writes a single byte ascending to the buffer. */\n    writeByteAscending(b) {\n        const masked = b & 0xff;\n        if (masked === ESCAPE1) {\n            this.writeEscapedByteAscending(ESCAPE1);\n            this.writeEscapedByteAscending(NULL_BYTE);\n        }\n        else if (masked === ESCAPE2) {\n            this.writeEscapedByteAscending(ESCAPE2);\n            this.writeEscapedByteAscending(FF_BYTE);\n        }\n        else {\n            this.writeEscapedByteAscending(masked);\n        }\n    }\n    /** Writes a single byte descending to the buffer.  */\n    writeByteDescending(b) {\n        const masked = b & 0xff;\n        if (masked === ESCAPE1) {\n            this.writeEscapedByteDescending(ESCAPE1);\n            this.writeEscapedByteDescending(NULL_BYTE);\n        }\n        else if (masked === ESCAPE2) {\n            this.writeEscapedByteDescending(ESCAPE2);\n            this.writeEscapedByteDescending(FF_BYTE);\n        }\n        else {\n            this.writeEscapedByteDescending(b);\n        }\n    }\n    writeSeparatorAscending() {\n        this.writeEscapedByteAscending(ESCAPE1);\n        this.writeEscapedByteAscending(SEPARATOR);\n    }\n    writeSeparatorDescending() {\n        this.writeEscapedByteDescending(ESCAPE1);\n        this.writeEscapedByteDescending(SEPARATOR);\n    }\n    writeEscapedByteAscending(b) {\n        this.ensureAvailable(1);\n        this.buffer[this.position++] = b;\n    }\n    writeEscapedByteDescending(b) {\n        this.ensureAvailable(1);\n        this.buffer[this.position++] = ~b;\n    }\n    ensureAvailable(bytes) {\n        const minCapacity = bytes + this.position;\n        if (minCapacity <= this.buffer.length) {\n            return;\n        }\n        // Try doubling.\n        let newLength = this.buffer.length * 2;\n        // Still not big enough? Just allocate the right size.\n        if (newLength < minCapacity) {\n            newLength = minCapacity;\n        }\n        // Create the new buffer.\n        const newBuffer = new Uint8Array(newLength);\n        newBuffer.set(this.buffer); // copy old data\n        this.buffer = newBuffer;\n    }\n}\n\nclass AscendingIndexByteEncoder {\n    constructor(orderedCode) {\n        this.orderedCode = orderedCode;\n    }\n    writeBytes(value) {\n        this.orderedCode.writeBytesAscending(value);\n    }\n    writeString(value) {\n        this.orderedCode.writeUtf8Ascending(value);\n    }\n    writeNumber(value) {\n        this.orderedCode.writeNumberAscending(value);\n    }\n    writeInfinity() {\n        this.orderedCode.writeInfinityAscending();\n    }\n}\nclass DescendingIndexByteEncoder {\n    constructor(orderedCode) {\n        this.orderedCode = orderedCode;\n    }\n    writeBytes(value) {\n        this.orderedCode.writeBytesDescending(value);\n    }\n    writeString(value) {\n        this.orderedCode.writeUtf8Descending(value);\n    }\n    writeNumber(value) {\n        this.orderedCode.writeNumberDescending(value);\n    }\n    writeInfinity() {\n        this.orderedCode.writeInfinityDescending();\n    }\n}\n/**\n * Implements `DirectionalIndexByteEncoder` using `OrderedCodeWriter` for the\n * actual encoding.\n */\nclass IndexByteEncoder {\n    constructor() {\n        this.orderedCode = new OrderedCodeWriter();\n        this.ascending = new AscendingIndexByteEncoder(this.orderedCode);\n        this.descending = new DescendingIndexByteEncoder(this.orderedCode);\n    }\n    seed(encodedBytes) {\n        this.orderedCode.seed(encodedBytes);\n    }\n    forKind(kind) {\n        return kind === 0 /* IndexKind.ASCENDING */ ? this.ascending : this.descending;\n    }\n    encodedBytes() {\n        return this.orderedCode.encodedBytes();\n    }\n    reset() {\n        this.orderedCode.reset();\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Represents an index entry saved by the SDK in persisted storage. */\nclass IndexEntry {\n    constructor(indexId, documentKey, arrayValue, directionalValue) {\n        this.indexId = indexId;\n        this.documentKey = documentKey;\n        this.arrayValue = arrayValue;\n        this.directionalValue = directionalValue;\n    }\n    /**\n     * Returns an IndexEntry entry that sorts immediately after the current\n     * directional value.\n     */\n    successor() {\n        const currentLength = this.directionalValue.length;\n        const newLength = currentLength === 0 || this.directionalValue[currentLength - 1] === 255\n            ? currentLength + 1\n            : currentLength;\n        const successor = new Uint8Array(newLength);\n        successor.set(this.directionalValue, 0);\n        if (newLength !== currentLength) {\n            successor.set([0], this.directionalValue.length);\n        }\n        else {\n            ++successor[successor.length - 1];\n        }\n        return new IndexEntry(this.indexId, this.documentKey, this.arrayValue, successor);\n    }\n}\nfunction indexEntryComparator(left, right) {\n    let cmp = left.indexId - right.indexId;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = compareByteArrays(left.arrayValue, right.arrayValue);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = compareByteArrays(left.directionalValue, right.directionalValue);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return DocumentKey.comparator(left.documentKey, right.documentKey);\n}\nfunction compareByteArrays(left, right) {\n    for (let i = 0; i < left.length && i < right.length; ++i) {\n        const compare = left[i] - right[i];\n        if (compare !== 0) {\n            return compare;\n        }\n    }\n    return left.length - right.length;\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A light query planner for Firestore.\n *\n * This class matches a `FieldIndex` against a Firestore Query `Target`. It\n * determines whether a given index can be used to serve the specified target.\n *\n * The following table showcases some possible index configurations:\n *\n * Query                                               | Index\n * -----------------------------------------------------------------------------\n * where('a', '==', 'a').where('b', '==', 'b')         | a ASC, b DESC\n * where('a', '==', 'a').where('b', '==', 'b')         | a ASC\n * where('a', '==', 'a').where('b', '==', 'b')         | b DESC\n * where('a', '>=', 'a').orderBy('a')                  | a ASC\n * where('a', '>=', 'a').orderBy('a', 'desc')          | a DESC\n * where('a', '>=', 'a').orderBy('a').orderBy('b')     | a ASC, b ASC\n * where('a', '>=', 'a').orderBy('a').orderBy('b')     | a ASC\n * where('a', 'array-contains', 'a').orderBy('b')      | a CONTAINS, b ASCENDING\n * where('a', 'array-contains', 'a').orderBy('b')      | a CONTAINS\n */\nclass TargetIndexMatcher {\n    constructor(target) {\n        // The inequality filters of the target (if it exists).\n        // Note: The sort on FieldFilters is not required. Using SortedSet here just to utilize the custom\n        // comparator.\n        this.inequalityFilters = new SortedSet((lhs, rhs) => FieldPath$1.comparator(lhs.field, rhs.field));\n        this.collectionId =\n            target.collectionGroup != null\n                ? target.collectionGroup\n                : target.path.lastSegment();\n        this.orderBys = target.orderBy;\n        this.equalityFilters = [];\n        for (const filter of target.filters) {\n            const fieldFilter = filter;\n            if (fieldFilter.isInequality()) {\n                this.inequalityFilters = this.inequalityFilters.add(fieldFilter);\n            }\n            else {\n                this.equalityFilters.push(fieldFilter);\n            }\n        }\n    }\n    get hasMultipleInequality() {\n        return this.inequalityFilters.size > 1;\n    }\n    /**\n     * Returns whether the index can be used to serve the TargetIndexMatcher's\n     * target.\n     *\n     * An index is considered capable of serving the target when:\n     * - The target uses all index segments for its filters and orderBy clauses.\n     *   The target can have additional filter and orderBy clauses, but not\n     *   fewer.\n     * - If an ArrayContains/ArrayContainsAnyfilter is used, the index must also\n     *   have a corresponding `CONTAINS` segment.\n     * - All directional index segments can be mapped to the target as a series of\n     *   equality filters, a single inequality filter and a series of orderBy\n     *   clauses.\n     * - The segments that represent the equality filters may appear out of order.\n     * - The optional segment for the inequality filter must appear after all\n     *   equality segments.\n     * - The segments that represent that orderBy clause of the target must appear\n     *   in order after all equality and inequality segments. Single orderBy\n     *   clauses cannot be skipped, but a continuous orderBy suffix may be\n     *   omitted.\n     */\n    servedByIndex(index) {\n        hardAssert(index.collectionGroup === this.collectionId);\n        if (this.hasMultipleInequality) {\n            // Only single inequality is supported for now.\n            // TODO(Add support for multiple inequality query): b/298441043\n            return false;\n        }\n        // If there is an array element, find a matching filter.\n        const arraySegment = fieldIndexGetArraySegment(index);\n        if (arraySegment !== undefined &&\n            !this.hasMatchingEqualityFilter(arraySegment)) {\n            return false;\n        }\n        const segments = fieldIndexGetDirectionalSegments(index);\n        let equalitySegments = new Set();\n        let segmentIndex = 0;\n        let orderBysIndex = 0;\n        // Process all equalities first. Equalities can appear out of order.\n        for (; segmentIndex < segments.length; ++segmentIndex) {\n            // We attempt to greedily match all segments to equality filters. If a\n            // filter matches an index segment, we can mark the segment as used.\n            if (this.hasMatchingEqualityFilter(segments[segmentIndex])) {\n                equalitySegments = equalitySegments.add(segments[segmentIndex].fieldPath.canonicalString());\n            }\n            else {\n                // If we cannot find a matching filter, we need to verify whether the\n                // remaining segments map to the target's inequality and its orderBy\n                // clauses.\n                break;\n            }\n        }\n        // If we already have processed all segments, all segments are used to serve\n        // the equality filters and we do not need to map any segments to the\n        // target's inequality and orderBy clauses.\n        if (segmentIndex === segments.length) {\n            return true;\n        }\n        if (this.inequalityFilters.size > 0) {\n            // Only a single inequality is currently supported. Get the only entry in the set.\n            const inequalityFilter = this.inequalityFilters.getIterator().getNext();\n            // If there is an inequality filter and the field was not in one of the\n            // equality filters above, the next segment must match both the filter\n            // and the first orderBy clause.\n            if (!equalitySegments.has(inequalityFilter.field.canonicalString())) {\n                const segment = segments[segmentIndex];\n                if (!this.matchesFilter(inequalityFilter, segment) ||\n                    !this.matchesOrderBy(this.orderBys[orderBysIndex++], segment)) {\n                    return false;\n                }\n            }\n            ++segmentIndex;\n        }\n        // All remaining segments need to represent the prefix of the target's\n        // orderBy.\n        for (; segmentIndex < segments.length; ++segmentIndex) {\n            const segment = segments[segmentIndex];\n            if (orderBysIndex >= this.orderBys.length ||\n                !this.matchesOrderBy(this.orderBys[orderBysIndex++], segment)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns a full matched field index for this target. Currently multiple\n     * inequality query is not supported so function returns null.\n     */\n    buildTargetIndex() {\n        if (this.hasMultipleInequality) {\n            return null;\n        }\n        // We want to make sure only one segment created for one field. For example,\n        // in case like a == 3 and a > 2, Index {a ASCENDING} will only be created\n        // once.\n        let uniqueFields = new SortedSet(FieldPath$1.comparator);\n        const segments = [];\n        for (const filter of this.equalityFilters) {\n            if (filter.field.isKeyField()) {\n                continue;\n            }\n            const isArrayOperator = filter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\n                filter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\n            if (isArrayOperator) {\n                segments.push(new IndexSegment(filter.field, 2 /* IndexKind.CONTAINS */));\n            }\n            else {\n                if (uniqueFields.has(filter.field)) {\n                    continue;\n                }\n                uniqueFields = uniqueFields.add(filter.field);\n                segments.push(new IndexSegment(filter.field, 0 /* IndexKind.ASCENDING */));\n            }\n        }\n        // Note: We do not explicitly check `this.inequalityFilter` but rather rely\n        // on the target defining an appropriate \"order by\" to ensure that the\n        // required index segment is added. The query engine would reject a query\n        // with an inequality filter that lacks the required order-by clause.\n        for (const orderBy of this.orderBys) {\n            // Stop adding more segments if we see a order-by on key. Typically this\n            // is the default implicit order-by which is covered in the index_entry\n            // table as a separate column. If it is not the default order-by, the\n            // generated index will be missing some segments optimized for order-bys,\n            // which is probably fine.\n            if (orderBy.field.isKeyField()) {\n                continue;\n            }\n            if (uniqueFields.has(orderBy.field)) {\n                continue;\n            }\n            uniqueFields = uniqueFields.add(orderBy.field);\n            segments.push(new IndexSegment(orderBy.field, orderBy.dir === \"asc\" /* Direction.ASCENDING */\n                ? 0 /* IndexKind.ASCENDING */\n                : 1 /* IndexKind.DESCENDING */));\n        }\n        return new FieldIndex(FieldIndex.UNKNOWN_ID, this.collectionId, segments, IndexState.empty());\n    }\n    hasMatchingEqualityFilter(segment) {\n        for (const filter of this.equalityFilters) {\n            if (this.matchesFilter(filter, segment)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    matchesFilter(filter, segment) {\n        if (filter === undefined || !filter.field.isEqual(segment.fieldPath)) {\n            return false;\n        }\n        const isArrayOperator = filter.op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ ||\n            filter.op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */;\n        return (segment.kind === 2 /* IndexKind.CONTAINS */) === isArrayOperator;\n    }\n    matchesOrderBy(orderBy, segment) {\n        if (!orderBy.field.isEqual(segment.fieldPath)) {\n            return false;\n        }\n        return ((segment.kind === 0 /* IndexKind.ASCENDING */ &&\n            orderBy.dir === \"asc\" /* Direction.ASCENDING */) ||\n            (segment.kind === 1 /* IndexKind.DESCENDING */ &&\n                orderBy.dir === \"desc\" /* Direction.DESCENDING */));\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides utility functions that help with boolean logic transformations needed for handling\n * complex filters used in queries.\n */\n/**\n * The `in` filter is only a syntactic sugar over a disjunction of equalities. For instance: `a in\n * [1,2,3]` is in fact `a==1 || a==2 || a==3`. This method expands any `in` filter in the given\n * input into a disjunction of equality filters and returns the expanded filter.\n */\nfunction computeInExpansion(filter) {\n    var _a, _b;\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter);\n    if (filter instanceof FieldFilter) {\n        if (filter instanceof InFilter) {\n            const expandedFilters = ((_b = (_a = filter.value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b.map(value => FieldFilter.create(filter.field, \"==\" /* Operator.EQUAL */, value))) || [];\n            return CompositeFilter.create(expandedFilters, \"or\" /* CompositeOperator.OR */);\n        }\n        else {\n            // We have reached other kinds of field filters.\n            return filter;\n        }\n    }\n    // We have a composite filter.\n    const expandedFilters = filter.filters.map(subfilter => computeInExpansion(subfilter));\n    return CompositeFilter.create(expandedFilters, filter.op);\n}\n/**\n * Given a composite filter, returns the list of terms in its disjunctive normal form.\n *\n * <p>Each element in the return value is one term of the resulting DNF. For instance: For the\n * input: (A || B) && C, the DNF form is: (A && C) || (B && C), and the return value is a list\n * with two elements: a composite filter that performs (A && C), and a composite filter that\n * performs (B && C).\n *\n * @param filter the composite filter to calculate DNF transform for.\n * @return the terms in the DNF transform.\n */\nfunction getDnfTerms(filter) {\n    if (filter.getFilters().length === 0) {\n        return [];\n    }\n    const result = computeDistributedNormalForm(computeInExpansion(filter));\n    hardAssert(isDisjunctiveNormalForm(result));\n    if (isSingleFieldFilter(result) || isFlatConjunction(result)) {\n        return [result];\n    }\n    return result.getFilters();\n}\n/** Returns true if the given filter is a single field filter. e.g. (a == 10). */\nfunction isSingleFieldFilter(filter) {\n    return filter instanceof FieldFilter;\n}\n/**\n * Returns true if the given filter is the conjunction of one or more field filters. e.g. (a == 10\n * && b == 20)\n */\nfunction isFlatConjunction(filter) {\n    return (filter instanceof CompositeFilter &&\n        compositeFilterIsFlatConjunction(filter));\n}\n/**\n * Returns whether or not the given filter is in disjunctive normal form (DNF).\n *\n * <p>In boolean logic, a disjunctive normal form (DNF) is a canonical normal form of a logical\n * formula consisting of a disjunction of conjunctions; it can also be described as an OR of ANDs.\n *\n * <p>For more info, visit: https://en.wikipedia.org/wiki/Disjunctive_normal_form\n */\nfunction isDisjunctiveNormalForm(filter) {\n    return (isSingleFieldFilter(filter) ||\n        isFlatConjunction(filter) ||\n        isDisjunctionOfFieldFiltersAndFlatConjunctions(filter));\n}\n/**\n * Returns true if the given filter is the disjunction of one or more \"flat conjunctions\" and\n * field filters. e.g. (a == 10) || (b==20 && c==30)\n */\nfunction isDisjunctionOfFieldFiltersAndFlatConjunctions(filter) {\n    if (filter instanceof CompositeFilter) {\n        if (compositeFilterIsDisjunction(filter)) {\n            for (const subFilter of filter.getFilters()) {\n                if (!isSingleFieldFilter(subFilter) && !isFlatConjunction(subFilter)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction computeDistributedNormalForm(filter) {\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter);\n    if (filter instanceof FieldFilter) {\n        return filter;\n    }\n    if (filter.filters.length === 1) {\n        return computeDistributedNormalForm(filter.filters[0]);\n    }\n    // Compute DNF for each of the subfilters first\n    const result = filter.filters.map(subfilter => computeDistributedNormalForm(subfilter));\n    let newFilter = CompositeFilter.create(result, filter.op);\n    newFilter = applyAssociation(newFilter);\n    if (isDisjunctiveNormalForm(newFilter)) {\n        return newFilter;\n    }\n    hardAssert(newFilter instanceof CompositeFilter);\n    hardAssert(compositeFilterIsConjunction(newFilter));\n    hardAssert(newFilter.filters.length > 1);\n    return newFilter.filters.reduce((runningResult, filter) => applyDistribution(runningResult, filter));\n}\nfunction applyDistribution(lhs, rhs) {\n    hardAssert(lhs instanceof FieldFilter || lhs instanceof CompositeFilter);\n    hardAssert(rhs instanceof FieldFilter || rhs instanceof CompositeFilter);\n    let result;\n    if (lhs instanceof FieldFilter) {\n        if (rhs instanceof FieldFilter) {\n            // FieldFilter FieldFilter\n            result = applyDistributionFieldFilters(lhs, rhs);\n        }\n        else {\n            // FieldFilter CompositeFilter\n            result = applyDistributionFieldAndCompositeFilters(lhs, rhs);\n        }\n    }\n    else {\n        if (rhs instanceof FieldFilter) {\n            // CompositeFilter FieldFilter\n            result = applyDistributionFieldAndCompositeFilters(rhs, lhs);\n        }\n        else {\n            // CompositeFilter CompositeFilter\n            result = applyDistributionCompositeFilters(lhs, rhs);\n        }\n    }\n    return applyAssociation(result);\n}\nfunction applyDistributionFieldFilters(lhs, rhs) {\n    // Conjunction distribution for two field filters is the conjunction of them.\n    return CompositeFilter.create([lhs, rhs], \"and\" /* CompositeOperator.AND */);\n}\nfunction applyDistributionCompositeFilters(lhs, rhs) {\n    hardAssert(lhs.filters.length > 0 && rhs.filters.length > 0);\n    // There are four cases:\n    // (A & B) & (C & D) --> (A & B & C & D)\n    // (A & B) & (C | D) --> (A & B & C) | (A & B & D)\n    // (A | B) & (C & D) --> (C & D & A) | (C & D & B)\n    // (A | B) & (C | D) --> (A & C) | (A & D) | (B & C) | (B & D)\n    // Case 1 is a merge.\n    if (compositeFilterIsConjunction(lhs) && compositeFilterIsConjunction(rhs)) {\n        return compositeFilterWithAddedFilters(lhs, rhs.getFilters());\n    }\n    // Case 2,3,4 all have at least one side (lhs or rhs) that is a disjunction. In all three cases\n    // we should take each element of the disjunction and distribute it over the other side, and\n    // return the disjunction of the distribution results.\n    const disjunctionSide = compositeFilterIsDisjunction(lhs) ? lhs : rhs;\n    const otherSide = compositeFilterIsDisjunction(lhs) ? rhs : lhs;\n    const results = disjunctionSide.filters.map(subfilter => applyDistribution(subfilter, otherSide));\n    return CompositeFilter.create(results, \"or\" /* CompositeOperator.OR */);\n}\nfunction applyDistributionFieldAndCompositeFilters(fieldFilter, compositeFilter) {\n    // There are two cases:\n    // A & (B & C) --> (A & B & C)\n    // A & (B | C) --> (A & B) | (A & C)\n    if (compositeFilterIsConjunction(compositeFilter)) {\n        // Case 1\n        return compositeFilterWithAddedFilters(compositeFilter, fieldFilter.getFilters());\n    }\n    else {\n        // Case 2\n        const newFilters = compositeFilter.filters.map(subfilter => applyDistribution(fieldFilter, subfilter));\n        return CompositeFilter.create(newFilters, \"or\" /* CompositeOperator.OR */);\n    }\n}\n/**\n * Applies the associativity property to the given filter and returns the resulting filter.\n *\n * <ul>\n *   <li>A | (B | C) == (A | B) | C == (A | B | C)\n *   <li>A & (B & C) == (A & B) & C == (A & B & C)\n * </ul>\n *\n * <p>For more info, visit: https://en.wikipedia.org/wiki/Associative_property#Propositional_logic\n */\nfunction applyAssociation(filter) {\n    hardAssert(filter instanceof FieldFilter || filter instanceof CompositeFilter);\n    if (filter instanceof FieldFilter) {\n        return filter;\n    }\n    const filters = filter.getFilters();\n    // If the composite filter only contains 1 filter, apply associativity to it.\n    if (filters.length === 1) {\n        return applyAssociation(filters[0]);\n    }\n    // Associativity applied to a flat composite filter results is itself.\n    if (compositeFilterIsFlat(filter)) {\n        return filter;\n    }\n    // First apply associativity to all subfilters. This will in turn recursively apply\n    // associativity to all nested composite filters and field filters.\n    const updatedFilters = filters.map(subfilter => applyAssociation(subfilter));\n    // For composite subfilters that perform the same kind of logical operation as `compositeFilter`\n    // take out their filters and add them to `compositeFilter`. For example:\n    // compositeFilter = (A | (B | C | D))\n    // compositeSubfilter = (B | C | D)\n    // Result: (A | B | C | D)\n    // Note that the `compositeSubfilter` has been eliminated, and its filters (B, C, D) have been\n    // added to the top-level \"compositeFilter\".\n    const newSubfilters = [];\n    updatedFilters.forEach(subfilter => {\n        if (subfilter instanceof FieldFilter) {\n            newSubfilters.push(subfilter);\n        }\n        else if (subfilter instanceof CompositeFilter) {\n            if (subfilter.op === filter.op) {\n                // compositeFilter: (A | (B | C))\n                // compositeSubfilter: (B | C)\n                // Result: (A | B | C)\n                newSubfilters.push(...subfilter.filters);\n            }\n            else {\n                // compositeFilter: (A | (B & C))\n                // compositeSubfilter: (B & C)\n                // Result: (A | (B & C))\n                newSubfilters.push(subfilter);\n            }\n        }\n    });\n    if (newSubfilters.length === 1) {\n        return newSubfilters[0];\n    }\n    return CompositeFilter.create(newSubfilters, filter.op);\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An in-memory implementation of IndexManager.\n */\nclass MemoryIndexManager {\n    constructor() {\n        this.collectionParentIndex = new MemoryCollectionParentIndex();\n    }\n    addToCollectionParentIndex(transaction, collectionPath) {\n        this.collectionParentIndex.add(collectionPath);\n        return PersistencePromise.resolve();\n    }\n    getCollectionParents(transaction, collectionId) {\n        return PersistencePromise.resolve(this.collectionParentIndex.getEntries(collectionId));\n    }\n    addFieldIndex(transaction, index) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    deleteFieldIndex(transaction, index) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    deleteAllFieldIndexes(transaction) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    createTargetIndexes(transaction, target) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    getDocumentsMatchingTarget(transaction, target) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve(null);\n    }\n    getIndexType(transaction, target) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve(0 /* IndexType.NONE */);\n    }\n    getFieldIndexes(transaction, collectionGroup) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve([]);\n    }\n    getNextCollectionGroupToUpdate(transaction) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve(null);\n    }\n    getMinOffset(transaction, target) {\n        return PersistencePromise.resolve(IndexOffset.min());\n    }\n    getMinOffsetFromCollectionGroup(transaction, collectionGroup) {\n        return PersistencePromise.resolve(IndexOffset.min());\n    }\n    updateCollectionGroup(transaction, collectionGroup, offset) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n    updateIndexEntries(transaction, documents) {\n        // Field indices are not supported with memory persistence.\n        return PersistencePromise.resolve();\n    }\n}\n/**\n * Internal implementation of the collection-parent index exposed by MemoryIndexManager.\n * Also used for in-memory caching by IndexedDbIndexManager and initial index population\n * in indexeddb_schema.ts\n */\nclass MemoryCollectionParentIndex {\n    constructor() {\n        this.index = {};\n    }\n    // Returns false if the entry already existed.\n    add(collectionPath) {\n        const collectionId = collectionPath.lastSegment();\n        const parentPath = collectionPath.popLast();\n        const existingParents = this.index[collectionId] ||\n            new SortedSet(ResourcePath.comparator);\n        const added = !existingParents.has(parentPath);\n        this.index[collectionId] = existingParents.add(parentPath);\n        return added;\n    }\n    has(collectionPath) {\n        const collectionId = collectionPath.lastSegment();\n        const parentPath = collectionPath.popLast();\n        const existingParents = this.index[collectionId];\n        return existingParents && existingParents.has(parentPath);\n    }\n    getEntries(collectionId) {\n        const parentPaths = this.index[collectionId] ||\n            new SortedSet(ResourcePath.comparator);\n        return parentPaths.toArray();\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$f = 'IndexedDbIndexManager';\nconst EMPTY_VALUE = new Uint8Array(0);\n/**\n * A persisted implementation of IndexManager.\n *\n * PORTING NOTE: Unlike iOS and Android, the Web SDK does not memoize index\n * data as it supports multi-tab access.\n */\nclass IndexedDbIndexManager {\n    constructor(user, databaseId) {\n        this.databaseId = databaseId;\n        /**\n         * An in-memory copy of the index entries we've already written since the SDK\n         * launched. Used to avoid re-writing the same entry repeatedly.\n         *\n         * This is *NOT* a complete cache of what's in persistence and so can never be\n         * used to satisfy reads.\n         */\n        this.collectionParentsCache = new MemoryCollectionParentIndex();\n        /**\n         * Maps from a target to its equivalent list of sub-targets. Each sub-target\n         * contains only one term from the target's disjunctive normal form (DNF).\n         */\n        this.targetToDnfSubTargets = new ObjectMap(t => canonifyTarget(t), (l, r) => targetEquals(l, r));\n        this.uid = user.uid || '';\n    }\n    /**\n     * Adds a new entry to the collection parent index.\n     *\n     * Repeated calls for the same collectionPath should be avoided within a\n     * transaction as IndexedDbIndexManager only caches writes once a transaction\n     * has been committed.\n     */\n    addToCollectionParentIndex(transaction, collectionPath) {\n        if (!this.collectionParentsCache.has(collectionPath)) {\n            const collectionId = collectionPath.lastSegment();\n            const parentPath = collectionPath.popLast();\n            transaction.addOnCommittedListener(() => {\n                // Add the collection to the in memory cache only if the transaction was\n                // successfully committed.\n                this.collectionParentsCache.add(collectionPath);\n            });\n            const collectionParent = {\n                collectionId,\n                parent: encodeResourcePath(parentPath)\n            };\n            return collectionParentsStore(transaction).put(collectionParent);\n        }\n        return PersistencePromise.resolve();\n    }\n    getCollectionParents(transaction, collectionId) {\n        const parentPaths = [];\n        const range = IDBKeyRange.bound([collectionId, ''], [immediateSuccessor(collectionId), ''], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        return collectionParentsStore(transaction)\n            .loadAll(range)\n            .next(entries => {\n            for (const entry of entries) {\n                // This collectionId guard shouldn't be necessary (and isn't as long\n                // as we're running in a real browser), but there's a bug in\n                // indexeddbshim that breaks our range in our tests running in node:\n                // https://github.com/axemclion/IndexedDBShim/issues/334\n                if (entry.collectionId !== collectionId) {\n                    break;\n                }\n                parentPaths.push(decodeResourcePath(entry.parent));\n            }\n            return parentPaths;\n        });\n    }\n    addFieldIndex(transaction, index) {\n        // TODO(indexing): Verify that the auto-incrementing index ID works in\n        // Safari & Firefox.\n        const indexes = indexConfigurationStore(transaction);\n        const dbIndex = toDbIndexConfiguration(index);\n        delete dbIndex.indexId; // `indexId` is auto-populated by IndexedDb\n        const result = indexes.add(dbIndex);\n        if (index.indexState) {\n            const states = indexStateStore(transaction);\n            return result.next(indexId => {\n                states.put(toDbIndexState(indexId, this.uid, index.indexState.sequenceNumber, index.indexState.offset));\n            });\n        }\n        else {\n            return result.next();\n        }\n    }\n    deleteFieldIndex(transaction, index) {\n        const indexes = indexConfigurationStore(transaction);\n        const states = indexStateStore(transaction);\n        const entries = indexEntriesStore(transaction);\n        return indexes\n            .delete(index.indexId)\n            .next(() => states.delete(IDBKeyRange.bound([index.indexId], [index.indexId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true)))\n            .next(() => entries.delete(IDBKeyRange.bound([index.indexId], [index.indexId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true)));\n    }\n    deleteAllFieldIndexes(transaction) {\n        const indexes = indexConfigurationStore(transaction);\n        const entries = indexEntriesStore(transaction);\n        const states = indexStateStore(transaction);\n        return indexes\n            .deleteAll()\n            .next(() => entries.deleteAll())\n            .next(() => states.deleteAll());\n    }\n    createTargetIndexes(transaction, target) {\n        return PersistencePromise.forEach(this.getSubTargets(target), (subTarget) => {\n            return this.getIndexType(transaction, subTarget).next(type => {\n                if (type === 0 /* IndexType.NONE */ || type === 1 /* IndexType.PARTIAL */) {\n                    const targetIndexMatcher = new TargetIndexMatcher(subTarget);\n                    const fieldIndex = targetIndexMatcher.buildTargetIndex();\n                    if (fieldIndex != null) {\n                        return this.addFieldIndex(transaction, fieldIndex);\n                    }\n                }\n            });\n        });\n    }\n    getDocumentsMatchingTarget(transaction, target) {\n        const indexEntries = indexEntriesStore(transaction);\n        let canServeTarget = true;\n        const indexes = new Map();\n        return PersistencePromise.forEach(this.getSubTargets(target), (subTarget) => {\n            return this.getFieldIndex(transaction, subTarget).next(index => {\n                canServeTarget && (canServeTarget = !!index);\n                indexes.set(subTarget, index);\n            });\n        }).next(() => {\n            if (!canServeTarget) {\n                return PersistencePromise.resolve(null);\n            }\n            else {\n                let existingKeys = documentKeySet();\n                const result = [];\n                return PersistencePromise.forEach(indexes, (index, subTarget) => {\n                    logDebug(LOG_TAG$f, `Using index ${fieldIndexToString(index)} to execute ${canonifyTarget(target)}`);\n                    const arrayValues = targetGetArrayValues(subTarget, index);\n                    const notInValues = targetGetNotInValues(subTarget, index);\n                    const lowerBound = targetGetLowerBound(subTarget, index);\n                    const upperBound = targetGetUpperBound(subTarget, index);\n                    const lowerBoundEncoded = this.encodeBound(index, subTarget, lowerBound);\n                    const upperBoundEncoded = this.encodeBound(index, subTarget, upperBound);\n                    const notInEncoded = this.encodeValues(index, subTarget, notInValues);\n                    const indexRanges = this.generateIndexRanges(index.indexId, arrayValues, lowerBoundEncoded, lowerBound.inclusive, upperBoundEncoded, upperBound.inclusive, notInEncoded);\n                    return PersistencePromise.forEach(indexRanges, (indexRange) => {\n                        return indexEntries\n                            .loadFirst(indexRange, target.limit)\n                            .next(entries => {\n                            entries.forEach(entry => {\n                                const documentKey = DocumentKey.fromSegments(entry.documentKey);\n                                if (!existingKeys.has(documentKey)) {\n                                    existingKeys = existingKeys.add(documentKey);\n                                    result.push(documentKey);\n                                }\n                            });\n                        });\n                    });\n                }).next(() => result);\n            }\n        });\n    }\n    getSubTargets(target) {\n        let subTargets = this.targetToDnfSubTargets.get(target);\n        if (subTargets) {\n            return subTargets;\n        }\n        if (target.filters.length === 0) {\n            subTargets = [target];\n        }\n        else {\n            // There is an implicit AND operation between all the filters stored in the target\n            const dnf = getDnfTerms(CompositeFilter.create(target.filters, \"and\" /* CompositeOperator.AND */));\n            subTargets = dnf.map(term => newTarget(target.path, target.collectionGroup, target.orderBy, term.getFilters(), target.limit, target.startAt, target.endAt));\n        }\n        this.targetToDnfSubTargets.set(target, subTargets);\n        return subTargets;\n    }\n    /**\n     * Constructs a key range query on `DbIndexEntryStore` that unions all\n     * bounds.\n     */\n    generateIndexRanges(indexId, arrayValues, lowerBounds, lowerBoundInclusive, upperBounds, upperBoundInclusive, notInValues) {\n        // The number of total index scans we union together. This is similar to a\n        // distributed normal form, but adapted for array values. We create a single\n        // index range per value in an ARRAY_CONTAINS or ARRAY_CONTAINS_ANY filter\n        // combined with the values from the query bounds.\n        const totalScans = (arrayValues != null ? arrayValues.length : 1) *\n            Math.max(lowerBounds.length, upperBounds.length);\n        const scansPerArrayElement = totalScans / (arrayValues != null ? arrayValues.length : 1);\n        const indexRanges = [];\n        for (let i = 0; i < totalScans; ++i) {\n            const arrayValue = arrayValues\n                ? this.encodeSingleElement(arrayValues[i / scansPerArrayElement])\n                : EMPTY_VALUE;\n            const lowerBound = this.generateLowerBound(indexId, arrayValue, lowerBounds[i % scansPerArrayElement], lowerBoundInclusive);\n            const upperBound = this.generateUpperBound(indexId, arrayValue, upperBounds[i % scansPerArrayElement], upperBoundInclusive);\n            const notInBound = notInValues.map(notIn => this.generateLowerBound(indexId, arrayValue, notIn, \n            /* inclusive= */ true));\n            indexRanges.push(...this.createRange(lowerBound, upperBound, notInBound));\n        }\n        return indexRanges;\n    }\n    /** Generates the lower bound for `arrayValue` and `directionalValue`. */\n    generateLowerBound(indexId, arrayValue, directionalValue, inclusive) {\n        const entry = new IndexEntry(indexId, DocumentKey.empty(), arrayValue, directionalValue);\n        return inclusive ? entry : entry.successor();\n    }\n    /** Generates the upper bound for `arrayValue` and `directionalValue`. */\n    generateUpperBound(indexId, arrayValue, directionalValue, inclusive) {\n        const entry = new IndexEntry(indexId, DocumentKey.empty(), arrayValue, directionalValue);\n        return inclusive ? entry.successor() : entry;\n    }\n    getFieldIndex(transaction, target) {\n        const targetIndexMatcher = new TargetIndexMatcher(target);\n        const collectionGroup = target.collectionGroup != null\n            ? target.collectionGroup\n            : target.path.lastSegment();\n        return this.getFieldIndexes(transaction, collectionGroup).next(indexes => {\n            // Return the index with the most number of segments.\n            let index = null;\n            for (const candidate of indexes) {\n                const matches = targetIndexMatcher.servedByIndex(candidate);\n                if (matches &&\n                    (!index || candidate.fields.length > index.fields.length)) {\n                    index = candidate;\n                }\n            }\n            return index;\n        });\n    }\n    getIndexType(transaction, target) {\n        let indexType = 2 /* IndexType.FULL */;\n        const subTargets = this.getSubTargets(target);\n        return PersistencePromise.forEach(subTargets, (target) => {\n            return this.getFieldIndex(transaction, target).next(index => {\n                if (!index) {\n                    indexType = 0 /* IndexType.NONE */;\n                }\n                else if (indexType !== 0 /* IndexType.NONE */ &&\n                    index.fields.length < targetGetSegmentCount(target)) {\n                    indexType = 1 /* IndexType.PARTIAL */;\n                }\n            });\n        }).next(() => {\n            // OR queries have more than one sub-target (one sub-target per DNF term). We currently consider\n            // OR queries that have a `limit` to have a partial index. For such queries we perform sorting\n            // and apply the limit in memory as a post-processing step.\n            if (targetHasLimit(target) &&\n                subTargets.length > 1 &&\n                indexType === 2 /* IndexType.FULL */) {\n                return 1 /* IndexType.PARTIAL */;\n            }\n            return indexType;\n        });\n    }\n    /**\n     * Returns the byte encoded form of the directional values in the field index.\n     * Returns `null` if the document does not have all fields specified in the\n     * index.\n     */\n    encodeDirectionalElements(fieldIndex, document) {\n        const encoder = new IndexByteEncoder();\n        for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n            const field = document.data.field(segment.fieldPath);\n            if (field == null) {\n                return null;\n            }\n            const directionalEncoder = encoder.forKind(segment.kind);\n            FirestoreIndexValueWriter.INSTANCE.writeIndexValue(field, directionalEncoder);\n        }\n        return encoder.encodedBytes();\n    }\n    /** Encodes a single value to the ascending index format. */\n    encodeSingleElement(value) {\n        const encoder = new IndexByteEncoder();\n        FirestoreIndexValueWriter.INSTANCE.writeIndexValue(value, encoder.forKind(0 /* IndexKind.ASCENDING */));\n        return encoder.encodedBytes();\n    }\n    /**\n     * Returns an encoded form of the document key that sorts based on the key\n     * ordering of the field index.\n     */\n    encodeDirectionalKey(fieldIndex, documentKey) {\n        const encoder = new IndexByteEncoder();\n        FirestoreIndexValueWriter.INSTANCE.writeIndexValue(refValue(this.databaseId, documentKey), encoder.forKind(fieldIndexGetKeyOrder(fieldIndex)));\n        return encoder.encodedBytes();\n    }\n    /**\n     * Encodes the given field values according to the specification in `target`.\n     * For IN queries, a list of possible values is returned.\n     */\n    encodeValues(fieldIndex, target, values) {\n        if (values === null) {\n            return [];\n        }\n        let encoders = [];\n        encoders.push(new IndexByteEncoder());\n        let valueIdx = 0;\n        for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\n            const value = values[valueIdx++];\n            for (const encoder of encoders) {\n                if (this.isInFilter(target, segment.fieldPath) && isArray(value)) {\n                    encoders = this.expandIndexValues(encoders, segment, value);\n                }\n                else {\n                    const directionalEncoder = encoder.forKind(segment.kind);\n                    FirestoreIndexValueWriter.INSTANCE.writeIndexValue(value, directionalEncoder);\n                }\n            }\n        }\n        return this.getEncodedBytes(encoders);\n    }\n    /**\n     * Encodes the given bounds according to the specification in `target`. For IN\n     * queries, a list of possible values is returned.\n     */\n    encodeBound(fieldIndex, target, bound) {\n        return this.encodeValues(fieldIndex, target, bound.position);\n    }\n    /** Returns the byte representation for the provided encoders. */\n    getEncodedBytes(encoders) {\n        const result = [];\n        for (let i = 0; i < encoders.length; ++i) {\n            result[i] = encoders[i].encodedBytes();\n        }\n        return result;\n    }\n    /**\n     * Creates a separate encoder for each element of an array.\n     *\n     * The method appends each value to all existing encoders (e.g. filter(\"a\",\n     * \"==\", \"a1\").filter(\"b\", \"in\", [\"b1\", \"b2\"]) becomes [\"a1,b1\", \"a1,b2\"]). A\n     * list of new encoders is returned.\n     */\n    expandIndexValues(encoders, segment, value) {\n        const prefixes = [...encoders];\n        const results = [];\n        for (const arrayElement of value.arrayValue.values || []) {\n            for (const prefix of prefixes) {\n                const clonedEncoder = new IndexByteEncoder();\n                clonedEncoder.seed(prefix.encodedBytes());\n                FirestoreIndexValueWriter.INSTANCE.writeIndexValue(arrayElement, clonedEncoder.forKind(segment.kind));\n                results.push(clonedEncoder);\n            }\n        }\n        return results;\n    }\n    isInFilter(target, fieldPath) {\n        return !!target.filters.find(f => f instanceof FieldFilter &&\n            f.field.isEqual(fieldPath) &&\n            (f.op === \"in\" /* Operator.IN */ || f.op === \"not-in\" /* Operator.NOT_IN */));\n    }\n    getFieldIndexes(transaction, collectionGroup) {\n        const indexes = indexConfigurationStore(transaction);\n        const states = indexStateStore(transaction);\n        return (collectionGroup\n            ? indexes.loadAll(DbIndexConfigurationCollectionGroupIndex, IDBKeyRange.bound(collectionGroup, collectionGroup))\n            : indexes.loadAll()).next(indexConfigs => {\n            const result = [];\n            return PersistencePromise.forEach(indexConfigs, (indexConfig) => {\n                return states\n                    .get([indexConfig.indexId, this.uid])\n                    .next(indexState => {\n                    result.push(fromDbIndexConfiguration(indexConfig, indexState));\n                });\n            }).next(() => result);\n        });\n    }\n    getNextCollectionGroupToUpdate(transaction) {\n        return this.getFieldIndexes(transaction).next(indexes => {\n            if (indexes.length === 0) {\n                return null;\n            }\n            indexes.sort((l, r) => {\n                const cmp = l.indexState.sequenceNumber - r.indexState.sequenceNumber;\n                return cmp !== 0\n                    ? cmp\n                    : primitiveComparator(l.collectionGroup, r.collectionGroup);\n            });\n            return indexes[0].collectionGroup;\n        });\n    }\n    updateCollectionGroup(transaction, collectionGroup, offset) {\n        const indexes = indexConfigurationStore(transaction);\n        const states = indexStateStore(transaction);\n        return this.getNextSequenceNumber(transaction).next(nextSequenceNumber => indexes\n            .loadAll(DbIndexConfigurationCollectionGroupIndex, IDBKeyRange.bound(collectionGroup, collectionGroup))\n            .next(configs => PersistencePromise.forEach(configs, (config) => states.put(toDbIndexState(config.indexId, this.uid, nextSequenceNumber, offset)))));\n    }\n    updateIndexEntries(transaction, documents) {\n        // Porting Note: `getFieldIndexes()` on Web does not cache index lookups as\n        // it could be used across different IndexedDB transactions. As any cached\n        // data might be invalidated by other multi-tab clients, we can only trust\n        // data within a single IndexedDB transaction. We therefore add a cache\n        // here.\n        const memoizedIndexes = new Map();\n        return PersistencePromise.forEach(documents, (key, doc) => {\n            const memoizedCollectionIndexes = memoizedIndexes.get(key.collectionGroup);\n            const fieldIndexes = memoizedCollectionIndexes\n                ? PersistencePromise.resolve(memoizedCollectionIndexes)\n                : this.getFieldIndexes(transaction, key.collectionGroup);\n            return fieldIndexes.next(fieldIndexes => {\n                memoizedIndexes.set(key.collectionGroup, fieldIndexes);\n                return PersistencePromise.forEach(fieldIndexes, (fieldIndex) => {\n                    return this.getExistingIndexEntries(transaction, key, fieldIndex).next(existingEntries => {\n                        const newEntries = this.computeIndexEntries(doc, fieldIndex);\n                        if (!existingEntries.isEqual(newEntries)) {\n                            return this.updateEntries(transaction, doc, fieldIndex, existingEntries, newEntries);\n                        }\n                        return PersistencePromise.resolve();\n                    });\n                });\n            });\n        });\n    }\n    addIndexEntry(transaction, document, fieldIndex, indexEntry) {\n        const indexEntries = indexEntriesStore(transaction);\n        return indexEntries.put({\n            indexId: indexEntry.indexId,\n            uid: this.uid,\n            arrayValue: indexEntry.arrayValue,\n            directionalValue: indexEntry.directionalValue,\n            orderedDocumentKey: this.encodeDirectionalKey(fieldIndex, document.key),\n            documentKey: document.key.path.toArray()\n        });\n    }\n    deleteIndexEntry(transaction, document, fieldIndex, indexEntry) {\n        const indexEntries = indexEntriesStore(transaction);\n        return indexEntries.delete([\n            indexEntry.indexId,\n            this.uid,\n            indexEntry.arrayValue,\n            indexEntry.directionalValue,\n            this.encodeDirectionalKey(fieldIndex, document.key),\n            document.key.path.toArray()\n        ]);\n    }\n    getExistingIndexEntries(transaction, documentKey, fieldIndex) {\n        const indexEntries = indexEntriesStore(transaction);\n        let results = new SortedSet(indexEntryComparator);\n        return indexEntries\n            .iterate({\n            index: DbIndexEntryDocumentKeyIndex,\n            range: IDBKeyRange.only([\n                fieldIndex.indexId,\n                this.uid,\n                this.encodeDirectionalKey(fieldIndex, documentKey)\n            ])\n        }, (_, entry) => {\n            results = results.add(new IndexEntry(fieldIndex.indexId, documentKey, entry.arrayValue, entry.directionalValue));\n        })\n            .next(() => results);\n    }\n    /** Creates the index entries for the given document. */\n    computeIndexEntries(document, fieldIndex) {\n        let results = new SortedSet(indexEntryComparator);\n        const directionalValue = this.encodeDirectionalElements(fieldIndex, document);\n        if (directionalValue == null) {\n            return results;\n        }\n        const arraySegment = fieldIndexGetArraySegment(fieldIndex);\n        if (arraySegment != null) {\n            const value = document.data.field(arraySegment.fieldPath);\n            if (isArray(value)) {\n                for (const arrayValue of value.arrayValue.values || []) {\n                    results = results.add(new IndexEntry(fieldIndex.indexId, document.key, this.encodeSingleElement(arrayValue), directionalValue));\n                }\n            }\n        }\n        else {\n            results = results.add(new IndexEntry(fieldIndex.indexId, document.key, EMPTY_VALUE, directionalValue));\n        }\n        return results;\n    }\n    /**\n     * Updates the index entries for the provided document by deleting entries\n     * that are no longer referenced in `newEntries` and adding all newly added\n     * entries.\n     */\n    updateEntries(transaction, document, fieldIndex, existingEntries, newEntries) {\n        logDebug(LOG_TAG$f, \"Updating index entries for document '%s'\", document.key);\n        const promises = [];\n        diffSortedSets(existingEntries, newEntries, indexEntryComparator, \n        /* onAdd= */ entry => {\n            promises.push(this.addIndexEntry(transaction, document, fieldIndex, entry));\n        }, \n        /* onRemove= */ entry => {\n            promises.push(this.deleteIndexEntry(transaction, document, fieldIndex, entry));\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    getNextSequenceNumber(transaction) {\n        let nextSequenceNumber = 1;\n        const states = indexStateStore(transaction);\n        return states\n            .iterate({\n            index: DbIndexStateSequenceNumberIndex,\n            reverse: true,\n            range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])\n        }, (_, state, controller) => {\n            controller.done();\n            nextSequenceNumber = state.sequenceNumber + 1;\n        })\n            .next(() => nextSequenceNumber);\n    }\n    /**\n     * Returns a new set of IDB ranges that splits the existing range and excludes\n     * any values that match the `notInValue` from these ranges. As an example,\n     * '[foo > 2 && foo != 3]` becomes  `[foo > 2 && < 3, foo > 3]`.\n     */\n    createRange(lower, upper, notInValues) {\n        // The notIn values need to be sorted and unique so that we can return a\n        // sorted set of non-overlapping ranges.\n        notInValues = notInValues\n            .sort((l, r) => indexEntryComparator(l, r))\n            .filter((el, i, values) => !i || indexEntryComparator(el, values[i - 1]) !== 0);\n        const bounds = [];\n        bounds.push(lower);\n        for (const notInValue of notInValues) {\n            const cmpToLower = indexEntryComparator(notInValue, lower);\n            const cmpToUpper = indexEntryComparator(notInValue, upper);\n            if (cmpToLower === 0) {\n                // `notInValue` is the lower bound. We therefore need to raise the bound\n                // to the next value.\n                bounds[0] = lower.successor();\n            }\n            else if (cmpToLower > 0 && cmpToUpper < 0) {\n                // `notInValue` is in the middle of the range\n                bounds.push(notInValue);\n                bounds.push(notInValue.successor());\n            }\n            else if (cmpToUpper > 0) {\n                // `notInValue` (and all following values) are out of the range\n                break;\n            }\n        }\n        bounds.push(upper);\n        const ranges = [];\n        for (let i = 0; i < bounds.length; i += 2) {\n            // If we encounter two bounds that will create an unmatchable key range,\n            // then we return an empty set of key ranges.\n            if (this.isRangeMatchable(bounds[i], bounds[i + 1])) {\n                return [];\n            }\n            const lowerBound = [\n                bounds[i].indexId,\n                this.uid,\n                bounds[i].arrayValue,\n                bounds[i].directionalValue,\n                EMPTY_VALUE,\n                []\n            ];\n            const upperBound = [\n                bounds[i + 1].indexId,\n                this.uid,\n                bounds[i + 1].arrayValue,\n                bounds[i + 1].directionalValue,\n                EMPTY_VALUE,\n                []\n            ];\n            ranges.push(IDBKeyRange.bound(lowerBound, upperBound));\n        }\n        return ranges;\n    }\n    isRangeMatchable(lowerBound, upperBound) {\n        // If lower bound is greater than the upper bound, then the key\n        // range can never be matched.\n        return indexEntryComparator(lowerBound, upperBound) > 0;\n    }\n    getMinOffsetFromCollectionGroup(transaction, collectionGroup) {\n        return this.getFieldIndexes(transaction, collectionGroup).next(getMinOffsetFromFieldIndexes);\n    }\n    getMinOffset(transaction, target) {\n        return PersistencePromise.mapArray(this.getSubTargets(target), (subTarget) => this.getFieldIndex(transaction, subTarget).next(index => index ? index : fail())).next(getMinOffsetFromFieldIndexes);\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the collectionParents\n * document store.\n */\nfunction collectionParentsStore(txn) {\n    return getStore(txn, DbCollectionParentStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the index entry object store.\n */\nfunction indexEntriesStore(txn) {\n    return getStore(txn, DbIndexEntryStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the index configuration object store.\n */\nfunction indexConfigurationStore(txn) {\n    return getStore(txn, DbIndexConfigurationStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the index state object store.\n */\nfunction indexStateStore(txn) {\n    return getStore(txn, DbIndexStateStore);\n}\nfunction getMinOffsetFromFieldIndexes(fieldIndexes) {\n    hardAssert(fieldIndexes.length !== 0);\n    let minOffset = fieldIndexes[0].indexState.offset;\n    let maxBatchId = minOffset.largestBatchId;\n    for (let i = 1; i < fieldIndexes.length; i++) {\n        const newOffset = fieldIndexes[i].indexState.offset;\n        if (indexOffsetComparator(newOffset, minOffset) < 0) {\n            minOffset = newOffset;\n        }\n        if (maxBatchId < newOffset.largestBatchId) {\n            maxBatchId = newOffset.largestBatchId;\n        }\n    }\n    return new IndexOffset(minOffset.readTime, minOffset.documentKey, maxBatchId);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Delete a mutation batch and the associated document mutations.\n * @returns A PersistencePromise of the document mutations that were removed.\n */\nfunction removeMutationBatch(txn, userId, batch) {\n    const mutationStore = txn.store(DbMutationBatchStore);\n    const indexTxn = txn.store(DbDocumentMutationStore);\n    const promises = [];\n    const range = IDBKeyRange.only(batch.batchId);\n    let numDeleted = 0;\n    const removePromise = mutationStore.iterate({ range }, (key, value, control) => {\n        numDeleted++;\n        return control.delete();\n    });\n    promises.push(removePromise.next(() => {\n        hardAssert(numDeleted === 1);\n    }));\n    const removedDocuments = [];\n    for (const mutation of batch.mutations) {\n        const indexKey = newDbDocumentMutationKey(userId, mutation.key.path, batch.batchId);\n        promises.push(indexTxn.delete(indexKey));\n        removedDocuments.push(mutation.key);\n    }\n    return PersistencePromise.waitFor(promises).next(() => removedDocuments);\n}\n/**\n * Returns an approximate size for the given document.\n */\nfunction dbDocumentSize(doc) {\n    if (!doc) {\n        return 0;\n    }\n    let value;\n    if (doc.document) {\n        value = doc.document;\n    }\n    else if (doc.unknownDocument) {\n        value = doc.unknownDocument;\n    }\n    else if (doc.noDocument) {\n        value = doc.noDocument;\n    }\n    else {\n        throw fail();\n    }\n    return JSON.stringify(value).length;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** A mutation queue for a specific user, backed by IndexedDB. */\nclass IndexedDbMutationQueue {\n    constructor(\n    /**\n     * The normalized userId (e.g. null UID => \"\" userId) used to store /\n     * retrieve mutations.\n     */\n    userId, serializer, indexManager, referenceDelegate) {\n        this.userId = userId;\n        this.serializer = serializer;\n        this.indexManager = indexManager;\n        this.referenceDelegate = referenceDelegate;\n        /**\n         * Caches the document keys for pending mutation batches. If the mutation\n         * has been removed from IndexedDb, the cached value may continue to\n         * be used to retrieve the batch's document keys. To remove a cached value\n         * locally, `removeCachedMutationKeys()` should be invoked either directly\n         * or through `removeMutationBatches()`.\n         *\n         * With multi-tab, when the primary client acknowledges or rejects a mutation,\n         * this cache is used by secondary clients to invalidate the local\n         * view of the documents that were previously affected by the mutation.\n         */\n        // PORTING NOTE: Multi-tab only.\n        this.documentKeysByBatchId = {};\n    }\n    /**\n     * Creates a new mutation queue for the given user.\n     * @param user - The user for which to create a mutation queue.\n     * @param serializer - The serializer to use when persisting to IndexedDb.\n     */\n    static forUser(user, serializer, indexManager, referenceDelegate) {\n        // TODO(mcg): Figure out what constraints there are on userIDs\n        // In particular, are there any reserved characters? are empty ids allowed?\n        // For the moment store these together in the same mutations table assuming\n        // that empty userIDs aren't allowed.\n        hardAssert(user.uid !== '');\n        const userId = user.isAuthenticated() ? user.uid : '';\n        return new IndexedDbMutationQueue(userId, serializer, indexManager, referenceDelegate);\n    }\n    checkEmpty(transaction) {\n        let empty = true;\n        const range = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);\n        return mutationsStore(transaction)\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range }, (key, value, control) => {\n            empty = false;\n            control.done();\n        })\n            .next(() => empty);\n    }\n    addMutationBatch(transaction, localWriteTime, baseMutations, mutations) {\n        const documentStore = documentMutationsStore(transaction);\n        const mutationStore = mutationsStore(transaction);\n        // The IndexedDb implementation in Chrome (and Firefox) does not handle\n        // compound indices that include auto-generated keys correctly. To ensure\n        // that the index entry is added correctly in all browsers, we perform two\n        // writes: The first write is used to retrieve the next auto-generated Batch\n        // ID, and the second write populates the index and stores the actual\n        // mutation batch.\n        // See: https://bugs.chromium.org/p/chromium/issues/detail?id=701972\n        // We write an empty object to obtain key\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return mutationStore.add({}).next(batchId => {\n            hardAssert(typeof batchId === 'number');\n            const batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);\n            const dbBatch = toDbMutationBatch(this.serializer, this.userId, batch);\n            const promises = [];\n            let collectionParents = new SortedSet((l, r) => primitiveComparator(l.canonicalString(), r.canonicalString()));\n            for (const mutation of mutations) {\n                const indexKey = newDbDocumentMutationKey(this.userId, mutation.key.path, batchId);\n                collectionParents = collectionParents.add(mutation.key.path.popLast());\n                promises.push(mutationStore.put(dbBatch));\n                promises.push(documentStore.put(indexKey, DbDocumentMutationPlaceholder));\n            }\n            collectionParents.forEach(parent => {\n                promises.push(this.indexManager.addToCollectionParentIndex(transaction, parent));\n            });\n            transaction.addOnCommittedListener(() => {\n                this.documentKeysByBatchId[batchId] = batch.keys();\n            });\n            return PersistencePromise.waitFor(promises).next(() => batch);\n        });\n    }\n    lookupMutationBatch(transaction, batchId) {\n        return mutationsStore(transaction)\n            .get(batchId)\n            .next(dbBatch => {\n            if (dbBatch) {\n                hardAssert(dbBatch.userId === this.userId);\n                return fromDbMutationBatch(this.serializer, dbBatch);\n            }\n            return null;\n        });\n    }\n    /**\n     * Returns the document keys for the mutation batch with the given batchId.\n     * For primary clients, this method returns `null` after\n     * `removeMutationBatches()` has been called. Secondary clients return a\n     * cached result until `removeCachedMutationKeys()` is invoked.\n     */\n    // PORTING NOTE: Multi-tab only.\n    lookupMutationKeys(transaction, batchId) {\n        if (this.documentKeysByBatchId[batchId]) {\n            return PersistencePromise.resolve(this.documentKeysByBatchId[batchId]);\n        }\n        else {\n            return this.lookupMutationBatch(transaction, batchId).next(batch => {\n                if (batch) {\n                    const keys = batch.keys();\n                    this.documentKeysByBatchId[batchId] = keys;\n                    return keys;\n                }\n                else {\n                    return null;\n                }\n            });\n        }\n    }\n    getNextMutationBatchAfterBatchId(transaction, batchId) {\n        const nextBatchId = batchId + 1;\n        const range = IDBKeyRange.lowerBound([this.userId, nextBatchId]);\n        let foundBatch = null;\n        return mutationsStore(transaction)\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range }, (key, dbBatch, control) => {\n            if (dbBatch.userId === this.userId) {\n                hardAssert(dbBatch.batchId >= nextBatchId);\n                foundBatch = fromDbMutationBatch(this.serializer, dbBatch);\n            }\n            control.done();\n        })\n            .next(() => foundBatch);\n    }\n    getHighestUnacknowledgedBatchId(transaction) {\n        const range = IDBKeyRange.upperBound([\n            this.userId,\n            Number.POSITIVE_INFINITY\n        ]);\n        let batchId = BATCHID_UNKNOWN;\n        return mutationsStore(transaction)\n            .iterate({ index: DbMutationBatchUserMutationsIndex, range, reverse: true }, (key, dbBatch, control) => {\n            batchId = dbBatch.batchId;\n            control.done();\n        })\n            .next(() => batchId);\n    }\n    getAllMutationBatches(transaction) {\n        const range = IDBKeyRange.bound([this.userId, BATCHID_UNKNOWN], [this.userId, Number.POSITIVE_INFINITY]);\n        return mutationsStore(transaction)\n            .loadAll(DbMutationBatchUserMutationsIndex, range)\n            .next(dbBatches => dbBatches.map(dbBatch => fromDbMutationBatch(this.serializer, dbBatch)));\n    }\n    getAllMutationBatchesAffectingDocumentKey(transaction, documentKey) {\n        // Scan the document-mutation index starting with a prefix starting with\n        // the given documentKey.\n        const indexPrefix = newDbDocumentMutationPrefixForPath(this.userId, documentKey.path);\n        const indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        const results = [];\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, (indexKey, _, control) => {\n            const [userID, encodedPath, batchId] = indexKey;\n            // Only consider rows matching exactly the specific key of\n            // interest. Note that because we order by path first, and we\n            // order terminators before path separators, we'll encounter all\n            // the index rows for documentKey contiguously. In particular, all\n            // the rows for documentKey will occur before any rows for\n            // documents nested in a subcollection beneath documentKey so we\n            // can stop as soon as we hit any such row.\n            const path = decodeResourcePath(encodedPath);\n            if (userID !== this.userId || !documentKey.path.isEqual(path)) {\n                control.done();\n                return;\n            }\n            // Look up the mutation batch in the store.\n            return mutationsStore(transaction)\n                .get(batchId)\n                .next(mutation => {\n                if (!mutation) {\n                    throw fail();\n                }\n                hardAssert(mutation.userId === this.userId);\n                results.push(fromDbMutationBatch(this.serializer, mutation));\n            });\n        })\n            .next(() => results);\n    }\n    getAllMutationBatchesAffectingDocumentKeys(transaction, documentKeys) {\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\n        const promises = [];\n        documentKeys.forEach(documentKey => {\n            const indexStart = newDbDocumentMutationPrefixForPath(this.userId, documentKey.path);\n            const range = IDBKeyRange.lowerBound(indexStart);\n            const promise = documentMutationsStore(transaction).iterate({ range }, (indexKey, _, control) => {\n                const [userID, encodedPath, batchID] = indexKey;\n                // Only consider rows matching exactly the specific key of\n                // interest. Note that because we order by path first, and we\n                // order terminators before path separators, we'll encounter all\n                // the index rows for documentKey contiguously. In particular, all\n                // the rows for documentKey will occur before any rows for\n                // documents nested in a subcollection beneath documentKey so we\n                // can stop as soon as we hit any such row.\n                const path = decodeResourcePath(encodedPath);\n                if (userID !== this.userId || !documentKey.path.isEqual(path)) {\n                    control.done();\n                    return;\n                }\n                uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n            });\n            promises.push(promise);\n        });\n        return PersistencePromise.waitFor(promises).next(() => this.lookupMutationBatches(transaction, uniqueBatchIDs));\n    }\n    getAllMutationBatchesAffectingQuery(transaction, query) {\n        const queryPath = query.path;\n        const immediateChildrenLength = queryPath.length + 1;\n        // TODO(mcg): Actually implement a single-collection query\n        //\n        // This is actually executing an ancestor query, traversing the whole\n        // subtree below the collection which can be horrifically inefficient for\n        // some structures. The right way to solve this is to implement the full\n        // value index, but that's not in the cards in the near future so this is\n        // the best we can do for the moment.\n        //\n        // Since we don't yet index the actual properties in the mutations, our\n        // current approach is to just return all mutation batches that affect\n        // documents in the collection being queried.\n        const indexPrefix = newDbDocumentMutationPrefixForPath(this.userId, queryPath);\n        const indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        // Collect up unique batchIDs encountered during a scan of the index. Use a\n        // SortedSet to accumulate batch IDs so they can be traversed in order in a\n        // scan of the main table.\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, (indexKey, _, control) => {\n            const [userID, encodedPath, batchID] = indexKey;\n            const path = decodeResourcePath(encodedPath);\n            if (userID !== this.userId || !queryPath.isPrefixOf(path)) {\n                control.done();\n                return;\n            }\n            // Rows with document keys more than one segment longer than the\n            // query path can't be matches. For example, a query on 'rooms'\n            // can't match the document /rooms/abc/messages/xyx.\n            // TODO(mcg): we'll need a different scanner when we implement\n            // ancestor queries.\n            if (path.length !== immediateChildrenLength) {\n                return;\n            }\n            uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n        })\n            .next(() => this.lookupMutationBatches(transaction, uniqueBatchIDs));\n    }\n    lookupMutationBatches(transaction, batchIDs) {\n        const results = [];\n        const promises = [];\n        // TODO(rockwood): Implement this using iterate.\n        batchIDs.forEach(batchId => {\n            promises.push(mutationsStore(transaction)\n                .get(batchId)\n                .next(mutation => {\n                if (mutation === null) {\n                    throw fail();\n                }\n                hardAssert(mutation.userId === this.userId);\n                results.push(fromDbMutationBatch(this.serializer, mutation));\n            }));\n        });\n        return PersistencePromise.waitFor(promises).next(() => results);\n    }\n    removeMutationBatch(transaction, batch) {\n        return removeMutationBatch(transaction.simpleDbTransaction, this.userId, batch).next(removedDocuments => {\n            transaction.addOnCommittedListener(() => {\n                this.removeCachedMutationKeys(batch.batchId);\n            });\n            return PersistencePromise.forEach(removedDocuments, (key) => {\n                return this.referenceDelegate.markPotentiallyOrphaned(transaction, key);\n            });\n        });\n    }\n    /**\n     * Clears the cached keys for a mutation batch. This method should be\n     * called by secondary clients after they process mutation updates.\n     *\n     * Note that this method does not have to be called from primary clients as\n     * the corresponding cache entries are cleared when an acknowledged or\n     * rejected batch is removed from the mutation queue.\n     */\n    // PORTING NOTE: Multi-tab only\n    removeCachedMutationKeys(batchId) {\n        delete this.documentKeysByBatchId[batchId];\n    }\n    performConsistencyCheck(txn) {\n        return this.checkEmpty(txn).next(empty => {\n            if (!empty) {\n                return PersistencePromise.resolve();\n            }\n            // Verify that there are no entries in the documentMutations index if\n            // the queue is empty.\n            const startRange = IDBKeyRange.lowerBound(newDbDocumentMutationPrefixForUser(this.userId));\n            const danglingMutationReferences = [];\n            return documentMutationsStore(txn)\n                .iterate({ range: startRange }, (key, _, control) => {\n                const userID = key[0];\n                if (userID !== this.userId) {\n                    control.done();\n                    return;\n                }\n                else {\n                    const path = decodeResourcePath(key[1]);\n                    danglingMutationReferences.push(path);\n                }\n            })\n                .next(() => {\n                hardAssert(danglingMutationReferences.length === 0);\n            });\n        });\n    }\n    containsKey(txn, key) {\n        return mutationQueueContainsKey(txn, this.userId, key);\n    }\n    // PORTING NOTE: Multi-tab only (state is held in memory in other clients).\n    /** Returns the mutation queue's metadata from IndexedDb. */\n    getMutationQueueMetadata(transaction) {\n        return mutationQueuesStore(transaction)\n            .get(this.userId)\n            .next((metadata) => {\n            return (metadata || {\n                userId: this.userId,\n                lastAcknowledgedBatchId: BATCHID_UNKNOWN,\n                lastStreamToken: ''\n            });\n        });\n    }\n}\n/**\n * @returns true if the mutation queue for the given user contains a pending\n *         mutation for the given key.\n */\nfunction mutationQueueContainsKey(txn, userId, key) {\n    const indexKey = newDbDocumentMutationPrefixForPath(userId, key.path);\n    const encodedPath = indexKey[1];\n    const startRange = IDBKeyRange.lowerBound(indexKey);\n    let containsKey = false;\n    return documentMutationsStore(txn)\n        .iterate({ range: startRange, keysOnly: true }, (key, value, control) => {\n        const [userID, keyPath, /*batchID*/ _] = key;\n        if (userID === userId && keyPath === encodedPath) {\n            containsKey = true;\n        }\n        control.done();\n    })\n        .next(() => containsKey);\n}\n/** Returns true if any mutation queue contains the given document. */\nfunction mutationQueuesContainKey(txn, docKey) {\n    let found = false;\n    return mutationQueuesStore(txn)\n        .iterateSerial(userId => {\n        return mutationQueueContainsKey(txn, userId, docKey).next(containsKey => {\n            if (containsKey) {\n                found = true;\n            }\n            return PersistencePromise.resolve(!containsKey);\n        });\n    })\n        .next(() => found);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutations object store.\n */\nfunction mutationsStore(txn) {\n    return getStore(txn, DbMutationBatchStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction documentMutationsStore(txn) {\n    return getStore(txn, DbDocumentMutationStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction mutationQueuesStore(txn) {\n    return getStore(txn, DbMutationQueueStore);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Offset to ensure non-overlapping target ids. */\nconst OFFSET = 2;\n/**\n * Generates monotonically increasing target IDs for sending targets to the\n * watch stream.\n *\n * The client constructs two generators, one for the target cache, and one for\n * for the sync engine (to generate limbo documents targets). These\n * generators produce non-overlapping IDs (by using even and odd IDs\n * respectively).\n *\n * By separating the target ID space, the query cache can generate target IDs\n * that persist across client restarts, while sync engine can independently\n * generate in-memory target IDs that are transient and can be reused after a\n * restart.\n */\nclass TargetIdGenerator {\n    constructor(lastId) {\n        this.lastId = lastId;\n    }\n    next() {\n        this.lastId += OFFSET;\n        return this.lastId;\n    }\n    static forTargetCache() {\n        // The target cache generator must return '2' in its first call to `next()`\n        // as there is no differentiation in the protocol layer between an unset\n        // number and the number '0'. If we were to sent a target with target ID\n        // '0', the backend would consider it unset and replace it with its own ID.\n        return new TargetIdGenerator(2 - OFFSET);\n    }\n    static forSyncEngine() {\n        // Sync engine assigns target IDs for limbo document detection.\n        return new TargetIdGenerator(1 - OFFSET);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass IndexedDbTargetCache {\n    constructor(referenceDelegate, serializer) {\n        this.referenceDelegate = referenceDelegate;\n        this.serializer = serializer;\n    }\n    // PORTING NOTE: We don't cache global metadata for the target cache, since\n    // some of it (in particular `highestTargetId`) can be modified by secondary\n    // tabs. We could perhaps be more granular (and e.g. still cache\n    // `lastRemoteSnapshotVersion` in memory) but for simplicity we currently go\n    // to IndexedDb whenever we need to read metadata. We can revisit if it turns\n    // out to have a meaningful performance impact.\n    allocateTargetId(transaction) {\n        return this.retrieveMetadata(transaction).next(metadata => {\n            const targetIdGenerator = new TargetIdGenerator(metadata.highestTargetId);\n            metadata.highestTargetId = targetIdGenerator.next();\n            return this.saveMetadata(transaction, metadata).next(() => metadata.highestTargetId);\n        });\n    }\n    getLastRemoteSnapshotVersion(transaction) {\n        return this.retrieveMetadata(transaction).next(metadata => {\n            return SnapshotVersion.fromTimestamp(new Timestamp(metadata.lastRemoteSnapshotVersion.seconds, metadata.lastRemoteSnapshotVersion.nanoseconds));\n        });\n    }\n    getHighestSequenceNumber(transaction) {\n        return this.retrieveMetadata(transaction).next(targetGlobal => targetGlobal.highestListenSequenceNumber);\n    }\n    setTargetsMetadata(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {\n        return this.retrieveMetadata(transaction).next(metadata => {\n            metadata.highestListenSequenceNumber = highestListenSequenceNumber;\n            if (lastRemoteSnapshotVersion) {\n                metadata.lastRemoteSnapshotVersion =\n                    lastRemoteSnapshotVersion.toTimestamp();\n            }\n            if (highestListenSequenceNumber > metadata.highestListenSequenceNumber) {\n                metadata.highestListenSequenceNumber = highestListenSequenceNumber;\n            }\n            return this.saveMetadata(transaction, metadata);\n        });\n    }\n    addTargetData(transaction, targetData) {\n        return this.saveTargetData(transaction, targetData).next(() => {\n            return this.retrieveMetadata(transaction).next(metadata => {\n                metadata.targetCount += 1;\n                this.updateMetadataFromTargetData(targetData, metadata);\n                return this.saveMetadata(transaction, metadata);\n            });\n        });\n    }\n    updateTargetData(transaction, targetData) {\n        return this.saveTargetData(transaction, targetData);\n    }\n    removeTargetData(transaction, targetData) {\n        return this.removeMatchingKeysForTargetId(transaction, targetData.targetId)\n            .next(() => targetsStore(transaction).delete(targetData.targetId))\n            .next(() => this.retrieveMetadata(transaction))\n            .next(metadata => {\n            hardAssert(metadata.targetCount > 0);\n            metadata.targetCount -= 1;\n            return this.saveMetadata(transaction, metadata);\n        });\n    }\n    /**\n     * Drops any targets with sequence number less than or equal to the upper bound, excepting those\n     * present in `activeTargetIds`. Document associations for the removed targets are also removed.\n     * Returns the number of targets removed.\n     */\n    removeTargets(txn, upperBound, activeTargetIds) {\n        let count = 0;\n        const promises = [];\n        return targetsStore(txn)\n            .iterate((key, value) => {\n            const targetData = fromDbTarget(value);\n            if (targetData.sequenceNumber <= upperBound &&\n                activeTargetIds.get(targetData.targetId) === null) {\n                count++;\n                promises.push(this.removeTargetData(txn, targetData));\n            }\n        })\n            .next(() => PersistencePromise.waitFor(promises))\n            .next(() => count);\n    }\n    /**\n     * Call provided function with each `TargetData` that we have cached.\n     */\n    forEachTarget(txn, f) {\n        return targetsStore(txn).iterate((key, value) => {\n            const targetData = fromDbTarget(value);\n            f(targetData);\n        });\n    }\n    retrieveMetadata(transaction) {\n        return globalTargetStore(transaction)\n            .get(DbTargetGlobalKey)\n            .next(metadata => {\n            hardAssert(metadata !== null);\n            return metadata;\n        });\n    }\n    saveMetadata(transaction, metadata) {\n        return globalTargetStore(transaction).put(DbTargetGlobalKey, metadata);\n    }\n    saveTargetData(transaction, targetData) {\n        return targetsStore(transaction).put(toDbTarget(this.serializer, targetData));\n    }\n    /**\n     * In-place updates the provided metadata to account for values in the given\n     * TargetData. Saving is done separately. Returns true if there were any\n     * changes to the metadata.\n     */\n    updateMetadataFromTargetData(targetData, metadata) {\n        let updated = false;\n        if (targetData.targetId > metadata.highestTargetId) {\n            metadata.highestTargetId = targetData.targetId;\n            updated = true;\n        }\n        if (targetData.sequenceNumber > metadata.highestListenSequenceNumber) {\n            metadata.highestListenSequenceNumber = targetData.sequenceNumber;\n            updated = true;\n        }\n        return updated;\n    }\n    getTargetCount(transaction) {\n        return this.retrieveMetadata(transaction).next(metadata => metadata.targetCount);\n    }\n    getTargetData(transaction, target) {\n        // Iterating by the canonicalId may yield more than one result because\n        // canonicalId values are not required to be unique per target. This query\n        // depends on the queryTargets index to be efficient.\n        const canonicalId = canonifyTarget(target);\n        const range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);\n        let result = null;\n        return targetsStore(transaction)\n            .iterate({ range, index: DbTargetQueryTargetsIndexName }, (key, value, control) => {\n            const found = fromDbTarget(value);\n            // After finding a potential match, check that the target is\n            // actually equal to the requested target.\n            if (targetEquals(target, found.target)) {\n                result = found;\n                control.done();\n            }\n        })\n            .next(() => result);\n    }\n    addMatchingKeys(txn, keys, targetId) {\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // IndexedDb.\n        const promises = [];\n        const store = documentTargetStore(txn);\n        keys.forEach(key => {\n            const path = encodeResourcePath(key.path);\n            promises.push(store.put({ targetId, path }));\n            promises.push(this.referenceDelegate.addReference(txn, targetId, key));\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    removeMatchingKeys(txn, keys, targetId) {\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // IndexedDb.\n        const store = documentTargetStore(txn);\n        return PersistencePromise.forEach(keys, (key) => {\n            const path = encodeResourcePath(key.path);\n            return PersistencePromise.waitFor([\n                store.delete([targetId, path]),\n                this.referenceDelegate.removeReference(txn, targetId, key)\n            ]);\n        });\n    }\n    removeMatchingKeysForTargetId(txn, targetId) {\n        const store = documentTargetStore(txn);\n        const range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        return store.delete(range);\n    }\n    getMatchingKeysForTargetId(txn, targetId) {\n        const range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        const store = documentTargetStore(txn);\n        let result = documentKeySet();\n        return store\n            .iterate({ range, keysOnly: true }, (key, _, control) => {\n            const path = decodeResourcePath(key[1]);\n            const docKey = new DocumentKey(path);\n            result = result.add(docKey);\n        })\n            .next(() => result);\n    }\n    containsKey(txn, key) {\n        const path = encodeResourcePath(key.path);\n        const range = IDBKeyRange.bound([path], [immediateSuccessor(path)], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        let count = 0;\n        return documentTargetStore(txn)\n            .iterate({\n            index: DbTargetDocumentDocumentTargetsIndex,\n            keysOnly: true,\n            range\n        }, ([targetId, path], _, control) => {\n            // Having a sentinel row for a document does not count as containing that document;\n            // For the target cache, containing the document means the document is part of some\n            // target.\n            if (targetId !== 0) {\n                count++;\n                control.done();\n            }\n        })\n            .next(() => count > 0);\n    }\n    /**\n     * Looks up a TargetData entry by target ID.\n     *\n     * @param targetId - The target ID of the TargetData entry to look up.\n     * @returns The cached TargetData entry, or null if the cache has no entry for\n     * the target.\n     */\n    // PORTING NOTE: Multi-tab only.\n    getTargetDataForTarget(transaction, targetId) {\n        return targetsStore(transaction)\n            .get(targetId)\n            .next(found => {\n            if (found) {\n                return fromDbTarget(found);\n            }\n            else {\n                return null;\n            }\n        });\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the queries object store.\n */\nfunction targetsStore(txn) {\n    return getStore(txn, DbTargetStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the target globals object store.\n */\nfunction globalTargetStore(txn) {\n    return getStore(txn, DbTargetGlobalStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the document target object store.\n */\nfunction documentTargetStore(txn) {\n    return getStore(txn, DbTargetDocumentStore);\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst GC_DID_NOT_RUN = {\n    didRun: false,\n    sequenceNumbersCollected: 0,\n    targetsRemoved: 0,\n    documentsRemoved: 0\n};\nconst LRU_COLLECTION_DISABLED = -1;\nconst LRU_DEFAULT_CACHE_SIZE_BYTES = 40 * 1024 * 1024;\nclass LruParams {\n    static withCacheSize(cacheSize) {\n        return new LruParams(cacheSize, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\n    }\n    constructor(\n    // When we attempt to collect, we will only do so if the cache size is greater than this\n    // threshold. Passing `COLLECTION_DISABLED` here will cause collection to always be skipped.\n    cacheSizeCollectionThreshold, \n    // The percentage of sequence numbers that we will attempt to collect\n    percentileToCollect, \n    // A cap on the total number of sequence numbers that will be collected. This prevents\n    // us from collecting a huge number of sequence numbers if the cache has grown very large.\n    maximumSequenceNumbersToCollect) {\n        this.cacheSizeCollectionThreshold = cacheSizeCollectionThreshold;\n        this.percentileToCollect = percentileToCollect;\n        this.maximumSequenceNumbersToCollect = maximumSequenceNumbersToCollect;\n    }\n}\nLruParams.DEFAULT_COLLECTION_PERCENTILE = 10;\nLruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1000;\nLruParams.DEFAULT = new LruParams(LRU_DEFAULT_CACHE_SIZE_BYTES, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\nLruParams.DISABLED = new LruParams(LRU_COLLECTION_DISABLED, 0, 0);\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$e = 'LruGarbageCollector';\nconst LRU_MINIMUM_CACHE_SIZE_BYTES = 1 * 1024 * 1024;\n/** How long we wait to try running LRU GC after SDK initialization. */\nconst INITIAL_GC_DELAY_MS = 1 * 60 * 1000;\n/** Minimum amount of time between GC checks, after the first one. */\nconst REGULAR_GC_DELAY_MS = 5 * 60 * 1000;\nfunction bufferEntryComparator([aSequence, aIndex], [bSequence, bIndex]) {\n    const seqCmp = primitiveComparator(aSequence, bSequence);\n    if (seqCmp === 0) {\n        // This order doesn't matter, but we can bias against churn by sorting\n        // entries created earlier as less than newer entries.\n        return primitiveComparator(aIndex, bIndex);\n    }\n    else {\n        return seqCmp;\n    }\n}\n/**\n * Used to calculate the nth sequence number. Keeps a rolling buffer of the\n * lowest n values passed to `addElement`, and finally reports the largest of\n * them in `maxValue`.\n */\nclass RollingSequenceNumberBuffer {\n    constructor(maxElements) {\n        this.maxElements = maxElements;\n        this.buffer = new SortedSet(bufferEntryComparator);\n        this.previousIndex = 0;\n    }\n    nextIndex() {\n        return ++this.previousIndex;\n    }\n    addElement(sequenceNumber) {\n        const entry = [sequenceNumber, this.nextIndex()];\n        if (this.buffer.size < this.maxElements) {\n            this.buffer = this.buffer.add(entry);\n        }\n        else {\n            const highestValue = this.buffer.last();\n            if (bufferEntryComparator(entry, highestValue) < 0) {\n                this.buffer = this.buffer.delete(highestValue).add(entry);\n            }\n        }\n    }\n    get maxValue() {\n        // Guaranteed to be non-empty. If we decide we are not collecting any\n        // sequence numbers, nthSequenceNumber below short-circuits. If we have\n        // decided that we are collecting n sequence numbers, it's because n is some\n        // percentage of the existing sequence numbers. That means we should never\n        // be in a situation where we are collecting sequence numbers but don't\n        // actually have any.\n        return this.buffer.last()[0];\n    }\n}\n/**\n * This class is responsible for the scheduling of LRU garbage collection. It handles checking\n * whether or not GC is enabled, as well as which delay to use before the next run.\n */\nclass LruScheduler {\n    constructor(garbageCollector, asyncQueue, localStore) {\n        this.garbageCollector = garbageCollector;\n        this.asyncQueue = asyncQueue;\n        this.localStore = localStore;\n        this.gcTask = null;\n    }\n    start() {\n        if (this.garbageCollector.params.cacheSizeCollectionThreshold !==\n            LRU_COLLECTION_DISABLED) {\n            this.scheduleGC(INITIAL_GC_DELAY_MS);\n        }\n    }\n    stop() {\n        if (this.gcTask) {\n            this.gcTask.cancel();\n            this.gcTask = null;\n        }\n    }\n    get started() {\n        return this.gcTask !== null;\n    }\n    scheduleGC(delay) {\n        logDebug(LOG_TAG$e, `Garbage collection scheduled in ${delay}ms`);\n        this.gcTask = this.asyncQueue.enqueueAfterDelay(\"lru_garbage_collection\" /* TimerId.LruGarbageCollection */, delay, async () => {\n            this.gcTask = null;\n            try {\n                await this.localStore.collectGarbage(this.garbageCollector);\n            }\n            catch (e) {\n                if (isIndexedDbTransactionError(e)) {\n                    logDebug(LOG_TAG$e, 'Ignoring IndexedDB error during garbage collection: ', e);\n                }\n                else {\n                    await ignoreIfPrimaryLeaseLoss(e);\n                }\n            }\n            await this.scheduleGC(REGULAR_GC_DELAY_MS);\n        });\n    }\n}\n/**\n * Implements the steps for LRU garbage collection.\n */\nclass LruGarbageCollectorImpl {\n    constructor(delegate, params) {\n        this.delegate = delegate;\n        this.params = params;\n    }\n    calculateTargetCount(txn, percentile) {\n        return this.delegate.getSequenceNumberCount(txn).next(targetCount => {\n            return Math.floor((percentile / 100.0) * targetCount);\n        });\n    }\n    nthSequenceNumber(txn, n) {\n        if (n === 0) {\n            return PersistencePromise.resolve(ListenSequence.INVALID);\n        }\n        const buffer = new RollingSequenceNumberBuffer(n);\n        return this.delegate\n            .forEachTarget(txn, target => buffer.addElement(target.sequenceNumber))\n            .next(() => {\n            return this.delegate.forEachOrphanedDocumentSequenceNumber(txn, sequenceNumber => buffer.addElement(sequenceNumber));\n        })\n            .next(() => buffer.maxValue);\n    }\n    removeTargets(txn, upperBound, activeTargetIds) {\n        return this.delegate.removeTargets(txn, upperBound, activeTargetIds);\n    }\n    removeOrphanedDocuments(txn, upperBound) {\n        return this.delegate.removeOrphanedDocuments(txn, upperBound);\n    }\n    collect(txn, activeTargetIds) {\n        if (this.params.cacheSizeCollectionThreshold === LRU_COLLECTION_DISABLED) {\n            logDebug('LruGarbageCollector', 'Garbage collection skipped; disabled');\n            return PersistencePromise.resolve(GC_DID_NOT_RUN);\n        }\n        return this.getCacheSize(txn).next(cacheSize => {\n            if (cacheSize < this.params.cacheSizeCollectionThreshold) {\n                logDebug('LruGarbageCollector', `Garbage collection skipped; Cache size ${cacheSize} ` +\n                    `is lower than threshold ${this.params.cacheSizeCollectionThreshold}`);\n                return GC_DID_NOT_RUN;\n            }\n            else {\n                return this.runGarbageCollection(txn, activeTargetIds);\n            }\n        });\n    }\n    getCacheSize(txn) {\n        return this.delegate.getCacheSize(txn);\n    }\n    runGarbageCollection(txn, activeTargetIds) {\n        let upperBoundSequenceNumber;\n        let sequenceNumbersToCollect, targetsRemoved;\n        // Timestamps for various pieces of the process\n        let countedTargetsTs, foundUpperBoundTs, removedTargetsTs, removedDocumentsTs;\n        const startTs = Date.now();\n        return this.calculateTargetCount(txn, this.params.percentileToCollect)\n            .next(sequenceNumbers => {\n            // Cap at the configured max\n            if (sequenceNumbers > this.params.maximumSequenceNumbersToCollect) {\n                logDebug('LruGarbageCollector', 'Capping sequence numbers to collect down ' +\n                    `to the maximum of ${this.params.maximumSequenceNumbersToCollect} ` +\n                    `from ${sequenceNumbers}`);\n                sequenceNumbersToCollect =\n                    this.params.maximumSequenceNumbersToCollect;\n            }\n            else {\n                sequenceNumbersToCollect = sequenceNumbers;\n            }\n            countedTargetsTs = Date.now();\n            return this.nthSequenceNumber(txn, sequenceNumbersToCollect);\n        })\n            .next(upperBound => {\n            upperBoundSequenceNumber = upperBound;\n            foundUpperBoundTs = Date.now();\n            return this.removeTargets(txn, upperBoundSequenceNumber, activeTargetIds);\n        })\n            .next(numTargetsRemoved => {\n            targetsRemoved = numTargetsRemoved;\n            removedTargetsTs = Date.now();\n            return this.removeOrphanedDocuments(txn, upperBoundSequenceNumber);\n        })\n            .next(documentsRemoved => {\n            removedDocumentsTs = Date.now();\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n                const desc = 'LRU Garbage Collection\\n' +\n                    `\\tCounted targets in ${countedTargetsTs - startTs}ms\\n` +\n                    `\\tDetermined least recently used ${sequenceNumbersToCollect} in ` +\n                    `${foundUpperBoundTs - countedTargetsTs}ms\\n` +\n                    `\\tRemoved ${targetsRemoved} targets in ` +\n                    `${removedTargetsTs - foundUpperBoundTs}ms\\n` +\n                    `\\tRemoved ${documentsRemoved} documents in ` +\n                    `${removedDocumentsTs - removedTargetsTs}ms\\n` +\n                    `Total Duration: ${removedDocumentsTs - startTs}ms`;\n                logDebug('LruGarbageCollector', desc);\n            }\n            return PersistencePromise.resolve({\n                didRun: true,\n                sequenceNumbersCollected: sequenceNumbersToCollect,\n                targetsRemoved,\n                documentsRemoved\n            });\n        });\n    }\n}\nfunction newLruGarbageCollector(delegate, params) {\n    return new LruGarbageCollectorImpl(delegate, params);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Provides LRU functionality for IndexedDB persistence. */\nclass IndexedDbLruDelegateImpl {\n    constructor(db, params) {\n        this.db = db;\n        this.garbageCollector = newLruGarbageCollector(this, params);\n    }\n    getSequenceNumberCount(txn) {\n        const docCountPromise = this.orphanedDocumentCount(txn);\n        const targetCountPromise = this.db.getTargetCache().getTargetCount(txn);\n        return targetCountPromise.next(targetCount => docCountPromise.next(docCount => targetCount + docCount));\n    }\n    orphanedDocumentCount(txn) {\n        let orphanedCount = 0;\n        return this.forEachOrphanedDocumentSequenceNumber(txn, _ => {\n            orphanedCount++;\n        }).next(() => orphanedCount);\n    }\n    forEachTarget(txn, f) {\n        return this.db.getTargetCache().forEachTarget(txn, f);\n    }\n    forEachOrphanedDocumentSequenceNumber(txn, f) {\n        return this.forEachOrphanedDocument(txn, (docKey, sequenceNumber) => f(sequenceNumber));\n    }\n    addReference(txn, targetId, key) {\n        return writeSentinelKey(txn, key);\n    }\n    removeReference(txn, targetId, key) {\n        return writeSentinelKey(txn, key);\n    }\n    removeTargets(txn, upperBound, activeTargetIds) {\n        return this.db.getTargetCache().removeTargets(txn, upperBound, activeTargetIds);\n    }\n    markPotentiallyOrphaned(txn, key) {\n        return writeSentinelKey(txn, key);\n    }\n    /**\n     * Returns true if anything would prevent this document from being garbage\n     * collected, given that the document in question is not present in any\n     * targets and has a sequence number less than or equal to the upper bound for\n     * the collection run.\n     */\n    isPinned(txn, docKey) {\n        return mutationQueuesContainKey(txn, docKey);\n    }\n    removeOrphanedDocuments(txn, upperBound) {\n        const documentCache = this.db.getRemoteDocumentCache();\n        const changeBuffer = documentCache.newChangeBuffer();\n        const promises = [];\n        let documentCount = 0;\n        const iteration = this.forEachOrphanedDocument(txn, (docKey, sequenceNumber) => {\n            if (sequenceNumber <= upperBound) {\n                const p = this.isPinned(txn, docKey).next(isPinned => {\n                    if (!isPinned) {\n                        documentCount++;\n                        // Our size accounting requires us to read all documents before\n                        // removing them.\n                        return changeBuffer.getEntry(txn, docKey).next(() => {\n                            changeBuffer.removeEntry(docKey, SnapshotVersion.min());\n                            return documentTargetStore(txn).delete(sentinelKey$1(docKey));\n                        });\n                    }\n                });\n                promises.push(p);\n            }\n        });\n        return iteration\n            .next(() => PersistencePromise.waitFor(promises))\n            .next(() => changeBuffer.apply(txn))\n            .next(() => documentCount);\n    }\n    removeTarget(txn, targetData) {\n        const updated = targetData.withSequenceNumber(txn.currentSequenceNumber);\n        return this.db.getTargetCache().updateTargetData(txn, updated);\n    }\n    updateLimboDocument(txn, key) {\n        return writeSentinelKey(txn, key);\n    }\n    /**\n     * Call provided function for each document in the cache that is 'orphaned'. Orphaned\n     * means not a part of any target, so the only entry in the target-document index for\n     * that document will be the sentinel row (targetId 0), which will also have the sequence\n     * number for the last time the document was accessed.\n     */\n    forEachOrphanedDocument(txn, f) {\n        const store = documentTargetStore(txn);\n        let nextToReport = ListenSequence.INVALID;\n        let nextPath;\n        return store\n            .iterate({\n            index: DbTargetDocumentDocumentTargetsIndex\n        }, ([targetId, docKey], { path, sequenceNumber }) => {\n            if (targetId === 0) {\n                // if nextToReport is valid, report it, this is a new key so the\n                // last one must not be a member of any targets.\n                if (nextToReport !== ListenSequence.INVALID) {\n                    f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);\n                }\n                // set nextToReport to be this sequence number. It's the next one we\n                // might report, if we don't find any targets for this document.\n                // Note that the sequence number must be defined when the targetId\n                // is 0.\n                nextToReport = sequenceNumber;\n                nextPath = path;\n            }\n            else {\n                // set nextToReport to be invalid, we know we don't need to report\n                // this one since we found a target for it.\n                nextToReport = ListenSequence.INVALID;\n            }\n        })\n            .next(() => {\n            // Since we report sequence numbers after getting to the next key, we\n            // need to check if the last key we iterated over was an orphaned\n            // document and report it.\n            if (nextToReport !== ListenSequence.INVALID) {\n                f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);\n            }\n        });\n    }\n    getCacheSize(txn) {\n        return this.db.getRemoteDocumentCache().getSize(txn);\n    }\n}\nfunction sentinelKey$1(key) {\n    return [0, encodeResourcePath(key.path)];\n}\n/**\n * @returns A value suitable for writing a sentinel row in the target-document\n * store.\n */\nfunction sentinelRow(key, sequenceNumber) {\n    return { targetId: 0, path: encodeResourcePath(key.path), sequenceNumber };\n}\nfunction writeSentinelKey(txn, key) {\n    return documentTargetStore(txn).put(sentinelRow(key, txn.currentSequenceNumber));\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An in-memory buffer of entries to be written to a RemoteDocumentCache.\n * It can be used to batch up a set of changes to be written to the cache, but\n * additionally supports reading entries back with the `getEntry()` method,\n * falling back to the underlying RemoteDocumentCache if no entry is\n * buffered.\n *\n * Entries added to the cache *must* be read first. This is to facilitate\n * calculating the size delta of the pending changes.\n *\n * PORTING NOTE: This class was implemented then removed from other platforms.\n * If byte-counting ends up being needed on the other platforms, consider\n * porting this class as part of that implementation work.\n */\nclass RemoteDocumentChangeBuffer {\n    constructor() {\n        // A mapping of document key to the new cache entry that should be written.\n        this.changes = new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\n        this.changesApplied = false;\n    }\n    /**\n     * Buffers a `RemoteDocumentCache.addEntry()` call.\n     *\n     * You can only modify documents that have already been retrieved via\n     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).\n     */\n    addEntry(document) {\n        this.assertNotApplied();\n        this.changes.set(document.key, document);\n    }\n    /**\n     * Buffers a `RemoteDocumentCache.removeEntry()` call.\n     *\n     * You can only remove documents that have already been retrieved via\n     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).\n     */\n    removeEntry(key, readTime) {\n        this.assertNotApplied();\n        this.changes.set(key, MutableDocument.newInvalidDocument(key).setReadTime(readTime));\n    }\n    /**\n     * Looks up an entry in the cache. The buffered changes will first be checked,\n     * and if no buffered change applies, this will forward to\n     * `RemoteDocumentCache.getEntry()`.\n     *\n     * @param transaction - The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKey - The key of the entry to look up.\n     * @returns The cached document or an invalid document if we have nothing\n     * cached.\n     */\n    getEntry(transaction, documentKey) {\n        this.assertNotApplied();\n        const bufferedEntry = this.changes.get(documentKey);\n        if (bufferedEntry !== undefined) {\n            return PersistencePromise.resolve(bufferedEntry);\n        }\n        else {\n            return this.getFromCache(transaction, documentKey);\n        }\n    }\n    /**\n     * Looks up several entries in the cache, forwarding to\n     * `RemoteDocumentCache.getEntry()`.\n     *\n     * @param transaction - The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKeys - The keys of the entries to look up.\n     * @returns A map of cached documents, indexed by key. If an entry cannot be\n     *     found, the corresponding key will be mapped to an invalid document.\n     */\n    getEntries(transaction, documentKeys) {\n        return this.getAllFromCache(transaction, documentKeys);\n    }\n    /**\n     * Applies buffered changes to the underlying RemoteDocumentCache, using\n     * the provided transaction.\n     */\n    apply(transaction) {\n        this.assertNotApplied();\n        this.changesApplied = true;\n        return this.applyChanges(transaction);\n    }\n    /** Helper to assert this.changes is not null  */\n    assertNotApplied() {\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The RemoteDocumentCache for IndexedDb. To construct, invoke\n * `newIndexedDbRemoteDocumentCache()`.\n */\nclass IndexedDbRemoteDocumentCacheImpl {\n    constructor(serializer) {\n        this.serializer = serializer;\n    }\n    setIndexManager(indexManager) {\n        this.indexManager = indexManager;\n    }\n    /**\n     * Adds the supplied entries to the cache.\n     *\n     * All calls of `addEntry` are required to go through the RemoteDocumentChangeBuffer\n     * returned by `newChangeBuffer()` to ensure proper accounting of metadata.\n     */\n    addEntry(transaction, key, doc) {\n        const documentStore = remoteDocumentsStore(transaction);\n        return documentStore.put(doc);\n    }\n    /**\n     * Removes a document from the cache.\n     *\n     * All calls of `removeEntry`  are required to go through the RemoteDocumentChangeBuffer\n     * returned by `newChangeBuffer()` to ensure proper accounting of metadata.\n     */\n    removeEntry(transaction, documentKey, readTime) {\n        const store = remoteDocumentsStore(transaction);\n        return store.delete(dbReadTimeKey(documentKey, readTime));\n    }\n    /**\n     * Updates the current cache size.\n     *\n     * Callers to `addEntry()` and `removeEntry()` *must* call this afterwards to update the\n     * cache's metadata.\n     */\n    updateMetadata(transaction, sizeDelta) {\n        return this.getMetadata(transaction).next(metadata => {\n            metadata.byteSize += sizeDelta;\n            return this.setMetadata(transaction, metadata);\n        });\n    }\n    getEntry(transaction, documentKey) {\n        let doc = MutableDocument.newInvalidDocument(documentKey);\n        return remoteDocumentsStore(transaction)\n            .iterate({\n            index: DbRemoteDocumentDocumentKeyIndex,\n            range: IDBKeyRange.only(dbKey(documentKey))\n        }, (_, dbRemoteDoc) => {\n            doc = this.maybeDecodeDocument(documentKey, dbRemoteDoc);\n        })\n            .next(() => doc);\n    }\n    /**\n     * Looks up an entry in the cache.\n     *\n     * @param documentKey - The key of the entry to look up.\n     * @returns The cached document entry and its size.\n     */\n    getSizedEntry(transaction, documentKey) {\n        let result = {\n            size: 0,\n            document: MutableDocument.newInvalidDocument(documentKey)\n        };\n        return remoteDocumentsStore(transaction)\n            .iterate({\n            index: DbRemoteDocumentDocumentKeyIndex,\n            range: IDBKeyRange.only(dbKey(documentKey))\n        }, (_, dbRemoteDoc) => {\n            result = {\n                document: this.maybeDecodeDocument(documentKey, dbRemoteDoc),\n                size: dbDocumentSize(dbRemoteDoc)\n            };\n        })\n            .next(() => result);\n    }\n    getEntries(transaction, documentKeys) {\n        let results = mutableDocumentMap();\n        return this.forEachDbEntry(transaction, documentKeys, (key, dbRemoteDoc) => {\n            const doc = this.maybeDecodeDocument(key, dbRemoteDoc);\n            results = results.insert(key, doc);\n        }).next(() => results);\n    }\n    /**\n     * Looks up several entries in the cache.\n     *\n     * @param documentKeys - The set of keys entries to look up.\n     * @returns A map of documents indexed by key and a map of sizes indexed by\n     *     key (zero if the document does not exist).\n     */\n    getSizedEntries(transaction, documentKeys) {\n        let results = mutableDocumentMap();\n        let sizeMap = new SortedMap(DocumentKey.comparator);\n        return this.forEachDbEntry(transaction, documentKeys, (key, dbRemoteDoc) => {\n            const doc = this.maybeDecodeDocument(key, dbRemoteDoc);\n            results = results.insert(key, doc);\n            sizeMap = sizeMap.insert(key, dbDocumentSize(dbRemoteDoc));\n        }).next(() => {\n            return { documents: results, sizeMap };\n        });\n    }\n    forEachDbEntry(transaction, documentKeys, callback) {\n        if (documentKeys.isEmpty()) {\n            return PersistencePromise.resolve();\n        }\n        let sortedKeys = new SortedSet(dbKeyComparator);\n        documentKeys.forEach(e => (sortedKeys = sortedKeys.add(e)));\n        const range = IDBKeyRange.bound(dbKey(sortedKeys.first()), dbKey(sortedKeys.last()));\n        const keyIter = sortedKeys.getIterator();\n        let nextKey = keyIter.getNext();\n        return remoteDocumentsStore(transaction)\n            .iterate({ index: DbRemoteDocumentDocumentKeyIndex, range }, (_, dbRemoteDoc, control) => {\n            const potentialKey = DocumentKey.fromSegments([\n                ...dbRemoteDoc.prefixPath,\n                dbRemoteDoc.collectionGroup,\n                dbRemoteDoc.documentId\n            ]);\n            // Go through keys not found in cache.\n            while (nextKey && dbKeyComparator(nextKey, potentialKey) < 0) {\n                callback(nextKey, null);\n                nextKey = keyIter.getNext();\n            }\n            if (nextKey && nextKey.isEqual(potentialKey)) {\n                // Key found in cache.\n                callback(nextKey, dbRemoteDoc);\n                nextKey = keyIter.hasNext() ? keyIter.getNext() : null;\n            }\n            // Skip to the next key (if there is one).\n            if (nextKey) {\n                control.skip(dbKey(nextKey));\n            }\n            else {\n                control.done();\n            }\n        })\n            .next(() => {\n            // The rest of the keys are not in the cache. One case where `iterate`\n            // above won't go through them is when the cache is empty.\n            while (nextKey) {\n                callback(nextKey, null);\n                nextKey = keyIter.hasNext() ? keyIter.getNext() : null;\n            }\n        });\n    }\n    getDocumentsMatchingQuery(transaction, query, offset, mutatedDocs, context) {\n        const collection = query.path;\n        const startKey = [\n            collection.popLast().toArray(),\n            collection.lastSegment(),\n            toDbTimestampKey(offset.readTime),\n            offset.documentKey.path.isEmpty()\n                ? ''\n                : offset.documentKey.path.lastSegment()\n        ];\n        const endKey = [\n            collection.popLast().toArray(),\n            collection.lastSegment(),\n            [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n            ''\n        ];\n        return remoteDocumentsStore(transaction)\n            .loadAll(IDBKeyRange.bound(startKey, endKey, true))\n            .next(dbRemoteDocs => {\n            context === null || context === void 0 ? void 0 : context.incrementDocumentReadCount(dbRemoteDocs.length);\n            let results = mutableDocumentMap();\n            for (const dbRemoteDoc of dbRemoteDocs) {\n                const document = this.maybeDecodeDocument(DocumentKey.fromSegments(dbRemoteDoc.prefixPath.concat(dbRemoteDoc.collectionGroup, dbRemoteDoc.documentId)), dbRemoteDoc);\n                if (document.isFoundDocument() &&\n                    (queryMatches(query, document) || mutatedDocs.has(document.key))) {\n                    // Either the document matches the given query, or it is mutated.\n                    results = results.insert(document.key, document);\n                }\n            }\n            return results;\n        });\n    }\n    getAllFromCollectionGroup(transaction, collectionGroup, offset, limit) {\n        let results = mutableDocumentMap();\n        const startKey = dbCollectionGroupKey(collectionGroup, offset);\n        const endKey = dbCollectionGroupKey(collectionGroup, IndexOffset.max());\n        return remoteDocumentsStore(transaction)\n            .iterate({\n            index: DbRemoteDocumentCollectionGroupIndex,\n            range: IDBKeyRange.bound(startKey, endKey, true)\n        }, (_, dbRemoteDoc, control) => {\n            const document = this.maybeDecodeDocument(DocumentKey.fromSegments(dbRemoteDoc.prefixPath.concat(dbRemoteDoc.collectionGroup, dbRemoteDoc.documentId)), dbRemoteDoc);\n            results = results.insert(document.key, document);\n            if (results.size === limit) {\n                control.done();\n            }\n        })\n            .next(() => results);\n    }\n    newChangeBuffer(options) {\n        return new IndexedDbRemoteDocumentChangeBuffer(this, !!options && options.trackRemovals);\n    }\n    getSize(txn) {\n        return this.getMetadata(txn).next(metadata => metadata.byteSize);\n    }\n    getMetadata(txn) {\n        return documentGlobalStore(txn)\n            .get(DbRemoteDocumentGlobalKey)\n            .next(metadata => {\n            hardAssert(!!metadata);\n            return metadata;\n        });\n    }\n    setMetadata(txn, metadata) {\n        return documentGlobalStore(txn).put(DbRemoteDocumentGlobalKey, metadata);\n    }\n    /**\n     * Decodes `dbRemoteDoc` and returns the document (or an invalid document if\n     * the document corresponds to the format used for sentinel deletes).\n     */\n    maybeDecodeDocument(documentKey, dbRemoteDoc) {\n        if (dbRemoteDoc) {\n            const doc = fromDbRemoteDocument(this.serializer, dbRemoteDoc);\n            // Whether the document is a sentinel removal and should only be used in the\n            // `getNewDocumentChanges()`\n            const isSentinelRemoval = doc.isNoDocument() && doc.version.isEqual(SnapshotVersion.min());\n            if (!isSentinelRemoval) {\n                return doc;\n            }\n        }\n        return MutableDocument.newInvalidDocument(documentKey);\n    }\n}\n/** Creates a new IndexedDbRemoteDocumentCache. */\nfunction newIndexedDbRemoteDocumentCache(serializer) {\n    return new IndexedDbRemoteDocumentCacheImpl(serializer);\n}\n/**\n * Handles the details of adding and updating documents in the IndexedDbRemoteDocumentCache.\n *\n * Unlike the MemoryRemoteDocumentChangeBuffer, the IndexedDb implementation computes the size\n * delta for all submitted changes. This avoids having to re-read all documents from IndexedDb\n * when we apply the changes.\n */\nclass IndexedDbRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {\n    /**\n     * @param documentCache - The IndexedDbRemoteDocumentCache to apply the changes to.\n     * @param trackRemovals - Whether to create sentinel deletes that can be tracked by\n     * `getNewDocumentChanges()`.\n     */\n    constructor(documentCache, trackRemovals) {\n        super();\n        this.documentCache = documentCache;\n        this.trackRemovals = trackRemovals;\n        // A map of document sizes and read times prior to applying the changes in\n        // this buffer.\n        this.documentStates = new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\n    }\n    applyChanges(transaction) {\n        const promises = [];\n        let sizeDelta = 0;\n        let collectionParents = new SortedSet((l, r) => primitiveComparator(l.canonicalString(), r.canonicalString()));\n        this.changes.forEach((key, documentChange) => {\n            const previousDoc = this.documentStates.get(key);\n            promises.push(this.documentCache.removeEntry(transaction, key, previousDoc.readTime));\n            if (documentChange.isValidDocument()) {\n                const doc = toDbRemoteDocument(this.documentCache.serializer, documentChange);\n                collectionParents = collectionParents.add(key.path.popLast());\n                const size = dbDocumentSize(doc);\n                sizeDelta += size - previousDoc.size;\n                promises.push(this.documentCache.addEntry(transaction, key, doc));\n            }\n            else {\n                sizeDelta -= previousDoc.size;\n                if (this.trackRemovals) {\n                    // In order to track removals, we store a \"sentinel delete\" in the\n                    // RemoteDocumentCache. This entry is represented by a NoDocument\n                    // with a version of 0 and ignored by `maybeDecodeDocument()` but\n                    // preserved in `getNewDocumentChanges()`.\n                    const deletedDoc = toDbRemoteDocument(this.documentCache.serializer, documentChange.convertToNoDocument(SnapshotVersion.min()));\n                    promises.push(this.documentCache.addEntry(transaction, key, deletedDoc));\n                }\n            }\n        });\n        collectionParents.forEach(parent => {\n            promises.push(this.documentCache.indexManager.addToCollectionParentIndex(transaction, parent));\n        });\n        promises.push(this.documentCache.updateMetadata(transaction, sizeDelta));\n        return PersistencePromise.waitFor(promises);\n    }\n    getFromCache(transaction, documentKey) {\n        // Record the size of everything we load from the cache so we can compute a delta later.\n        return this.documentCache\n            .getSizedEntry(transaction, documentKey)\n            .next(getResult => {\n            this.documentStates.set(documentKey, {\n                size: getResult.size,\n                readTime: getResult.document.readTime\n            });\n            return getResult.document;\n        });\n    }\n    getAllFromCache(transaction, documentKeys) {\n        // Record the size of everything we load from the cache so we can compute\n        // a delta later.\n        return this.documentCache\n            .getSizedEntries(transaction, documentKeys)\n            .next(({ documents, sizeMap }) => {\n            // Note: `getAllFromCache` returns two maps instead of a single map from\n            // keys to `DocumentSizeEntry`s. This is to allow returning the\n            // `MutableDocumentMap` directly, without a conversion.\n            sizeMap.forEach((documentKey, size) => {\n                this.documentStates.set(documentKey, {\n                    size,\n                    readTime: documents.get(documentKey).readTime\n                });\n            });\n            return documents;\n        });\n    }\n}\nfunction documentGlobalStore(txn) {\n    return getStore(txn, DbRemoteDocumentGlobalStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the remoteDocuments object store.\n */\nfunction remoteDocumentsStore(txn) {\n    return getStore(txn, DbRemoteDocumentStore);\n}\n/**\n * Returns a key that can be used for document lookups on the\n * `DbRemoteDocumentDocumentKeyIndex` index.\n */\nfunction dbKey(documentKey) {\n    const path = documentKey.path.toArray();\n    return [\n        /* prefix path */ path.slice(0, path.length - 2),\n        /* collection id */ path[path.length - 2],\n        /* document id */ path[path.length - 1]\n    ];\n}\n/**\n * Returns a key that can be used for document lookups via the primary key of\n * the DbRemoteDocument object store.\n */\nfunction dbReadTimeKey(documentKey, readTime) {\n    const path = documentKey.path.toArray();\n    return [\n        /* prefix path */ path.slice(0, path.length - 2),\n        /* collection id */ path[path.length - 2],\n        toDbTimestampKey(readTime),\n        /* document id */ path[path.length - 1]\n    ];\n}\n/**\n * Returns a key that can be used for document lookups on the\n * `DbRemoteDocumentDocumentCollectionGroupIndex` index.\n */\nfunction dbCollectionGroupKey(collectionGroup, offset) {\n    const path = offset.documentKey.path.toArray();\n    return [\n        /* collection id */ collectionGroup,\n        toDbTimestampKey(offset.readTime),\n        /* prefix path */ path.slice(0, path.length - 2),\n        /* document id */ path.length > 0 ? path[path.length - 1] : ''\n    ];\n}\n/**\n * Comparator that compares document keys according to the primary key sorting\n * used by the `DbRemoteDocumentDocument` store (by prefix path, collection id\n * and then document ID).\n *\n * Visible for testing.\n */\nfunction dbKeyComparator(l, r) {\n    const left = l.path.toArray();\n    const right = r.path.toArray();\n    // The ordering is based on https://chromium.googlesource.com/chromium/blink/+/fe5c21fef94dae71c1c3344775b8d8a7f7e6d9ec/Source/modules/indexeddb/IDBKey.cpp#74\n    let cmp = 0;\n    for (let i = 0; i < left.length - 2 && i < right.length - 2; ++i) {\n        cmp = primitiveComparator(left[i], right[i]);\n        if (cmp) {\n            return cmp;\n        }\n    }\n    cmp = primitiveComparator(left.length, right.length);\n    if (cmp) {\n        return cmp;\n    }\n    cmp = primitiveComparator(left[left.length - 2], right[right.length - 2]);\n    if (cmp) {\n        return cmp;\n    }\n    // TODO(b/329441702): Document IDs should be sorted by UTF-8 encoded byte\n    // order, but IndexedDB sorts strings lexicographically. Document ID\n    // comparison here still relies on primitive comparison to avoid mismatches\n    // observed in snapshot listeners with Unicode characters in documentIds\n    return primitiveComparator(left[left.length - 1], right[right.length - 1]);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Schema Version for the Web client:\n * 1.  Initial version including Mutation Queue, Query Cache, and Remote\n *     Document Cache\n * 2.  Used to ensure a targetGlobal object exists and add targetCount to it. No\n *     longer required because migration 3 unconditionally clears it.\n * 3.  Dropped and re-created Query Cache to deal with cache corruption related\n *     to limbo resolution. Addresses\n *     https://github.com/firebase/firebase-ios-sdk/issues/1548\n * 4.  Multi-Tab Support.\n * 5.  Removal of held write acks.\n * 6.  Create document global for tracking document cache size.\n * 7.  Ensure every cached document has a sentinel row with a sequence number.\n * 8.  Add collection-parent index for Collection Group queries.\n * 9.  Change RemoteDocumentChanges store to be keyed by readTime rather than\n *     an auto-incrementing ID. This is required for Index-Free queries.\n * 10. Rewrite the canonical IDs to the explicit Protobuf-based format.\n * 11. Add bundles and named_queries for bundle support.\n * 12. Add document overlays.\n * 13. Rewrite the keys of the remote document cache to allow for efficient\n *     document lookup via `getAll()`.\n * 14. Add overlays.\n * 15. Add indexing support.\n * 16. Parse timestamp strings before creating index entries.\n */\nconst SCHEMA_VERSION = 17;\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a local view (overlay) of a document, and the fields that are\n * locally mutated.\n */\nclass OverlayedDocument {\n    constructor(overlayedDocument, \n    /**\n     * The fields that are locally mutated by patch mutations.\n     *\n     * If the overlayed\tdocument is from set or delete mutations, this is `null`.\n     * If there is no overlay (mutation) for the document, this is an empty `FieldMask`.\n     */\n    mutatedFields) {\n        this.overlayedDocument = overlayedDocument;\n        this.mutatedFields = mutatedFields;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A readonly view of the local state of all documents we're tracking (i.e. we\n * have a cached version in remoteDocumentCache or local mutations for the\n * document). The view is computed by applying the mutations in the\n * MutationQueue to the RemoteDocumentCache.\n */\nclass LocalDocumentsView {\n    constructor(remoteDocumentCache, mutationQueue, documentOverlayCache, indexManager) {\n        this.remoteDocumentCache = remoteDocumentCache;\n        this.mutationQueue = mutationQueue;\n        this.documentOverlayCache = documentOverlayCache;\n        this.indexManager = indexManager;\n    }\n    /**\n     * Get the local view of the document identified by `key`.\n     *\n     * @returns Local view of the document or null if we don't have any cached\n     * state for it.\n     */\n    getDocument(transaction, key) {\n        let overlay = null;\n        return this.documentOverlayCache\n            .getOverlay(transaction, key)\n            .next(value => {\n            overlay = value;\n            return this.remoteDocumentCache.getEntry(transaction, key);\n        })\n            .next(document => {\n            if (overlay !== null) {\n                mutationApplyToLocalView(overlay.mutation, document, FieldMask.empty(), Timestamp.now());\n            }\n            return document;\n        });\n    }\n    /**\n     * Gets the local view of the documents identified by `keys`.\n     *\n     * If we don't have cached state for a document in `keys`, a NoDocument will\n     * be stored for that key in the resulting set.\n     */\n    getDocuments(transaction, keys) {\n        return this.remoteDocumentCache\n            .getEntries(transaction, keys)\n            .next(docs => this.getLocalViewOfDocuments(transaction, docs, documentKeySet()).next(() => docs));\n    }\n    /**\n     * Similar to `getDocuments`, but creates the local view from the given\n     * `baseDocs` without retrieving documents from the local store.\n     *\n     * @param transaction - The transaction this operation is scoped to.\n     * @param docs - The documents to apply local mutations to get the local views.\n     * @param existenceStateChanged - The set of document keys whose existence state\n     *   is changed. This is useful to determine if some documents overlay needs\n     *   to be recalculated.\n     */\n    getLocalViewOfDocuments(transaction, docs, existenceStateChanged = documentKeySet()) {\n        const overlays = newOverlayMap();\n        return this.populateOverlays(transaction, overlays, docs).next(() => {\n            return this.computeViews(transaction, docs, overlays, existenceStateChanged).next(computeViewsResult => {\n                let result = documentMap();\n                computeViewsResult.forEach((documentKey, overlayedDocument) => {\n                    result = result.insert(documentKey, overlayedDocument.overlayedDocument);\n                });\n                return result;\n            });\n        });\n    }\n    /**\n     * Gets the overlayed documents for the given document map, which will include\n     * the local view of those documents and a `FieldMask` indicating which fields\n     * are mutated locally, `null` if overlay is a Set or Delete mutation.\n     */\n    getOverlayedDocuments(transaction, docs) {\n        const overlays = newOverlayMap();\n        return this.populateOverlays(transaction, overlays, docs).next(() => this.computeViews(transaction, docs, overlays, documentKeySet()));\n    }\n    /**\n     * Fetches the overlays for {@code docs} and adds them to provided overlay map\n     * if the map does not already contain an entry for the given document key.\n     */\n    populateOverlays(transaction, overlays, docs) {\n        const missingOverlays = [];\n        docs.forEach(key => {\n            if (!overlays.has(key)) {\n                missingOverlays.push(key);\n            }\n        });\n        return this.documentOverlayCache\n            .getOverlays(transaction, missingOverlays)\n            .next(result => {\n            result.forEach((key, val) => {\n                overlays.set(key, val);\n            });\n        });\n    }\n    /**\n     * Computes the local view for the given documents.\n     *\n     * @param docs - The documents to compute views for. It also has the base\n     *   version of the documents.\n     * @param overlays - The overlays that need to be applied to the given base\n     *   version of the documents.\n     * @param existenceStateChanged - A set of documents whose existence states\n     *   might have changed. This is used to determine if we need to re-calculate\n     *   overlays from mutation queues.\n     * @return A map represents the local documents view.\n     */\n    computeViews(transaction, docs, overlays, existenceStateChanged) {\n        let recalculateDocuments = mutableDocumentMap();\n        const mutatedFields = newDocumentKeyMap();\n        const results = newOverlayedDocumentMap();\n        docs.forEach((_, doc) => {\n            const overlay = overlays.get(doc.key);\n            // Recalculate an overlay if the document's existence state changed due to\n            // a remote event *and* the overlay is a PatchMutation. This is because\n            // document existence state can change if some patch mutation's\n            // preconditions are met.\n            // NOTE: we recalculate when `overlay` is undefined as well, because there\n            // might be a patch mutation whose precondition does not match before the\n            // change (hence overlay is undefined), but would now match.\n            if (existenceStateChanged.has(doc.key) &&\n                (overlay === undefined || overlay.mutation instanceof PatchMutation)) {\n                recalculateDocuments = recalculateDocuments.insert(doc.key, doc);\n            }\n            else if (overlay !== undefined) {\n                mutatedFields.set(doc.key, overlay.mutation.getFieldMask());\n                mutationApplyToLocalView(overlay.mutation, doc, overlay.mutation.getFieldMask(), Timestamp.now());\n            }\n            else {\n                // no overlay exists\n                // Using EMPTY to indicate there is no overlay for the document.\n                mutatedFields.set(doc.key, FieldMask.empty());\n            }\n        });\n        return this.recalculateAndSaveOverlays(transaction, recalculateDocuments).next(recalculatedFields => {\n            recalculatedFields.forEach((documentKey, mask) => mutatedFields.set(documentKey, mask));\n            docs.forEach((documentKey, document) => {\n                var _a;\n                return results.set(documentKey, new OverlayedDocument(document, (_a = mutatedFields.get(documentKey)) !== null && _a !== void 0 ? _a : null));\n            });\n            return results;\n        });\n    }\n    recalculateAndSaveOverlays(transaction, docs) {\n        const masks = newDocumentKeyMap();\n        // A reverse lookup map from batch id to the documents within that batch.\n        let documentsByBatchId = new SortedMap((key1, key2) => key1 - key2);\n        let processed = documentKeySet();\n        return this.mutationQueue\n            .getAllMutationBatchesAffectingDocumentKeys(transaction, docs)\n            .next(batches => {\n            for (const batch of batches) {\n                batch.keys().forEach(key => {\n                    const baseDoc = docs.get(key);\n                    if (baseDoc === null) {\n                        return;\n                    }\n                    let mask = masks.get(key) || FieldMask.empty();\n                    mask = batch.applyToLocalView(baseDoc, mask);\n                    masks.set(key, mask);\n                    const newSet = (documentsByBatchId.get(batch.batchId) || documentKeySet()).add(key);\n                    documentsByBatchId = documentsByBatchId.insert(batch.batchId, newSet);\n                });\n            }\n        })\n            .next(() => {\n            const promises = [];\n            // Iterate in descending order of batch IDs, and skip documents that are\n            // already saved.\n            const iter = documentsByBatchId.getReverseIterator();\n            while (iter.hasNext()) {\n                const entry = iter.getNext();\n                const batchId = entry.key;\n                const keys = entry.value;\n                const overlays = newMutationMap();\n                keys.forEach(key => {\n                    if (!processed.has(key)) {\n                        const overlayMutation = calculateOverlayMutation(docs.get(key), masks.get(key));\n                        if (overlayMutation !== null) {\n                            overlays.set(key, overlayMutation);\n                        }\n                        processed = processed.add(key);\n                    }\n                });\n                promises.push(this.documentOverlayCache.saveOverlays(transaction, batchId, overlays));\n            }\n            return PersistencePromise.waitFor(promises);\n        })\n            .next(() => masks);\n    }\n    /**\n     * Recalculates overlays by reading the documents from remote document cache\n     * first, and saves them after they are calculated.\n     */\n    recalculateAndSaveOverlaysForDocumentKeys(transaction, documentKeys) {\n        return this.remoteDocumentCache\n            .getEntries(transaction, documentKeys)\n            .next(docs => this.recalculateAndSaveOverlays(transaction, docs));\n    }\n    /**\n     * Performs a query against the local view of all documents.\n     *\n     * @param transaction - The persistence transaction.\n     * @param query - The query to match documents against.\n     * @param offset - Read time and key to start scanning by (exclusive).\n     * @param context - A optional tracker to keep a record of important details\n     *   during database local query execution.\n     */\n    getDocumentsMatchingQuery(transaction, query, offset, context) {\n        if (isDocumentQuery$1(query)) {\n            return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\n        }\n        else if (isCollectionGroupQuery(query)) {\n            return this.getDocumentsMatchingCollectionGroupQuery(transaction, query, offset, context);\n        }\n        else {\n            return this.getDocumentsMatchingCollectionQuery(transaction, query, offset, context);\n        }\n    }\n    /**\n     * Given a collection group, returns the next documents that follow the provided offset, along\n     * with an updated batch ID.\n     *\n     * <p>The documents returned by this method are ordered by remote version from the provided\n     * offset. If there are no more remote documents after the provided offset, documents with\n     * mutations in order of batch id from the offset are returned. Since all documents in a batch are\n     * returned together, the total number of documents returned can exceed {@code count}.\n     *\n     * @param transaction\n     * @param collectionGroup The collection group for the documents.\n     * @param offset The offset to index into.\n     * @param count The number of documents to return\n     * @return A LocalWriteResult with the documents that follow the provided offset and the last processed batch id.\n     */\n    getNextDocuments(transaction, collectionGroup, offset, count) {\n        return this.remoteDocumentCache\n            .getAllFromCollectionGroup(transaction, collectionGroup, offset, count)\n            .next((originalDocs) => {\n            const overlaysPromise = count - originalDocs.size > 0\n                ? this.documentOverlayCache.getOverlaysForCollectionGroup(transaction, collectionGroup, offset.largestBatchId, count - originalDocs.size)\n                : PersistencePromise.resolve(newOverlayMap());\n            // The callsite will use the largest batch ID together with the latest read time to create\n            // a new index offset. Since we only process batch IDs if all remote documents have been read,\n            // no overlay will increase the overall read time. This is why we only need to special case\n            // the batch id.\n            let largestBatchId = INITIAL_LARGEST_BATCH_ID;\n            let modifiedDocs = originalDocs;\n            return overlaysPromise.next(overlays => {\n                return PersistencePromise.forEach(overlays, (key, overlay) => {\n                    if (largestBatchId < overlay.largestBatchId) {\n                        largestBatchId = overlay.largestBatchId;\n                    }\n                    if (originalDocs.get(key)) {\n                        return PersistencePromise.resolve();\n                    }\n                    return this.remoteDocumentCache\n                        .getEntry(transaction, key)\n                        .next(doc => {\n                        modifiedDocs = modifiedDocs.insert(key, doc);\n                    });\n                })\n                    .next(() => this.populateOverlays(transaction, overlays, originalDocs))\n                    .next(() => this.computeViews(transaction, modifiedDocs, overlays, documentKeySet()))\n                    .next(localDocs => ({\n                    batchId: largestBatchId,\n                    changes: convertOverlayedDocumentMapToDocumentMap(localDocs)\n                }));\n            });\n        });\n    }\n    getDocumentsMatchingDocumentQuery(transaction, docPath) {\n        // Just do a simple document lookup.\n        return this.getDocument(transaction, new DocumentKey(docPath)).next(document => {\n            let result = documentMap();\n            if (document.isFoundDocument()) {\n                result = result.insert(document.key, document);\n            }\n            return result;\n        });\n    }\n    getDocumentsMatchingCollectionGroupQuery(transaction, query, offset, context) {\n        const collectionId = query.collectionGroup;\n        let results = documentMap();\n        return this.indexManager\n            .getCollectionParents(transaction, collectionId)\n            .next(parents => {\n            // Perform a collection query against each parent that contains the\n            // collectionId and aggregate the results.\n            return PersistencePromise.forEach(parents, (parent) => {\n                const collectionQuery = asCollectionQueryAtPath(query, parent.child(collectionId));\n                return this.getDocumentsMatchingCollectionQuery(transaction, collectionQuery, offset, context).next(r => {\n                    r.forEach((key, doc) => {\n                        results = results.insert(key, doc);\n                    });\n                });\n            }).next(() => results);\n        });\n    }\n    getDocumentsMatchingCollectionQuery(transaction, query, offset, context) {\n        // Query the remote documents and overlay mutations.\n        let overlays;\n        return this.documentOverlayCache\n            .getOverlaysForCollection(transaction, query.path, offset.largestBatchId)\n            .next(result => {\n            overlays = result;\n            return this.remoteDocumentCache.getDocumentsMatchingQuery(transaction, query, offset, overlays, context);\n        })\n            .next(remoteDocuments => {\n            // As documents might match the query because of their overlay we need to\n            // include documents for all overlays in the initial document set.\n            overlays.forEach((_, overlay) => {\n                const key = overlay.getKey();\n                if (remoteDocuments.get(key) === null) {\n                    remoteDocuments = remoteDocuments.insert(key, MutableDocument.newInvalidDocument(key));\n                }\n            });\n            // Apply the overlays and match against the query.\n            let results = documentMap();\n            remoteDocuments.forEach((key, document) => {\n                const overlay = overlays.get(key);\n                if (overlay !== undefined) {\n                    mutationApplyToLocalView(overlay.mutation, document, FieldMask.empty(), Timestamp.now());\n                }\n                // Finally, insert the documents that still match the query\n                if (queryMatches(query, document)) {\n                    results = results.insert(key, document);\n                }\n            });\n            return results;\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryBundleCache {\n    constructor(serializer) {\n        this.serializer = serializer;\n        this.bundles = new Map();\n        this.namedQueries = new Map();\n    }\n    getBundleMetadata(transaction, bundleId) {\n        return PersistencePromise.resolve(this.bundles.get(bundleId));\n    }\n    saveBundleMetadata(transaction, bundleMetadata) {\n        this.bundles.set(bundleMetadata.id, fromBundleMetadata(bundleMetadata));\n        return PersistencePromise.resolve();\n    }\n    getNamedQuery(transaction, queryName) {\n        return PersistencePromise.resolve(this.namedQueries.get(queryName));\n    }\n    saveNamedQuery(transaction, query) {\n        this.namedQueries.set(query.name, fromProtoNamedQuery(query));\n        return PersistencePromise.resolve();\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An in-memory implementation of DocumentOverlayCache.\n */\nclass MemoryDocumentOverlayCache {\n    constructor() {\n        // A map sorted by DocumentKey, whose value is a pair of the largest batch id\n        // for the overlay and the overlay itself.\n        this.overlays = new SortedMap(DocumentKey.comparator);\n        this.overlayByBatchId = new Map();\n    }\n    getOverlay(transaction, key) {\n        return PersistencePromise.resolve(this.overlays.get(key));\n    }\n    getOverlays(transaction, keys) {\n        const result = newOverlayMap();\n        return PersistencePromise.forEach(keys, (key) => {\n            return this.getOverlay(transaction, key).next(overlay => {\n                if (overlay !== null) {\n                    result.set(key, overlay);\n                }\n            });\n        }).next(() => result);\n    }\n    saveOverlays(transaction, largestBatchId, overlays) {\n        overlays.forEach((_, mutation) => {\n            this.saveOverlay(transaction, largestBatchId, mutation);\n        });\n        return PersistencePromise.resolve();\n    }\n    removeOverlaysForBatchId(transaction, documentKeys, batchId) {\n        const keys = this.overlayByBatchId.get(batchId);\n        if (keys !== undefined) {\n            keys.forEach(key => (this.overlays = this.overlays.remove(key)));\n            this.overlayByBatchId.delete(batchId);\n        }\n        return PersistencePromise.resolve();\n    }\n    getOverlaysForCollection(transaction, collection, sinceBatchId) {\n        const result = newOverlayMap();\n        const immediateChildrenPathLength = collection.length + 1;\n        const prefix = new DocumentKey(collection.child(''));\n        const iter = this.overlays.getIteratorFrom(prefix);\n        while (iter.hasNext()) {\n            const entry = iter.getNext();\n            const overlay = entry.value;\n            const key = overlay.getKey();\n            if (!collection.isPrefixOf(key.path)) {\n                break;\n            }\n            // Documents from sub-collections\n            if (key.path.length !== immediateChildrenPathLength) {\n                continue;\n            }\n            if (overlay.largestBatchId > sinceBatchId) {\n                result.set(overlay.getKey(), overlay);\n            }\n        }\n        return PersistencePromise.resolve(result);\n    }\n    getOverlaysForCollectionGroup(transaction, collectionGroup, sinceBatchId, count) {\n        let batchIdToOverlays = new SortedMap((key1, key2) => key1 - key2);\n        const iter = this.overlays.getIterator();\n        while (iter.hasNext()) {\n            const entry = iter.getNext();\n            const overlay = entry.value;\n            const key = overlay.getKey();\n            if (key.getCollectionGroup() !== collectionGroup) {\n                continue;\n            }\n            if (overlay.largestBatchId > sinceBatchId) {\n                let overlaysForBatchId = batchIdToOverlays.get(overlay.largestBatchId);\n                if (overlaysForBatchId === null) {\n                    overlaysForBatchId = newOverlayMap();\n                    batchIdToOverlays = batchIdToOverlays.insert(overlay.largestBatchId, overlaysForBatchId);\n                }\n                overlaysForBatchId.set(overlay.getKey(), overlay);\n            }\n        }\n        const result = newOverlayMap();\n        const batchIter = batchIdToOverlays.getIterator();\n        while (batchIter.hasNext()) {\n            const entry = batchIter.getNext();\n            const overlays = entry.value;\n            overlays.forEach((key, overlay) => result.set(key, overlay));\n            if (result.size() >= count) {\n                break;\n            }\n        }\n        return PersistencePromise.resolve(result);\n    }\n    saveOverlay(transaction, largestBatchId, mutation) {\n        // Remove the association of the overlay to its batch id.\n        const existing = this.overlays.get(mutation.key);\n        if (existing !== null) {\n            const newSet = this.overlayByBatchId\n                .get(existing.largestBatchId)\n                .delete(mutation.key);\n            this.overlayByBatchId.set(existing.largestBatchId, newSet);\n        }\n        this.overlays = this.overlays.insert(mutation.key, new Overlay(largestBatchId, mutation));\n        // Create the association of this overlay to the given largestBatchId.\n        let batch = this.overlayByBatchId.get(largestBatchId);\n        if (batch === undefined) {\n            batch = documentKeySet();\n            this.overlayByBatchId.set(largestBatchId, batch);\n        }\n        this.overlayByBatchId.set(largestBatchId, batch.add(mutation.key));\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryGlobalsCache {\n    constructor() {\n        this.sessionToken = ByteString.EMPTY_BYTE_STRING;\n    }\n    getSessionToken(transaction) {\n        return PersistencePromise.resolve(this.sessionToken);\n    }\n    setSessionToken(transaction, sessionToken) {\n        this.sessionToken = sessionToken;\n        return PersistencePromise.resolve();\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A collection of references to a document from some kind of numbered entity\n * (either a target ID or batch ID). As references are added to or removed from\n * the set corresponding events are emitted to a registered garbage collector.\n *\n * Each reference is represented by a DocumentReference object. Each of them\n * contains enough information to uniquely identify the reference. They are all\n * stored primarily in a set sorted by key. A document is considered garbage if\n * there's no references in that set (this can be efficiently checked thanks to\n * sorting by key).\n *\n * ReferenceSet also keeps a secondary set that contains references sorted by\n * IDs. This one is used to efficiently implement removal of all references by\n * some target ID.\n */\nclass ReferenceSet {\n    constructor() {\n        // A set of outstanding references to a document sorted by key.\n        this.refsByKey = new SortedSet(DocReference.compareByKey);\n        // A set of outstanding references to a document sorted by target id.\n        this.refsByTarget = new SortedSet(DocReference.compareByTargetId);\n    }\n    /** Returns true if the reference set contains no references. */\n    isEmpty() {\n        return this.refsByKey.isEmpty();\n    }\n    /** Adds a reference to the given document key for the given ID. */\n    addReference(key, id) {\n        const ref = new DocReference(key, id);\n        this.refsByKey = this.refsByKey.add(ref);\n        this.refsByTarget = this.refsByTarget.add(ref);\n    }\n    /** Add references to the given document keys for the given ID. */\n    addReferences(keys, id) {\n        keys.forEach(key => this.addReference(key, id));\n    }\n    /**\n     * Removes a reference to the given document key for the given\n     * ID.\n     */\n    removeReference(key, id) {\n        this.removeRef(new DocReference(key, id));\n    }\n    removeReferences(keys, id) {\n        keys.forEach(key => this.removeReference(key, id));\n    }\n    /**\n     * Clears all references with a given ID. Calls removeRef() for each key\n     * removed.\n     */\n    removeReferencesForId(id) {\n        const emptyKey = new DocumentKey(new ResourcePath([]));\n        const startRef = new DocReference(emptyKey, id);\n        const endRef = new DocReference(emptyKey, id + 1);\n        const keys = [];\n        this.refsByTarget.forEachInRange([startRef, endRef], ref => {\n            this.removeRef(ref);\n            keys.push(ref.key);\n        });\n        return keys;\n    }\n    removeAllReferences() {\n        this.refsByKey.forEach(ref => this.removeRef(ref));\n    }\n    removeRef(ref) {\n        this.refsByKey = this.refsByKey.delete(ref);\n        this.refsByTarget = this.refsByTarget.delete(ref);\n    }\n    referencesForId(id) {\n        const emptyKey = new DocumentKey(new ResourcePath([]));\n        const startRef = new DocReference(emptyKey, id);\n        const endRef = new DocReference(emptyKey, id + 1);\n        let keys = documentKeySet();\n        this.refsByTarget.forEachInRange([startRef, endRef], ref => {\n            keys = keys.add(ref.key);\n        });\n        return keys;\n    }\n    containsKey(key) {\n        const ref = new DocReference(key, 0);\n        const firstRef = this.refsByKey.firstAfterOrEqual(ref);\n        return firstRef !== null && key.isEqual(firstRef.key);\n    }\n}\nclass DocReference {\n    constructor(key, targetOrBatchId) {\n        this.key = key;\n        this.targetOrBatchId = targetOrBatchId;\n    }\n    /** Compare by key then by ID */\n    static compareByKey(left, right) {\n        return (DocumentKey.comparator(left.key, right.key) ||\n            primitiveComparator(left.targetOrBatchId, right.targetOrBatchId));\n    }\n    /** Compare by ID then by key */\n    static compareByTargetId(left, right) {\n        return (primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) ||\n            DocumentKey.comparator(left.key, right.key));\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryMutationQueue {\n    constructor(indexManager, referenceDelegate) {\n        this.indexManager = indexManager;\n        this.referenceDelegate = referenceDelegate;\n        /**\n         * The set of all mutations that have been sent but not yet been applied to\n         * the backend.\n         */\n        this.mutationQueue = [];\n        /** Next value to use when assigning sequential IDs to each mutation batch. */\n        this.nextBatchId = 1;\n        /** An ordered mapping between documents and the mutations batch IDs. */\n        this.batchesByDocumentKey = new SortedSet(DocReference.compareByKey);\n    }\n    checkEmpty(transaction) {\n        return PersistencePromise.resolve(this.mutationQueue.length === 0);\n    }\n    addMutationBatch(transaction, localWriteTime, baseMutations, mutations) {\n        const batchId = this.nextBatchId;\n        this.nextBatchId++;\n        if (this.mutationQueue.length > 0) {\n            this.mutationQueue[this.mutationQueue.length - 1];\n        }\n        const batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);\n        this.mutationQueue.push(batch);\n        // Track references by document key and index collection parents.\n        for (const mutation of mutations) {\n            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new DocReference(mutation.key, batchId));\n            this.indexManager.addToCollectionParentIndex(transaction, mutation.key.path.popLast());\n        }\n        return PersistencePromise.resolve(batch);\n    }\n    lookupMutationBatch(transaction, batchId) {\n        return PersistencePromise.resolve(this.findMutationBatch(batchId));\n    }\n    getNextMutationBatchAfterBatchId(transaction, batchId) {\n        const nextBatchId = batchId + 1;\n        // The requested batchId may still be out of range so normalize it to the\n        // start of the queue.\n        const rawIndex = this.indexOfBatchId(nextBatchId);\n        const index = rawIndex < 0 ? 0 : rawIndex;\n        return PersistencePromise.resolve(this.mutationQueue.length > index ? this.mutationQueue[index] : null);\n    }\n    getHighestUnacknowledgedBatchId() {\n        return PersistencePromise.resolve(this.mutationQueue.length === 0 ? BATCHID_UNKNOWN : this.nextBatchId - 1);\n    }\n    getAllMutationBatches(transaction) {\n        return PersistencePromise.resolve(this.mutationQueue.slice());\n    }\n    getAllMutationBatchesAffectingDocumentKey(transaction, documentKey) {\n        const start = new DocReference(documentKey, 0);\n        const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n        const result = [];\n        this.batchesByDocumentKey.forEachInRange([start, end], ref => {\n            const batch = this.findMutationBatch(ref.targetOrBatchId);\n            result.push(batch);\n        });\n        return PersistencePromise.resolve(result);\n    }\n    getAllMutationBatchesAffectingDocumentKeys(transaction, documentKeys) {\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\n        documentKeys.forEach(documentKey => {\n            const start = new DocReference(documentKey, 0);\n            const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n            this.batchesByDocumentKey.forEachInRange([start, end], ref => {\n                uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n            });\n        });\n        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));\n    }\n    getAllMutationBatchesAffectingQuery(transaction, query) {\n        // Use the query path as a prefix for testing if a document matches the\n        // query.\n        const prefix = query.path;\n        const immediateChildrenPathLength = prefix.length + 1;\n        // Construct a document reference for actually scanning the index. Unlike\n        // the prefix the document key in this reference must have an even number of\n        // segments. The empty segment can be used a suffix of the query path\n        // because it precedes all other segments in an ordered traversal.\n        let startPath = prefix;\n        if (!DocumentKey.isDocumentKey(startPath)) {\n            startPath = startPath.child('');\n        }\n        const start = new DocReference(new DocumentKey(startPath), 0);\n        // Find unique batchIDs referenced by all documents potentially matching the\n        // query.\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\n        this.batchesByDocumentKey.forEachWhile(ref => {\n            const rowKeyPath = ref.key.path;\n            if (!prefix.isPrefixOf(rowKeyPath)) {\n                return false;\n            }\n            else {\n                // Rows with document keys more than one segment longer than the query\n                // path can't be matches. For example, a query on 'rooms' can't match\n                // the document /rooms/abc/messages/xyx.\n                // TODO(mcg): we'll need a different scanner when we implement\n                // ancestor queries.\n                if (rowKeyPath.length === immediateChildrenPathLength) {\n                    uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n                }\n                return true;\n            }\n        }, start);\n        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));\n    }\n    findMutationBatches(batchIDs) {\n        // Construct an array of matching batches, sorted by batchID to ensure that\n        // multiple mutations affecting the same document key are applied in order.\n        const result = [];\n        batchIDs.forEach(batchId => {\n            const batch = this.findMutationBatch(batchId);\n            if (batch !== null) {\n                result.push(batch);\n            }\n        });\n        return result;\n    }\n    removeMutationBatch(transaction, batch) {\n        // Find the position of the first batch for removal.\n        const batchIndex = this.indexOfExistingBatchId(batch.batchId, 'removed');\n        hardAssert(batchIndex === 0);\n        this.mutationQueue.shift();\n        let references = this.batchesByDocumentKey;\n        return PersistencePromise.forEach(batch.mutations, (mutation) => {\n            const ref = new DocReference(mutation.key, batch.batchId);\n            references = references.delete(ref);\n            return this.referenceDelegate.markPotentiallyOrphaned(transaction, mutation.key);\n        }).next(() => {\n            this.batchesByDocumentKey = references;\n        });\n    }\n    removeCachedMutationKeys(batchId) {\n        // No-op since the memory mutation queue does not maintain a separate cache.\n    }\n    containsKey(txn, key) {\n        const ref = new DocReference(key, 0);\n        const firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\n        return PersistencePromise.resolve(key.isEqual(firstRef && firstRef.key));\n    }\n    performConsistencyCheck(txn) {\n        if (this.mutationQueue.length === 0) ;\n        return PersistencePromise.resolve();\n    }\n    /**\n     * Finds the index of the given batchId in the mutation queue and asserts that\n     * the resulting index is within the bounds of the queue.\n     *\n     * @param batchId - The batchId to search for\n     * @param action - A description of what the caller is doing, phrased in passive\n     * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\n     */\n    indexOfExistingBatchId(batchId, action) {\n        const index = this.indexOfBatchId(batchId);\n        return index;\n    }\n    /**\n     * Finds the index of the given batchId in the mutation queue. This operation\n     * is O(1).\n     *\n     * @returns The computed index of the batch with the given batchId, based on\n     * the state of the queue. Note this index can be negative if the requested\n     * batchId has already been removed from the queue or past the end of the\n     * queue if the batchId is larger than the last added batch.\n     */\n    indexOfBatchId(batchId) {\n        if (this.mutationQueue.length === 0) {\n            // As an index this is past the end of the queue\n            return 0;\n        }\n        // Examine the front of the queue to figure out the difference between the\n        // batchId and indexes in the array. Note that since the queue is ordered\n        // by batchId, if the first batch has a larger batchId then the requested\n        // batchId doesn't exist in the queue.\n        const firstBatchId = this.mutationQueue[0].batchId;\n        return batchId - firstBatchId;\n    }\n    /**\n     * A version of lookupMutationBatch that doesn't return a promise, this makes\n     * other functions that uses this code easier to read and more efficient.\n     */\n    findMutationBatch(batchId) {\n        const index = this.indexOfBatchId(batchId);\n        if (index < 0 || index >= this.mutationQueue.length) {\n            return null;\n        }\n        const batch = this.mutationQueue[index];\n        return batch;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The smallest value representable by a 64-bit signed integer (long).\n */\nconst MIN_LONG_VALUE = '-9223372036854775808';\nfunction documentEntryMap() {\n    return new SortedMap(DocumentKey.comparator);\n}\n/**\n * The memory-only RemoteDocumentCache for IndexedDb. To construct, invoke\n * `newMemoryRemoteDocumentCache()`.\n */\nclass MemoryRemoteDocumentCacheImpl {\n    /**\n     * @param sizer - Used to assess the size of a document. For eager GC, this is\n     * expected to just return 0 to avoid unnecessarily doing the work of\n     * calculating the size.\n     */\n    constructor(sizer) {\n        this.sizer = sizer;\n        /** Underlying cache of documents and their read times. */\n        this.docs = documentEntryMap();\n        /** Size of all cached documents. */\n        this.size = 0;\n    }\n    setIndexManager(indexManager) {\n        this.indexManager = indexManager;\n    }\n    /**\n     * Adds the supplied entry to the cache and updates the cache size as appropriate.\n     *\n     * All calls of `addEntry`  are required to go through the RemoteDocumentChangeBuffer\n     * returned by `newChangeBuffer()`.\n     */\n    addEntry(transaction, doc) {\n        const key = doc.key;\n        const entry = this.docs.get(key);\n        const previousSize = entry ? entry.size : 0;\n        const currentSize = this.sizer(doc);\n        this.docs = this.docs.insert(key, {\n            document: doc.mutableCopy(),\n            size: currentSize\n        });\n        this.size += currentSize - previousSize;\n        return this.indexManager.addToCollectionParentIndex(transaction, key.path.popLast());\n    }\n    /**\n     * Removes the specified entry from the cache and updates the cache size as appropriate.\n     *\n     * All calls of `removeEntry` are required to go through the RemoteDocumentChangeBuffer\n     * returned by `newChangeBuffer()`.\n     */\n    removeEntry(documentKey) {\n        const entry = this.docs.get(documentKey);\n        if (entry) {\n            this.docs = this.docs.remove(documentKey);\n            this.size -= entry.size;\n        }\n    }\n    getEntry(transaction, documentKey) {\n        const entry = this.docs.get(documentKey);\n        return PersistencePromise.resolve(entry\n            ? entry.document.mutableCopy()\n            : MutableDocument.newInvalidDocument(documentKey));\n    }\n    getEntries(transaction, documentKeys) {\n        let results = mutableDocumentMap();\n        documentKeys.forEach(documentKey => {\n            const entry = this.docs.get(documentKey);\n            results = results.insert(documentKey, entry\n                ? entry.document.mutableCopy()\n                : MutableDocument.newInvalidDocument(documentKey));\n        });\n        return PersistencePromise.resolve(results);\n    }\n    getDocumentsMatchingQuery(transaction, query, offset, mutatedDocs) {\n        let results = mutableDocumentMap();\n        // Documents are ordered by key, so we can use a prefix scan to narrow down\n        // the documents we need to match the query against.\n        const collectionPath = query.path;\n        // Document keys are ordered first by numeric value (\"__id<Long>__\"),\n        // then lexicographically by string value. Start the iterator at the minimum\n        // possible Document key value.\n        const prefix = new DocumentKey(collectionPath.child('__id' + MIN_LONG_VALUE + '__'));\n        const iterator = this.docs.getIteratorFrom(prefix);\n        while (iterator.hasNext()) {\n            const { key, value: { document } } = iterator.getNext();\n            if (!collectionPath.isPrefixOf(key.path)) {\n                break;\n            }\n            if (key.path.length > collectionPath.length + 1) {\n                // Exclude entries from subcollections.\n                continue;\n            }\n            if (indexOffsetComparator(newIndexOffsetFromDocument(document), offset) <= 0) {\n                // The document sorts before the offset.\n                continue;\n            }\n            if (!mutatedDocs.has(document.key) && !queryMatches(query, document)) {\n                // The document cannot possibly match the query.\n                continue;\n            }\n            results = results.insert(document.key, document.mutableCopy());\n        }\n        return PersistencePromise.resolve(results);\n    }\n    getAllFromCollectionGroup(transaction, collectionGroup, offset, limit) {\n        // This method should only be called from the IndexBackfiller if persistence\n        // is enabled.\n        fail();\n    }\n    forEachDocumentKey(transaction, f) {\n        return PersistencePromise.forEach(this.docs, (key) => f(key));\n    }\n    newChangeBuffer(options) {\n        // `trackRemovals` is ignores since the MemoryRemoteDocumentCache keeps\n        // a separate changelog and does not need special handling for removals.\n        return new MemoryRemoteDocumentChangeBuffer(this);\n    }\n    getSize(txn) {\n        return PersistencePromise.resolve(this.size);\n    }\n}\n/**\n * Creates a new memory-only RemoteDocumentCache.\n *\n * @param sizer - Used to assess the size of a document. For eager GC, this is\n * expected to just return 0 to avoid unnecessarily doing the work of\n * calculating the size.\n */\nfunction newMemoryRemoteDocumentCache(sizer) {\n    return new MemoryRemoteDocumentCacheImpl(sizer);\n}\n/**\n * Handles the details of adding and updating documents in the MemoryRemoteDocumentCache.\n */\nclass MemoryRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {\n    constructor(documentCache) {\n        super();\n        this.documentCache = documentCache;\n    }\n    applyChanges(transaction) {\n        const promises = [];\n        this.changes.forEach((key, doc) => {\n            if (doc.isValidDocument()) {\n                promises.push(this.documentCache.addEntry(transaction, doc));\n            }\n            else {\n                this.documentCache.removeEntry(key);\n            }\n        });\n        return PersistencePromise.waitFor(promises);\n    }\n    getFromCache(transaction, documentKey) {\n        return this.documentCache.getEntry(transaction, documentKey);\n    }\n    getAllFromCache(transaction, documentKeys) {\n        return this.documentCache.getEntries(transaction, documentKeys);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryTargetCache {\n    constructor(persistence) {\n        this.persistence = persistence;\n        /**\n         * Maps a target to the data about that target\n         */\n        this.targets = new ObjectMap(t => canonifyTarget(t), targetEquals);\n        /** The last received snapshot version. */\n        this.lastRemoteSnapshotVersion = SnapshotVersion.min();\n        /** The highest numbered target ID encountered. */\n        this.highestTargetId = 0;\n        /** The highest sequence number encountered. */\n        this.highestSequenceNumber = 0;\n        /**\n         * A ordered bidirectional mapping between documents and the remote target\n         * IDs.\n         */\n        this.references = new ReferenceSet();\n        this.targetCount = 0;\n        this.targetIdGenerator = TargetIdGenerator.forTargetCache();\n    }\n    forEachTarget(txn, f) {\n        this.targets.forEach((_, targetData) => f(targetData));\n        return PersistencePromise.resolve();\n    }\n    getLastRemoteSnapshotVersion(transaction) {\n        return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);\n    }\n    getHighestSequenceNumber(transaction) {\n        return PersistencePromise.resolve(this.highestSequenceNumber);\n    }\n    allocateTargetId(transaction) {\n        this.highestTargetId = this.targetIdGenerator.next();\n        return PersistencePromise.resolve(this.highestTargetId);\n    }\n    setTargetsMetadata(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {\n        if (lastRemoteSnapshotVersion) {\n            this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;\n        }\n        if (highestListenSequenceNumber > this.highestSequenceNumber) {\n            this.highestSequenceNumber = highestListenSequenceNumber;\n        }\n        return PersistencePromise.resolve();\n    }\n    saveTargetData(targetData) {\n        this.targets.set(targetData.target, targetData);\n        const targetId = targetData.targetId;\n        if (targetId > this.highestTargetId) {\n            this.targetIdGenerator = new TargetIdGenerator(targetId);\n            this.highestTargetId = targetId;\n        }\n        if (targetData.sequenceNumber > this.highestSequenceNumber) {\n            this.highestSequenceNumber = targetData.sequenceNumber;\n        }\n    }\n    addTargetData(transaction, targetData) {\n        this.saveTargetData(targetData);\n        this.targetCount += 1;\n        return PersistencePromise.resolve();\n    }\n    updateTargetData(transaction, targetData) {\n        this.saveTargetData(targetData);\n        return PersistencePromise.resolve();\n    }\n    removeTargetData(transaction, targetData) {\n        this.targets.delete(targetData.target);\n        this.references.removeReferencesForId(targetData.targetId);\n        this.targetCount -= 1;\n        return PersistencePromise.resolve();\n    }\n    removeTargets(transaction, upperBound, activeTargetIds) {\n        let count = 0;\n        const removals = [];\n        this.targets.forEach((key, targetData) => {\n            if (targetData.sequenceNumber <= upperBound &&\n                activeTargetIds.get(targetData.targetId) === null) {\n                this.targets.delete(key);\n                removals.push(this.removeMatchingKeysForTargetId(transaction, targetData.targetId));\n                count++;\n            }\n        });\n        return PersistencePromise.waitFor(removals).next(() => count);\n    }\n    getTargetCount(transaction) {\n        return PersistencePromise.resolve(this.targetCount);\n    }\n    getTargetData(transaction, target) {\n        const targetData = this.targets.get(target) || null;\n        return PersistencePromise.resolve(targetData);\n    }\n    addMatchingKeys(txn, keys, targetId) {\n        this.references.addReferences(keys, targetId);\n        return PersistencePromise.resolve();\n    }\n    removeMatchingKeys(txn, keys, targetId) {\n        this.references.removeReferences(keys, targetId);\n        const referenceDelegate = this.persistence.referenceDelegate;\n        const promises = [];\n        if (referenceDelegate) {\n            keys.forEach(key => {\n                promises.push(referenceDelegate.markPotentiallyOrphaned(txn, key));\n            });\n        }\n        return PersistencePromise.waitFor(promises);\n    }\n    removeMatchingKeysForTargetId(txn, targetId) {\n        this.references.removeReferencesForId(targetId);\n        return PersistencePromise.resolve();\n    }\n    getMatchingKeysForTargetId(txn, targetId) {\n        const matchingKeys = this.references.referencesForId(targetId);\n        return PersistencePromise.resolve(matchingKeys);\n    }\n    containsKey(txn, key) {\n        return PersistencePromise.resolve(this.references.containsKey(key));\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$d = 'MemoryPersistence';\n/**\n * A memory-backed instance of Persistence. Data is stored only in RAM and\n * not persisted across sessions.\n */\nclass MemoryPersistence {\n    /**\n     * The constructor accepts a factory for creating a reference delegate. This\n     * allows both the delegate and this instance to have strong references to\n     * each other without having nullable fields that would then need to be\n     * checked or asserted on every access.\n     */\n    constructor(referenceDelegateFactory, serializer) {\n        this.mutationQueues = {};\n        this.overlays = {};\n        this.listenSequence = new ListenSequence(0);\n        this._started = false;\n        this._started = true;\n        this.globalsCache = new MemoryGlobalsCache();\n        this.referenceDelegate = referenceDelegateFactory(this);\n        this.targetCache = new MemoryTargetCache(this);\n        const sizer = (doc) => this.referenceDelegate.documentSize(doc);\n        this.indexManager = new MemoryIndexManager();\n        this.remoteDocumentCache = newMemoryRemoteDocumentCache(sizer);\n        this.serializer = new LocalSerializer(serializer);\n        this.bundleCache = new MemoryBundleCache(this.serializer);\n    }\n    start() {\n        return Promise.resolve();\n    }\n    shutdown() {\n        // No durable state to ensure is closed on shutdown.\n        this._started = false;\n        return Promise.resolve();\n    }\n    get started() {\n        return this._started;\n    }\n    setDatabaseDeletedListener() {\n        // No op.\n    }\n    setNetworkEnabled() {\n        // No op.\n    }\n    getIndexManager(user) {\n        // We do not currently support indices for memory persistence, so we can\n        // return the same shared instance of the memory index manager.\n        return this.indexManager;\n    }\n    getDocumentOverlayCache(user) {\n        let overlay = this.overlays[user.toKey()];\n        if (!overlay) {\n            overlay = new MemoryDocumentOverlayCache();\n            this.overlays[user.toKey()] = overlay;\n        }\n        return overlay;\n    }\n    getMutationQueue(user, indexManager) {\n        let queue = this.mutationQueues[user.toKey()];\n        if (!queue) {\n            queue = new MemoryMutationQueue(indexManager, this.referenceDelegate);\n            this.mutationQueues[user.toKey()] = queue;\n        }\n        return queue;\n    }\n    getGlobalsCache() {\n        return this.globalsCache;\n    }\n    getTargetCache() {\n        return this.targetCache;\n    }\n    getRemoteDocumentCache() {\n        return this.remoteDocumentCache;\n    }\n    getBundleCache() {\n        return this.bundleCache;\n    }\n    runTransaction(action, mode, transactionOperation) {\n        logDebug(LOG_TAG$d, 'Starting transaction:', action);\n        const txn = new MemoryTransaction(this.listenSequence.next());\n        this.referenceDelegate.onTransactionStarted();\n        return transactionOperation(txn)\n            .next(result => {\n            return this.referenceDelegate\n                .onTransactionCommitted(txn)\n                .next(() => result);\n        })\n            .toPromise()\n            .then(result => {\n            txn.raiseOnCommittedEvent();\n            return result;\n        });\n    }\n    mutationQueuesContainKey(transaction, key) {\n        return PersistencePromise.or(Object.values(this.mutationQueues).map(queue => () => queue.containsKey(transaction, key)));\n    }\n}\n/**\n * Memory persistence is not actually transactional, but future implementations\n * may have transaction-scoped state.\n */\nclass MemoryTransaction extends PersistenceTransaction {\n    constructor(currentSequenceNumber) {\n        super();\n        this.currentSequenceNumber = currentSequenceNumber;\n    }\n}\nclass MemoryEagerDelegate {\n    constructor(persistence) {\n        this.persistence = persistence;\n        /** Tracks all documents that are active in Query views. */\n        this.localViewReferences = new ReferenceSet();\n        /** The list of documents that are potentially GCed after each transaction. */\n        this._orphanedDocuments = null;\n    }\n    static factory(persistence) {\n        return new MemoryEagerDelegate(persistence);\n    }\n    get orphanedDocuments() {\n        if (!this._orphanedDocuments) {\n            throw fail();\n        }\n        else {\n            return this._orphanedDocuments;\n        }\n    }\n    addReference(txn, targetId, key) {\n        this.localViewReferences.addReference(key, targetId);\n        this.orphanedDocuments.delete(key.toString());\n        return PersistencePromise.resolve();\n    }\n    removeReference(txn, targetId, key) {\n        this.localViewReferences.removeReference(key, targetId);\n        this.orphanedDocuments.add(key.toString());\n        return PersistencePromise.resolve();\n    }\n    markPotentiallyOrphaned(txn, key) {\n        this.orphanedDocuments.add(key.toString());\n        return PersistencePromise.resolve();\n    }\n    removeTarget(txn, targetData) {\n        const orphaned = this.localViewReferences.removeReferencesForId(targetData.targetId);\n        orphaned.forEach(key => this.orphanedDocuments.add(key.toString()));\n        const cache = this.persistence.getTargetCache();\n        return cache\n            .getMatchingKeysForTargetId(txn, targetData.targetId)\n            .next(keys => {\n            keys.forEach(key => this.orphanedDocuments.add(key.toString()));\n        })\n            .next(() => cache.removeTargetData(txn, targetData));\n    }\n    onTransactionStarted() {\n        this._orphanedDocuments = new Set();\n    }\n    onTransactionCommitted(txn) {\n        // Remove newly orphaned documents.\n        const cache = this.persistence.getRemoteDocumentCache();\n        const changeBuffer = cache.newChangeBuffer();\n        return PersistencePromise.forEach(this.orphanedDocuments, (path) => {\n            const key = DocumentKey.fromPath(path);\n            return this.isReferenced(txn, key).next(isReferenced => {\n                if (!isReferenced) {\n                    changeBuffer.removeEntry(key, SnapshotVersion.min());\n                }\n            });\n        }).next(() => {\n            this._orphanedDocuments = null;\n            return changeBuffer.apply(txn);\n        });\n    }\n    updateLimboDocument(txn, key) {\n        return this.isReferenced(txn, key).next(isReferenced => {\n            if (isReferenced) {\n                this.orphanedDocuments.delete(key.toString());\n            }\n            else {\n                this.orphanedDocuments.add(key.toString());\n            }\n        });\n    }\n    documentSize(doc) {\n        // For eager GC, we don't care about the document size, there are no size thresholds.\n        return 0;\n    }\n    isReferenced(txn, key) {\n        return PersistencePromise.or([\n            () => PersistencePromise.resolve(this.localViewReferences.containsKey(key)),\n            () => this.persistence.getTargetCache().containsKey(txn, key),\n            () => this.persistence.mutationQueuesContainKey(txn, key)\n        ]);\n    }\n}\nclass MemoryLruDelegate {\n    constructor(persistence, lruParams) {\n        this.persistence = persistence;\n        this.orphanedSequenceNumbers = new ObjectMap(k => encodeResourcePath(k.path), (l, r) => l.isEqual(r));\n        this.garbageCollector = newLruGarbageCollector(this, lruParams);\n    }\n    static factory(persistence, lruParams) {\n        return new MemoryLruDelegate(persistence, lruParams);\n    }\n    // No-ops, present so memory persistence doesn't have to care which delegate\n    // it has.\n    onTransactionStarted() { }\n    onTransactionCommitted(txn) {\n        return PersistencePromise.resolve();\n    }\n    forEachTarget(txn, f) {\n        return this.persistence.getTargetCache().forEachTarget(txn, f);\n    }\n    getSequenceNumberCount(txn) {\n        const docCountPromise = this.orphanedDocumentCount(txn);\n        const targetCountPromise = this.persistence\n            .getTargetCache()\n            .getTargetCount(txn);\n        return targetCountPromise.next(targetCount => docCountPromise.next(docCount => targetCount + docCount));\n    }\n    orphanedDocumentCount(txn) {\n        let orphanedCount = 0;\n        return this.forEachOrphanedDocumentSequenceNumber(txn, _ => {\n            orphanedCount++;\n        }).next(() => orphanedCount);\n    }\n    forEachOrphanedDocumentSequenceNumber(txn, f) {\n        return PersistencePromise.forEach(this.orphanedSequenceNumbers, (key, sequenceNumber) => {\n            // Pass in the exact sequence number as the upper bound so we know it won't be pinned by\n            // being too recent.\n            return this.isPinned(txn, key, sequenceNumber).next(isPinned => {\n                if (!isPinned) {\n                    return f(sequenceNumber);\n                }\n                else {\n                    return PersistencePromise.resolve();\n                }\n            });\n        });\n    }\n    removeTargets(txn, upperBound, activeTargetIds) {\n        return this.persistence\n            .getTargetCache()\n            .removeTargets(txn, upperBound, activeTargetIds);\n    }\n    removeOrphanedDocuments(txn, upperBound) {\n        let count = 0;\n        const cache = this.persistence.getRemoteDocumentCache();\n        const changeBuffer = cache.newChangeBuffer();\n        const p = cache.forEachDocumentKey(txn, key => {\n            return this.isPinned(txn, key, upperBound).next(isPinned => {\n                if (!isPinned) {\n                    count++;\n                    changeBuffer.removeEntry(key, SnapshotVersion.min());\n                }\n            });\n        });\n        return p.next(() => changeBuffer.apply(txn)).next(() => count);\n    }\n    markPotentiallyOrphaned(txn, key) {\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n        return PersistencePromise.resolve();\n    }\n    removeTarget(txn, targetData) {\n        const updated = targetData.withSequenceNumber(txn.currentSequenceNumber);\n        return this.persistence.getTargetCache().updateTargetData(txn, updated);\n    }\n    addReference(txn, targetId, key) {\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n        return PersistencePromise.resolve();\n    }\n    removeReference(txn, targetId, key) {\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n        return PersistencePromise.resolve();\n    }\n    updateLimboDocument(txn, key) {\n        this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n        return PersistencePromise.resolve();\n    }\n    documentSize(document) {\n        let documentSize = document.key.toString().length;\n        if (document.isFoundDocument()) {\n            documentSize += estimateByteSize(document.data.value);\n        }\n        return documentSize;\n    }\n    isPinned(txn, key, upperBound) {\n        return PersistencePromise.or([\n            () => this.persistence.mutationQueuesContainKey(txn, key),\n            () => this.persistence.getTargetCache().containsKey(txn, key),\n            () => {\n                const orphanedAt = this.orphanedSequenceNumbers.get(key);\n                return PersistencePromise.resolve(orphanedAt !== undefined && orphanedAt > upperBound);\n            }\n        ]);\n    }\n    getCacheSize(txn) {\n        return this.persistence.getRemoteDocumentCache().getSize(txn);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Performs database creation and schema upgrades. */\nclass SchemaConverter {\n    constructor(serializer) {\n        this.serializer = serializer;\n    }\n    /**\n     * Performs database creation and schema upgrades.\n     *\n     * Note that in production, this method is only ever used to upgrade the schema\n     * to SCHEMA_VERSION. Different values of toVersion are only used for testing\n     * and local feature development.\n     */\n    createOrUpgrade(db, txn, fromVersion, toVersion) {\n        const simpleDbTransaction = new SimpleDbTransaction('createOrUpgrade', txn);\n        if (fromVersion < 1 && toVersion >= 1) {\n            createPrimaryClientStore(db);\n            createMutationQueue(db);\n            createQueryCache(db);\n            createLegacyRemoteDocumentCache(db);\n        }\n        // Migration 2 to populate the targetGlobal object no longer needed since\n        // migration 3 unconditionally clears it.\n        let p = PersistencePromise.resolve();\n        if (fromVersion < 3 && toVersion >= 3) {\n            // Brand new clients don't need to drop and recreate--only clients that\n            // potentially have corrupt data.\n            if (fromVersion !== 0) {\n                dropQueryCache(db);\n                createQueryCache(db);\n            }\n            p = p.next(() => writeEmptyTargetGlobalEntry(simpleDbTransaction));\n        }\n        if (fromVersion < 4 && toVersion >= 4) {\n            if (fromVersion !== 0) {\n                // Schema version 3 uses auto-generated keys to generate globally unique\n                // mutation batch IDs (this was previously ensured internally by the\n                // client). To migrate to the new schema, we have to read all mutations\n                // and write them back out. We preserve the existing batch IDs to guarantee\n                // consistency with other object stores. Any further mutation batch IDs will\n                // be auto-generated.\n                p = p.next(() => upgradeMutationBatchSchemaAndMigrateData(db, simpleDbTransaction));\n            }\n            p = p.next(() => {\n                createClientMetadataStore(db);\n            });\n        }\n        if (fromVersion < 5 && toVersion >= 5) {\n            p = p.next(() => this.removeAcknowledgedMutations(simpleDbTransaction));\n        }\n        if (fromVersion < 6 && toVersion >= 6) {\n            p = p.next(() => {\n                createDocumentGlobalStore(db);\n                return this.addDocumentGlobal(simpleDbTransaction);\n            });\n        }\n        if (fromVersion < 7 && toVersion >= 7) {\n            p = p.next(() => this.ensureSequenceNumbers(simpleDbTransaction));\n        }\n        if (fromVersion < 8 && toVersion >= 8) {\n            p = p.next(() => this.createCollectionParentIndex(db, simpleDbTransaction));\n        }\n        if (fromVersion < 9 && toVersion >= 9) {\n            p = p.next(() => {\n                // Multi-Tab used to manage its own changelog, but this has been moved\n                // to the DbRemoteDocument object store itself. Since the previous change\n                // log only contained transient data, we can drop its object store.\n                dropRemoteDocumentChangesStore(db);\n                // Note: Schema version 9 used to create a read time index for the\n                // RemoteDocumentCache. This is now done with schema version 13.\n            });\n        }\n        if (fromVersion < 10 && toVersion >= 10) {\n            p = p.next(() => this.rewriteCanonicalIds(simpleDbTransaction));\n        }\n        if (fromVersion < 11 && toVersion >= 11) {\n            p = p.next(() => {\n                createBundlesStore(db);\n                createNamedQueriesStore(db);\n            });\n        }\n        if (fromVersion < 12 && toVersion >= 12) {\n            p = p.next(() => {\n                createDocumentOverlayStore(db);\n            });\n        }\n        if (fromVersion < 13 && toVersion >= 13) {\n            p = p\n                .next(() => createRemoteDocumentCache(db))\n                .next(() => this.rewriteRemoteDocumentCache(db, simpleDbTransaction))\n                .next(() => db.deleteObjectStore(DbRemoteDocumentStore$1));\n        }\n        if (fromVersion < 14 && toVersion >= 14) {\n            p = p.next(() => this.runOverlayMigration(db, simpleDbTransaction));\n        }\n        if (fromVersion < 15 && toVersion >= 15) {\n            p = p.next(() => createFieldIndex(db));\n        }\n        if (fromVersion < 16 && toVersion >= 16) {\n            // Clear the object stores to remove possibly corrupted index entries\n            p = p\n                .next(() => {\n                const indexStateStore = txn.objectStore(DbIndexStateStore);\n                indexStateStore.clear();\n            })\n                .next(() => {\n                const indexEntryStore = txn.objectStore(DbIndexEntryStore);\n                indexEntryStore.clear();\n            });\n        }\n        if (fromVersion < 17 && toVersion >= 17) {\n            p = p.next(() => {\n                createGlobalsStore(db);\n            });\n        }\n        return p;\n    }\n    addDocumentGlobal(txn) {\n        let byteSize = 0;\n        return txn\n            .store(DbRemoteDocumentStore$1)\n            .iterate((_, doc) => {\n            byteSize += dbDocumentSize(doc);\n        })\n            .next(() => {\n            const metadata = { byteSize };\n            return txn\n                .store(DbRemoteDocumentGlobalStore)\n                .put(DbRemoteDocumentGlobalKey, metadata);\n        });\n    }\n    removeAcknowledgedMutations(txn) {\n        const queuesStore = txn.store(DbMutationQueueStore);\n        const mutationsStore = txn.store(DbMutationBatchStore);\n        return queuesStore.loadAll().next(queues => {\n            return PersistencePromise.forEach(queues, (queue) => {\n                const range = IDBKeyRange.bound([queue.userId, BATCHID_UNKNOWN], [queue.userId, queue.lastAcknowledgedBatchId]);\n                return mutationsStore\n                    .loadAll(DbMutationBatchUserMutationsIndex, range)\n                    .next(dbBatches => {\n                    return PersistencePromise.forEach(dbBatches, (dbBatch) => {\n                        hardAssert(dbBatch.userId === queue.userId);\n                        const batch = fromDbMutationBatch(this.serializer, dbBatch);\n                        return removeMutationBatch(txn, queue.userId, batch).next(() => { });\n                    });\n                });\n            });\n        });\n    }\n    /**\n     * Ensures that every document in the remote document cache has a corresponding sentinel row\n     * with a sequence number. Missing rows are given the most recently used sequence number.\n     */\n    ensureSequenceNumbers(txn) {\n        const documentTargetStore = txn.store(DbTargetDocumentStore);\n        const documentsStore = txn.store(DbRemoteDocumentStore$1);\n        const globalTargetStore = txn.store(DbTargetGlobalStore);\n        return globalTargetStore.get(DbTargetGlobalKey).next(metadata => {\n            const writeSentinelKey = (path) => {\n                return documentTargetStore.put({\n                    targetId: 0,\n                    path: encodeResourcePath(path),\n                    sequenceNumber: metadata.highestListenSequenceNumber\n                });\n            };\n            const promises = [];\n            return documentsStore\n                .iterate((key, doc) => {\n                const path = new ResourcePath(key);\n                const docSentinelKey = sentinelKey(path);\n                promises.push(documentTargetStore.get(docSentinelKey).next(maybeSentinel => {\n                    if (!maybeSentinel) {\n                        return writeSentinelKey(path);\n                    }\n                    else {\n                        return PersistencePromise.resolve();\n                    }\n                }));\n            })\n                .next(() => PersistencePromise.waitFor(promises));\n        });\n    }\n    createCollectionParentIndex(db, txn) {\n        // Create the index.\n        db.createObjectStore(DbCollectionParentStore, {\n            keyPath: DbCollectionParentKeyPath\n        });\n        const collectionParentsStore = txn.store(DbCollectionParentStore);\n        // Helper to add an index entry iff we haven't already written it.\n        const cache = new MemoryCollectionParentIndex();\n        const addEntry = (collectionPath) => {\n            if (cache.add(collectionPath)) {\n                const collectionId = collectionPath.lastSegment();\n                const parentPath = collectionPath.popLast();\n                return collectionParentsStore.put({\n                    collectionId,\n                    parent: encodeResourcePath(parentPath)\n                });\n            }\n        };\n        // Index existing remote documents.\n        return txn\n            .store(DbRemoteDocumentStore$1)\n            .iterate({ keysOnly: true }, (pathSegments, _) => {\n            const path = new ResourcePath(pathSegments);\n            return addEntry(path.popLast());\n        })\n            .next(() => {\n            // Index existing mutations.\n            return txn\n                .store(DbDocumentMutationStore)\n                .iterate({ keysOnly: true }, ([userID, encodedPath, batchId], _) => {\n                const path = decodeResourcePath(encodedPath);\n                return addEntry(path.popLast());\n            });\n        });\n    }\n    rewriteCanonicalIds(txn) {\n        const targetStore = txn.store(DbTargetStore);\n        return targetStore.iterate((key, originalDbTarget) => {\n            const originalTargetData = fromDbTarget(originalDbTarget);\n            const updatedDbTarget = toDbTarget(this.serializer, originalTargetData);\n            return targetStore.put(updatedDbTarget);\n        });\n    }\n    rewriteRemoteDocumentCache(db, transaction) {\n        const legacyRemoteDocumentStore = transaction.store(DbRemoteDocumentStore$1);\n        const writes = [];\n        return legacyRemoteDocumentStore\n            .iterate((_, legacyDocument) => {\n            const remoteDocumentStore = transaction.store(DbRemoteDocumentStore);\n            const path = extractKey(legacyDocument).path.toArray();\n            const dbRemoteDocument = {\n                prefixPath: path.slice(0, path.length - 2),\n                collectionGroup: path[path.length - 2],\n                documentId: path[path.length - 1],\n                readTime: legacyDocument.readTime || [0, 0],\n                unknownDocument: legacyDocument.unknownDocument,\n                noDocument: legacyDocument.noDocument,\n                document: legacyDocument.document,\n                hasCommittedMutations: !!legacyDocument.hasCommittedMutations\n            };\n            writes.push(remoteDocumentStore.put(dbRemoteDocument));\n        })\n            .next(() => PersistencePromise.waitFor(writes));\n    }\n    runOverlayMigration(db, transaction) {\n        const mutationsStore = transaction.store(DbMutationBatchStore);\n        const remoteDocumentCache = newIndexedDbRemoteDocumentCache(this.serializer);\n        const memoryPersistence = new MemoryPersistence(MemoryEagerDelegate.factory, this.serializer.remoteSerializer);\n        return mutationsStore.loadAll().next(dbBatches => {\n            const userToDocumentSet = new Map();\n            dbBatches.forEach(dbBatch => {\n                var _a;\n                let documentSet = (_a = userToDocumentSet.get(dbBatch.userId)) !== null && _a !== void 0 ? _a : documentKeySet();\n                const batch = fromDbMutationBatch(this.serializer, dbBatch);\n                batch.keys().forEach(key => (documentSet = documentSet.add(key)));\n                userToDocumentSet.set(dbBatch.userId, documentSet);\n            });\n            return PersistencePromise.forEach(userToDocumentSet, (allDocumentKeysForUser, userId) => {\n                const user = new User(userId);\n                const documentOverlayCache = IndexedDbDocumentOverlayCache.forUser(this.serializer, user);\n                // NOTE: The index manager and the reference delegate are\n                // irrelevant for the purpose of recalculating and saving\n                // overlays. We can therefore simply use the memory\n                // implementation.\n                const indexManager = memoryPersistence.getIndexManager(user);\n                const mutationQueue = IndexedDbMutationQueue.forUser(user, this.serializer, indexManager, memoryPersistence.referenceDelegate);\n                const localDocumentsView = new LocalDocumentsView(remoteDocumentCache, mutationQueue, documentOverlayCache, indexManager);\n                return localDocumentsView\n                    .recalculateAndSaveOverlaysForDocumentKeys(new IndexedDbTransaction(transaction, ListenSequence.INVALID), allDocumentKeysForUser)\n                    .next();\n            });\n        });\n    }\n}\nfunction sentinelKey(path) {\n    return [0, encodeResourcePath(path)];\n}\nfunction createPrimaryClientStore(db) {\n    db.createObjectStore(DbPrimaryClientStore);\n}\nfunction createMutationQueue(db) {\n    db.createObjectStore(DbMutationQueueStore, {\n        keyPath: DbMutationQueueKeyPath\n    });\n    const mutationBatchesStore = db.createObjectStore(DbMutationBatchStore, {\n        keyPath: DbMutationBatchKeyPath,\n        autoIncrement: true\n    });\n    mutationBatchesStore.createIndex(DbMutationBatchUserMutationsIndex, DbMutationBatchUserMutationsKeyPath, { unique: true });\n    db.createObjectStore(DbDocumentMutationStore);\n}\n/**\n * Upgrade function to migrate the 'mutations' store from V1 to V3. Loads\n * and rewrites all data.\n */\nfunction upgradeMutationBatchSchemaAndMigrateData(db, txn) {\n    const v1MutationsStore = txn.store(DbMutationBatchStore);\n    return v1MutationsStore.loadAll().next(existingMutations => {\n        db.deleteObjectStore(DbMutationBatchStore);\n        const mutationsStore = db.createObjectStore(DbMutationBatchStore, {\n            keyPath: DbMutationBatchKeyPath,\n            autoIncrement: true\n        });\n        mutationsStore.createIndex(DbMutationBatchUserMutationsIndex, DbMutationBatchUserMutationsKeyPath, { unique: true });\n        const v3MutationsStore = txn.store(DbMutationBatchStore);\n        const writeAll = existingMutations.map(mutation => v3MutationsStore.put(mutation));\n        return PersistencePromise.waitFor(writeAll);\n    });\n}\nfunction createLegacyRemoteDocumentCache(db) {\n    db.createObjectStore(DbRemoteDocumentStore$1);\n}\nfunction createRemoteDocumentCache(db) {\n    const remoteDocumentStore = db.createObjectStore(DbRemoteDocumentStore, {\n        keyPath: DbRemoteDocumentKeyPath\n    });\n    remoteDocumentStore.createIndex(DbRemoteDocumentDocumentKeyIndex, DbRemoteDocumentDocumentKeyIndexPath);\n    remoteDocumentStore.createIndex(DbRemoteDocumentCollectionGroupIndex, DbRemoteDocumentCollectionGroupIndexPath);\n}\nfunction createDocumentGlobalStore(db) {\n    db.createObjectStore(DbRemoteDocumentGlobalStore);\n}\nfunction createQueryCache(db) {\n    const targetDocumentsStore = db.createObjectStore(DbTargetDocumentStore, {\n        keyPath: DbTargetDocumentKeyPath\n    });\n    targetDocumentsStore.createIndex(DbTargetDocumentDocumentTargetsIndex, DbTargetDocumentDocumentTargetsKeyPath, { unique: true });\n    const targetStore = db.createObjectStore(DbTargetStore, {\n        keyPath: DbTargetKeyPath\n    });\n    // NOTE: This is unique only because the TargetId is the suffix.\n    targetStore.createIndex(DbTargetQueryTargetsIndexName, DbTargetQueryTargetsKeyPath, { unique: true });\n    db.createObjectStore(DbTargetGlobalStore);\n}\nfunction dropQueryCache(db) {\n    db.deleteObjectStore(DbTargetDocumentStore);\n    db.deleteObjectStore(DbTargetStore);\n    db.deleteObjectStore(DbTargetGlobalStore);\n}\nfunction dropRemoteDocumentChangesStore(db) {\n    if (db.objectStoreNames.contains('remoteDocumentChanges')) {\n        db.deleteObjectStore('remoteDocumentChanges');\n    }\n}\n/**\n * Creates the target global singleton row.\n *\n * @param txn - The version upgrade transaction for indexeddb\n */\nfunction writeEmptyTargetGlobalEntry(txn) {\n    const globalStore = txn.store(DbTargetGlobalStore);\n    const metadata = {\n        highestTargetId: 0,\n        highestListenSequenceNumber: 0,\n        lastRemoteSnapshotVersion: SnapshotVersion.min().toTimestamp(),\n        targetCount: 0\n    };\n    return globalStore.put(DbTargetGlobalKey, metadata);\n}\nfunction createClientMetadataStore(db) {\n    db.createObjectStore(DbClientMetadataStore, {\n        keyPath: DbClientMetadataKeyPath\n    });\n}\nfunction createBundlesStore(db) {\n    db.createObjectStore(DbBundleStore, {\n        keyPath: DbBundleKeyPath\n    });\n}\nfunction createNamedQueriesStore(db) {\n    db.createObjectStore(DbNamedQueryStore, {\n        keyPath: DbNamedQueryKeyPath\n    });\n}\nfunction createFieldIndex(db) {\n    const indexConfigurationStore = db.createObjectStore(DbIndexConfigurationStore, {\n        keyPath: DbIndexConfigurationKeyPath,\n        autoIncrement: true\n    });\n    indexConfigurationStore.createIndex(DbIndexConfigurationCollectionGroupIndex, DbIndexConfigurationCollectionGroupIndexPath, { unique: false });\n    const indexStateStore = db.createObjectStore(DbIndexStateStore, {\n        keyPath: DbIndexStateKeyPath\n    });\n    indexStateStore.createIndex(DbIndexStateSequenceNumberIndex, DbIndexStateSequenceNumberIndexPath, { unique: false });\n    const indexEntryStore = db.createObjectStore(DbIndexEntryStore, {\n        keyPath: DbIndexEntryKeyPath\n    });\n    indexEntryStore.createIndex(DbIndexEntryDocumentKeyIndex, DbIndexEntryDocumentKeyIndexPath, { unique: false });\n}\nfunction createDocumentOverlayStore(db) {\n    const documentOverlayStore = db.createObjectStore(DbDocumentOverlayStore, {\n        keyPath: DbDocumentOverlayKeyPath\n    });\n    documentOverlayStore.createIndex(DbDocumentOverlayCollectionPathOverlayIndex, DbDocumentOverlayCollectionPathOverlayIndexPath, { unique: false });\n    documentOverlayStore.createIndex(DbDocumentOverlayCollectionGroupOverlayIndex, DbDocumentOverlayCollectionGroupOverlayIndexPath, { unique: false });\n}\nfunction createGlobalsStore(db) {\n    db.createObjectStore(DbGlobalsStore, {\n        keyPath: DbGlobalsKeyPath\n    });\n}\nfunction extractKey(remoteDoc) {\n    if (remoteDoc.document) {\n        return new DocumentKey(ResourcePath.fromString(remoteDoc.document.name).popFirst(5));\n    }\n    else if (remoteDoc.noDocument) {\n        return DocumentKey.fromSegments(remoteDoc.noDocument.path);\n    }\n    else if (remoteDoc.unknownDocument) {\n        return DocumentKey.fromSegments(remoteDoc.unknownDocument.path);\n    }\n    else {\n        return fail();\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$c = 'IndexedDbPersistence';\n/**\n * Oldest acceptable age in milliseconds for client metadata before the client\n * is considered inactive and its associated data is garbage collected.\n */\nconst MAX_CLIENT_AGE_MS = 30 * 60 * 1000; // 30 minutes\n/**\n * Oldest acceptable metadata age for clients that may participate in the\n * primary lease election. Clients that have not updated their client metadata\n * within 5 seconds are not eligible to receive a primary lease.\n */\nconst MAX_PRIMARY_ELIGIBLE_AGE_MS = 5000;\n/**\n * The interval at which clients will update their metadata, including\n * refreshing their primary lease if held or potentially trying to acquire it if\n * not held.\n *\n * Primary clients may opportunistically refresh their metadata earlier\n * if they're already performing an IndexedDB operation.\n */\nconst CLIENT_METADATA_REFRESH_INTERVAL_MS = 4000;\n/** User-facing error when the primary lease is required but not available. */\nconst PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG = 'Failed to obtain exclusive access to the persistence layer. To allow ' +\n    'shared access, multi-tab synchronization has to be enabled in all tabs. ' +\n    'If you are using `experimentalForceOwningTab:true`, make sure that only ' +\n    'one tab has persistence enabled at any given time.';\nconst UNSUPPORTED_PLATFORM_ERROR_MSG = 'This platform is either missing IndexedDB or is known to have ' +\n    'an incomplete implementation. Offline persistence has been disabled.';\n// The format of the LocalStorage key that stores zombied client is:\n//     firestore_zombie_<persistence_prefix>_<instance_key>\nconst ZOMBIED_CLIENTS_KEY_PREFIX = 'firestore_zombie';\n/**\n * The name of the main (and currently only) IndexedDB database. This name is\n * appended to the prefix provided to the IndexedDbPersistence constructor.\n */\nconst MAIN_DATABASE = 'main';\n/**\n * An IndexedDB-backed instance of Persistence. Data is stored persistently\n * across sessions.\n *\n * On Web only, the Firestore SDKs support shared access to its persistence\n * layer. This allows multiple browser tabs to read and write to IndexedDb and\n * to synchronize state even without network connectivity. Shared access is\n * currently optional and not enabled unless all clients invoke\n * `enablePersistence()` with `{synchronizeTabs:true}`.\n *\n * In multi-tab mode, if multiple clients are active at the same time, the SDK\n * will designate one client as the “primary client”. An effort is made to pick\n * a visible, network-connected and active client, and this client is\n * responsible for letting other clients know about its presence. The primary\n * client writes a unique client-generated identifier (the client ID) to\n * IndexedDb’s “owner” store every 4 seconds. If the primary client fails to\n * update this entry, another client can acquire the lease and take over as\n * primary.\n *\n * Some persistence operations in the SDK are designated as primary-client only\n * operations. This includes the acknowledgment of mutations and all updates of\n * remote documents. The effects of these operations are written to persistence\n * and then broadcast to other tabs via LocalStorage (see\n * `WebStorageSharedClientState`), which then refresh their state from\n * persistence.\n *\n * Similarly, the primary client listens to notifications sent by secondary\n * clients to discover persistence changes written by secondary clients, such as\n * the addition of new mutations and query targets.\n *\n * If multi-tab is not enabled and another tab already obtained the primary\n * lease, IndexedDbPersistence enters a failed state and all subsequent\n * operations will automatically fail.\n *\n * Additionally, there is an optimization so that when a tab is closed, the\n * primary lease is released immediately (this is especially important to make\n * sure that a refreshed tab is able to immediately re-acquire the primary\n * lease). Unfortunately, IndexedDB cannot be reliably used in window.unload\n * since it is an asynchronous API. So in addition to attempting to give up the\n * lease, the leaseholder writes its client ID to a \"zombiedClient\" entry in\n * LocalStorage which acts as an indicator that another tab should go ahead and\n * take the primary lease immediately regardless of the current lease timestamp.\n *\n * TODO(b/114226234): Remove `synchronizeTabs` section when multi-tab is no\n * longer optional.\n */\nclass IndexedDbPersistence {\n    constructor(\n    /**\n     * Whether to synchronize the in-memory state of multiple tabs and share\n     * access to local persistence.\n     */\n    allowTabSynchronization, persistenceKey, clientId, lruParams, queue, window, document, serializer, sequenceNumberSyncer, \n    /**\n     * If set to true, forcefully obtains database access. Existing tabs will\n     * no longer be able to access IndexedDB.\n     */\n    forceOwningTab, schemaVersion = SCHEMA_VERSION) {\n        this.allowTabSynchronization = allowTabSynchronization;\n        this.persistenceKey = persistenceKey;\n        this.clientId = clientId;\n        this.queue = queue;\n        this.window = window;\n        this.document = document;\n        this.sequenceNumberSyncer = sequenceNumberSyncer;\n        this.forceOwningTab = forceOwningTab;\n        this.schemaVersion = schemaVersion;\n        this.listenSequence = null;\n        this._started = false;\n        this.isPrimary = false;\n        this.networkEnabled = true;\n        /** Our window.unload handler, if registered. */\n        this.windowUnloadHandler = null;\n        this.inForeground = false;\n        /** Our 'visibilitychange' listener if registered. */\n        this.documentVisibilityHandler = null;\n        /** The client metadata refresh task. */\n        this.clientMetadataRefresher = null;\n        /** The last time we garbage collected the client metadata object store. */\n        this.lastGarbageCollectionTime = Number.NEGATIVE_INFINITY;\n        /** A listener to notify on primary state changes. */\n        this.primaryStateListener = _ => Promise.resolve();\n        if (!IndexedDbPersistence.isAvailable()) {\n            throw new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);\n        }\n        this.referenceDelegate = new IndexedDbLruDelegateImpl(this, lruParams);\n        this.dbName = persistenceKey + MAIN_DATABASE;\n        this.serializer = new LocalSerializer(serializer);\n        this.simpleDb = new SimpleDb(this.dbName, this.schemaVersion, new SchemaConverter(this.serializer));\n        this.globalsCache = new IndexedDbGlobalsCache();\n        this.targetCache = new IndexedDbTargetCache(this.referenceDelegate, this.serializer);\n        this.remoteDocumentCache = newIndexedDbRemoteDocumentCache(this.serializer);\n        this.bundleCache = new IndexedDbBundleCache();\n        if (this.window && this.window.localStorage) {\n            this.webStorage = this.window.localStorage;\n        }\n        else {\n            this.webStorage = null;\n            if (forceOwningTab === false) {\n                logError(LOG_TAG$c, 'LocalStorage is unavailable. As a result, persistence may not work ' +\n                    'reliably. In particular enablePersistence() could fail immediately ' +\n                    'after refreshing the page.');\n            }\n        }\n    }\n    /**\n     * Attempt to start IndexedDb persistence.\n     *\n     * @returns Whether persistence was enabled.\n     */\n    start() {\n        // NOTE: This is expected to fail sometimes (in the case of another tab\n        // already having the persistence lock), so it's the first thing we should\n        // do.\n        return this.updateClientMetadataAndTryBecomePrimary()\n            .then(() => {\n            if (!this.isPrimary && !this.allowTabSynchronization) {\n                // Fail `start()` if `synchronizeTabs` is disabled and we cannot\n                // obtain the primary lease.\n                throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\n            }\n            this.attachVisibilityHandler();\n            this.attachWindowUnloadHook();\n            this.scheduleClientMetadataAndPrimaryLeaseRefreshes();\n            return this.runTransaction('getHighestListenSequenceNumber', 'readonly', txn => this.targetCache.getHighestSequenceNumber(txn));\n        })\n            .then(highestListenSequenceNumber => {\n            this.listenSequence = new ListenSequence(highestListenSequenceNumber, this.sequenceNumberSyncer);\n        })\n            .then(() => {\n            this._started = true;\n        })\n            .catch(reason => {\n            this.simpleDb && this.simpleDb.close();\n            return Promise.reject(reason);\n        });\n    }\n    /**\n     * Registers a listener that gets called when the primary state of the\n     * instance changes. Upon registering, this listener is invoked immediately\n     * with the current primary state.\n     *\n     * PORTING NOTE: This is only used for Web multi-tab.\n     */\n    setPrimaryStateListener(primaryStateListener) {\n        this.primaryStateListener = async (primaryState) => {\n            if (this.started) {\n                return primaryStateListener(primaryState);\n            }\n        };\n        return primaryStateListener(this.isPrimary);\n    }\n    /**\n     * Registers a listener that gets called when the database receives a\n     * version change event indicating that it has deleted.\n     *\n     * PORTING NOTE: This is only used for Web multi-tab.\n     */\n    setDatabaseDeletedListener(databaseDeletedListener) {\n        this.simpleDb.setVersionChangeListener(async (event) => {\n            // Check if an attempt is made to delete IndexedDB.\n            if (event.newVersion === null) {\n                await databaseDeletedListener();\n            }\n        });\n    }\n    /**\n     * Adjusts the current network state in the client's metadata, potentially\n     * affecting the primary lease.\n     *\n     * PORTING NOTE: This is only used for Web multi-tab.\n     */\n    setNetworkEnabled(networkEnabled) {\n        if (this.networkEnabled !== networkEnabled) {\n            this.networkEnabled = networkEnabled;\n            // Schedule a primary lease refresh for immediate execution. The eventual\n            // lease update will be propagated via `primaryStateListener`.\n            this.queue.enqueueAndForget(async () => {\n                if (this.started) {\n                    await this.updateClientMetadataAndTryBecomePrimary();\n                }\n            });\n        }\n    }\n    /**\n     * Updates the client metadata in IndexedDb and attempts to either obtain or\n     * extend the primary lease for the local client. Asynchronously notifies the\n     * primary state listener if the client either newly obtained or released its\n     * primary lease.\n     */\n    updateClientMetadataAndTryBecomePrimary() {\n        return this.runTransaction('updateClientMetadataAndTryBecomePrimary', 'readwrite', txn => {\n            const metadataStore = clientMetadataStore(txn);\n            return metadataStore\n                .put({\n                clientId: this.clientId,\n                updateTimeMs: Date.now(),\n                networkEnabled: this.networkEnabled,\n                inForeground: this.inForeground\n            })\n                .next(() => {\n                if (this.isPrimary) {\n                    return this.verifyPrimaryLease(txn).next(success => {\n                        if (!success) {\n                            this.isPrimary = false;\n                            this.queue.enqueueRetryable(() => this.primaryStateListener(false));\n                        }\n                    });\n                }\n            })\n                .next(() => this.canActAsPrimary(txn))\n                .next(canActAsPrimary => {\n                if (this.isPrimary && !canActAsPrimary) {\n                    return this.releasePrimaryLeaseIfHeld(txn).next(() => false);\n                }\n                else if (canActAsPrimary) {\n                    return this.acquireOrExtendPrimaryLease(txn).next(() => true);\n                }\n                else {\n                    return /* canActAsPrimary= */ false;\n                }\n            });\n        })\n            .catch(e => {\n            if (isIndexedDbTransactionError(e)) {\n                logDebug(LOG_TAG$c, 'Failed to extend owner lease: ', e);\n                // Proceed with the existing state. Any subsequent access to\n                // IndexedDB will verify the lease.\n                return this.isPrimary;\n            }\n            if (!this.allowTabSynchronization) {\n                throw e;\n            }\n            logDebug(LOG_TAG$c, 'Releasing owner lease after error during lease refresh', e);\n            return /* isPrimary= */ false;\n        })\n            .then(isPrimary => {\n            if (this.isPrimary !== isPrimary) {\n                this.queue.enqueueRetryable(() => this.primaryStateListener(isPrimary));\n            }\n            this.isPrimary = isPrimary;\n        });\n    }\n    verifyPrimaryLease(txn) {\n        const store = primaryClientStore(txn);\n        return store.get(DbPrimaryClientKey).next(primaryClient => {\n            return PersistencePromise.resolve(this.isLocalClient(primaryClient));\n        });\n    }\n    removeClientMetadata(txn) {\n        const metadataStore = clientMetadataStore(txn);\n        return metadataStore.delete(this.clientId);\n    }\n    /**\n     * If the garbage collection threshold has passed, prunes the\n     * RemoteDocumentChanges and the ClientMetadata store based on the last update\n     * time of all clients.\n     */\n    async maybeGarbageCollectMultiClientState() {\n        if (this.isPrimary &&\n            !this.isWithinAge(this.lastGarbageCollectionTime, MAX_CLIENT_AGE_MS)) {\n            this.lastGarbageCollectionTime = Date.now();\n            const inactiveClients = await this.runTransaction('maybeGarbageCollectMultiClientState', 'readwrite-primary', txn => {\n                const metadataStore = getStore(txn, DbClientMetadataStore);\n                return metadataStore.loadAll().next(existingClients => {\n                    const active = this.filterActiveClients(existingClients, MAX_CLIENT_AGE_MS);\n                    const inactive = existingClients.filter(client => active.indexOf(client) === -1);\n                    // Delete metadata for clients that are no longer considered active.\n                    return PersistencePromise.forEach(inactive, (inactiveClient) => metadataStore.delete(inactiveClient.clientId)).next(() => inactive);\n                });\n            }).catch(() => {\n                // Ignore primary lease violations or any other type of error. The next\n                // primary will run `maybeGarbageCollectMultiClientState()` again.\n                // We don't use `ignoreIfPrimaryLeaseLoss()` since we don't want to depend\n                // on LocalStore.\n                return [];\n            });\n            // Delete potential leftover entries that may continue to mark the\n            // inactive clients as zombied in LocalStorage.\n            // Ideally we'd delete the IndexedDb and LocalStorage zombie entries for\n            // the client atomically, but we can't. So we opt to delete the IndexedDb\n            // entries first to avoid potentially reviving a zombied client.\n            if (this.webStorage) {\n                for (const inactiveClient of inactiveClients) {\n                    this.webStorage.removeItem(this.zombiedClientLocalStorageKey(inactiveClient.clientId));\n                }\n            }\n        }\n    }\n    /**\n     * Schedules a recurring timer to update the client metadata and to either\n     * extend or acquire the primary lease if the client is eligible.\n     */\n    scheduleClientMetadataAndPrimaryLeaseRefreshes() {\n        this.clientMetadataRefresher = this.queue.enqueueAfterDelay(\"client_metadata_refresh\" /* TimerId.ClientMetadataRefresh */, CLIENT_METADATA_REFRESH_INTERVAL_MS, () => {\n            return this.updateClientMetadataAndTryBecomePrimary()\n                .then(() => this.maybeGarbageCollectMultiClientState())\n                .then(() => this.scheduleClientMetadataAndPrimaryLeaseRefreshes());\n        });\n    }\n    /** Checks whether `client` is the local client. */\n    isLocalClient(client) {\n        return client ? client.ownerId === this.clientId : false;\n    }\n    /**\n     * Evaluate the state of all active clients and determine whether the local\n     * client is or can act as the holder of the primary lease. Returns whether\n     * the client is eligible for the lease, but does not actually acquire it.\n     * May return 'false' even if there is no active leaseholder and another\n     * (foreground) client should become leaseholder instead.\n     */\n    canActAsPrimary(txn) {\n        if (this.forceOwningTab) {\n            return PersistencePromise.resolve(true);\n        }\n        const store = primaryClientStore(txn);\n        return store\n            .get(DbPrimaryClientKey)\n            .next(currentPrimary => {\n            const currentLeaseIsValid = currentPrimary !== null &&\n                this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) &&\n                !this.isClientZombied(currentPrimary.ownerId);\n            // A client is eligible for the primary lease if:\n            // - its network is enabled and the client's tab is in the foreground.\n            // - its network is enabled and no other client's tab is in the\n            //   foreground.\n            // - every clients network is disabled and the client's tab is in the\n            //   foreground.\n            // - every clients network is disabled and no other client's tab is in\n            //   the foreground.\n            // - the `forceOwningTab` setting was passed in.\n            if (currentLeaseIsValid) {\n                if (this.isLocalClient(currentPrimary) && this.networkEnabled) {\n                    return true;\n                }\n                if (!this.isLocalClient(currentPrimary)) {\n                    if (!currentPrimary.allowTabSynchronization) {\n                        // Fail the `canActAsPrimary` check if the current leaseholder has\n                        // not opted into multi-tab synchronization. If this happens at\n                        // client startup, we reject the Promise returned by\n                        // `enablePersistence()` and the user can continue to use Firestore\n                        // with in-memory persistence.\n                        // If this fails during a lease refresh, we will instead block the\n                        // AsyncQueue from executing further operations. Note that this is\n                        // acceptable since mixing & matching different `synchronizeTabs`\n                        // settings is not supported.\n                        //\n                        // TODO(b/114226234): Remove this check when `synchronizeTabs` can\n                        // no longer be turned off.\n                        throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\n                    }\n                    return false;\n                }\n            }\n            if (this.networkEnabled && this.inForeground) {\n                return true;\n            }\n            return clientMetadataStore(txn)\n                .loadAll()\n                .next(existingClients => {\n                // Process all existing clients and determine whether at least one of\n                // them is better suited to obtain the primary lease.\n                const preferredCandidate = this.filterActiveClients(existingClients, MAX_PRIMARY_ELIGIBLE_AGE_MS).find(otherClient => {\n                    if (this.clientId !== otherClient.clientId) {\n                        const otherClientHasBetterNetworkState = !this.networkEnabled && otherClient.networkEnabled;\n                        const otherClientHasBetterVisibility = !this.inForeground && otherClient.inForeground;\n                        const otherClientHasSameNetworkState = this.networkEnabled === otherClient.networkEnabled;\n                        if (otherClientHasBetterNetworkState ||\n                            (otherClientHasBetterVisibility &&\n                                otherClientHasSameNetworkState)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                });\n                return preferredCandidate === undefined;\n            });\n        })\n            .next(canActAsPrimary => {\n            if (this.isPrimary !== canActAsPrimary) {\n                logDebug(LOG_TAG$c, `Client ${canActAsPrimary ? 'is' : 'is not'} eligible for a primary lease.`);\n            }\n            return canActAsPrimary;\n        });\n    }\n    async shutdown() {\n        // The shutdown() operations are idempotent and can be called even when\n        // start() aborted (e.g. because it couldn't acquire the persistence lease).\n        this._started = false;\n        this.markClientZombied();\n        if (this.clientMetadataRefresher) {\n            this.clientMetadataRefresher.cancel();\n            this.clientMetadataRefresher = null;\n        }\n        this.detachVisibilityHandler();\n        this.detachWindowUnloadHook();\n        // Use `SimpleDb.runTransaction` directly to avoid failing if another tab\n        // has obtained the primary lease.\n        await this.simpleDb.runTransaction('shutdown', 'readwrite', [DbPrimaryClientStore, DbClientMetadataStore], simpleDbTxn => {\n            const persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, ListenSequence.INVALID);\n            return this.releasePrimaryLeaseIfHeld(persistenceTransaction).next(() => this.removeClientMetadata(persistenceTransaction));\n        });\n        this.simpleDb.close();\n        // Remove the entry marking the client as zombied from LocalStorage since\n        // we successfully deleted its metadata from IndexedDb.\n        this.removeClientZombiedEntry();\n    }\n    /**\n     * Returns clients that are not zombied and have an updateTime within the\n     * provided threshold.\n     */\n    filterActiveClients(clients, activityThresholdMs) {\n        return clients.filter(client => this.isWithinAge(client.updateTimeMs, activityThresholdMs) &&\n            !this.isClientZombied(client.clientId));\n    }\n    /**\n     * Returns the IDs of the clients that are currently active. If multi-tab\n     * is not supported, returns an array that only contains the local client's\n     * ID.\n     *\n     * PORTING NOTE: This is only used for Web multi-tab.\n     */\n    getActiveClients() {\n        return this.runTransaction('getActiveClients', 'readonly', txn => {\n            return clientMetadataStore(txn)\n                .loadAll()\n                .next(clients => this.filterActiveClients(clients, MAX_CLIENT_AGE_MS).map(clientMetadata => clientMetadata.clientId));\n        });\n    }\n    get started() {\n        return this._started;\n    }\n    getGlobalsCache() {\n        return this.globalsCache;\n    }\n    getMutationQueue(user, indexManager) {\n        return IndexedDbMutationQueue.forUser(user, this.serializer, indexManager, this.referenceDelegate);\n    }\n    getTargetCache() {\n        return this.targetCache;\n    }\n    getRemoteDocumentCache() {\n        return this.remoteDocumentCache;\n    }\n    getIndexManager(user) {\n        return new IndexedDbIndexManager(user, this.serializer.remoteSerializer.databaseId);\n    }\n    getDocumentOverlayCache(user) {\n        return IndexedDbDocumentOverlayCache.forUser(this.serializer, user);\n    }\n    getBundleCache() {\n        return this.bundleCache;\n    }\n    runTransaction(action, mode, transactionOperation) {\n        logDebug(LOG_TAG$c, 'Starting transaction:', action);\n        const simpleDbMode = mode === 'readonly' ? 'readonly' : 'readwrite';\n        const objectStores = getObjectStores(this.schemaVersion);\n        let persistenceTransaction;\n        // Do all transactions as readwrite against all object stores, since we\n        // are the only reader/writer.\n        return this.simpleDb\n            .runTransaction(action, simpleDbMode, objectStores, simpleDbTxn => {\n            persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, this.listenSequence\n                ? this.listenSequence.next()\n                : ListenSequence.INVALID);\n            if (mode === 'readwrite-primary') {\n                // While we merely verify that we have (or can acquire) the lease\n                // immediately, we wait to extend the primary lease until after\n                // executing transactionOperation(). This ensures that even if the\n                // transactionOperation takes a long time, we'll use a recent\n                // leaseTimestampMs in the extended (or newly acquired) lease.\n                return this.verifyPrimaryLease(persistenceTransaction)\n                    .next(holdsPrimaryLease => {\n                    if (holdsPrimaryLease) {\n                        return /* holdsPrimaryLease= */ true;\n                    }\n                    return this.canActAsPrimary(persistenceTransaction);\n                })\n                    .next(holdsPrimaryLease => {\n                    if (!holdsPrimaryLease) {\n                        logError(`Failed to obtain primary lease for action '${action}'.`);\n                        this.isPrimary = false;\n                        this.queue.enqueueRetryable(() => this.primaryStateListener(false));\n                        throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_LOST_ERROR_MSG);\n                    }\n                    return transactionOperation(persistenceTransaction);\n                })\n                    .next(result => {\n                    return this.acquireOrExtendPrimaryLease(persistenceTransaction).next(() => result);\n                });\n            }\n            else {\n                return this.verifyAllowTabSynchronization(persistenceTransaction).next(() => transactionOperation(persistenceTransaction));\n            }\n        })\n            .then(result => {\n            persistenceTransaction.raiseOnCommittedEvent();\n            return result;\n        });\n    }\n    /**\n     * Verifies that the current tab is the primary leaseholder or alternatively\n     * that the leaseholder has opted into multi-tab synchronization.\n     */\n    // TODO(b/114226234): Remove this check when `synchronizeTabs` can no longer\n    // be turned off.\n    verifyAllowTabSynchronization(txn) {\n        const store = primaryClientStore(txn);\n        return store.get(DbPrimaryClientKey).next(currentPrimary => {\n            const currentLeaseIsValid = currentPrimary !== null &&\n                this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) &&\n                !this.isClientZombied(currentPrimary.ownerId);\n            if (currentLeaseIsValid && !this.isLocalClient(currentPrimary)) {\n                if (!this.forceOwningTab &&\n                    (!this.allowTabSynchronization ||\n                        !currentPrimary.allowTabSynchronization)) {\n                    throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\n                }\n            }\n        });\n    }\n    /**\n     * Obtains or extends the new primary lease for the local client. This\n     * method does not verify that the client is eligible for this lease.\n     */\n    acquireOrExtendPrimaryLease(txn) {\n        const newPrimary = {\n            ownerId: this.clientId,\n            allowTabSynchronization: this.allowTabSynchronization,\n            leaseTimestampMs: Date.now()\n        };\n        return primaryClientStore(txn).put(DbPrimaryClientKey, newPrimary);\n    }\n    static isAvailable() {\n        return SimpleDb.isAvailable();\n    }\n    /** Checks the primary lease and removes it if we are the current primary. */\n    releasePrimaryLeaseIfHeld(txn) {\n        const store = primaryClientStore(txn);\n        return store.get(DbPrimaryClientKey).next(primaryClient => {\n            if (this.isLocalClient(primaryClient)) {\n                logDebug(LOG_TAG$c, 'Releasing primary lease.');\n                return store.delete(DbPrimaryClientKey);\n            }\n            else {\n                return PersistencePromise.resolve();\n            }\n        });\n    }\n    /** Verifies that `updateTimeMs` is within `maxAgeMs`. */\n    isWithinAge(updateTimeMs, maxAgeMs) {\n        const now = Date.now();\n        const minAcceptable = now - maxAgeMs;\n        const maxAcceptable = now;\n        if (updateTimeMs < minAcceptable) {\n            return false;\n        }\n        else if (updateTimeMs > maxAcceptable) {\n            logError(`Detected an update time that is in the future: ${updateTimeMs} > ${maxAcceptable}`);\n            return false;\n        }\n        return true;\n    }\n    attachVisibilityHandler() {\n        if (this.document !== null &&\n            typeof this.document.addEventListener === 'function') {\n            this.documentVisibilityHandler = () => {\n                this.queue.enqueueAndForget(() => {\n                    this.inForeground = this.document.visibilityState === 'visible';\n                    return this.updateClientMetadataAndTryBecomePrimary();\n                });\n            };\n            this.document.addEventListener('visibilitychange', this.documentVisibilityHandler);\n            this.inForeground = this.document.visibilityState === 'visible';\n        }\n    }\n    detachVisibilityHandler() {\n        if (this.documentVisibilityHandler) {\n            this.document.removeEventListener('visibilitychange', this.documentVisibilityHandler);\n            this.documentVisibilityHandler = null;\n        }\n    }\n    /**\n     * Attaches a window.unload handler that will synchronously write our\n     * clientId to a \"zombie client id\" location in LocalStorage. This can be used\n     * by tabs trying to acquire the primary lease to determine that the lease\n     * is no longer valid even if the timestamp is recent. This is particularly\n     * important for the refresh case (so the tab correctly re-acquires the\n     * primary lease). LocalStorage is used for this rather than IndexedDb because\n     * it is a synchronous API and so can be used reliably from  an unload\n     * handler.\n     */\n    attachWindowUnloadHook() {\n        var _a;\n        if (typeof ((_a = this.window) === null || _a === void 0 ? void 0 : _a.addEventListener) === 'function') {\n            this.windowUnloadHandler = () => {\n                // Note: In theory, this should be scheduled on the AsyncQueue since it\n                // accesses internal state. We execute this code directly during shutdown\n                // to make sure it gets a chance to run.\n                this.markClientZombied();\n                const safariIndexdbBugVersionRegex = /(?:Version|Mobile)\\/1[456]/;\n                if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isSafari)() &&\n                    (navigator.appVersion.match(safariIndexdbBugVersionRegex) ||\n                        navigator.userAgent.match(safariIndexdbBugVersionRegex))) {\n                    // On Safari 14, 15, and 16, we do not run any cleanup actions as it might\n                    // trigger a bug that prevents Safari from re-opening IndexedDB during\n                    // the next page load.\n                    // See https://bugs.webkit.org/show_bug.cgi?id=226547\n                    this.queue.enterRestrictedMode(/* purgeExistingTasks= */ true);\n                }\n                this.queue.enqueueAndForget(() => {\n                    // Attempt graceful shutdown (including releasing our primary lease),\n                    // but there's no guarantee it will complete.\n                    return this.shutdown();\n                });\n            };\n            this.window.addEventListener('pagehide', this.windowUnloadHandler);\n        }\n    }\n    detachWindowUnloadHook() {\n        if (this.windowUnloadHandler) {\n            this.window.removeEventListener('pagehide', this.windowUnloadHandler);\n            this.windowUnloadHandler = null;\n        }\n    }\n    /**\n     * Returns whether a client is \"zombied\" based on its LocalStorage entry.\n     * Clients become zombied when their tab closes without running all of the\n     * cleanup logic in `shutdown()`.\n     */\n    isClientZombied(clientId) {\n        var _a;\n        try {\n            const isZombied = ((_a = this.webStorage) === null || _a === void 0 ? void 0 : _a.getItem(this.zombiedClientLocalStorageKey(clientId))) !== null;\n            logDebug(LOG_TAG$c, `Client '${clientId}' ${isZombied ? 'is' : 'is not'} zombied in LocalStorage`);\n            return isZombied;\n        }\n        catch (e) {\n            // Gracefully handle if LocalStorage isn't working.\n            logError(LOG_TAG$c, 'Failed to get zombied client id.', e);\n            return false;\n        }\n    }\n    /**\n     * Record client as zombied (a client that had its tab closed). Zombied\n     * clients are ignored during primary tab selection.\n     */\n    markClientZombied() {\n        if (!this.webStorage) {\n            return;\n        }\n        try {\n            this.webStorage.setItem(this.zombiedClientLocalStorageKey(this.clientId), String(Date.now()));\n        }\n        catch (e) {\n            // Gracefully handle if LocalStorage isn't available / working.\n            logError('Failed to set zombie client id.', e);\n        }\n    }\n    /** Removes the zombied client entry if it exists. */\n    removeClientZombiedEntry() {\n        if (!this.webStorage) {\n            return;\n        }\n        try {\n            this.webStorage.removeItem(this.zombiedClientLocalStorageKey(this.clientId));\n        }\n        catch (e) {\n            // Ignore\n        }\n    }\n    zombiedClientLocalStorageKey(clientId) {\n        return `${ZOMBIED_CLIENTS_KEY_PREFIX}_${this.persistenceKey}_${clientId}`;\n    }\n}\n/**\n * Helper to get a typed SimpleDbStore for the primary client object store.\n */\nfunction primaryClientStore(txn) {\n    return getStore(txn, DbPrimaryClientStore);\n}\n/**\n * Helper to get a typed SimpleDbStore for the client metadata object store.\n */\nfunction clientMetadataStore(txn) {\n    return getStore(txn, DbClientMetadataStore);\n}\n/**\n * Generates a string used as a prefix when storing data in IndexedDB and\n * LocalStorage.\n */\nfunction indexedDbStoragePrefix(databaseId, persistenceKey) {\n    // Use two different prefix formats:\n    //\n    //   * firestore / persistenceKey / projectID . databaseID / ...\n    //   * firestore / persistenceKey / projectID / ...\n    //\n    // projectIDs are DNS-compatible names and cannot contain dots\n    // so there's no danger of collisions.\n    let database = databaseId.projectId;\n    if (!databaseId.isDefaultDatabase) {\n        database += '.' + databaseId.database;\n    }\n    return 'firestore/' + persistenceKey + '/' + database + '/';\n}\nasync function indexedDbClearPersistence(persistenceKey) {\n    if (!SimpleDb.isAvailable()) {\n        return Promise.resolve();\n    }\n    const dbName = persistenceKey + MAIN_DATABASE;\n    await SimpleDb.delete(dbName);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Compares two array for equality using comparator. The method computes the\n * intersection and invokes `onAdd` for every element that is in `after` but not\n * `before`. `onRemove` is invoked for every element in `before` but missing\n * from `after`.\n *\n * The method creates a copy of both `before` and `after` and runs in O(n log\n * n), where n is the size of the two lists.\n *\n * @param before - The elements that exist in the original array.\n * @param after - The elements to diff against the original array.\n * @param comparator - The comparator for the elements in before and after.\n * @param onAdd - A function to invoke for every element that is part of `\n * after` but not `before`.\n * @param onRemove - A function to invoke for every element that is part of\n * `before` but not `after`.\n */\nfunction diffArrays(before, after, comparator, onAdd, onRemove) {\n    before = [...before];\n    after = [...after];\n    before.sort(comparator);\n    after.sort(comparator);\n    const bLen = before.length;\n    const aLen = after.length;\n    let a = 0;\n    let b = 0;\n    while (a < aLen && b < bLen) {\n        const cmp = comparator(before[b], after[a]);\n        if (cmp < 0) {\n            // The element was removed if the next element in our ordered\n            // walkthrough is only in `before`.\n            onRemove(before[b++]);\n        }\n        else if (cmp > 0) {\n            // The element was added if the next element in our ordered walkthrough\n            // is only in `after`.\n            onAdd(after[a++]);\n        }\n        else {\n            a++;\n            b++;\n        }\n    }\n    while (a < aLen) {\n        onAdd(after[a++]);\n    }\n    while (b < bLen) {\n        onRemove(before[b++]);\n    }\n}\n/**\n * Verifies equality for an array of primitives.\n *\n * @private\n * @internal\n * @param left Array of primitives.\n * @param right Array of primitives.\n * @return True if arrays are equal.\n */\nfunction isPrimitiveArrayEqual(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    for (let i = 0; i < left.length; ++i) {\n        if (left[i] !== right[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$b = 'LocalStore';\n/**\n * The maximum time to leave a resume token buffered without writing it out.\n * This value is arbitrary: it's long enough to avoid several writes\n * (possibly indefinitely if updates come more frequently than this) but\n * short enough that restarting after crashing will still have a pretty\n * recent resume token.\n */\nconst RESUME_TOKEN_MAX_AGE_MICROS = 5 * 60 * 1e6;\n/**\n * Implements `LocalStore` interface.\n *\n * Note: some field defined in this class might have public access level, but\n * the class is not exported so they are only accessible from this module.\n * This is useful to implement optional features (like bundles) in free\n * functions, such that they are tree-shakeable.\n */\nclass LocalStoreImpl {\n    constructor(\n    /** Manages our in-memory or durable persistence. */\n    persistence, queryEngine, initialUser, serializer) {\n        this.persistence = persistence;\n        this.queryEngine = queryEngine;\n        this.serializer = serializer;\n        /**\n         * Maps a targetID to data about its target.\n         *\n         * PORTING NOTE: We are using an immutable data structure on Web to make re-runs\n         * of `applyRemoteEvent()` idempotent.\n         */\n        this.targetDataByTarget = new SortedMap(primitiveComparator);\n        /** Maps a target to its targetID. */\n        // TODO(wuandy): Evaluate if TargetId can be part of Target.\n        this.targetIdByTarget = new ObjectMap(t => canonifyTarget(t), targetEquals);\n        /**\n         * A per collection group index of the last read time processed by\n         * `getNewDocumentChanges()`.\n         *\n         * PORTING NOTE: This is only used for multi-tab synchronization.\n         */\n        this.collectionGroupReadTime = new Map();\n        this.remoteDocuments = persistence.getRemoteDocumentCache();\n        this.targetCache = persistence.getTargetCache();\n        this.bundleCache = persistence.getBundleCache();\n        this.initializeUserComponents(initialUser);\n    }\n    initializeUserComponents(user) {\n        // TODO(indexing): Add spec tests that test these components change after a\n        // user change\n        this.documentOverlayCache = this.persistence.getDocumentOverlayCache(user);\n        this.indexManager = this.persistence.getIndexManager(user);\n        this.mutationQueue = this.persistence.getMutationQueue(user, this.indexManager);\n        this.localDocuments = new LocalDocumentsView(this.remoteDocuments, this.mutationQueue, this.documentOverlayCache, this.indexManager);\n        this.remoteDocuments.setIndexManager(this.indexManager);\n        this.queryEngine.initialize(this.localDocuments, this.indexManager);\n    }\n    collectGarbage(garbageCollector) {\n        return this.persistence.runTransaction('Collect garbage', 'readwrite-primary', txn => garbageCollector.collect(txn, this.targetDataByTarget));\n    }\n}\nfunction newLocalStore(\n/** Manages our in-memory or durable persistence. */\npersistence, queryEngine, initialUser, serializer) {\n    return new LocalStoreImpl(persistence, queryEngine, initialUser, serializer);\n}\n/**\n * Tells the LocalStore that the currently authenticated user has changed.\n *\n * In response the local store switches the mutation queue to the new user and\n * returns any resulting document changes.\n */\n// PORTING NOTE: Android and iOS only return the documents affected by the\n// change.\nasync function localStoreHandleUserChange(localStore, user) {\n    const localStoreImpl = debugCast(localStore);\n    const result = await localStoreImpl.persistence.runTransaction('Handle user change', 'readonly', txn => {\n        // Swap out the mutation queue, grabbing the pending mutation batches\n        // before and after.\n        let oldBatches;\n        return localStoreImpl.mutationQueue\n            .getAllMutationBatches(txn)\n            .next(promisedOldBatches => {\n            oldBatches = promisedOldBatches;\n            localStoreImpl.initializeUserComponents(user);\n            return localStoreImpl.mutationQueue.getAllMutationBatches(txn);\n        })\n            .next(newBatches => {\n            const removedBatchIds = [];\n            const addedBatchIds = [];\n            // Union the old/new changed keys.\n            let changedKeys = documentKeySet();\n            for (const batch of oldBatches) {\n                removedBatchIds.push(batch.batchId);\n                for (const mutation of batch.mutations) {\n                    changedKeys = changedKeys.add(mutation.key);\n                }\n            }\n            for (const batch of newBatches) {\n                addedBatchIds.push(batch.batchId);\n                for (const mutation of batch.mutations) {\n                    changedKeys = changedKeys.add(mutation.key);\n                }\n            }\n            // Return the set of all (potentially) changed documents and the list\n            // of mutation batch IDs that were affected by change.\n            return localStoreImpl.localDocuments\n                .getDocuments(txn, changedKeys)\n                .next(affectedDocuments => {\n                return {\n                    affectedDocuments,\n                    removedBatchIds,\n                    addedBatchIds\n                };\n            });\n        });\n    });\n    return result;\n}\n/* Accepts locally generated Mutations and commit them to storage. */\nfunction localStoreWriteLocally(localStore, mutations) {\n    const localStoreImpl = debugCast(localStore);\n    const localWriteTime = Timestamp.now();\n    const keys = mutations.reduce((keys, m) => keys.add(m.key), documentKeySet());\n    let overlayedDocuments;\n    let mutationBatch;\n    return localStoreImpl.persistence\n        .runTransaction('Locally write mutations', 'readwrite', txn => {\n        // Figure out which keys do not have a remote version in the cache, this\n        // is needed to create the right overlay mutation: if no remote version\n        // presents, we do not need to create overlays as patch mutations.\n        // TODO(Overlay): Is there a better way to determine this? Using the\n        //  document version does not work because local mutations set them back\n        //  to 0.\n        let remoteDocs = mutableDocumentMap();\n        let docsWithoutRemoteVersion = documentKeySet();\n        return localStoreImpl.remoteDocuments\n            .getEntries(txn, keys)\n            .next(docs => {\n            remoteDocs = docs;\n            remoteDocs.forEach((key, doc) => {\n                if (!doc.isValidDocument()) {\n                    docsWithoutRemoteVersion = docsWithoutRemoteVersion.add(key);\n                }\n            });\n        })\n            .next(() => {\n            // Load and apply all existing mutations. This lets us compute the\n            // current base state for all non-idempotent transforms before applying\n            // any additional user-provided writes.\n            return localStoreImpl.localDocuments.getOverlayedDocuments(txn, remoteDocs);\n        })\n            .next((docs) => {\n            overlayedDocuments = docs;\n            // For non-idempotent mutations (such as `FieldValue.increment()`),\n            // we record the base state in a separate patch mutation. This is\n            // later used to guarantee consistent values and prevents flicker\n            // even if the backend sends us an update that already includes our\n            // transform.\n            const baseMutations = [];\n            for (const mutation of mutations) {\n                const baseValue = mutationExtractBaseValue(mutation, overlayedDocuments.get(mutation.key).overlayedDocument);\n                if (baseValue != null) {\n                    // NOTE: The base state should only be applied if there's some\n                    // existing document to override, so use a Precondition of\n                    // exists=true\n                    baseMutations.push(new PatchMutation(mutation.key, baseValue, extractFieldMask(baseValue.value.mapValue), Precondition.exists(true)));\n                }\n            }\n            return localStoreImpl.mutationQueue.addMutationBatch(txn, localWriteTime, baseMutations, mutations);\n        })\n            .next(batch => {\n            mutationBatch = batch;\n            const overlays = batch.applyToLocalDocumentSet(overlayedDocuments, docsWithoutRemoteVersion);\n            return localStoreImpl.documentOverlayCache.saveOverlays(txn, batch.batchId, overlays);\n        });\n    })\n        .then(() => ({\n        batchId: mutationBatch.batchId,\n        changes: convertOverlayedDocumentMapToDocumentMap(overlayedDocuments)\n    }));\n}\n/**\n * Acknowledges the given batch.\n *\n * On the happy path when a batch is acknowledged, the local store will\n *\n *  + remove the batch from the mutation queue;\n *  + apply the changes to the remote document cache;\n *  + recalculate the latency compensated view implied by those changes (there\n *    may be mutations in the queue that affect the documents but haven't been\n *    acknowledged yet); and\n *  + give the changed documents back the sync engine\n *\n * @returns The resulting (modified) documents.\n */\nfunction localStoreAcknowledgeBatch(localStore, batchResult) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Acknowledge batch', 'readwrite-primary', txn => {\n        const affected = batchResult.batch.keys();\n        const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\n            trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\n        });\n        return applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer)\n            .next(() => documentBuffer.apply(txn))\n            .next(() => localStoreImpl.mutationQueue.performConsistencyCheck(txn))\n            .next(() => localStoreImpl.documentOverlayCache.removeOverlaysForBatchId(txn, affected, batchResult.batch.batchId))\n            .next(() => localStoreImpl.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(txn, getKeysWithTransformResults(batchResult)))\n            .next(() => localStoreImpl.localDocuments.getDocuments(txn, affected));\n    });\n}\nfunction getKeysWithTransformResults(batchResult) {\n    let result = documentKeySet();\n    for (let i = 0; i < batchResult.mutationResults.length; ++i) {\n        const mutationResult = batchResult.mutationResults[i];\n        if (mutationResult.transformResults.length > 0) {\n            result = result.add(batchResult.batch.mutations[i].key);\n        }\n    }\n    return result;\n}\n/**\n * Removes mutations from the MutationQueue for the specified batch;\n * LocalDocuments will be recalculated.\n *\n * @returns The resulting modified documents.\n */\nfunction localStoreRejectBatch(localStore, batchId) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Reject batch', 'readwrite-primary', txn => {\n        let affectedKeys;\n        return localStoreImpl.mutationQueue\n            .lookupMutationBatch(txn, batchId)\n            .next((batch) => {\n            hardAssert(batch !== null);\n            affectedKeys = batch.keys();\n            return localStoreImpl.mutationQueue.removeMutationBatch(txn, batch);\n        })\n            .next(() => localStoreImpl.mutationQueue.performConsistencyCheck(txn))\n            .next(() => localStoreImpl.documentOverlayCache.removeOverlaysForBatchId(txn, affectedKeys, batchId))\n            .next(() => localStoreImpl.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(txn, affectedKeys))\n            .next(() => localStoreImpl.localDocuments.getDocuments(txn, affectedKeys));\n    });\n}\n/**\n * Returns the largest (latest) batch id in mutation queue that is pending\n * server response.\n *\n * Returns `BATCHID_UNKNOWN` if the queue is empty.\n */\nfunction localStoreGetHighestUnacknowledgedBatchId(localStore) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Get highest unacknowledged batch id', 'readonly', txn => localStoreImpl.mutationQueue.getHighestUnacknowledgedBatchId(txn));\n}\n/**\n * Returns the last consistent snapshot processed (used by the RemoteStore to\n * determine whether to buffer incoming snapshots from the backend).\n */\nfunction localStoreGetLastRemoteSnapshotVersion(localStore) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Get last remote snapshot version', 'readonly', txn => localStoreImpl.targetCache.getLastRemoteSnapshotVersion(txn));\n}\n/**\n * Updates the \"ground-state\" (remote) documents. We assume that the remote\n * event reflects any write batches that have been acknowledged or rejected\n * (i.e. we do not re-apply local mutations to updates from this event).\n *\n * LocalDocuments are re-calculated if there are remaining mutations in the\n * queue.\n */\nfunction localStoreApplyRemoteEventToLocalCache(localStore, remoteEvent) {\n    const localStoreImpl = debugCast(localStore);\n    const remoteVersion = remoteEvent.snapshotVersion;\n    let newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;\n    return localStoreImpl.persistence\n        .runTransaction('Apply remote event', 'readwrite-primary', txn => {\n        const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\n            trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\n        });\n        // Reset newTargetDataByTargetMap in case this transaction gets re-run.\n        newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;\n        const promises = [];\n        remoteEvent.targetChanges.forEach((change, targetId) => {\n            const oldTargetData = newTargetDataByTargetMap.get(targetId);\n            if (!oldTargetData) {\n                return;\n            }\n            // Only update the remote keys if the target is still active. This\n            // ensures that we can persist the updated target data along with\n            // the updated assignment.\n            promises.push(localStoreImpl.targetCache\n                .removeMatchingKeys(txn, change.removedDocuments, targetId)\n                .next(() => {\n                return localStoreImpl.targetCache.addMatchingKeys(txn, change.addedDocuments, targetId);\n            }));\n            let newTargetData = oldTargetData.withSequenceNumber(txn.currentSequenceNumber);\n            if (remoteEvent.targetMismatches.get(targetId) !== null) {\n                newTargetData = newTargetData\n                    .withResumeToken(ByteString.EMPTY_BYTE_STRING, SnapshotVersion.min())\n                    .withLastLimboFreeSnapshotVersion(SnapshotVersion.min());\n            }\n            else if (change.resumeToken.approximateByteSize() > 0) {\n                newTargetData = newTargetData.withResumeToken(change.resumeToken, remoteVersion);\n            }\n            newTargetDataByTargetMap = newTargetDataByTargetMap.insert(targetId, newTargetData);\n            // Update the target data if there are target changes (or if\n            // sufficient time has passed since the last update).\n            if (shouldPersistTargetData(oldTargetData, newTargetData, change)) {\n                promises.push(localStoreImpl.targetCache.updateTargetData(txn, newTargetData));\n            }\n        });\n        let changedDocs = mutableDocumentMap();\n        let existenceChangedKeys = documentKeySet();\n        remoteEvent.documentUpdates.forEach(key => {\n            if (remoteEvent.resolvedLimboDocuments.has(key)) {\n                promises.push(localStoreImpl.persistence.referenceDelegate.updateLimboDocument(txn, key));\n            }\n        });\n        // Each loop iteration only affects its \"own\" doc, so it's safe to get all\n        // the remote documents in advance in a single call.\n        promises.push(populateDocumentChangeBuffer(txn, documentBuffer, remoteEvent.documentUpdates).next(result => {\n            changedDocs = result.changedDocuments;\n            existenceChangedKeys = result.existenceChangedKeys;\n        }));\n        // HACK: The only reason we allow a null snapshot version is so that we\n        // can synthesize remote events when we get permission denied errors while\n        // trying to resolve the state of a locally cached document that is in\n        // limbo.\n        if (!remoteVersion.isEqual(SnapshotVersion.min())) {\n            const updateRemoteVersion = localStoreImpl.targetCache\n                .getLastRemoteSnapshotVersion(txn)\n                .next(lastRemoteSnapshotVersion => {\n                return localStoreImpl.targetCache.setTargetsMetadata(txn, txn.currentSequenceNumber, remoteVersion);\n            });\n            promises.push(updateRemoteVersion);\n        }\n        return PersistencePromise.waitFor(promises)\n            .next(() => documentBuffer.apply(txn))\n            .next(() => localStoreImpl.localDocuments.getLocalViewOfDocuments(txn, changedDocs, existenceChangedKeys))\n            .next(() => changedDocs);\n    })\n        .then(changedDocs => {\n        localStoreImpl.targetDataByTarget = newTargetDataByTargetMap;\n        return changedDocs;\n    });\n}\n/**\n * Populates document change buffer with documents from backend or a bundle.\n * Returns the document changes resulting from applying those documents, and\n * also a set of documents whose existence state are changed as a result.\n *\n * @param txn - Transaction to use to read existing documents from storage.\n * @param documentBuffer - Document buffer to collect the resulted changes to be\n *        applied to storage.\n * @param documents - Documents to be applied.\n */\nfunction populateDocumentChangeBuffer(txn, documentBuffer, documents) {\n    let updatedKeys = documentKeySet();\n    let existenceChangedKeys = documentKeySet();\n    documents.forEach(k => (updatedKeys = updatedKeys.add(k)));\n    return documentBuffer.getEntries(txn, updatedKeys).next(existingDocs => {\n        let changedDocuments = mutableDocumentMap();\n        documents.forEach((key, doc) => {\n            const existingDoc = existingDocs.get(key);\n            // Check if see if there is a existence state change for this document.\n            if (doc.isFoundDocument() !== existingDoc.isFoundDocument()) {\n                existenceChangedKeys = existenceChangedKeys.add(key);\n            }\n            // Note: The order of the steps below is important, since we want\n            // to ensure that rejected limbo resolutions (which fabricate\n            // NoDocuments with SnapshotVersion.min()) never add documents to\n            // cache.\n            if (doc.isNoDocument() && doc.version.isEqual(SnapshotVersion.min())) {\n                // NoDocuments with SnapshotVersion.min() are used in manufactured\n                // events. We remove these documents from cache since we lost\n                // access.\n                documentBuffer.removeEntry(key, doc.readTime);\n                changedDocuments = changedDocuments.insert(key, doc);\n            }\n            else if (!existingDoc.isValidDocument() ||\n                doc.version.compareTo(existingDoc.version) > 0 ||\n                (doc.version.compareTo(existingDoc.version) === 0 &&\n                    existingDoc.hasPendingWrites)) {\n                documentBuffer.addEntry(doc);\n                changedDocuments = changedDocuments.insert(key, doc);\n            }\n            else {\n                logDebug(LOG_TAG$b, 'Ignoring outdated watch update for ', key, '. Current version:', existingDoc.version, ' Watch version:', doc.version);\n            }\n        });\n        return { changedDocuments, existenceChangedKeys };\n    });\n}\n/**\n * Returns true if the newTargetData should be persisted during an update of\n * an active target. TargetData should always be persisted when a target is\n * being released and should not call this function.\n *\n * While the target is active, TargetData updates can be omitted when nothing\n * about the target has changed except metadata like the resume token or\n * snapshot version. Occasionally it's worth the extra write to prevent these\n * values from getting too stale after a crash, but this doesn't have to be\n * too frequent.\n */\nfunction shouldPersistTargetData(oldTargetData, newTargetData, change) {\n    // Always persist target data if we don't already have a resume token.\n    if (oldTargetData.resumeToken.approximateByteSize() === 0) {\n        return true;\n    }\n    // Don't allow resume token changes to be buffered indefinitely. This\n    // allows us to be reasonably up-to-date after a crash and avoids needing\n    // to loop over all active queries on shutdown. Especially in the browser\n    // we may not get time to do anything interesting while the current tab is\n    // closing.\n    const timeDelta = newTargetData.snapshotVersion.toMicroseconds() -\n        oldTargetData.snapshotVersion.toMicroseconds();\n    if (timeDelta >= RESUME_TOKEN_MAX_AGE_MICROS) {\n        return true;\n    }\n    // Otherwise if the only thing that has changed about a target is its resume\n    // token it's not worth persisting. Note that the RemoteStore keeps an\n    // in-memory view of the currently active targets which includes the current\n    // resume token, so stream failure or user changes will still use an\n    // up-to-date resume token regardless of what we do here.\n    const changes = change.addedDocuments.size +\n        change.modifiedDocuments.size +\n        change.removedDocuments.size;\n    return changes > 0;\n}\n/**\n * Notifies local store of the changed views to locally pin documents.\n */\nasync function localStoreNotifyLocalViewChanges(localStore, viewChanges) {\n    const localStoreImpl = debugCast(localStore);\n    try {\n        await localStoreImpl.persistence.runTransaction('notifyLocalViewChanges', 'readwrite', txn => {\n            return PersistencePromise.forEach(viewChanges, (viewChange) => {\n                return PersistencePromise.forEach(viewChange.addedKeys, (key) => localStoreImpl.persistence.referenceDelegate.addReference(txn, viewChange.targetId, key)).next(() => PersistencePromise.forEach(viewChange.removedKeys, (key) => localStoreImpl.persistence.referenceDelegate.removeReference(txn, viewChange.targetId, key)));\n            });\n        });\n    }\n    catch (e) {\n        if (isIndexedDbTransactionError(e)) {\n            // If `notifyLocalViewChanges` fails, we did not advance the sequence\n            // number for the documents that were included in this transaction.\n            // This might trigger them to be deleted earlier than they otherwise\n            // would have, but it should not invalidate the integrity of the data.\n            logDebug(LOG_TAG$b, 'Failed to update sequence numbers: ' + e);\n        }\n        else {\n            throw e;\n        }\n    }\n    for (const viewChange of viewChanges) {\n        const targetId = viewChange.targetId;\n        if (!viewChange.fromCache) {\n            const targetData = localStoreImpl.targetDataByTarget.get(targetId);\n            // Advance the last limbo free snapshot version\n            const lastLimboFreeSnapshotVersion = targetData.snapshotVersion;\n            const updatedTargetData = targetData.withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion);\n            localStoreImpl.targetDataByTarget =\n                localStoreImpl.targetDataByTarget.insert(targetId, updatedTargetData);\n            // TODO(b/272564316): Apply the optimization done on other platforms.\n            // This is a problem for web because saving the updated targetData from\n            // non-primary client conflicts with what primary client saved.\n        }\n    }\n}\n/**\n * Gets the mutation batch after the passed in batchId in the mutation queue\n * or null if empty.\n * @param afterBatchId - If provided, the batch to search after.\n * @returns The next mutation or null if there wasn't one.\n */\nfunction localStoreGetNextMutationBatch(localStore, afterBatchId) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Get next mutation batch', 'readonly', txn => {\n        if (afterBatchId === undefined) {\n            afterBatchId = BATCHID_UNKNOWN;\n        }\n        return localStoreImpl.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);\n    });\n}\n/**\n * Reads the current value of a Document with a given key or null if not\n * found - used for testing.\n */\nfunction localStoreReadDocument(localStore, key) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('read document', 'readonly', txn => localStoreImpl.localDocuments.getDocument(txn, key));\n}\n/**\n * Assigns the given target an internal ID so that its results can be pinned so\n * they don't get GC'd. A target must be allocated in the local store before\n * the store can be used to manage its view.\n *\n * Allocating an already allocated `Target` will return the existing `TargetData`\n * for that `Target`.\n */\nfunction localStoreAllocateTarget(localStore, target) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence\n        .runTransaction('Allocate target', 'readwrite', txn => {\n        let targetData;\n        return localStoreImpl.targetCache\n            .getTargetData(txn, target)\n            .next((cached) => {\n            if (cached) {\n                // This target has been listened to previously, so reuse the\n                // previous targetID.\n                // TODO(mcg): freshen last accessed date?\n                targetData = cached;\n                return PersistencePromise.resolve(targetData);\n            }\n            else {\n                return localStoreImpl.targetCache\n                    .allocateTargetId(txn)\n                    .next(targetId => {\n                    targetData = new TargetData(target, targetId, \"TargetPurposeListen\" /* TargetPurpose.Listen */, txn.currentSequenceNumber);\n                    return localStoreImpl.targetCache\n                        .addTargetData(txn, targetData)\n                        .next(() => targetData);\n                });\n            }\n        });\n    })\n        .then(targetData => {\n        // If Multi-Tab is enabled, the existing target data may be newer than\n        // the in-memory data\n        const cachedTargetData = localStoreImpl.targetDataByTarget.get(targetData.targetId);\n        if (cachedTargetData === null ||\n            targetData.snapshotVersion.compareTo(cachedTargetData.snapshotVersion) >\n                0) {\n            localStoreImpl.targetDataByTarget =\n                localStoreImpl.targetDataByTarget.insert(targetData.targetId, targetData);\n            localStoreImpl.targetIdByTarget.set(target, targetData.targetId);\n        }\n        return targetData;\n    });\n}\n/**\n * Returns the TargetData as seen by the LocalStore, including updates that may\n * have not yet been persisted to the TargetCache.\n */\n// Visible for testing.\nfunction localStoreGetTargetData(localStore, transaction, target) {\n    const localStoreImpl = debugCast(localStore);\n    const targetId = localStoreImpl.targetIdByTarget.get(target);\n    if (targetId !== undefined) {\n        return PersistencePromise.resolve(localStoreImpl.targetDataByTarget.get(targetId));\n    }\n    else {\n        return localStoreImpl.targetCache.getTargetData(transaction, target);\n    }\n}\n/**\n * Unpins all the documents associated with the given target. If\n * `keepPersistedTargetData` is set to false and Eager GC enabled, the method\n * directly removes the associated target data from the target cache.\n *\n * Releasing a non-existing `Target` is a no-op.\n */\n// PORTING NOTE: `keepPersistedTargetData` is multi-tab only.\nasync function localStoreReleaseTarget(localStore, targetId, keepPersistedTargetData) {\n    const localStoreImpl = debugCast(localStore);\n    const targetData = localStoreImpl.targetDataByTarget.get(targetId);\n    const mode = keepPersistedTargetData ? 'readwrite' : 'readwrite-primary';\n    try {\n        if (!keepPersistedTargetData) {\n            await localStoreImpl.persistence.runTransaction('Release target', mode, txn => {\n                return localStoreImpl.persistence.referenceDelegate.removeTarget(txn, targetData);\n            });\n        }\n    }\n    catch (e) {\n        if (isIndexedDbTransactionError(e)) {\n            // All `releaseTarget` does is record the final metadata state for the\n            // target, but we've been recording this periodically during target\n            // activity. If we lose this write this could cause a very slight\n            // difference in the order of target deletion during GC, but we\n            // don't define exact LRU semantics so this is acceptable.\n            logDebug(LOG_TAG$b, `Failed to update sequence numbers for target ${targetId}: ${e}`);\n        }\n        else {\n            throw e;\n        }\n    }\n    localStoreImpl.targetDataByTarget =\n        localStoreImpl.targetDataByTarget.remove(targetId);\n    localStoreImpl.targetIdByTarget.delete(targetData.target);\n}\n/**\n * Runs the specified query against the local store and returns the results,\n * potentially taking advantage of query data from previous executions (such\n * as the set of remote keys).\n *\n * @param usePreviousResults - Whether results from previous executions can\n * be used to optimize this query execution.\n */\nfunction localStoreExecuteQuery(localStore, query, usePreviousResults) {\n    const localStoreImpl = debugCast(localStore);\n    let lastLimboFreeSnapshotVersion = SnapshotVersion.min();\n    let remoteKeys = documentKeySet();\n    return localStoreImpl.persistence.runTransaction('Execute query', 'readwrite', // Use readwrite instead of readonly so indexes can be created\n    // Use readwrite instead of readonly so indexes can be created\n    txn => {\n        return localStoreGetTargetData(localStoreImpl, txn, queryToTarget(query))\n            .next(targetData => {\n            if (targetData) {\n                lastLimboFreeSnapshotVersion =\n                    targetData.lastLimboFreeSnapshotVersion;\n                return localStoreImpl.targetCache\n                    .getMatchingKeysForTargetId(txn, targetData.targetId)\n                    .next(result => {\n                    remoteKeys = result;\n                });\n            }\n        })\n            .next(() => localStoreImpl.queryEngine.getDocumentsMatchingQuery(txn, query, usePreviousResults\n            ? lastLimboFreeSnapshotVersion\n            : SnapshotVersion.min(), usePreviousResults ? remoteKeys : documentKeySet()))\n            .next(documents => {\n            setMaxReadTime(localStoreImpl, queryCollectionGroup(query), documents);\n            return { documents, remoteKeys };\n        });\n    });\n}\nfunction applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer) {\n    const batch = batchResult.batch;\n    const docKeys = batch.keys();\n    let promiseChain = PersistencePromise.resolve();\n    docKeys.forEach(docKey => {\n        promiseChain = promiseChain\n            .next(() => documentBuffer.getEntry(txn, docKey))\n            .next(doc => {\n            const ackVersion = batchResult.docVersions.get(docKey);\n            hardAssert(ackVersion !== null);\n            if (doc.version.compareTo(ackVersion) < 0) {\n                batch.applyToRemoteDocument(doc, batchResult);\n                if (doc.isValidDocument()) {\n                    // We use the commitVersion as the readTime rather than the\n                    // document's updateTime since the updateTime is not advanced\n                    // for updates that do not modify the underlying document.\n                    doc.setReadTime(batchResult.commitVersion);\n                    documentBuffer.addEntry(doc);\n                }\n            }\n        });\n    });\n    return promiseChain.next(() => localStoreImpl.mutationQueue.removeMutationBatch(txn, batch));\n}\n/** Returns the local view of the documents affected by a mutation batch. */\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreLookupMutationDocuments(localStore, batchId) {\n    const localStoreImpl = debugCast(localStore);\n    const mutationQueueImpl = debugCast(localStoreImpl.mutationQueue);\n    return localStoreImpl.persistence.runTransaction('Lookup mutation documents', 'readonly', txn => {\n        return mutationQueueImpl.lookupMutationKeys(txn, batchId).next(keys => {\n            if (keys) {\n                return localStoreImpl.localDocuments.getDocuments(txn, keys);\n            }\n            else {\n                return PersistencePromise.resolve(null);\n            }\n        });\n    });\n}\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreRemoveCachedMutationBatchMetadata(localStore, batchId) {\n    const mutationQueueImpl = debugCast(debugCast(localStore, LocalStoreImpl).mutationQueue);\n    mutationQueueImpl.removeCachedMutationKeys(batchId);\n}\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreGetActiveClients(localStore) {\n    const persistenceImpl = debugCast(debugCast(localStore, LocalStoreImpl).persistence);\n    return persistenceImpl.getActiveClients();\n}\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreGetCachedTarget(localStore, targetId) {\n    const localStoreImpl = debugCast(localStore);\n    const targetCacheImpl = debugCast(localStoreImpl.targetCache);\n    const cachedTargetData = localStoreImpl.targetDataByTarget.get(targetId);\n    if (cachedTargetData) {\n        return Promise.resolve(cachedTargetData.target);\n    }\n    else {\n        return localStoreImpl.persistence.runTransaction('Get target data', 'readonly', txn => {\n            return targetCacheImpl\n                .getTargetDataForTarget(txn, targetId)\n                .next(targetData => (targetData ? targetData.target : null));\n        });\n    }\n}\n/**\n * Returns the set of documents that have been updated since the last call.\n * If this is the first call, returns the set of changes since client\n * initialization. Further invocations will return document that have changed\n * since the prior call.\n */\n// PORTING NOTE: Multi-Tab only.\nfunction localStoreGetNewDocumentChanges(localStore, collectionGroup) {\n    const localStoreImpl = debugCast(localStore);\n    // Get the current maximum read time for the collection. This should always\n    // exist, but to reduce the chance for regressions we default to\n    // SnapshotVersion.Min()\n    // TODO(indexing): Consider removing the default value.\n    const readTime = localStoreImpl.collectionGroupReadTime.get(collectionGroup) ||\n        SnapshotVersion.min();\n    return localStoreImpl.persistence\n        .runTransaction('Get new document changes', 'readonly', txn => localStoreImpl.remoteDocuments.getAllFromCollectionGroup(txn, collectionGroup, newIndexOffsetSuccessorFromReadTime(readTime, INITIAL_LARGEST_BATCH_ID), \n    /* limit= */ Number.MAX_SAFE_INTEGER))\n        .then(changedDocs => {\n        setMaxReadTime(localStoreImpl, collectionGroup, changedDocs);\n        return changedDocs;\n    });\n}\n/** Sets the collection group's maximum read time from the given documents. */\n// PORTING NOTE: Multi-Tab only.\nfunction setMaxReadTime(localStoreImpl, collectionGroup, changedDocs) {\n    let readTime = localStoreImpl.collectionGroupReadTime.get(collectionGroup) ||\n        SnapshotVersion.min();\n    changedDocs.forEach((_, doc) => {\n        if (doc.readTime.compareTo(readTime) > 0) {\n            readTime = doc.readTime;\n        }\n    });\n    localStoreImpl.collectionGroupReadTime.set(collectionGroup, readTime);\n}\n/**\n * Creates a new target using the given bundle name, which will be used to\n * hold the keys of all documents from the bundle in query-document mappings.\n * This ensures that the loaded documents do not get garbage collected\n * right away.\n */\nfunction umbrellaTarget(bundleName) {\n    // It is OK that the path used for the query is not valid, because this will\n    // not be read and queried.\n    return queryToTarget(newQueryForPath(ResourcePath.fromString(`__bundle__/docs/${bundleName}`)));\n}\n/**\n * Applies the documents from a bundle to the \"ground-state\" (remote)\n * documents.\n *\n * LocalDocuments are re-calculated if there are remaining mutations in the\n * queue.\n */\nasync function localStoreApplyBundledDocuments(localStore, bundleConverter, documents, bundleName) {\n    const localStoreImpl = debugCast(localStore);\n    let documentKeys = documentKeySet();\n    let documentMap = mutableDocumentMap();\n    for (const bundleDoc of documents) {\n        const documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);\n        if (bundleDoc.document) {\n            documentKeys = documentKeys.add(documentKey);\n        }\n        const doc = bundleConverter.toMutableDocument(bundleDoc);\n        doc.setReadTime(bundleConverter.toSnapshotVersion(bundleDoc.metadata.readTime));\n        documentMap = documentMap.insert(documentKey, doc);\n    }\n    const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\n        trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\n    });\n    // Allocates a target to hold all document keys from the bundle, such that\n    // they will not get garbage collected right away.\n    const umbrellaTargetData = await localStoreAllocateTarget(localStoreImpl, umbrellaTarget(bundleName));\n    return localStoreImpl.persistence.runTransaction('Apply bundle documents', 'readwrite', txn => {\n        return populateDocumentChangeBuffer(txn, documentBuffer, documentMap)\n            .next(documentChangeResult => {\n            documentBuffer.apply(txn);\n            return documentChangeResult;\n        })\n            .next(documentChangeResult => {\n            return localStoreImpl.targetCache\n                .removeMatchingKeysForTargetId(txn, umbrellaTargetData.targetId)\n                .next(() => localStoreImpl.targetCache.addMatchingKeys(txn, documentKeys, umbrellaTargetData.targetId))\n                .next(() => localStoreImpl.localDocuments.getLocalViewOfDocuments(txn, documentChangeResult.changedDocuments, documentChangeResult.existenceChangedKeys))\n                .next(() => documentChangeResult.changedDocuments);\n        });\n    });\n}\n/**\n * Returns a promise of a boolean to indicate if the given bundle has already\n * been loaded and the create time is newer than the current loading bundle.\n */\nfunction localStoreHasNewerBundle(localStore, bundleMetadata) {\n    const localStoreImpl = debugCast(localStore);\n    const currentReadTime = fromVersion(bundleMetadata.createTime);\n    return localStoreImpl.persistence\n        .runTransaction('hasNewerBundle', 'readonly', transaction => {\n        return localStoreImpl.bundleCache.getBundleMetadata(transaction, bundleMetadata.id);\n    })\n        .then(cached => {\n        return !!cached && cached.createTime.compareTo(currentReadTime) >= 0;\n    });\n}\n/**\n * Saves the given `BundleMetadata` to local persistence.\n */\nfunction localStoreSaveBundle(localStore, bundleMetadata) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Save bundle', 'readwrite', transaction => {\n        return localStoreImpl.bundleCache.saveBundleMetadata(transaction, bundleMetadata);\n    });\n}\n/**\n * Returns a promise of a `NamedQuery` associated with given query name. Promise\n * resolves to undefined if no persisted data can be found.\n */\nfunction localStoreGetNamedQuery(localStore, queryName) {\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Get named query', 'readonly', transaction => localStoreImpl.bundleCache.getNamedQuery(transaction, queryName));\n}\n/**\n * Saves the given `NamedQuery` to local persistence.\n */\nasync function localStoreSaveNamedQuery(localStore, query, documents = documentKeySet()) {\n    // Allocate a target for the named query such that it can be resumed\n    // from associated read time if users use it to listen.\n    // NOTE: this also means if no corresponding target exists, the new target\n    // will remain active and will not get collected, unless users happen to\n    // unlisten the query somehow.\n    const allocated = await localStoreAllocateTarget(localStore, queryToTarget(fromBundledQuery(query.bundledQuery)));\n    const localStoreImpl = debugCast(localStore);\n    return localStoreImpl.persistence.runTransaction('Save named query', 'readwrite', transaction => {\n        const readTime = fromVersion(query.readTime);\n        // Simply save the query itself if it is older than what the SDK already\n        // has.\n        if (allocated.snapshotVersion.compareTo(readTime) >= 0) {\n            return localStoreImpl.bundleCache.saveNamedQuery(transaction, query);\n        }\n        // Update existing target data because the query from the bundle is newer.\n        const newTargetData = allocated.withResumeToken(ByteString.EMPTY_BYTE_STRING, readTime);\n        localStoreImpl.targetDataByTarget =\n            localStoreImpl.targetDataByTarget.insert(newTargetData.targetId, newTargetData);\n        return localStoreImpl.targetCache\n            .updateTargetData(transaction, newTargetData)\n            .next(() => localStoreImpl.targetCache.removeMatchingKeysForTargetId(transaction, allocated.targetId))\n            .next(() => localStoreImpl.targetCache.addMatchingKeys(transaction, documents, allocated.targetId))\n            .next(() => localStoreImpl.bundleCache.saveNamedQuery(transaction, query));\n    });\n}\nasync function localStoreConfigureFieldIndexes(localStore, newFieldIndexes) {\n    const localStoreImpl = debugCast(localStore);\n    const indexManager = localStoreImpl.indexManager;\n    const promises = [];\n    return localStoreImpl.persistence.runTransaction('Configure indexes', 'readwrite', transaction => indexManager\n        .getFieldIndexes(transaction)\n        .next(oldFieldIndexes => diffArrays(oldFieldIndexes, newFieldIndexes, fieldIndexSemanticComparator, fieldIndex => {\n        promises.push(indexManager.addFieldIndex(transaction, fieldIndex));\n    }, fieldIndex => {\n        promises.push(indexManager.deleteFieldIndex(transaction, fieldIndex));\n    }))\n        .next(() => PersistencePromise.waitFor(promises)));\n}\nfunction localStoreSetIndexAutoCreationEnabled(localStore, isEnabled) {\n    const localStoreImpl = debugCast(localStore);\n    localStoreImpl.queryEngine.indexAutoCreationEnabled = isEnabled;\n}\nfunction localStoreDeleteAllFieldIndexes(localStore) {\n    const localStoreImpl = debugCast(localStore);\n    const indexManager = localStoreImpl.indexManager;\n    return localStoreImpl.persistence.runTransaction('Delete All Indexes', 'readwrite', transaction => indexManager.deleteAllFieldIndexes(transaction));\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A tracker to keep a record of important details during database local query\n * execution.\n */\nclass QueryContext {\n    constructor() {\n        /**\n         * Counts the number of documents passed through during local query execution.\n         */\n        this._documentReadCount = 0;\n    }\n    get documentReadCount() {\n        return this._documentReadCount;\n    }\n    incrementDocumentReadCount(amount) {\n        this._documentReadCount += amount;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_INDEX_AUTO_CREATION_MIN_COLLECTION_SIZE = 100;\n/**\n * This cost represents the evaluation result of\n * (([index, docKey] + [docKey, docContent]) per document in the result set)\n * / ([docKey, docContent] per documents in full collection scan) coming from\n * experiment [enter PR experiment URL here].\n */\nfunction getDefaultRelativeIndexReadCostPerDocument() {\n    // These values were derived from an experiment where several members of the\n    // Firestore SDK team ran a performance test in various environments.\n    // Googlers can see b/299284287 for details.\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isSafari)()) {\n        return 8;\n    }\n    else if (getAndroidVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)()) > 0) {\n        return 6;\n    }\n    else {\n        return 4;\n    }\n}\n/**\n * The Firestore query engine.\n *\n * Firestore queries can be executed in three modes. The Query Engine determines\n * what mode to use based on what data is persisted. The mode only determines\n * the runtime complexity of the query - the result set is equivalent across all\n * implementations.\n *\n * The Query engine will use indexed-based execution if a user has configured\n * any index that can be used to execute query (via `setIndexConfiguration()`).\n * Otherwise, the engine will try to optimize the query by re-using a previously\n * persisted query result. If that is not possible, the query will be executed\n * via a full collection scan.\n *\n * Index-based execution is the default when available. The query engine\n * supports partial indexed execution and merges the result from the index\n * lookup with documents that have not yet been indexed. The index evaluation\n * matches the backend's format and as such, the SDK can use indexing for all\n * queries that the backend supports.\n *\n * If no index exists, the query engine tries to take advantage of the target\n * document mapping in the TargetCache. These mappings exists for all queries\n * that have been synced with the backend at least once and allow the query\n * engine to only read documents that previously matched a query plus any\n * documents that were edited after the query was last listened to.\n *\n * There are some cases when this optimization is not guaranteed to produce\n * the same results as full collection scans. In these cases, query\n * processing falls back to full scans. These cases are:\n *\n * - Limit queries where a document that matched the query previously no longer\n *   matches the query.\n *\n * - Limit queries where a document edit may cause the document to sort below\n *   another document that is in the local cache.\n *\n * - Queries that have never been CURRENT or free of limbo documents.\n */\nclass QueryEngine {\n    constructor() {\n        this.initialized = false;\n        this.indexAutoCreationEnabled = false;\n        /**\n         * SDK only decides whether it should create index when collection size is\n         * larger than this.\n         */\n        this.indexAutoCreationMinCollectionSize = DEFAULT_INDEX_AUTO_CREATION_MIN_COLLECTION_SIZE;\n        this.relativeIndexReadCostPerDocument = getDefaultRelativeIndexReadCostPerDocument();\n    }\n    /** Sets the document view to query against. */\n    initialize(localDocuments, indexManager) {\n        this.localDocumentsView = localDocuments;\n        this.indexManager = indexManager;\n        this.initialized = true;\n    }\n    /** Returns all local documents matching the specified query. */\n    getDocumentsMatchingQuery(transaction, query, lastLimboFreeSnapshotVersion, remoteKeys) {\n        // Stores the result from executing the query; using this object is more\n        // convenient than passing the result between steps of the persistence\n        // transaction and improves readability comparatively.\n        const queryResult = { result: null };\n        return this.performQueryUsingIndex(transaction, query)\n            .next(result => {\n            queryResult.result = result;\n        })\n            .next(() => {\n            if (queryResult.result) {\n                return;\n            }\n            return this.performQueryUsingRemoteKeys(transaction, query, remoteKeys, lastLimboFreeSnapshotVersion).next(result => {\n                queryResult.result = result;\n            });\n        })\n            .next(() => {\n            if (queryResult.result) {\n                return;\n            }\n            const context = new QueryContext();\n            return this.executeFullCollectionScan(transaction, query, context).next(result => {\n                queryResult.result = result;\n                if (this.indexAutoCreationEnabled) {\n                    return this.createCacheIndexes(transaction, query, context, result.size);\n                }\n            });\n        })\n            .next(() => queryResult.result);\n    }\n    createCacheIndexes(transaction, query, context, resultSize) {\n        if (context.documentReadCount < this.indexAutoCreationMinCollectionSize) {\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n                logDebug('QueryEngine', 'SDK will not create cache indexes for query:', stringifyQuery(query), 'since it only creates cache indexes for collection contains', 'more than or equal to', this.indexAutoCreationMinCollectionSize, 'documents');\n            }\n            return PersistencePromise.resolve();\n        }\n        if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n            logDebug('QueryEngine', 'Query:', stringifyQuery(query), 'scans', context.documentReadCount, 'local documents and returns', resultSize, 'documents as results.');\n        }\n        if (context.documentReadCount >\n            this.relativeIndexReadCostPerDocument * resultSize) {\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n                logDebug('QueryEngine', 'The SDK decides to create cache indexes for query:', stringifyQuery(query), 'as using cache indexes may help improve performance.');\n            }\n            return this.indexManager.createTargetIndexes(transaction, queryToTarget(query));\n        }\n        return PersistencePromise.resolve();\n    }\n    /**\n     * Performs an indexed query that evaluates the query based on a collection's\n     * persisted index values. Returns `null` if an index is not available.\n     */\n    performQueryUsingIndex(transaction, query) {\n        if (queryMatchesAllDocuments(query)) {\n            // Queries that match all documents don't benefit from using\n            // key-based lookups. It is more efficient to scan all documents in a\n            // collection, rather than to perform individual lookups.\n            return PersistencePromise.resolve(null);\n        }\n        let target = queryToTarget(query);\n        return this.indexManager\n            .getIndexType(transaction, target)\n            .next(indexType => {\n            if (indexType === 0 /* IndexType.NONE */) {\n                // The target cannot be served from any index.\n                return null;\n            }\n            if (query.limit !== null && indexType === 1 /* IndexType.PARTIAL */) {\n                // We cannot apply a limit for targets that are served using a partial\n                // index. If a partial index will be used to serve the target, the\n                // query may return a superset of documents that match the target\n                // (e.g. if the index doesn't include all the target's filters), or\n                // may return the correct set of documents in the wrong order (e.g. if\n                // the index doesn't include a segment for one of the orderBys).\n                // Therefore, a limit should not be applied in such cases.\n                query = queryWithLimit(query, null, \"F\" /* LimitType.First */);\n                target = queryToTarget(query);\n            }\n            return this.indexManager\n                .getDocumentsMatchingTarget(transaction, target)\n                .next(keys => {\n                const sortedKeys = documentKeySet(...keys);\n                return this.localDocumentsView\n                    .getDocuments(transaction, sortedKeys)\n                    .next(indexedDocuments => {\n                    return this.indexManager\n                        .getMinOffset(transaction, target)\n                        .next(offset => {\n                        const previousResults = this.applyQuery(query, indexedDocuments);\n                        if (this.needsRefill(query, previousResults, sortedKeys, offset.readTime)) {\n                            // A limit query whose boundaries change due to local\n                            // edits can be re-run against the cache by excluding the\n                            // limit. This ensures that all documents that match the\n                            // query's filters are included in the result set. The SDK\n                            // can then apply the limit once all local edits are\n                            // incorporated.\n                            return this.performQueryUsingIndex(transaction, queryWithLimit(query, null, \"F\" /* LimitType.First */));\n                        }\n                        return this.appendRemainingResults(transaction, previousResults, query, offset);\n                    });\n                });\n            });\n        });\n    }\n    /**\n     * Performs a query based on the target's persisted query mapping. Returns\n     * `null` if the mapping is not available or cannot be used.\n     */\n    performQueryUsingRemoteKeys(transaction, query, remoteKeys, lastLimboFreeSnapshotVersion) {\n        if (queryMatchesAllDocuments(query)) {\n            // Queries that match all documents don't benefit from using\n            // key-based lookups. It is more efficient to scan all documents in a\n            // collection, rather than to perform individual lookups.\n            return PersistencePromise.resolve(null);\n        }\n        // Queries that have never seen a snapshot without limbo free documents\n        // should also be run as a full collection scan.\n        if (lastLimboFreeSnapshotVersion.isEqual(SnapshotVersion.min())) {\n            return PersistencePromise.resolve(null);\n        }\n        return this.localDocumentsView.getDocuments(transaction, remoteKeys).next(documents => {\n            const previousResults = this.applyQuery(query, documents);\n            if (this.needsRefill(query, previousResults, remoteKeys, lastLimboFreeSnapshotVersion)) {\n                return PersistencePromise.resolve(null);\n            }\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n                logDebug('QueryEngine', 'Re-using previous result from %s to execute query: %s', lastLimboFreeSnapshotVersion.toString(), stringifyQuery(query));\n            }\n            // Retrieve all results for documents that were updated since the last\n            // limbo-document free remote snapshot.\n            return this.appendRemainingResults(transaction, previousResults, query, newIndexOffsetSuccessorFromReadTime(lastLimboFreeSnapshotVersion, INITIAL_LARGEST_BATCH_ID)).next(results => results);\n        });\n    }\n    /** Applies the query filter and sorting to the provided documents.  */\n    applyQuery(query, documents) {\n        // Sort the documents and re-apply the query filter since previously\n        // matching documents do not necessarily still match the query.\n        let queryResults = new SortedSet(newQueryComparator(query));\n        documents.forEach((_, maybeDoc) => {\n            if (queryMatches(query, maybeDoc)) {\n                queryResults = queryResults.add(maybeDoc);\n            }\n        });\n        return queryResults;\n    }\n    /**\n     * Determines if a limit query needs to be refilled from cache, making it\n     * ineligible for index-free execution.\n     *\n     * @param query - The query.\n     * @param sortedPreviousResults - The documents that matched the query when it\n     * was last synchronized, sorted by the query's comparator.\n     * @param remoteKeys - The document keys that matched the query at the last\n     * snapshot.\n     * @param limboFreeSnapshotVersion - The version of the snapshot when the\n     * query was last synchronized.\n     */\n    needsRefill(query, sortedPreviousResults, remoteKeys, limboFreeSnapshotVersion) {\n        if (query.limit === null) {\n            // Queries without limits do not need to be refilled.\n            return false;\n        }\n        if (remoteKeys.size !== sortedPreviousResults.size) {\n            // The query needs to be refilled if a previously matching document no\n            // longer matches.\n            return true;\n        }\n        // Limit queries are not eligible for index-free query execution if there is\n        // a potential that an older document from cache now sorts before a document\n        // that was previously part of the limit. This, however, can only happen if\n        // the document at the edge of the limit goes out of limit.\n        // If a document that is not the limit boundary sorts differently,\n        // the boundary of the limit itself did not change and documents from cache\n        // will continue to be \"rejected\" by this boundary. Therefore, we can ignore\n        // any modifications that don't affect the last document.\n        const docAtLimitEdge = query.limitType === \"F\" /* LimitType.First */\n            ? sortedPreviousResults.last()\n            : sortedPreviousResults.first();\n        if (!docAtLimitEdge) {\n            // We don't need to refill the query if there were already no documents.\n            return false;\n        }\n        return (docAtLimitEdge.hasPendingWrites ||\n            docAtLimitEdge.version.compareTo(limboFreeSnapshotVersion) > 0);\n    }\n    executeFullCollectionScan(transaction, query, context) {\n        if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\n            logDebug('QueryEngine', 'Using full collection scan to execute query:', stringifyQuery(query));\n        }\n        return this.localDocumentsView.getDocumentsMatchingQuery(transaction, query, IndexOffset.min(), context);\n    }\n    /**\n     * Combines the results from an indexed execution with the remaining documents\n     * that have not yet been indexed.\n     */\n    appendRemainingResults(transaction, indexedResults, query, offset) {\n        // Retrieve all results for documents that were updated since the offset.\n        return this.localDocumentsView\n            .getDocumentsMatchingQuery(transaction, query, offset)\n            .next(remainingResults => {\n            // Merge with existing results\n            indexedResults.forEach(d => {\n                remainingResults = remainingResults.insert(d.key, d);\n            });\n            return remainingResults;\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// The format of the LocalStorage key that stores the client state is:\n//     firestore_clients_<persistence_prefix>_<instance_key>\nconst CLIENT_STATE_KEY_PREFIX = 'firestore_clients';\n/** Assembles the key for a client state in WebStorage */\nfunction createWebStorageClientStateKey(persistenceKey, clientId) {\n    return `${CLIENT_STATE_KEY_PREFIX}_${persistenceKey}_${clientId}`;\n}\n// The format of the WebStorage key that stores the mutation state is:\n//     firestore_mutations_<persistence_prefix>_<batch_id>\n//     (for unauthenticated users)\n// or: firestore_mutations_<persistence_prefix>_<batch_id>_<user_uid>\n//\n// 'user_uid' is last to avoid needing to escape '_' characters that it might\n// contain.\nconst MUTATION_BATCH_KEY_PREFIX = 'firestore_mutations';\n/** Assembles the key for a mutation batch in WebStorage */\nfunction createWebStorageMutationBatchKey(persistenceKey, user, batchId) {\n    let mutationKey = `${MUTATION_BATCH_KEY_PREFIX}_${persistenceKey}_${batchId}`;\n    if (user.isAuthenticated()) {\n        mutationKey += `_${user.uid}`;\n    }\n    return mutationKey;\n}\n// The format of the WebStorage key that stores a query target's metadata is:\n//     firestore_targets_<persistence_prefix>_<target_id>\nconst QUERY_TARGET_KEY_PREFIX = 'firestore_targets';\n/** Assembles the key for a query state in WebStorage */\nfunction createWebStorageQueryTargetMetadataKey(persistenceKey, targetId) {\n    return `${QUERY_TARGET_KEY_PREFIX}_${persistenceKey}_${targetId}`;\n}\n// The WebStorage prefix that stores the primary tab's online state. The\n// format of the key is:\n//     firestore_online_state_<persistence_prefix>\nconst ONLINE_STATE_KEY_PREFIX = 'firestore_online_state';\n/** Assembles the key for the online state of the primary tab. */\nfunction createWebStorageOnlineStateKey(persistenceKey) {\n    return `${ONLINE_STATE_KEY_PREFIX}_${persistenceKey}`;\n}\n// The WebStorage prefix that plays as a event to indicate the remote documents\n// might have changed due to some secondary tabs loading a bundle.\n// format of the key is:\n//     firestore_bundle_loaded_v2_<persistenceKey>\n// The version ending with \"v2\" stores the list of modified collection groups.\nconst BUNDLE_LOADED_KEY_PREFIX = 'firestore_bundle_loaded_v2';\nfunction createBundleLoadedKey(persistenceKey) {\n    return `${BUNDLE_LOADED_KEY_PREFIX}_${persistenceKey}`;\n}\n// The WebStorage key prefix for the key that stores the last sequence number allocated. The key\n// looks like 'firestore_sequence_number_<persistence_prefix>'.\nconst SEQUENCE_NUMBER_KEY_PREFIX = 'firestore_sequence_number';\n/** Assembles the key for the current sequence number. */\nfunction createWebStorageSequenceNumberKey(persistenceKey) {\n    return `${SEQUENCE_NUMBER_KEY_PREFIX}_${persistenceKey}`;\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$a = 'SharedClientState';\n/**\n * Holds the state of a mutation batch, including its user ID, batch ID and\n * whether the batch is 'pending', 'acknowledged' or 'rejected'.\n */\n// Visible for testing\nclass MutationMetadata {\n    constructor(user, batchId, state, error) {\n        this.user = user;\n        this.batchId = batchId;\n        this.state = state;\n        this.error = error;\n    }\n    /**\n     * Parses a MutationMetadata from its JSON representation in WebStorage.\n     * Logs a warning and returns null if the format of the data is not valid.\n     */\n    static fromWebStorageEntry(user, batchId, value) {\n        const mutationBatch = JSON.parse(value);\n        let validData = typeof mutationBatch === 'object' &&\n            ['pending', 'acknowledged', 'rejected'].indexOf(mutationBatch.state) !==\n                -1 &&\n            (mutationBatch.error === undefined ||\n                typeof mutationBatch.error === 'object');\n        let firestoreError = undefined;\n        if (validData && mutationBatch.error) {\n            validData =\n                typeof mutationBatch.error.message === 'string' &&\n                    typeof mutationBatch.error.code === 'string';\n            if (validData) {\n                firestoreError = new FirestoreError(mutationBatch.error.code, mutationBatch.error.message);\n            }\n        }\n        if (validData) {\n            return new MutationMetadata(user, batchId, mutationBatch.state, firestoreError);\n        }\n        else {\n            logError(LOG_TAG$a, `Failed to parse mutation state for ID '${batchId}': ${value}`);\n            return null;\n        }\n    }\n    toWebStorageJSON() {\n        const batchMetadata = {\n            state: this.state,\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\n        };\n        if (this.error) {\n            batchMetadata.error = {\n                code: this.error.code,\n                message: this.error.message\n            };\n        }\n        return JSON.stringify(batchMetadata);\n    }\n}\n/**\n * Holds the state of a query target, including its target ID and whether the\n * target is 'not-current', 'current' or 'rejected'.\n */\n// Visible for testing\nclass QueryTargetMetadata {\n    constructor(targetId, state, error) {\n        this.targetId = targetId;\n        this.state = state;\n        this.error = error;\n    }\n    /**\n     * Parses a QueryTargetMetadata from its JSON representation in WebStorage.\n     * Logs a warning and returns null if the format of the data is not valid.\n     */\n    static fromWebStorageEntry(targetId, value) {\n        const targetState = JSON.parse(value);\n        let validData = typeof targetState === 'object' &&\n            ['not-current', 'current', 'rejected'].indexOf(targetState.state) !==\n                -1 &&\n            (targetState.error === undefined ||\n                typeof targetState.error === 'object');\n        let firestoreError = undefined;\n        if (validData && targetState.error) {\n            validData =\n                typeof targetState.error.message === 'string' &&\n                    typeof targetState.error.code === 'string';\n            if (validData) {\n                firestoreError = new FirestoreError(targetState.error.code, targetState.error.message);\n            }\n        }\n        if (validData) {\n            return new QueryTargetMetadata(targetId, targetState.state, firestoreError);\n        }\n        else {\n            logError(LOG_TAG$a, `Failed to parse target state for ID '${targetId}': ${value}`);\n            return null;\n        }\n    }\n    toWebStorageJSON() {\n        const targetState = {\n            state: this.state,\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\n        };\n        if (this.error) {\n            targetState.error = {\n                code: this.error.code,\n                message: this.error.message\n            };\n        }\n        return JSON.stringify(targetState);\n    }\n}\n/**\n * This class represents the immutable ClientState for a client read from\n * WebStorage, containing the list of active query targets.\n */\nclass RemoteClientState {\n    constructor(clientId, activeTargetIds) {\n        this.clientId = clientId;\n        this.activeTargetIds = activeTargetIds;\n    }\n    /**\n     * Parses a RemoteClientState from the JSON representation in WebStorage.\n     * Logs a warning and returns null if the format of the data is not valid.\n     */\n    static fromWebStorageEntry(clientId, value) {\n        const clientState = JSON.parse(value);\n        let validData = typeof clientState === 'object' &&\n            clientState.activeTargetIds instanceof Array;\n        let activeTargetIdsSet = targetIdSet();\n        for (let i = 0; validData && i < clientState.activeTargetIds.length; ++i) {\n            validData = isSafeInteger(clientState.activeTargetIds[i]);\n            activeTargetIdsSet = activeTargetIdsSet.add(clientState.activeTargetIds[i]);\n        }\n        if (validData) {\n            return new RemoteClientState(clientId, activeTargetIdsSet);\n        }\n        else {\n            logError(LOG_TAG$a, `Failed to parse client data for instance '${clientId}': ${value}`);\n            return null;\n        }\n    }\n}\n/**\n * This class represents the online state for all clients participating in\n * multi-tab. The online state is only written to by the primary client, and\n * used in secondary clients to update their query views.\n */\nclass SharedOnlineState {\n    constructor(clientId, onlineState) {\n        this.clientId = clientId;\n        this.onlineState = onlineState;\n    }\n    /**\n     * Parses a SharedOnlineState from its JSON representation in WebStorage.\n     * Logs a warning and returns null if the format of the data is not valid.\n     */\n    static fromWebStorageEntry(value) {\n        const onlineState = JSON.parse(value);\n        const validData = typeof onlineState === 'object' &&\n            ['Unknown', 'Online', 'Offline'].indexOf(onlineState.onlineState) !==\n                -1 &&\n            typeof onlineState.clientId === 'string';\n        if (validData) {\n            return new SharedOnlineState(onlineState.clientId, onlineState.onlineState);\n        }\n        else {\n            logError(LOG_TAG$a, `Failed to parse online state: ${value}`);\n            return null;\n        }\n    }\n}\n/**\n * Metadata state of the local client. Unlike `RemoteClientState`, this class is\n * mutable and keeps track of all pending mutations, which allows us to\n * update the range of pending mutation batch IDs as new mutations are added or\n * removed.\n *\n * The data in `LocalClientState` is not read from WebStorage and instead\n * updated via its instance methods. The updated state can be serialized via\n * `toWebStorageJSON()`.\n */\n// Visible for testing.\nclass LocalClientState {\n    constructor() {\n        this.activeTargetIds = targetIdSet();\n    }\n    addQueryTarget(targetId) {\n        this.activeTargetIds = this.activeTargetIds.add(targetId);\n    }\n    removeQueryTarget(targetId) {\n        this.activeTargetIds = this.activeTargetIds.delete(targetId);\n    }\n    /**\n     * Converts this entry into a JSON-encoded format we can use for WebStorage.\n     * Does not encode `clientId` as it is part of the key in WebStorage.\n     */\n    toWebStorageJSON() {\n        const data = {\n            activeTargetIds: this.activeTargetIds.toArray(),\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\n        };\n        return JSON.stringify(data);\n    }\n}\n/**\n * `WebStorageSharedClientState` uses WebStorage (window.localStorage) as the\n * backing store for the SharedClientState. It keeps track of all active\n * clients and supports modifications of the local client's data.\n */\nclass WebStorageSharedClientState {\n    constructor(window, queue, persistenceKey, localClientId, initialUser) {\n        this.window = window;\n        this.queue = queue;\n        this.persistenceKey = persistenceKey;\n        this.localClientId = localClientId;\n        this.syncEngine = null;\n        this.onlineStateHandler = null;\n        this.sequenceNumberHandler = null;\n        this.storageListener = this.handleWebStorageEvent.bind(this);\n        this.activeClients = new SortedMap(primitiveComparator);\n        this.started = false;\n        /**\n         * Captures WebStorage events that occur before `start()` is called. These\n         * events are replayed once `WebStorageSharedClientState` is started.\n         */\n        this.earlyEvents = [];\n        // Escape the special characters mentioned here:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n        const escapedPersistenceKey = persistenceKey.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n        this.storage = this.window.localStorage;\n        this.currentUser = initialUser;\n        this.localClientStorageKey = createWebStorageClientStateKey(this.persistenceKey, this.localClientId);\n        this.sequenceNumberKey = createWebStorageSequenceNumberKey(this.persistenceKey);\n        this.activeClients = this.activeClients.insert(this.localClientId, new LocalClientState());\n        this.clientStateKeyRe = new RegExp(`^${CLIENT_STATE_KEY_PREFIX}_${escapedPersistenceKey}_([^_]*)$`);\n        this.mutationBatchKeyRe = new RegExp(`^${MUTATION_BATCH_KEY_PREFIX}_${escapedPersistenceKey}_(\\\\d+)(?:_(.*))?$`);\n        this.queryTargetKeyRe = new RegExp(`^${QUERY_TARGET_KEY_PREFIX}_${escapedPersistenceKey}_(\\\\d+)$`);\n        this.onlineStateKey = createWebStorageOnlineStateKey(this.persistenceKey);\n        this.bundleLoadedKey = createBundleLoadedKey(this.persistenceKey);\n        // Rather than adding the storage observer during start(), we add the\n        // storage observer during initialization. This ensures that we collect\n        // events before other components populate their initial state (during their\n        // respective start() calls). Otherwise, we might for example miss a\n        // mutation that is added after LocalStore's start() processed the existing\n        // mutations but before we observe WebStorage events.\n        this.window.addEventListener('storage', this.storageListener);\n    }\n    /** Returns 'true' if WebStorage is available in the current environment. */\n    static isAvailable(window) {\n        return !!(window && window.localStorage);\n    }\n    async start() {\n        // Retrieve the list of existing clients to backfill the data in\n        // SharedClientState.\n        const existingClients = await this.syncEngine.getActiveClients();\n        for (const clientId of existingClients) {\n            if (clientId === this.localClientId) {\n                continue;\n            }\n            const storageItem = this.getItem(createWebStorageClientStateKey(this.persistenceKey, clientId));\n            if (storageItem) {\n                const clientState = RemoteClientState.fromWebStorageEntry(clientId, storageItem);\n                if (clientState) {\n                    this.activeClients = this.activeClients.insert(clientState.clientId, clientState);\n                }\n            }\n        }\n        this.persistClientState();\n        // Check if there is an existing online state and call the callback handler\n        // if applicable.\n        const onlineStateJSON = this.storage.getItem(this.onlineStateKey);\n        if (onlineStateJSON) {\n            const onlineState = this.fromWebStorageOnlineState(onlineStateJSON);\n            if (onlineState) {\n                this.handleOnlineStateEvent(onlineState);\n            }\n        }\n        for (const event of this.earlyEvents) {\n            this.handleWebStorageEvent(event);\n        }\n        this.earlyEvents = [];\n        // Register a window unload hook to remove the client metadata entry from\n        // WebStorage even if `shutdown()` was not called.\n        this.window.addEventListener('pagehide', () => this.shutdown());\n        this.started = true;\n    }\n    writeSequenceNumber(sequenceNumber) {\n        this.setItem(this.sequenceNumberKey, JSON.stringify(sequenceNumber));\n    }\n    getAllActiveQueryTargets() {\n        return this.extractActiveQueryTargets(this.activeClients);\n    }\n    isActiveQueryTarget(targetId) {\n        let found = false;\n        this.activeClients.forEach((key, value) => {\n            if (value.activeTargetIds.has(targetId)) {\n                found = true;\n            }\n        });\n        return found;\n    }\n    addPendingMutation(batchId) {\n        this.persistMutationState(batchId, 'pending');\n    }\n    updateMutationState(batchId, state, error) {\n        this.persistMutationState(batchId, state, error);\n        // Once a final mutation result is observed by other clients, they no longer\n        // access the mutation's metadata entry. Since WebStorage replays events\n        // in order, it is safe to delete the entry right after updating it.\n        this.removeMutationState(batchId);\n    }\n    addLocalQueryTarget(targetId, addToActiveTargetIds = true) {\n        let queryState = 'not-current';\n        // Lookup an existing query state if the target ID was already registered\n        // by another tab\n        if (this.isActiveQueryTarget(targetId)) {\n            const storageItem = this.storage.getItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));\n            if (storageItem) {\n                const metadata = QueryTargetMetadata.fromWebStorageEntry(targetId, storageItem);\n                if (metadata) {\n                    queryState = metadata.state;\n                }\n            }\n        }\n        // If the query is listening to cache only, the target ID should not be registered with the\n        // local Firestore client as an active watch target.\n        if (addToActiveTargetIds) {\n            this.localClientState.addQueryTarget(targetId);\n        }\n        this.persistClientState();\n        return queryState;\n    }\n    removeLocalQueryTarget(targetId) {\n        this.localClientState.removeQueryTarget(targetId);\n        this.persistClientState();\n    }\n    isLocalQueryTarget(targetId) {\n        return this.localClientState.activeTargetIds.has(targetId);\n    }\n    clearQueryState(targetId) {\n        this.removeItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));\n    }\n    updateQueryState(targetId, state, error) {\n        this.persistQueryTargetState(targetId, state, error);\n    }\n    handleUserChange(user, removedBatchIds, addedBatchIds) {\n        removedBatchIds.forEach(batchId => {\n            this.removeMutationState(batchId);\n        });\n        this.currentUser = user;\n        addedBatchIds.forEach(batchId => {\n            this.addPendingMutation(batchId);\n        });\n    }\n    setOnlineState(onlineState) {\n        this.persistOnlineState(onlineState);\n    }\n    notifyBundleLoaded(collectionGroups) {\n        this.persistBundleLoadedState(collectionGroups);\n    }\n    shutdown() {\n        if (this.started) {\n            this.window.removeEventListener('storage', this.storageListener);\n            this.removeItem(this.localClientStorageKey);\n            this.started = false;\n        }\n    }\n    getItem(key) {\n        const value = this.storage.getItem(key);\n        logDebug(LOG_TAG$a, 'READ', key, value);\n        return value;\n    }\n    setItem(key, value) {\n        logDebug(LOG_TAG$a, 'SET', key, value);\n        this.storage.setItem(key, value);\n    }\n    removeItem(key) {\n        logDebug(LOG_TAG$a, 'REMOVE', key);\n        this.storage.removeItem(key);\n    }\n    handleWebStorageEvent(event) {\n        // Note: The function is typed to take Event to be interface-compatible with\n        // `Window.addEventListener`.\n        const storageEvent = event;\n        if (storageEvent.storageArea === this.storage) {\n            logDebug(LOG_TAG$a, 'EVENT', storageEvent.key, storageEvent.newValue);\n            if (storageEvent.key === this.localClientStorageKey) {\n                logError('Received WebStorage notification for local change. Another client might have ' +\n                    'garbage-collected our state');\n                return;\n            }\n            this.queue.enqueueRetryable(async () => {\n                if (!this.started) {\n                    this.earlyEvents.push(storageEvent);\n                    return;\n                }\n                if (storageEvent.key === null) {\n                    return;\n                }\n                if (this.clientStateKeyRe.test(storageEvent.key)) {\n                    if (storageEvent.newValue != null) {\n                        const clientState = this.fromWebStorageClientState(storageEvent.key, storageEvent.newValue);\n                        if (clientState) {\n                            return this.handleClientStateEvent(clientState.clientId, clientState);\n                        }\n                    }\n                    else {\n                        const clientId = this.fromWebStorageClientStateKey(storageEvent.key);\n                        return this.handleClientStateEvent(clientId, null);\n                    }\n                }\n                else if (this.mutationBatchKeyRe.test(storageEvent.key)) {\n                    if (storageEvent.newValue !== null) {\n                        const mutationMetadata = this.fromWebStorageMutationMetadata(storageEvent.key, storageEvent.newValue);\n                        if (mutationMetadata) {\n                            return this.handleMutationBatchEvent(mutationMetadata);\n                        }\n                    }\n                }\n                else if (this.queryTargetKeyRe.test(storageEvent.key)) {\n                    if (storageEvent.newValue !== null) {\n                        const queryTargetMetadata = this.fromWebStorageQueryTargetMetadata(storageEvent.key, storageEvent.newValue);\n                        if (queryTargetMetadata) {\n                            return this.handleQueryTargetEvent(queryTargetMetadata);\n                        }\n                    }\n                }\n                else if (storageEvent.key === this.onlineStateKey) {\n                    if (storageEvent.newValue !== null) {\n                        const onlineState = this.fromWebStorageOnlineState(storageEvent.newValue);\n                        if (onlineState) {\n                            return this.handleOnlineStateEvent(onlineState);\n                        }\n                    }\n                }\n                else if (storageEvent.key === this.sequenceNumberKey) {\n                    const sequenceNumber = fromWebStorageSequenceNumber(storageEvent.newValue);\n                    if (sequenceNumber !== ListenSequence.INVALID) {\n                        this.sequenceNumberHandler(sequenceNumber);\n                    }\n                }\n                else if (storageEvent.key === this.bundleLoadedKey) {\n                    const collectionGroups = this.fromWebStoreBundleLoadedState(storageEvent.newValue);\n                    await Promise.all(collectionGroups.map(cg => this.syncEngine.synchronizeWithChangedDocuments(cg)));\n                }\n            });\n        }\n    }\n    get localClientState() {\n        return this.activeClients.get(this.localClientId);\n    }\n    persistClientState() {\n        this.setItem(this.localClientStorageKey, this.localClientState.toWebStorageJSON());\n    }\n    persistMutationState(batchId, state, error) {\n        const mutationState = new MutationMetadata(this.currentUser, batchId, state, error);\n        const mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);\n        this.setItem(mutationKey, mutationState.toWebStorageJSON());\n    }\n    removeMutationState(batchId) {\n        const mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);\n        this.removeItem(mutationKey);\n    }\n    persistOnlineState(onlineState) {\n        const entry = {\n            clientId: this.localClientId,\n            onlineState\n        };\n        this.storage.setItem(this.onlineStateKey, JSON.stringify(entry));\n    }\n    persistQueryTargetState(targetId, state, error) {\n        const targetKey = createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId);\n        const targetMetadata = new QueryTargetMetadata(targetId, state, error);\n        this.setItem(targetKey, targetMetadata.toWebStorageJSON());\n    }\n    persistBundleLoadedState(collectionGroups) {\n        const json = JSON.stringify(Array.from(collectionGroups));\n        this.setItem(this.bundleLoadedKey, json);\n    }\n    /**\n     * Parses a client state key in WebStorage. Returns null if the key does not\n     * match the expected key format.\n     */\n    fromWebStorageClientStateKey(key) {\n        const match = this.clientStateKeyRe.exec(key);\n        return match ? match[1] : null;\n    }\n    /**\n     * Parses a client state in WebStorage. Returns 'null' if the value could not\n     * be parsed.\n     */\n    fromWebStorageClientState(key, value) {\n        const clientId = this.fromWebStorageClientStateKey(key);\n        return RemoteClientState.fromWebStorageEntry(clientId, value);\n    }\n    /**\n     * Parses a mutation batch state in WebStorage. Returns 'null' if the value\n     * could not be parsed.\n     */\n    fromWebStorageMutationMetadata(key, value) {\n        const match = this.mutationBatchKeyRe.exec(key);\n        const batchId = Number(match[1]);\n        const userId = match[2] !== undefined ? match[2] : null;\n        return MutationMetadata.fromWebStorageEntry(new User(userId), batchId, value);\n    }\n    /**\n     * Parses a query target state from WebStorage. Returns 'null' if the value\n     * could not be parsed.\n     */\n    fromWebStorageQueryTargetMetadata(key, value) {\n        const match = this.queryTargetKeyRe.exec(key);\n        const targetId = Number(match[1]);\n        return QueryTargetMetadata.fromWebStorageEntry(targetId, value);\n    }\n    /**\n     * Parses an online state from WebStorage. Returns 'null' if the value\n     * could not be parsed.\n     */\n    fromWebStorageOnlineState(value) {\n        return SharedOnlineState.fromWebStorageEntry(value);\n    }\n    fromWebStoreBundleLoadedState(value) {\n        return JSON.parse(value);\n    }\n    async handleMutationBatchEvent(mutationBatch) {\n        if (mutationBatch.user.uid !== this.currentUser.uid) {\n            logDebug(LOG_TAG$a, `Ignoring mutation for non-active user ${mutationBatch.user.uid}`);\n            return;\n        }\n        return this.syncEngine.applyBatchState(mutationBatch.batchId, mutationBatch.state, mutationBatch.error);\n    }\n    handleQueryTargetEvent(targetMetadata) {\n        return this.syncEngine.applyTargetState(targetMetadata.targetId, targetMetadata.state, targetMetadata.error);\n    }\n    handleClientStateEvent(clientId, clientState) {\n        const updatedClients = clientState\n            ? this.activeClients.insert(clientId, clientState)\n            : this.activeClients.remove(clientId);\n        const existingTargets = this.extractActiveQueryTargets(this.activeClients);\n        const newTargets = this.extractActiveQueryTargets(updatedClients);\n        const addedTargets = [];\n        const removedTargets = [];\n        newTargets.forEach(targetId => {\n            if (!existingTargets.has(targetId)) {\n                addedTargets.push(targetId);\n            }\n        });\n        existingTargets.forEach(targetId => {\n            if (!newTargets.has(targetId)) {\n                removedTargets.push(targetId);\n            }\n        });\n        return this.syncEngine.applyActiveTargetsChange(addedTargets, removedTargets).then(() => {\n            this.activeClients = updatedClients;\n        });\n    }\n    handleOnlineStateEvent(onlineState) {\n        // We check whether the client that wrote this online state is still active\n        // by comparing its client ID to the list of clients kept active in\n        // IndexedDb. If a client does not update their IndexedDb client state\n        // within 5 seconds, it is considered inactive and we don't emit an online\n        // state event.\n        if (this.activeClients.get(onlineState.clientId)) {\n            this.onlineStateHandler(onlineState.onlineState);\n        }\n    }\n    extractActiveQueryTargets(clients) {\n        let activeTargets = targetIdSet();\n        clients.forEach((kev, value) => {\n            activeTargets = activeTargets.unionWith(value.activeTargetIds);\n        });\n        return activeTargets;\n    }\n}\nfunction fromWebStorageSequenceNumber(seqString) {\n    let sequenceNumber = ListenSequence.INVALID;\n    if (seqString != null) {\n        try {\n            const parsed = JSON.parse(seqString);\n            hardAssert(typeof parsed === 'number');\n            sequenceNumber = parsed;\n        }\n        catch (e) {\n            logError(LOG_TAG$a, 'Failed to read sequence number from WebStorage', e);\n        }\n    }\n    return sequenceNumber;\n}\n/**\n * `MemorySharedClientState` is a simple implementation of SharedClientState for\n * clients using memory persistence. The state in this class remains fully\n * isolated and no synchronization is performed.\n */\nclass MemorySharedClientState {\n    constructor() {\n        this.localState = new LocalClientState();\n        this.queryState = {};\n        this.onlineStateHandler = null;\n        this.sequenceNumberHandler = null;\n    }\n    addPendingMutation(batchId) {\n        // No op.\n    }\n    updateMutationState(batchId, state, error) {\n        // No op.\n    }\n    addLocalQueryTarget(targetId, addToActiveTargetIds = true) {\n        if (addToActiveTargetIds) {\n            this.localState.addQueryTarget(targetId);\n        }\n        return this.queryState[targetId] || 'not-current';\n    }\n    updateQueryState(targetId, state, error) {\n        this.queryState[targetId] = state;\n    }\n    removeLocalQueryTarget(targetId) {\n        this.localState.removeQueryTarget(targetId);\n    }\n    isLocalQueryTarget(targetId) {\n        return this.localState.activeTargetIds.has(targetId);\n    }\n    clearQueryState(targetId) {\n        delete this.queryState[targetId];\n    }\n    getAllActiveQueryTargets() {\n        return this.localState.activeTargetIds;\n    }\n    isActiveQueryTarget(targetId) {\n        return this.localState.activeTargetIds.has(targetId);\n    }\n    start() {\n        this.localState = new LocalClientState();\n        return Promise.resolve();\n    }\n    handleUserChange(user, removedBatchIds, addedBatchIds) {\n        // No op.\n    }\n    setOnlineState(onlineState) {\n        // No op.\n    }\n    shutdown() { }\n    writeSequenceNumber(sequenceNumber) { }\n    notifyBundleLoaded(collectionGroups) {\n        // No op.\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass NoopConnectivityMonitor {\n    addCallback(callback) {\n        // No-op.\n    }\n    shutdown() {\n        // No-op.\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides a simple helper class that implements the Stream interface to\n * bridge to other implementations that are streams but do not implement the\n * interface. The stream callbacks are invoked with the callOn... methods.\n */\nclass StreamBridge {\n    constructor(args) {\n        this.sendFn = args.sendFn;\n        this.closeFn = args.closeFn;\n    }\n    onConnected(callback) {\n        this.wrappedOnConnected = callback;\n    }\n    onOpen(callback) {\n        this.wrappedOnOpen = callback;\n    }\n    onClose(callback) {\n        this.wrappedOnClose = callback;\n    }\n    onMessage(callback) {\n        this.wrappedOnMessage = callback;\n    }\n    close() {\n        this.closeFn();\n    }\n    send(msg) {\n        this.sendFn(msg);\n    }\n    callOnConnected() {\n        this.wrappedOnConnected();\n    }\n    callOnOpen() {\n        this.wrappedOnOpen();\n    }\n    callOnClose(err) {\n        this.wrappedOnClose(err);\n    }\n    callOnMessage(msg) {\n        this.wrappedOnMessage(msg);\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The value returned from the most recent invocation of\n * `generateUniqueDebugId()`, or null if it has never been invoked.\n */\nlet lastUniqueDebugId = null;\n/**\n * Generates and returns an initial value for `lastUniqueDebugId`.\n *\n * The returned value is randomly selected from a range of integers that are\n * represented as 8 hexadecimal digits. This means that (within reason) any\n * numbers generated by incrementing the returned number by 1 will also be\n * represented by 8 hexadecimal digits. This leads to all \"IDs\" having the same\n * length when converted to a hexadecimal string, making reading logs containing\n * these IDs easier to follow. And since the return value is randomly selected\n * it will help to differentiate between logs from different executions.\n */\nfunction generateInitialUniqueDebugId() {\n    const minResult = 0x10000000;\n    const maxResult = 0x90000000;\n    const resultRange = maxResult - minResult;\n    const resultOffset = Math.round(resultRange * Math.random());\n    return minResult + resultOffset;\n}\n/**\n * Generates and returns a unique ID as a hexadecimal string.\n *\n * The returned ID is intended to be used in debug logging messages to help\n * correlate log messages that may be spatially separated in the logs, but\n * logically related. For example, a network connection could include the same\n * \"debug ID\" string in all of its log messages to help trace a specific\n * connection over time.\n *\n * @return the 10-character generated ID (e.g. \"0xa1b2c3d4\").\n */\nfunction generateUniqueDebugId() {\n    if (lastUniqueDebugId === null) {\n        lastUniqueDebugId = generateInitialUniqueDebugId();\n    }\n    else {\n        lastUniqueDebugId++;\n    }\n    return '0x' + lastUniqueDebugId.toString(16);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Utilities for dealing with node.js-style APIs. See nodePromise for more\n * details.\n */\n/**\n * Creates a node-style callback that resolves or rejects a new Promise. The\n * callback is passed to the given action which can then use the callback as\n * a parameter to a node-style function.\n *\n * The intent is to directly bridge a node-style function (which takes a\n * callback) into a Promise without manually converting between the node-style\n * callback and the promise at each call.\n *\n * In effect it allows you to convert:\n *\n * @example\n * new Promise((resolve: (value?: fs.Stats) => void,\n *              reject: (error?: any) => void) => {\n *   fs.stat(path, (error?: any, stat?: fs.Stats) => {\n *     if (error) {\n *       reject(error);\n *     } else {\n *       resolve(stat);\n *     }\n *   });\n * });\n *\n * Into\n * @example\n * nodePromise((callback: NodeCallback<fs.Stats>) => {\n *   fs.stat(path, callback);\n * });\n *\n * @param action - a function that takes a node-style callback as an argument\n *     and then uses that callback to invoke some node-style API.\n * @returns a new Promise which will be rejected if the callback is given the\n *     first Error parameter or will resolve to the value given otherwise.\n */\nfunction nodePromise(action) {\n    return new Promise((resolve, reject) => {\n        action((error, value) => {\n            if (error) {\n                reject(error);\n            }\n            else {\n                resolve(value);\n            }\n        });\n    });\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// TODO: Fetch runtime version from grpc-js/package.json instead\n// when there's a cleaner way to dynamic require JSON in both Node ESM and CJS\nconst grpcVersion = '1.9.15';\nconst LOG_TAG$9 = 'GrpcConnection';\nconst X_GOOG_API_CLIENT_VALUE = `gl-node/${process.versions.node} fire/${SDK_VERSION} grpc/${grpcVersion}`;\nfunction createMetadata(databasePath, authToken, appCheckToken, appId) {\n    hardAssert(authToken === null || authToken.type === 'OAuth');\n    const metadata = new _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.Metadata();\n    if (authToken) {\n        authToken.headers.forEach((value, key) => metadata.set(key, value));\n    }\n    if (appCheckToken) {\n        appCheckToken.headers.forEach((value, key) => metadata.set(key, value));\n    }\n    if (appId) {\n        metadata.set('X-Firebase-GMPID', appId);\n    }\n    metadata.set('X-Goog-Api-Client', X_GOOG_API_CLIENT_VALUE);\n    // These headers are used to improve routing and project isolation by the\n    // backend.\n    // TODO(b/199767712): We are keeping 'Google-Cloud-Resource-Prefix' until Emulators can be\n    // released with cl/428820046. Currently blocked because Emulators are now built with Java\n    // 11 from Google3.\n    metadata.set('Google-Cloud-Resource-Prefix', databasePath);\n    metadata.set('x-goog-request-params', databasePath);\n    return metadata;\n}\n/**\n * A Connection implemented by GRPC-Node.\n */\nclass GrpcConnection {\n    get shouldResourcePathBeIncludedInRequest() {\n        // Both `invokeRPC()` and `invokeStreamingRPC()` ignore their `path` arguments, and expect\n        // the \"path\" to be part of the given `request`.\n        return true;\n    }\n    constructor(protos, databaseInfo) {\n        this.databaseInfo = databaseInfo;\n        // We cache stubs for the most-recently-used token.\n        this.cachedStub = null;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.firestore = protos['google']['firestore']['v1'];\n        this.databasePath = `projects/${databaseInfo.databaseId.projectId}/databases/${databaseInfo.databaseId.database}`;\n    }\n    ensureActiveStub() {\n        if (!this.cachedStub) {\n            logDebug(LOG_TAG$9, 'Creating Firestore stub.');\n            const credentials = this.databaseInfo.ssl\n                ? _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.credentials.createSsl()\n                : _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.credentials.createInsecure();\n            this.cachedStub = new this.firestore.Firestore(this.databaseInfo.host, credentials);\n        }\n        return this.cachedStub;\n    }\n    invokeRPC(rpcName, path, request, authToken, appCheckToken) {\n        const streamId = generateUniqueDebugId();\n        const stub = this.ensureActiveStub();\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\n        const jsonRequest = Object.assign({ database: this.databasePath }, request);\n        return nodePromise((callback) => {\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} invoked with request:`, request);\n            return stub[rpcName](jsonRequest, metadata, (grpcError, value) => {\n                if (grpcError) {\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} failed with error:`, grpcError);\n                    callback(new FirestoreError(mapCodeFromRpcCode(grpcError.code), grpcError.message));\n                }\n                else {\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} completed with response:`, value);\n                    callback(undefined, value);\n                }\n            });\n        });\n    }\n    invokeStreamingRPC(rpcName, path, request, authToken, appCheckToken, expectedResponseCount) {\n        const streamId = generateUniqueDebugId();\n        const results = [];\n        const responseDeferred = new Deferred();\n        logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} invoked (streaming) with request:`, request);\n        const stub = this.ensureActiveStub();\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\n        const jsonRequest = Object.assign(Object.assign({}, request), { database: this.databasePath });\n        const stream = stub[rpcName](jsonRequest, metadata);\n        let callbackFired = false;\n        stream.on('data', (response) => {\n            logDebug(LOG_TAG$9, `RPC ${rpcName} ${streamId} received result:`, response);\n            results.push(response);\n            if (expectedResponseCount !== undefined &&\n                results.length === expectedResponseCount) {\n                callbackFired = true;\n                responseDeferred.resolve(results);\n            }\n        });\n        stream.on('end', () => {\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} completed.`);\n            if (!callbackFired) {\n                callbackFired = true;\n                responseDeferred.resolve(results);\n            }\n        });\n        stream.on('error', (grpcError) => {\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' ${streamId} failed with error:`, grpcError);\n            const code = mapCodeFromRpcCode(grpcError.code);\n            responseDeferred.reject(new FirestoreError(code, grpcError.message));\n        });\n        return responseDeferred.promise;\n    }\n    // TODO(mikelehen): This \"method\" is a monster. Should be refactored.\n    openStream(rpcName, authToken, appCheckToken) {\n        const streamId = generateUniqueDebugId();\n        const stub = this.ensureActiveStub();\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\n        const grpcStream = stub[rpcName](metadata);\n        let closed = false;\n        const close = (err) => {\n            if (!closed) {\n                closed = true;\n                stream.callOnClose(err);\n                grpcStream.end();\n            }\n        };\n        const stream = new StreamBridge({\n            sendFn: (msg) => {\n                if (!closed) {\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} sending:`, msg);\n                    try {\n                        grpcStream.write(msg);\n                    }\n                    catch (e) {\n                        // This probably means we didn't conform to the proto.  Make sure to\n                        // log the message we sent.\n                        logError('Failure sending:', msg);\n                        logError('Error:', e);\n                        throw e;\n                    }\n                }\n                else {\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} ` +\n                        'not sending because gRPC stream is closed:', msg);\n                }\n            },\n            closeFn: () => {\n                logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} closed locally via close().`);\n                close();\n            }\n        });\n        let onConnectedSent = false;\n        grpcStream.on('data', (msg) => {\n            if (!closed) {\n                logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} received:`, msg);\n                // Emulate the \"onConnected\" event that WebChannelConnection sends.\n                if (!onConnectedSent) {\n                    stream.callOnConnected();\n                    onConnectedSent = true;\n                }\n                stream.callOnMessage(msg);\n            }\n        });\n        grpcStream.on('end', () => {\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} ended.`);\n            close();\n        });\n        grpcStream.on('error', (grpcError) => {\n            if (!closed) {\n                logWarn(LOG_TAG$9, `RPC '${rpcName}' stream ${streamId} error. Code:`, grpcError.code, 'Message:', grpcError.message);\n                const code = mapCodeFromRpcCode(grpcError.code);\n                close(new FirestoreError(code, grpcError.message));\n            }\n        });\n        logDebug(LOG_TAG$9, `Opening RPC '${rpcName}' stream ${streamId} ` +\n            `to ${this.databaseInfo.host}`);\n        // TODO(dimond): Since grpc has no explicit open status (or does it?) we\n        // simulate an onOpen in the next loop after the stream had it's listeners\n        // registered\n        setTimeout(() => {\n            stream.callOnOpen();\n        }, 0);\n        return stream;\n    }\n    /**\n     * Closes and cleans up any resources associated with the GrpcConnection.\n     * If a gRPC client has been generated for this connection, the gRPC client\n     * is closed. Failure to call terminate on a GrpcConnection can result\n     * in leaked resources of the gRPC client.\n     */\n    terminate() {\n        if (this.cachedStub) {\n            this.cachedStub.close();\n            this.cachedStub = undefined;\n        }\n    }\n}\n\nconst nested = {\n\tgoogle: {\n\t\tnested: {\n\t\t\tprotobuf: {\n\t\t\t\toptions: {\n\t\t\t\t\tcsharp_namespace: \"Google.Protobuf.WellKnownTypes\",\n\t\t\t\t\tgo_package: \"github.com/golang/protobuf/ptypes/wrappers\",\n\t\t\t\t\tjava_package: \"com.google.protobuf\",\n\t\t\t\t\tjava_outer_classname: \"WrappersProto\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tobjc_class_prefix: \"GPB\",\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\toptimize_for: \"SPEED\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tTimestamp: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tseconds: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnanos: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileDescriptorSet: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tfile: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FileDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"package\": {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpublicDependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 10,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tpacked: false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tweakDependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 11,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tpacked: false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessageType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"DescriptorProto\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tenumType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tservice: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ServiceDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textension: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"FileOptions\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsourceCodeInfo: {\n\t\t\t\t\t\t\t\ttype: \"SourceCodeInfo\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsyntax: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textension: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnestedType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"DescriptorProto\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tenumType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textensionRange: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ExtensionRange\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toneofDecl: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"OneofDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"MessageOptions\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\treservedRange: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ReservedRange\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\treservedName: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tExtensionRange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tReservedRange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFieldDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumber: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlabel: {\n\t\t\t\t\t\t\t\ttype: \"Label\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttype: {\n\t\t\t\t\t\t\t\ttype: \"Type\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttypeName: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textendee: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdefaultValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toneofIndex: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjsonName: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"FieldOptions\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tTYPE_DOUBLE: 1,\n\t\t\t\t\t\t\t\t\tTYPE_FLOAT: 2,\n\t\t\t\t\t\t\t\t\tTYPE_INT64: 3,\n\t\t\t\t\t\t\t\t\tTYPE_UINT64: 4,\n\t\t\t\t\t\t\t\t\tTYPE_INT32: 5,\n\t\t\t\t\t\t\t\t\tTYPE_FIXED64: 6,\n\t\t\t\t\t\t\t\t\tTYPE_FIXED32: 7,\n\t\t\t\t\t\t\t\t\tTYPE_BOOL: 8,\n\t\t\t\t\t\t\t\t\tTYPE_STRING: 9,\n\t\t\t\t\t\t\t\t\tTYPE_GROUP: 10,\n\t\t\t\t\t\t\t\t\tTYPE_MESSAGE: 11,\n\t\t\t\t\t\t\t\t\tTYPE_BYTES: 12,\n\t\t\t\t\t\t\t\t\tTYPE_UINT32: 13,\n\t\t\t\t\t\t\t\t\tTYPE_ENUM: 14,\n\t\t\t\t\t\t\t\t\tTYPE_SFIXED32: 15,\n\t\t\t\t\t\t\t\t\tTYPE_SFIXED64: 16,\n\t\t\t\t\t\t\t\t\tTYPE_SINT32: 17,\n\t\t\t\t\t\t\t\t\tTYPE_SINT64: 18\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tLabel: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tLABEL_OPTIONAL: 1,\n\t\t\t\t\t\t\t\t\tLABEL_REQUIRED: 2,\n\t\t\t\t\t\t\t\t\tLABEL_REPEATED: 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tOneofDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"OneofOptions\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEnumDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumValueDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"EnumOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEnumValueDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumber: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"EnumValueOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tServiceDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmethod: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"MethodDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"ServiceOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tMethodDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tinputType: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toutputType: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"MethodOptions\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tclientStreaming: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tserverStreaming: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tjavaPackage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaOuterClassname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaMultipleFiles: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaGenerateEqualsAndHash: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 20,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tdeprecated: true\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaStringCheckUtf8: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 27\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptimizeFor: {\n\t\t\t\t\t\t\t\ttype: \"OptimizeMode\",\n\t\t\t\t\t\t\t\tid: 9,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"SPEED\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgoPackage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tccGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 16\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 17\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpyGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 18\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 23\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tccEnableArenas: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 31\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tobjcClassPrefix: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 36\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcsharpNamespace: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 37\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t38,\n\t\t\t\t\t\t\t\t38\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tOptimizeMode: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tSPEED: 1,\n\t\t\t\t\t\t\t\t\tCODE_SIZE: 2,\n\t\t\t\t\t\t\t\t\tLITE_RUNTIME: 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tMessageOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tmessageSetWireFormat: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnoStandardDescriptorAccessor: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmapEntry: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t8,\n\t\t\t\t\t\t\t\t8\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tFieldOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tctype: {\n\t\t\t\t\t\t\t\ttype: \"CType\",\n\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"STRING\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpacked: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjstype: {\n\t\t\t\t\t\t\t\ttype: \"JSType\",\n\t\t\t\t\t\t\t\tid: 6,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"JS_NORMAL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlazy: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tweak: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t4,\n\t\t\t\t\t\t\t\t4\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tCType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tSTRING: 0,\n\t\t\t\t\t\t\t\t\tCORD: 1,\n\t\t\t\t\t\t\t\t\tSTRING_PIECE: 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tJSType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tJS_NORMAL: 0,\n\t\t\t\t\t\t\t\t\tJS_STRING: 1,\n\t\t\t\t\t\t\t\t\tJS_NUMBER: 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tOneofOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tEnumOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tallowAlias: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tEnumValueOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tServiceOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 33\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tMethodOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 33\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tUninterpretedOption: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"NamePart\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tidentifierValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpositiveIntValue: {\n\t\t\t\t\t\t\t\ttype: \"uint64\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnegativeIntValue: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdoubleValue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\taggregateValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tNamePart: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tnamePart: {\n\t\t\t\t\t\t\t\t\t\trule: \"required\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tisExtension: {\n\t\t\t\t\t\t\t\t\t\trule: \"required\",\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tSourceCodeInfo: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tlocation: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Location\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tLocation: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tspan: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tleadingComments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttrailingComments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tleadingDetachedComments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tGeneratedCodeInfo: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tannotation: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Annotation\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tAnnotation: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tsourceFile: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbegin: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tStruct: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tValue: {\n\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\tkind: {\n\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\"nullValue\",\n\t\t\t\t\t\t\t\t\t\"numberValue\",\n\t\t\t\t\t\t\t\t\t\"stringValue\",\n\t\t\t\t\t\t\t\t\t\"boolValue\",\n\t\t\t\t\t\t\t\t\t\"structValue\",\n\t\t\t\t\t\t\t\t\t\"listValue\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tnullValue: {\n\t\t\t\t\t\t\t\ttype: \"NullValue\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumberValue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tboolValue: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstructValue: {\n\t\t\t\t\t\t\t\ttype: \"Struct\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlistValue: {\n\t\t\t\t\t\t\t\ttype: \"ListValue\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tNullValue: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tNULL_VALUE: 0\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tListValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEmpty: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tDoubleValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFloatValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"float\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tInt64Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tUInt64Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"uint64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tInt32Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tUInt32Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"uint32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tBoolValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tStringValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tBytesValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tAny: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\ttypeUrl: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tfirestore: {\n\t\t\t\tnested: {\n\t\t\t\t\tv1: {\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tcsharp_namespace: \"Google.Cloud.Firestore.V1\",\n\t\t\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/firestore/v1;firestore\",\n\t\t\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\t\t\tjava_outer_classname: \"WriteProto\",\n\t\t\t\t\t\t\tjava_package: \"com.google.firestore.v1\",\n\t\t\t\t\t\t\tobjc_class_prefix: \"GCFS\",\n\t\t\t\t\t\t\tphp_namespace: \"Google\\\\Cloud\\\\Firestore\\\\V1\",\n\t\t\t\t\t\t\truby_package: \"Google::Cloud::Firestore::V1\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tAggregationResult: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\taggregateFields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBitSequence: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tbitmap: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpadding: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBloomFilter: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tbits: {\n\t\t\t\t\t\t\t\t\t\ttype: \"BitSequence\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\thashCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentMask: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfieldPaths: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPrecondition: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconditionType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"exists\",\n\t\t\t\t\t\t\t\t\t\t\t\"updateTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\texists: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTransactionOptions: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tmode: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"readOnly\",\n\t\t\t\t\t\t\t\t\t\t\t\"readWrite\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\treadOnly: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ReadOnly\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadWrite: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ReadWrite\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tReadWrite: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tretryTransaction: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tReadOnly: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocument: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcreateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tValue: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tvalueType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"nullValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"booleanValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"integerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"doubleValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"timestampValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"stringValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"bytesValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"referenceValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"geoPointValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"arrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"mapValue\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tnullValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.NullValue\",\n\t\t\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbooleanValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tintegerValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdoubleValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttimestampValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 17\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbytesValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 18\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treferenceValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tgeoPointValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.type.LatLng\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tarrayValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmapValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"MapValue\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tArrayValue: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMapValue: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tFirestore: {\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"(google.api.default_host)\": \"firestore.googleapis.com\",\n\t\t\t\t\t\t\t\t\t\"(google.api.oauth_scopes)\": \"https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/datastore\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tmethods: {\n\t\t\t\t\t\t\t\t\tGetDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"GetDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).get\": \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tget: \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListDocuments: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListDocumentsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListDocumentsResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).get\": \"/v1/{parent=projects/*/databases/*/documents/*/**}/{collection_id}\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tget: \"/v1/{parent=projects/*/databases/*/documents/*/**}/{collection_id}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tUpdateDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"UpdateDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).patch\": \"/v1/{document.name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"document\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"document,update_mask\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpatch: \"/v1/{document.name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"document\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"document,update_mask\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tDeleteDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"DeleteDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"google.protobuf.Empty\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).delete\": \"/v1/{name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"name\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"delete\": \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"name\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBatchGetDocuments: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BatchGetDocumentsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BatchGetDocumentsResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:batchGet\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:batchGet\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBeginTransaction: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BeginTransactionRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BeginTransactionResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:beginTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:beginTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCommit: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"CommitRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"CommitResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:commit\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,writes\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:commit\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,writes\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRollback: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RollbackRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"google.protobuf.Empty\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:rollback\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,transaction\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:rollback\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,transaction\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRunQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RunQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"RunQueryResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRunAggregationQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RunAggregationQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"RunAggregationQueryResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:runAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tPartitionQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"PartitionQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"PartitionQueryResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tWrite: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"WriteRequest\",\n\t\t\t\t\t\t\t\t\t\trequestStream: true,\n\t\t\t\t\t\t\t\t\t\tresponseType: \"WriteResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:write\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:write\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListen: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListenRequest\",\n\t\t\t\t\t\t\t\t\t\trequestStream: true,\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListenResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:listen\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:listen\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListCollectionIds: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListCollectionIdsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListCollectionIdsResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"parent\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"parent\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBatchWrite: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BatchWriteRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BatchWriteResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:batchWrite\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:batchWrite\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCreateDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"CreateDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents/**}/{collection_id}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"document\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/**}/{collection_id}\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"document\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tGetDocumentRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListDocumentsRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tshowMissing: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListDocumentsResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCreateDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 4,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tUpdateDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateMask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDeleteDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchGetDocumentsRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchGetDocumentsResponse: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tresult: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"found\",\n\t\t\t\t\t\t\t\t\t\t\t\"missing\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfound: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmissing: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBeginTransactionRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBeginTransactionResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCommitRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCommitResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcommitTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRollbackRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tskippedResults: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunAggregationQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredAggregationQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredAggregationQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredAggregationQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunAggregationQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tresult: {\n\t\t\t\t\t\t\t\t\t\ttype: \"AggregationResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPartitionQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpartitionCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPartitionQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpartitions: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstreamId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcommitTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListenRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\ttargetChange: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"addTarget\",\n\t\t\t\t\t\t\t\t\t\t\t\"removeTarget\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\taddTarget: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Target\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremoveTarget: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListenResponse: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tresponseType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"targetChange\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentChange\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentDelete\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentRemove\",\n\t\t\t\t\t\t\t\t\t\t\t\"filter\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetChange: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TargetChange\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentChange: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentChange\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentDelete: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentDelete\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentRemove: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentRemove\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfilter: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ExistenceFilter\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTarget: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\ttargetType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"query\",\n\t\t\t\t\t\t\t\t\t\t\t\"documents\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"resumeToken\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tquery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"QueryTarget\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentsTarget\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tonce: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\texpectedCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int32Value\",\n\t\t\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tDocumentsTarget: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tQueryTarget: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTargetChange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetChangeType: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TargetChangeType\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcause: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.rpc.Status\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tTargetChangeType: {\n\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\tNO_CHANGE: 0,\n\t\t\t\t\t\t\t\t\t\t\tADD: 1,\n\t\t\t\t\t\t\t\t\t\t\tREMOVE: 2,\n\t\t\t\t\t\t\t\t\t\t\tCURRENT: 3,\n\t\t\t\t\t\t\t\t\t\t\tRESET: 4\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListCollectionIdsRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListCollectionIdsResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tcollectionIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchWriteRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchWriteResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"google.rpc.Status\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStructuredQuery: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tselect: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Projection\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfrom: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"CollectionSelector\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twhere: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Filter\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Order\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstartAt: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tendAt: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toffset: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlimit: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int32Value\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tCollectionSelector: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tallDescendants: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFilter: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tfilterType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"compositeFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"fieldFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"unaryFilter\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcompositeFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"CompositeFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfieldFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tunaryFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"UnaryFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCompositeFilter: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfilters: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Filter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tAND: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tOR: 2\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFieldFilter: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tLESS_THAN: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tLESS_THAN_OR_EQUAL: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\tGREATER_THAN: 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\tGREATER_THAN_OR_EQUAL: 4,\n\t\t\t\t\t\t\t\t\t\t\t\t\tEQUAL: 5,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNOT_EQUAL: 6,\n\t\t\t\t\t\t\t\t\t\t\t\t\tARRAY_CONTAINS: 7,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIN: 8,\n\t\t\t\t\t\t\t\t\t\t\t\t\tARRAY_CONTAINS_ANY: 9,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNOT_IN: 10\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tUnaryFilter: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\toperandType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"field\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NAN: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NULL: 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NOT_NAN: 4,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NOT_NULL: 5\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tOrder: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tdirection: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Direction\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFieldReference: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfieldPath: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tProjection: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tDirection: {\n\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\tDIRECTION_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\tASCENDING: 1,\n\t\t\t\t\t\t\t\t\t\t\tDESCENDING: 2\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStructuredAggregationQuery: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\taggregations: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Aggregation\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tAggregation: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\toperator: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"count\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"sum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"avg\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcount: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Count\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tsum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Sum\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tavg: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Avg\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\talias: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tCount: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tupTo: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int64Value\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tSum: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tAvg: {\n\t\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCursor: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbefore: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWrite: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\toperation: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"update\",\n\t\t\t\t\t\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\t\t\t\t\t\"verify\",\n\t\t\t\t\t\t\t\t\t\t\t\"transform\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tupdate: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"delete\": {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tverify: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransform: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateMask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTransforms: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentTransform.FieldTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentTransform: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfieldTransforms: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"FieldTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tFieldTransform: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\ttransformType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"setToServerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"increment\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"maximum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"minimum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"appendMissingElements\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"removeAllFromArray\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfieldPath: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tsetToServerValue: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ServerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tincrement: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tmaximum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tminimum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tappendMissingElements: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tremoveAllFromArray: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tServerValue: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tSERVER_VALUE_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tREQUEST_TIME: 1\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteResult: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransformResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentChange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentDelete: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentRemove: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tExistenceFilter: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tunchangedNames: {\n\t\t\t\t\t\t\t\t\t\ttype: \"BloomFilter\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tapi: {\n\t\t\t\toptions: {\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/api/annotations;annotations\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"HttpProto\",\n\t\t\t\t\tjava_package: \"com.google.api\",\n\t\t\t\t\tobjc_class_prefix: \"GAPI\",\n\t\t\t\t\tcc_enable_arenas: true\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\thttp: {\n\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\tid: 72295728,\n\t\t\t\t\t\textend: \"google.protobuf.MethodOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tHttp: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\trules: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tHttpRule: {\n\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\tpattern: {\n\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\"get\",\n\t\t\t\t\t\t\t\t\t\"put\",\n\t\t\t\t\t\t\t\t\t\"post\",\n\t\t\t\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\t\t\t\"patch\",\n\t\t\t\t\t\t\t\t\t\"custom\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tget: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tput: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpost: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"delete\": {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpatch: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcustom: {\n\t\t\t\t\t\t\t\ttype: \"CustomHttpPattern\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tselector: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tadditionalBindings: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tCustomHttpPattern: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tkind: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmethodSignature: {\n\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1051,\n\t\t\t\t\t\textend: \"google.protobuf.MethodOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tdefaultHost: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1049,\n\t\t\t\t\t\textend: \"google.protobuf.ServiceOptions\"\n\t\t\t\t\t},\n\t\t\t\t\toauthScopes: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1050,\n\t\t\t\t\t\textend: \"google.protobuf.ServiceOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tfieldBehavior: {\n\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\ttype: \"google.api.FieldBehavior\",\n\t\t\t\t\t\tid: 1052,\n\t\t\t\t\t\textend: \"google.protobuf.FieldOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tFieldBehavior: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tFIELD_BEHAVIOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\tOPTIONAL: 1,\n\t\t\t\t\t\t\tREQUIRED: 2,\n\t\t\t\t\t\t\tOUTPUT_ONLY: 3,\n\t\t\t\t\t\t\tINPUT_ONLY: 4,\n\t\t\t\t\t\t\tIMMUTABLE: 5,\n\t\t\t\t\t\t\tUNORDERED_LIST: 6,\n\t\t\t\t\t\t\tNON_EMPTY_DEFAULT: 7\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\ttype: {\n\t\t\t\toptions: {\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/type/latlng;latlng\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"LatLngProto\",\n\t\t\t\t\tjava_package: \"com.google.type\",\n\t\t\t\t\tobjc_class_prefix: \"GTP\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tLatLng: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tlatitude: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlongitude: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\trpc: {\n\t\t\t\toptions: {\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/rpc/status;status\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"StatusProto\",\n\t\t\t\t\tjava_package: \"com.google.rpc\",\n\t\t\t\t\tobjc_class_prefix: \"RPC\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tStatus: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tcode: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdetails: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"google.protobuf.Any\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nvar protos = {\n\tnested: nested\n};\n\nvar protos$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  nested: nested,\n  'default': protos\n});\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Used by tests so we can match @grpc/proto-loader behavior. */\nconst protoLoaderOptions = {\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: false\n};\n/**\n * Loads the protocol buffer definitions for Firestore.\n *\n * @returns The GrpcObject representing our protos.\n */\nfunction loadProtos() {\n    const packageDefinition = _grpc_proto_loader__WEBPACK_IMPORTED_MODULE_8__.fromJSON(protos$1, protoLoaderOptions);\n    return _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_7__.loadPackageDefinition(packageDefinition);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Loads the GRPC stack */\nfunction newConnection(databaseInfo) {\n    const protos = loadProtos();\n    return new GrpcConnection(protos, databaseInfo);\n}\n/** Return the Platform-specific connectivity monitor. */\nfunction newConnectivityMonitor() {\n    return new NoopConnectivityMonitor();\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** The Platform's 'window' implementation or null if not available. */\nfunction getWindow() {\n    if (process.env.USE_MOCK_PERSISTENCE === 'YES') {\n        // eslint-disable-next-line no-restricted-globals\n        return window;\n    }\n    return null;\n}\n/** The Platform's 'document' implementation or null if not available. */\nfunction getDocument() {\n    return null;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction newSerializer(databaseId) {\n    return new JsonProtoSerializer(databaseId, /* useProto3Json= */ false);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$8 = 'ExponentialBackoff';\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nconst DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\nconst DEFAULT_BACKOFF_FACTOR = 1.5;\n/** Maximum backoff time in milliseconds */\nconst DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\nclass ExponentialBackoff {\n    constructor(\n    /**\n     * The AsyncQueue to run backoff operations on.\n     */\n    queue, \n    /**\n     * The ID to use when scheduling backoff operations on the AsyncQueue.\n     */\n    timerId, \n    /**\n     * The initial delay (used as the base delay on the first retry attempt).\n     * Note that jitter will still be applied, so the actual delay could be as\n     * little as 0.5*initialDelayMs.\n     */\n    initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS, \n    /**\n     * The multiplier to use to determine the extended base delay after each\n     * attempt.\n     */\n    backoffFactor = DEFAULT_BACKOFF_FACTOR, \n    /**\n     * The maximum base delay after which no further backoff is performed.\n     * Note that jitter will still be applied, so the actual delay could be as\n     * much as 1.5*maxDelayMs.\n     */\n    maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS) {\n        this.queue = queue;\n        this.timerId = timerId;\n        this.initialDelayMs = initialDelayMs;\n        this.backoffFactor = backoffFactor;\n        this.maxDelayMs = maxDelayMs;\n        this.currentBaseMs = 0;\n        this.timerPromise = null;\n        /** The last backoff attempt, as epoch milliseconds. */\n        this.lastAttemptTime = Date.now();\n        this.reset();\n    }\n    /**\n     * Resets the backoff delay.\n     *\n     * The very next backoffAndWait() will have no delay. If it is called again\n     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n     * subsequent ones will increase according to the backoffFactor.\n     */\n    reset() {\n        this.currentBaseMs = 0;\n    }\n    /**\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\n     * RESOURCE_EXHAUSTED error).\n     */\n    resetToMax() {\n        this.currentBaseMs = this.maxDelayMs;\n    }\n    /**\n     * Returns a promise that resolves after currentDelayMs, and increases the\n     * delay for any subsequent attempts. If there was a pending backoff operation\n     * already, it will be canceled.\n     */\n    backoffAndRun(op) {\n        // Cancel any pending backoff operation.\n        this.cancel();\n        // First schedule using the current base (which may be 0 and should be\n        // honored as such).\n        const desiredDelayWithJitterMs = Math.floor(this.currentBaseMs + this.jitterDelayMs());\n        // Guard against lastAttemptTime being in the future due to a clock change.\n        const delaySoFarMs = Math.max(0, Date.now() - this.lastAttemptTime);\n        // Guard against the backoff delay already being past.\n        const remainingDelayMs = Math.max(0, desiredDelayWithJitterMs - delaySoFarMs);\n        if (remainingDelayMs > 0) {\n            logDebug(LOG_TAG$8, `Backing off for ${remainingDelayMs} ms ` +\n                `(base delay: ${this.currentBaseMs} ms, ` +\n                `delay with jitter: ${desiredDelayWithJitterMs} ms, ` +\n                `last attempt: ${delaySoFarMs} ms ago)`);\n        }\n        this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, remainingDelayMs, () => {\n            this.lastAttemptTime = Date.now();\n            return op();\n        });\n        // Apply backoff factor to determine next delay and ensure it is within\n        // bounds.\n        this.currentBaseMs *= this.backoffFactor;\n        if (this.currentBaseMs < this.initialDelayMs) {\n            this.currentBaseMs = this.initialDelayMs;\n        }\n        if (this.currentBaseMs > this.maxDelayMs) {\n            this.currentBaseMs = this.maxDelayMs;\n        }\n    }\n    skipBackoff() {\n        if (this.timerPromise !== null) {\n            this.timerPromise.skipDelay();\n            this.timerPromise = null;\n        }\n    }\n    cancel() {\n        if (this.timerPromise !== null) {\n            this.timerPromise.cancel();\n            this.timerPromise = null;\n        }\n    }\n    /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n    jitterDelayMs() {\n        return (Math.random() - 0.5) * this.currentBaseMs;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$7 = 'PersistentStream';\n/** The time a stream stays open after it is marked idle. */\nconst IDLE_TIMEOUT_MS = 60 * 1000;\n/** The time a stream stays open until we consider it healthy. */\nconst HEALTHY_TIMEOUT_MS = 10 * 1000;\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *   - Closing idle streams after 60 seconds of inactivity\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be start()ed before messages can\n * be sent and received. The PersistentStream will call the onOpen() function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a start() fail, PersistentStream will call the registered onClose()\n * listener with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\nclass PersistentStream {\n    constructor(queue, connectionTimerId, idleTimerId, healthTimerId, connection, authCredentialsProvider, appCheckCredentialsProvider, listener) {\n        this.queue = queue;\n        this.idleTimerId = idleTimerId;\n        this.healthTimerId = healthTimerId;\n        this.connection = connection;\n        this.authCredentialsProvider = authCredentialsProvider;\n        this.appCheckCredentialsProvider = appCheckCredentialsProvider;\n        this.listener = listener;\n        this.state = 0 /* PersistentStreamState.Initial */;\n        /**\n         * A close count that's incremented every time the stream is closed; used by\n         * getCloseGuardedDispatcher() to invalidate callbacks that happen after\n         * close.\n         */\n        this.closeCount = 0;\n        this.idleTimer = null;\n        this.healthCheck = null;\n        this.stream = null;\n        /**\n         * Count of response messages received.\n         */\n        this.responseCount = 0;\n        this.backoff = new ExponentialBackoff(queue, connectionTimerId);\n    }\n    /**\n     * Returns true if start() has been called and no error has occurred. True\n     * indicates the stream is open or in the process of opening (which\n     * encompasses respecting backoff, getting auth tokens, and starting the\n     * actual RPC). Use isOpen() to determine if the stream is open and ready for\n     * outbound requests.\n     */\n    isStarted() {\n        return (this.state === 1 /* PersistentStreamState.Starting */ ||\n            this.state === 5 /* PersistentStreamState.Backoff */ ||\n            this.isOpen());\n    }\n    /**\n     * Returns true if the underlying RPC is open (the onOpen() listener has been\n     * called) and the stream is ready for outbound requests.\n     */\n    isOpen() {\n        return (this.state === 2 /* PersistentStreamState.Open */ ||\n            this.state === 3 /* PersistentStreamState.Healthy */);\n    }\n    /**\n     * Starts the RPC. Only allowed if isStarted() returns false. The stream is\n     * not immediately ready for use: onOpen() will be invoked when the RPC is\n     * ready for outbound requests, at which point isOpen() will return true.\n     *\n     * When start returns, isStarted() will return true.\n     */\n    start() {\n        this.responseCount = 0;\n        if (this.state === 4 /* PersistentStreamState.Error */) {\n            this.performBackoff();\n            return;\n        }\n        this.auth();\n    }\n    /**\n     * Stops the RPC. This call is idempotent and allowed regardless of the\n     * current isStarted() state.\n     *\n     * When stop returns, isStarted() and isOpen() will both return false.\n     */\n    async stop() {\n        if (this.isStarted()) {\n            await this.close(0 /* PersistentStreamState.Initial */);\n        }\n    }\n    /**\n     * After an error the stream will usually back off on the next attempt to\n     * start it. If the error warrants an immediate restart of the stream, the\n     * sender can use this to indicate that the receiver should not back off.\n     *\n     * Each error will call the onClose() listener. That function can decide to\n     * inhibit backoff if required.\n     */\n    inhibitBackoff() {\n        this.state = 0 /* PersistentStreamState.Initial */;\n        this.backoff.reset();\n    }\n    /**\n     * Marks this stream as idle. If no further actions are performed on the\n     * stream for one minute, the stream will automatically close itself and\n     * notify the stream's onClose() handler with Status.OK. The stream will then\n     * be in a !isStarted() state, requiring the caller to start the stream again\n     * before further use.\n     *\n     * Only streams that are in state 'Open' can be marked idle, as all other\n     * states imply pending network operations.\n     */\n    markIdle() {\n        // Starts the idle time if we are in state 'Open' and are not yet already\n        // running a timer (in which case the previous idle timeout still applies).\n        if (this.isOpen() && this.idleTimer === null) {\n            this.idleTimer = this.queue.enqueueAfterDelay(this.idleTimerId, IDLE_TIMEOUT_MS, () => this.handleIdleCloseTimer());\n        }\n    }\n    /** Sends a message to the underlying stream. */\n    sendRequest(msg) {\n        this.cancelIdleCheck();\n        this.stream.send(msg);\n    }\n    /** Called by the idle timer when the stream should close due to inactivity. */\n    async handleIdleCloseTimer() {\n        if (this.isOpen()) {\n            // When timing out an idle stream there's no reason to force the stream into backoff when\n            // it restarts so set the stream state to Initial instead of Error.\n            return this.close(0 /* PersistentStreamState.Initial */);\n        }\n    }\n    /** Marks the stream as active again. */\n    cancelIdleCheck() {\n        if (this.idleTimer) {\n            this.idleTimer.cancel();\n            this.idleTimer = null;\n        }\n    }\n    /** Cancels the health check delayed operation. */\n    cancelHealthCheck() {\n        if (this.healthCheck) {\n            this.healthCheck.cancel();\n            this.healthCheck = null;\n        }\n    }\n    /**\n     * Closes the stream and cleans up as necessary:\n     *\n     * * closes the underlying GRPC stream;\n     * * calls the onClose handler with the given 'error';\n     * * sets internal stream state to 'finalState';\n     * * adjusts the backoff timer based on the error\n     *\n     * A new stream can be opened by calling start().\n     *\n     * @param finalState - the intended state of the stream after closing.\n     * @param error - the error the connection was closed with.\n     */\n    async close(finalState, error) {\n        // Cancel any outstanding timers (they're guaranteed not to execute).\n        this.cancelIdleCheck();\n        this.cancelHealthCheck();\n        this.backoff.cancel();\n        // Invalidates any stream-related callbacks (e.g. from auth or the\n        // underlying stream), guaranteeing they won't execute.\n        this.closeCount++;\n        if (finalState !== 4 /* PersistentStreamState.Error */) {\n            // If this is an intentional close ensure we don't delay our next connection attempt.\n            this.backoff.reset();\n        }\n        else if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n            // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)\n            logError(error.toString());\n            logError('Using maximum backoff delay to prevent overloading the backend.');\n            this.backoff.resetToMax();\n        }\n        else if (error &&\n            error.code === Code.UNAUTHENTICATED &&\n            this.state !== 3 /* PersistentStreamState.Healthy */) {\n            // \"unauthenticated\" error means the token was rejected. This should rarely\n            // happen since both Auth and AppCheck ensure a sufficient TTL when we\n            // request a token. If a user manually resets their system clock this can\n            // fail, however. In this case, we should get a Code.UNAUTHENTICATED error\n            // before we received the first message and we need to invalidate the token\n            // to ensure that we fetch a new token.\n            this.authCredentialsProvider.invalidateToken();\n            this.appCheckCredentialsProvider.invalidateToken();\n        }\n        // Clean up the underlying stream because we are no longer interested in events.\n        if (this.stream !== null) {\n            this.tearDown();\n            this.stream.close();\n            this.stream = null;\n        }\n        // This state must be assigned before calling onClose() to allow the callback to\n        // inhibit backoff or otherwise manipulate the state in its non-started state.\n        this.state = finalState;\n        // Notify the listener that the stream closed.\n        await this.listener.onClose(error);\n    }\n    /**\n     * Can be overridden to perform additional cleanup before the stream is closed.\n     * Calling super.tearDown() is not required.\n     */\n    tearDown() { }\n    auth() {\n        this.state = 1 /* PersistentStreamState.Starting */;\n        const dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);\n        // TODO(mikelehen): Just use dispatchIfNotClosed, but see TODO below.\n        const closeCount = this.closeCount;\n        Promise.all([\n            this.authCredentialsProvider.getToken(),\n            this.appCheckCredentialsProvider.getToken()\n        ]).then(([authToken, appCheckToken]) => {\n            // Stream can be stopped while waiting for authentication.\n            // TODO(mikelehen): We really should just use dispatchIfNotClosed\n            // and let this dispatch onto the queue, but that opened a spec test can\n            // of worms that I don't want to deal with in this PR.\n            if (this.closeCount === closeCount) {\n                // Normally we'd have to schedule the callback on the AsyncQueue.\n                // However, the following calls are safe to be called outside the\n                // AsyncQueue since they don't chain asynchronous calls\n                this.startStream(authToken, appCheckToken);\n            }\n        }, (error) => {\n            dispatchIfNotClosed(() => {\n                const rpcError = new FirestoreError(Code.UNKNOWN, 'Fetching auth token failed: ' + error.message);\n                return this.handleStreamClose(rpcError);\n            });\n        });\n    }\n    startStream(authToken, appCheckToken) {\n        const dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);\n        this.stream = this.startRpc(authToken, appCheckToken);\n        this.stream.onConnected(() => {\n            dispatchIfNotClosed(() => this.listener.onConnected());\n        });\n        this.stream.onOpen(() => {\n            dispatchIfNotClosed(() => {\n                this.state = 2 /* PersistentStreamState.Open */;\n                this.healthCheck = this.queue.enqueueAfterDelay(this.healthTimerId, HEALTHY_TIMEOUT_MS, () => {\n                    if (this.isOpen()) {\n                        this.state = 3 /* PersistentStreamState.Healthy */;\n                    }\n                    return Promise.resolve();\n                });\n                return this.listener.onOpen();\n            });\n        });\n        this.stream.onClose((error) => {\n            dispatchIfNotClosed(() => {\n                return this.handleStreamClose(error);\n            });\n        });\n        this.stream.onMessage((msg) => {\n            dispatchIfNotClosed(() => {\n                if (++this.responseCount === 1) {\n                    return this.onFirst(msg);\n                }\n                else {\n                    return this.onNext(msg);\n                }\n            });\n        });\n    }\n    performBackoff() {\n        this.state = 5 /* PersistentStreamState.Backoff */;\n        this.backoff.backoffAndRun(async () => {\n            this.state = 0 /* PersistentStreamState.Initial */;\n            this.start();\n        });\n    }\n    // Visible for tests\n    handleStreamClose(error) {\n        logDebug(LOG_TAG$7, `close with error: ${error}`);\n        this.stream = null;\n        // In theory the stream could close cleanly, however, in our current model\n        // we never expect this to happen because if we stop a stream ourselves,\n        // this callback will never be called. To prevent cases where we retry\n        // without a backoff accidentally, we set the stream to error in all cases.\n        return this.close(4 /* PersistentStreamState.Error */, error);\n    }\n    /**\n     * Returns a \"dispatcher\" function that dispatches operations onto the\n     * AsyncQueue but only runs them if closeCount remains unchanged. This allows\n     * us to turn auth / stream callbacks into no-ops if the stream is closed /\n     * re-opened, etc.\n     */\n    getCloseGuardedDispatcher(startCloseCount) {\n        return (fn) => {\n            this.queue.enqueueAndForget(() => {\n                if (this.closeCount === startCloseCount) {\n                    return fn();\n                }\n                else {\n                    logDebug(LOG_TAG$7, 'stream callback skipped by getCloseGuardedDispatcher.');\n                    return Promise.resolve();\n                }\n            });\n        };\n    }\n}\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the onOpen() listener, any number of\n * listen() and unlisten() calls can be made to control what changes will be\n * sent from the server for ListenResponses.\n */\nclass PersistentListenStream extends PersistentStream {\n    constructor(queue, connection, authCredentials, appCheckCredentials, serializer, listener) {\n        super(queue, \"listen_stream_connection_backoff\" /* TimerId.ListenStreamConnectionBackoff */, \"listen_stream_idle\" /* TimerId.ListenStreamIdle */, \"health_check_timeout\" /* TimerId.HealthCheckTimeout */, connection, authCredentials, appCheckCredentials, listener);\n        this.serializer = serializer;\n    }\n    startRpc(authToken, appCheckToken) {\n        return this.connection.openStream('Listen', authToken, appCheckToken);\n    }\n    onFirst(watchChangeProto) {\n        return this.onNext(watchChangeProto);\n    }\n    onNext(watchChangeProto) {\n        // A successful response means the stream is healthy\n        this.backoff.reset();\n        const watchChange = fromWatchChange(this.serializer, watchChangeProto);\n        const snapshot = versionFromListenResponse(watchChangeProto);\n        return this.listener.onWatchChange(watchChange, snapshot);\n    }\n    /**\n     * Registers interest in the results of the given target. If the target\n     * includes a resumeToken it will be included in the request. Results that\n     * affect the target will be streamed back as WatchChange messages that\n     * reference the targetId.\n     */\n    watch(targetData) {\n        const request = {};\n        request.database = getEncodedDatabaseId(this.serializer);\n        request.addTarget = toTarget(this.serializer, targetData);\n        const labels = toListenRequestLabels(this.serializer, targetData);\n        if (labels) {\n            request.labels = labels;\n        }\n        this.sendRequest(request);\n    }\n    /**\n     * Unregisters interest in the results of the target associated with the\n     * given targetId.\n     */\n    unwatch(targetId) {\n        const request = {};\n        request.database = getEncodedDatabaseId(this.serializer);\n        request.removeTarget = targetId;\n        this.sendRequest(request);\n    }\n}\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\nclass PersistentWriteStream extends PersistentStream {\n    constructor(queue, connection, authCredentials, appCheckCredentials, serializer, listener) {\n        super(queue, \"write_stream_connection_backoff\" /* TimerId.WriteStreamConnectionBackoff */, \"write_stream_idle\" /* TimerId.WriteStreamIdle */, \"health_check_timeout\" /* TimerId.HealthCheckTimeout */, connection, authCredentials, appCheckCredentials, listener);\n        this.serializer = serializer;\n    }\n    /**\n     * Tracks whether or not a handshake has been successfully exchanged and\n     * the stream is ready to accept mutations.\n     */\n    get handshakeComplete() {\n        return this.responseCount > 0;\n    }\n    // Override of PersistentStream.start\n    start() {\n        this.lastStreamToken = undefined;\n        super.start();\n    }\n    tearDown() {\n        if (this.handshakeComplete) {\n            this.writeMutations([]);\n        }\n    }\n    startRpc(authToken, appCheckToken) {\n        return this.connection.openStream('Write', authToken, appCheckToken);\n    }\n    onFirst(responseProto) {\n        // Always capture the last stream token.\n        hardAssert(!!responseProto.streamToken);\n        this.lastStreamToken = responseProto.streamToken;\n        // The first response is always the handshake response\n        hardAssert(!responseProto.writeResults || responseProto.writeResults.length === 0);\n        return this.listener.onHandshakeComplete();\n    }\n    onNext(responseProto) {\n        // Always capture the last stream token.\n        hardAssert(!!responseProto.streamToken);\n        this.lastStreamToken = responseProto.streamToken;\n        // A successful first write response means the stream is healthy,\n        // Note, that we could consider a successful handshake healthy, however,\n        // the write itself might be causing an error we want to back off from.\n        this.backoff.reset();\n        const results = fromWriteResults(responseProto.writeResults, responseProto.commitTime);\n        const commitVersion = fromVersion(responseProto.commitTime);\n        return this.listener.onMutationResult(commitVersion, results);\n    }\n    /**\n     * Sends an initial streamToken to the server, performing the handshake\n     * required to make the StreamingWrite RPC work. Subsequent\n     * calls should wait until onHandshakeComplete was called.\n     */\n    writeHandshake() {\n        // TODO(dimond): Support stream resumption. We intentionally do not set the\n        // stream token on the handshake, ignoring any stream token we might have.\n        const request = {};\n        request.database = getEncodedDatabaseId(this.serializer);\n        this.sendRequest(request);\n    }\n    /** Sends a group of mutations to the Firestore backend to apply. */\n    writeMutations(mutations) {\n        const request = {\n            streamToken: this.lastStreamToken,\n            writes: mutations.map(mutation => toMutation(this.serializer, mutation))\n        };\n        this.sendRequest(request);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Datastore and its related methods are a wrapper around the external Google\n * Cloud Datastore grpc API, which provides an interface that is more convenient\n * for the rest of the client SDK architecture to consume.\n */\nclass Datastore {\n}\n/**\n * An implementation of Datastore that exposes additional state for internal\n * consumption.\n */\nclass DatastoreImpl extends Datastore {\n    constructor(authCredentials, appCheckCredentials, connection, serializer) {\n        super();\n        this.authCredentials = authCredentials;\n        this.appCheckCredentials = appCheckCredentials;\n        this.connection = connection;\n        this.serializer = serializer;\n        this.terminated = false;\n    }\n    verifyInitialized() {\n        if (this.terminated) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');\n        }\n    }\n    /** Invokes the provided RPC with auth and AppCheck tokens. */\n    invokeRPC(rpcName, databaseId, resourcePath, request) {\n        this.verifyInitialized();\n        return Promise.all([\n            this.authCredentials.getToken(),\n            this.appCheckCredentials.getToken()\n        ])\n            .then(([authToken, appCheckToken]) => {\n            return this.connection.invokeRPC(rpcName, toResourcePath(databaseId, resourcePath), request, authToken, appCheckToken);\n        })\n            .catch((error) => {\n            if (error.name === 'FirebaseError') {\n                if (error.code === Code.UNAUTHENTICATED) {\n                    this.authCredentials.invalidateToken();\n                    this.appCheckCredentials.invalidateToken();\n                }\n                throw error;\n            }\n            else {\n                throw new FirestoreError(Code.UNKNOWN, error.toString());\n            }\n        });\n    }\n    /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */\n    invokeStreamingRPC(rpcName, databaseId, resourcePath, request, expectedResponseCount) {\n        this.verifyInitialized();\n        return Promise.all([\n            this.authCredentials.getToken(),\n            this.appCheckCredentials.getToken()\n        ])\n            .then(([authToken, appCheckToken]) => {\n            return this.connection.invokeStreamingRPC(rpcName, toResourcePath(databaseId, resourcePath), request, authToken, appCheckToken, expectedResponseCount);\n        })\n            .catch((error) => {\n            if (error.name === 'FirebaseError') {\n                if (error.code === Code.UNAUTHENTICATED) {\n                    this.authCredentials.invalidateToken();\n                    this.appCheckCredentials.invalidateToken();\n                }\n                throw error;\n            }\n            else {\n                throw new FirestoreError(Code.UNKNOWN, error.toString());\n            }\n        });\n    }\n    terminate() {\n        this.terminated = true;\n        this.connection.terminate();\n    }\n}\n// TODO(firestorexp): Make sure there is only one Datastore instance per\n// firestore-exp client.\nfunction newDatastore(authCredentials, appCheckCredentials, connection, serializer) {\n    return new DatastoreImpl(authCredentials, appCheckCredentials, connection, serializer);\n}\nasync function invokeCommitRpc(datastore, mutations) {\n    const datastoreImpl = debugCast(datastore);\n    const request = {\n        writes: mutations.map(m => toMutation(datastoreImpl.serializer, m))\n    };\n    await datastoreImpl.invokeRPC('Commit', datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), request);\n}\nasync function invokeBatchGetDocumentsRpc(datastore, keys) {\n    const datastoreImpl = debugCast(datastore);\n    const request = {\n        documents: keys.map(k => toName(datastoreImpl.serializer, k))\n    };\n    const response = await datastoreImpl.invokeStreamingRPC('BatchGetDocuments', datastoreImpl.serializer.databaseId, ResourcePath.emptyPath(), request, keys.length);\n    const docs = new Map();\n    response.forEach(proto => {\n        const doc = fromBatchGetDocumentsResponse(datastoreImpl.serializer, proto);\n        docs.set(doc.key.toString(), doc);\n    });\n    const result = [];\n    keys.forEach(key => {\n        const doc = docs.get(key.toString());\n        hardAssert(!!doc);\n        result.push(doc);\n    });\n    return result;\n}\nasync function invokeRunAggregationQueryRpc(datastore, query, aggregates) {\n    var _a;\n    const datastoreImpl = debugCast(datastore);\n    const { request, aliasMap, parent } = toRunAggregationQueryRequest(datastoreImpl.serializer, queryToAggregateTarget(query), aggregates);\n    if (!datastoreImpl.connection.shouldResourcePathBeIncludedInRequest) {\n        delete request.parent;\n    }\n    const response = await datastoreImpl.invokeStreamingRPC('RunAggregationQuery', datastoreImpl.serializer.databaseId, parent, request, \n    /*expectedResponseCount=*/ 1);\n    // Omit RunAggregationQueryResponse that only contain readTimes.\n    const filteredResult = response.filter(proto => !!proto.result);\n    hardAssert(filteredResult.length === 1);\n    // Remap the short-form aliases that were sent to the server\n    // to the client-side aliases. Users will access the results\n    // using the client-side alias.\n    const unmappedAggregateFields = (_a = filteredResult[0].result) === null || _a === void 0 ? void 0 : _a.aggregateFields;\n    const remappedFields = Object.keys(unmappedAggregateFields).reduce((accumulator, key) => {\n        accumulator[aliasMap[key]] = unmappedAggregateFields[key];\n        return accumulator;\n    }, {});\n    return remappedFields;\n}\nfunction newPersistentWriteStream(datastore, queue, listener) {\n    const datastoreImpl = debugCast(datastore);\n    datastoreImpl.verifyInitialized();\n    return new PersistentWriteStream(queue, datastoreImpl.connection, datastoreImpl.authCredentials, datastoreImpl.appCheckCredentials, datastoreImpl.serializer, listener);\n}\nfunction newPersistentWatchStream(datastore, queue, listener) {\n    const datastoreImpl = debugCast(datastore);\n    datastoreImpl.verifyInitialized();\n    return new PersistentListenStream(queue, datastoreImpl.connection, datastoreImpl.authCredentials, datastoreImpl.appCheckCredentials, datastoreImpl.serializer, listener);\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$6 = 'OnlineStateTracker';\n// To deal with transient failures, we allow multiple stream attempts before\n// giving up and transitioning from OnlineState.Unknown to Offline.\n// TODO(mikelehen): This used to be set to 2 as a mitigation for b/66228394.\n// @jdimond thinks that bug is sufficiently fixed so that we can set this back\n// to 1. If that works okay, we could potentially remove this logic entirely.\nconst MAX_WATCH_STREAM_FAILURES = 1;\n// To deal with stream attempts that don't succeed or fail in a timely manner,\n// we have a timeout for OnlineState to reach Online or Offline.\n// If the timeout is reached, we transition to Offline rather than waiting\n// indefinitely.\nconst ONLINE_STATE_TIMEOUT_MS = 10 * 1000;\n/**\n * A component used by the RemoteStore to track the OnlineState (that is,\n * whether or not the client as a whole should be considered to be online or\n * offline), implementing the appropriate heuristics.\n *\n * In particular, when the client is trying to connect to the backend, we\n * allow up to MAX_WATCH_STREAM_FAILURES within ONLINE_STATE_TIMEOUT_MS for\n * a connection to succeed. If we have too many failures or the timeout elapses,\n * then we set the OnlineState to Offline, and the client will behave as if\n * it is offline (get()s will return cached data, etc.).\n */\nclass OnlineStateTracker {\n    constructor(asyncQueue, onlineStateHandler) {\n        this.asyncQueue = asyncQueue;\n        this.onlineStateHandler = onlineStateHandler;\n        /** The current OnlineState. */\n        this.state = \"Unknown\" /* OnlineState.Unknown */;\n        /**\n         * A count of consecutive failures to open the stream. If it reaches the\n         * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to\n         * Offline.\n         */\n        this.watchStreamFailures = 0;\n        /**\n         * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we\n         * transition from OnlineState.Unknown to OnlineState.Offline without waiting\n         * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).\n         */\n        this.onlineStateTimer = null;\n        /**\n         * Whether the client should log a warning message if it fails to connect to\n         * the backend (initially true, cleared after a successful stream, or if we've\n         * logged the message already).\n         */\n        this.shouldWarnClientIsOffline = true;\n    }\n    /**\n     * Called by RemoteStore when a watch stream is started (including on each\n     * backoff attempt).\n     *\n     * If this is the first attempt, it sets the OnlineState to Unknown and starts\n     * the onlineStateTimer.\n     */\n    handleWatchStreamStart() {\n        if (this.watchStreamFailures === 0) {\n            this.setAndBroadcast(\"Unknown\" /* OnlineState.Unknown */);\n            this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(\"online_state_timeout\" /* TimerId.OnlineStateTimeout */, ONLINE_STATE_TIMEOUT_MS, () => {\n                this.onlineStateTimer = null;\n                this.logClientOfflineWarningIfNecessary(`Backend didn't respond within ${ONLINE_STATE_TIMEOUT_MS / 1000} ` +\n                    `seconds.`);\n                this.setAndBroadcast(\"Offline\" /* OnlineState.Offline */);\n                // NOTE: handleWatchStreamFailure() will continue to increment\n                // watchStreamFailures even though we are already marked Offline,\n                // but this is non-harmful.\n                return Promise.resolve();\n            });\n        }\n    }\n    /**\n     * Updates our OnlineState as appropriate after the watch stream reports a\n     * failure. The first failure moves us to the 'Unknown' state. We then may\n     * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we\n     * actually transition to the 'Offline' state.\n     */\n    handleWatchStreamFailure(error) {\n        if (this.state === \"Online\" /* OnlineState.Online */) {\n            this.setAndBroadcast(\"Unknown\" /* OnlineState.Unknown */);\n        }\n        else {\n            this.watchStreamFailures++;\n            if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {\n                this.clearOnlineStateTimer();\n                this.logClientOfflineWarningIfNecessary(`Connection failed ${MAX_WATCH_STREAM_FAILURES} ` +\n                    `times. Most recent error: ${error.toString()}`);\n                this.setAndBroadcast(\"Offline\" /* OnlineState.Offline */);\n            }\n        }\n    }\n    /**\n     * Explicitly sets the OnlineState to the specified state.\n     *\n     * Note that this resets our timers / failure counters, etc. used by our\n     * Offline heuristics, so must not be used in place of\n     * handleWatchStreamStart() and handleWatchStreamFailure().\n     */\n    set(newState) {\n        this.clearOnlineStateTimer();\n        this.watchStreamFailures = 0;\n        if (newState === \"Online\" /* OnlineState.Online */) {\n            // We've connected to watch at least once. Don't warn the developer\n            // about being offline going forward.\n            this.shouldWarnClientIsOffline = false;\n        }\n        this.setAndBroadcast(newState);\n    }\n    setAndBroadcast(newState) {\n        if (newState !== this.state) {\n            this.state = newState;\n            this.onlineStateHandler(newState);\n        }\n    }\n    logClientOfflineWarningIfNecessary(details) {\n        const message = `Could not reach Cloud Firestore backend. ${details}\\n` +\n            `This typically indicates that your device does not have a healthy ` +\n            `Internet connection at the moment. The client will operate in offline ` +\n            `mode until it is able to successfully connect to the backend.`;\n        if (this.shouldWarnClientIsOffline) {\n            logError(message);\n            this.shouldWarnClientIsOffline = false;\n        }\n        else {\n            logDebug(LOG_TAG$6, message);\n        }\n    }\n    clearOnlineStateTimer() {\n        if (this.onlineStateTimer !== null) {\n            this.onlineStateTimer.cancel();\n            this.onlineStateTimer = null;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$5 = 'RemoteStore';\n// TODO(b/35853402): Negotiate this with the stream.\nconst MAX_PENDING_WRITES = 10;\nclass RemoteStoreImpl {\n    constructor(\n    /**\n     * The local store, used to fill the write pipeline with outbound mutations.\n     */\n    localStore, \n    /** The client-side proxy for interacting with the backend. */\n    datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {\n        this.localStore = localStore;\n        this.datastore = datastore;\n        this.asyncQueue = asyncQueue;\n        this.remoteSyncer = {};\n        /**\n         * A list of up to MAX_PENDING_WRITES writes that we have fetched from the\n         * LocalStore via fillWritePipeline() and have or will send to the write\n         * stream.\n         *\n         * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or\n         * restart the write stream. When the stream is established the writes in the\n         * pipeline will be sent in order.\n         *\n         * Writes remain in writePipeline until they are acknowledged by the backend\n         * and thus will automatically be re-sent if the stream is interrupted /\n         * restarted before they're acknowledged.\n         *\n         * Write responses from the backend are linked to their originating request\n         * purely based on order, and so we can just shift() writes from the front of\n         * the writePipeline as we receive responses.\n         */\n        this.writePipeline = [];\n        /**\n         * A mapping of watched targets that the client cares about tracking and the\n         * user has explicitly called a 'listen' for this target.\n         *\n         * These targets may or may not have been sent to or acknowledged by the\n         * server. On re-establishing the listen stream, these targets should be sent\n         * to the server. The targets removed with unlistens are removed eagerly\n         * without waiting for confirmation from the listen stream.\n         */\n        this.listenTargets = new Map();\n        /**\n         * A set of reasons for why the RemoteStore may be offline. If empty, the\n         * RemoteStore may start its network connections.\n         */\n        this.offlineCauses = new Set();\n        /**\n         * Event handlers that get called when the network is disabled or enabled.\n         *\n         * PORTING NOTE: These functions are used on the Web client to create the\n         * underlying streams (to support tree-shakeable streams). On Android and iOS,\n         * the streams are created during construction of RemoteStore.\n         */\n        this.onNetworkStatusChange = [];\n        this.connectivityMonitor = connectivityMonitor;\n        this.connectivityMonitor.addCallback((_) => {\n            asyncQueue.enqueueAndForget(async () => {\n                // Porting Note: Unlike iOS, `restartNetwork()` is called even when the\n                // network becomes unreachable as we don't have any other way to tear\n                // down our streams.\n                if (canUseNetwork(this)) {\n                    logDebug(LOG_TAG$5, 'Restarting streams for network reachability change.');\n                    await restartNetwork(this);\n                }\n            });\n        });\n        this.onlineStateTracker = new OnlineStateTracker(asyncQueue, onlineStateHandler);\n    }\n}\nfunction newRemoteStore(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {\n    return new RemoteStoreImpl(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor);\n}\n/** Re-enables the network. Idempotent. */\nfunction remoteStoreEnableNetwork(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    remoteStoreImpl.offlineCauses.delete(0 /* OfflineCause.UserDisabled */);\n    return enableNetworkInternal(remoteStoreImpl);\n}\nasync function enableNetworkInternal(remoteStoreImpl) {\n    if (canUseNetwork(remoteStoreImpl)) {\n        for (const networkStatusHandler of remoteStoreImpl.onNetworkStatusChange) {\n            await networkStatusHandler(/* enabled= */ true);\n        }\n    }\n}\n/**\n * Temporarily disables the network. The network can be re-enabled using\n * enableNetwork().\n */\nasync function remoteStoreDisableNetwork(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    remoteStoreImpl.offlineCauses.add(0 /* OfflineCause.UserDisabled */);\n    await disableNetworkInternal(remoteStoreImpl);\n    // Set the OnlineState to Offline so get()s return from cache, etc.\n    remoteStoreImpl.onlineStateTracker.set(\"Offline\" /* OnlineState.Offline */);\n}\nasync function disableNetworkInternal(remoteStoreImpl) {\n    for (const networkStatusHandler of remoteStoreImpl.onNetworkStatusChange) {\n        await networkStatusHandler(/* enabled= */ false);\n    }\n}\nasync function remoteStoreShutdown(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    logDebug(LOG_TAG$5, 'RemoteStore shutting down.');\n    remoteStoreImpl.offlineCauses.add(5 /* OfflineCause.Shutdown */);\n    await disableNetworkInternal(remoteStoreImpl);\n    remoteStoreImpl.connectivityMonitor.shutdown();\n    // Set the OnlineState to Unknown (rather than Offline) to avoid potentially\n    // triggering spurious listener events with cached data, etc.\n    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n}\n/**\n * Starts new listen for the given target. Uses resume token if provided. It\n * is a no-op if the target of given `TargetData` is already being listened to.\n */\nfunction remoteStoreListen(remoteStore, targetData) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    if (remoteStoreImpl.listenTargets.has(targetData.targetId)) {\n        return;\n    }\n    // Mark this as something the client is currently listening for.\n    remoteStoreImpl.listenTargets.set(targetData.targetId, targetData);\n    if (shouldStartWatchStream(remoteStoreImpl)) {\n        // The listen will be sent in onWatchStreamOpen\n        startWatchStream(remoteStoreImpl);\n    }\n    else if (ensureWatchStream(remoteStoreImpl).isOpen()) {\n        sendWatchRequest(remoteStoreImpl, targetData);\n    }\n}\n/**\n * Removes the listen from server. It is a no-op if the given target id is\n * not being listened to.\n */\nfunction remoteStoreUnlisten(remoteStore, targetId) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    const watchStream = ensureWatchStream(remoteStoreImpl);\n    remoteStoreImpl.listenTargets.delete(targetId);\n    if (watchStream.isOpen()) {\n        sendUnwatchRequest(remoteStoreImpl, targetId);\n    }\n    if (remoteStoreImpl.listenTargets.size === 0) {\n        if (watchStream.isOpen()) {\n            watchStream.markIdle();\n        }\n        else if (canUseNetwork(remoteStoreImpl)) {\n            // Revert to OnlineState.Unknown if the watch stream is not open and we\n            // have no listeners, since without any listens to send we cannot\n            // confirm if the stream is healthy and upgrade to OnlineState.Online.\n            remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n        }\n    }\n}\n/**\n * We need to increment the expected number of pending responses we're due\n * from watch so we wait for the ack to process any messages from this target.\n */\nfunction sendWatchRequest(remoteStoreImpl, targetData) {\n    remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetData.targetId);\n    if (targetData.resumeToken.approximateByteSize() > 0 ||\n        targetData.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {\n        const expectedCount = remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetData.targetId).size;\n        targetData = targetData.withExpectedCount(expectedCount);\n    }\n    ensureWatchStream(remoteStoreImpl).watch(targetData);\n}\n/**\n * We need to increment the expected number of pending responses we're due\n * from watch so we wait for the removal on the server before we process any\n * messages from this target.\n */\nfunction sendUnwatchRequest(remoteStoreImpl, targetId) {\n    remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetId);\n    ensureWatchStream(remoteStoreImpl).unwatch(targetId);\n}\nfunction startWatchStream(remoteStoreImpl) {\n    remoteStoreImpl.watchChangeAggregator = new WatchChangeAggregator({\n        getRemoteKeysForTarget: targetId => remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetId),\n        getTargetDataForTarget: targetId => remoteStoreImpl.listenTargets.get(targetId) || null,\n        getDatabaseId: () => remoteStoreImpl.datastore.serializer.databaseId\n    });\n    ensureWatchStream(remoteStoreImpl).start();\n    remoteStoreImpl.onlineStateTracker.handleWatchStreamStart();\n}\n/**\n * Returns whether the watch stream should be started because it's necessary\n * and has not yet been started.\n */\nfunction shouldStartWatchStream(remoteStoreImpl) {\n    return (canUseNetwork(remoteStoreImpl) &&\n        !ensureWatchStream(remoteStoreImpl).isStarted() &&\n        remoteStoreImpl.listenTargets.size > 0);\n}\nfunction canUseNetwork(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    return remoteStoreImpl.offlineCauses.size === 0;\n}\nfunction cleanUpWatchStreamState(remoteStoreImpl) {\n    remoteStoreImpl.watchChangeAggregator = undefined;\n}\nasync function onWatchStreamConnected(remoteStoreImpl) {\n    // Mark the client as online since we got a \"connected\" notification.\n    remoteStoreImpl.onlineStateTracker.set(\"Online\" /* OnlineState.Online */);\n}\nasync function onWatchStreamOpen(remoteStoreImpl) {\n    remoteStoreImpl.listenTargets.forEach((targetData, targetId) => {\n        sendWatchRequest(remoteStoreImpl, targetData);\n    });\n}\nasync function onWatchStreamClose(remoteStoreImpl, error) {\n    cleanUpWatchStreamState(remoteStoreImpl);\n    // If we still need the watch stream, retry the connection.\n    if (shouldStartWatchStream(remoteStoreImpl)) {\n        remoteStoreImpl.onlineStateTracker.handleWatchStreamFailure(error);\n        startWatchStream(remoteStoreImpl);\n    }\n    else {\n        // No need to restart watch stream because there are no active targets.\n        // The online state is set to unknown because there is no active attempt\n        // at establishing a connection\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n    }\n}\nasync function onWatchStreamChange(remoteStoreImpl, watchChange, snapshotVersion) {\n    // Mark the client as online since we got a message from the server\n    remoteStoreImpl.onlineStateTracker.set(\"Online\" /* OnlineState.Online */);\n    if (watchChange instanceof WatchTargetChange &&\n        watchChange.state === 2 /* WatchTargetChangeState.Removed */ &&\n        watchChange.cause) {\n        // There was an error on a target, don't wait for a consistent snapshot\n        // to raise events\n        try {\n            await handleTargetError(remoteStoreImpl, watchChange);\n        }\n        catch (e) {\n            logDebug(LOG_TAG$5, 'Failed to remove targets %s: %s ', watchChange.targetIds.join(','), e);\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\n        }\n        return;\n    }\n    if (watchChange instanceof DocumentWatchChange) {\n        remoteStoreImpl.watchChangeAggregator.handleDocumentChange(watchChange);\n    }\n    else if (watchChange instanceof ExistenceFilterChange) {\n        remoteStoreImpl.watchChangeAggregator.handleExistenceFilter(watchChange);\n    }\n    else {\n        remoteStoreImpl.watchChangeAggregator.handleTargetChange(watchChange);\n    }\n    if (!snapshotVersion.isEqual(SnapshotVersion.min())) {\n        try {\n            const lastRemoteSnapshotVersion = await localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);\n            if (snapshotVersion.compareTo(lastRemoteSnapshotVersion) >= 0) {\n                // We have received a target change with a global snapshot if the snapshot\n                // version is not equal to SnapshotVersion.min().\n                await raiseWatchSnapshot(remoteStoreImpl, snapshotVersion);\n            }\n        }\n        catch (e) {\n            logDebug(LOG_TAG$5, 'Failed to raise snapshot:', e);\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\n        }\n    }\n}\n/**\n * Recovery logic for IndexedDB errors that takes the network offline until\n * `op` succeeds. Retries are scheduled with backoff using\n * `enqueueRetryable()`. If `op()` is not provided, IndexedDB access is\n * validated via a generic operation.\n *\n * The returned Promise is resolved once the network is disabled and before\n * any retry attempt.\n */\nasync function disableNetworkUntilRecovery(remoteStoreImpl, e, op) {\n    if (isIndexedDbTransactionError(e)) {\n        remoteStoreImpl.offlineCauses.add(1 /* OfflineCause.IndexedDbFailed */);\n        // Disable network and raise offline snapshots\n        await disableNetworkInternal(remoteStoreImpl);\n        remoteStoreImpl.onlineStateTracker.set(\"Offline\" /* OnlineState.Offline */);\n        if (!op) {\n            // Use a simple read operation to determine if IndexedDB recovered.\n            // Ideally, we would expose a health check directly on SimpleDb, but\n            // RemoteStore only has access to persistence through LocalStore.\n            op = () => localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);\n        }\n        // Probe IndexedDB periodically and re-enable network\n        remoteStoreImpl.asyncQueue.enqueueRetryable(async () => {\n            logDebug(LOG_TAG$5, 'Retrying IndexedDB access');\n            await op();\n            remoteStoreImpl.offlineCauses.delete(1 /* OfflineCause.IndexedDbFailed */);\n            await enableNetworkInternal(remoteStoreImpl);\n        });\n    }\n    else {\n        throw e;\n    }\n}\n/**\n * Executes `op`. If `op` fails, takes the network offline until `op`\n * succeeds. Returns after the first attempt.\n */\nfunction executeWithRecovery(remoteStoreImpl, op) {\n    return op().catch(e => disableNetworkUntilRecovery(remoteStoreImpl, e, op));\n}\n/**\n * Takes a batch of changes from the Datastore, repackages them as a\n * RemoteEvent, and passes that on to the listener, which is typically the\n * SyncEngine.\n */\nfunction raiseWatchSnapshot(remoteStoreImpl, snapshotVersion) {\n    const remoteEvent = remoteStoreImpl.watchChangeAggregator.createRemoteEvent(snapshotVersion);\n    // Update in-memory resume tokens. LocalStore will update the\n    // persistent view of these when applying the completed RemoteEvent.\n    remoteEvent.targetChanges.forEach((change, targetId) => {\n        if (change.resumeToken.approximateByteSize() > 0) {\n            const targetData = remoteStoreImpl.listenTargets.get(targetId);\n            // A watched target might have been removed already.\n            if (targetData) {\n                remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(change.resumeToken, snapshotVersion));\n            }\n        }\n    });\n    // Re-establish listens for the targets that have been invalidated by\n    // existence filter mismatches.\n    remoteEvent.targetMismatches.forEach((targetId, targetPurpose) => {\n        const targetData = remoteStoreImpl.listenTargets.get(targetId);\n        if (!targetData) {\n            // A watched target might have been removed already.\n            return;\n        }\n        // Clear the resume token for the target, since we're in a known mismatch\n        // state.\n        remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(ByteString.EMPTY_BYTE_STRING, targetData.snapshotVersion));\n        // Cause a hard reset by unwatching and rewatching immediately, but\n        // deliberately don't send a resume token so that we get a full update.\n        sendUnwatchRequest(remoteStoreImpl, targetId);\n        // Mark the target we send as being on behalf of an existence filter\n        // mismatch, but don't actually retain that in listenTargets. This ensures\n        // that we flag the first re-listen this way without impacting future\n        // listens of this target (that might happen e.g. on reconnect).\n        const requestTargetData = new TargetData(targetData.target, targetId, targetPurpose, targetData.sequenceNumber);\n        sendWatchRequest(remoteStoreImpl, requestTargetData);\n    });\n    return remoteStoreImpl.remoteSyncer.applyRemoteEvent(remoteEvent);\n}\n/** Handles an error on a target */\nasync function handleTargetError(remoteStoreImpl, watchChange) {\n    const error = watchChange.cause;\n    for (const targetId of watchChange.targetIds) {\n        // A watched target might have been removed already.\n        if (remoteStoreImpl.listenTargets.has(targetId)) {\n            await remoteStoreImpl.remoteSyncer.rejectListen(targetId, error);\n            remoteStoreImpl.listenTargets.delete(targetId);\n            remoteStoreImpl.watchChangeAggregator.removeTarget(targetId);\n        }\n    }\n}\n/**\n * Attempts to fill our write pipeline with writes from the LocalStore.\n *\n * Called internally to bootstrap or refill the write pipeline and by\n * SyncEngine whenever there are new mutations to process.\n *\n * Starts the write stream if necessary.\n */\nasync function fillWritePipeline(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    const writeStream = ensureWriteStream(remoteStoreImpl);\n    let lastBatchIdRetrieved = remoteStoreImpl.writePipeline.length > 0\n        ? remoteStoreImpl.writePipeline[remoteStoreImpl.writePipeline.length - 1]\n            .batchId\n        : BATCHID_UNKNOWN;\n    while (canAddToWritePipeline(remoteStoreImpl)) {\n        try {\n            const batch = await localStoreGetNextMutationBatch(remoteStoreImpl.localStore, lastBatchIdRetrieved);\n            if (batch === null) {\n                if (remoteStoreImpl.writePipeline.length === 0) {\n                    writeStream.markIdle();\n                }\n                break;\n            }\n            else {\n                lastBatchIdRetrieved = batch.batchId;\n                addToWritePipeline(remoteStoreImpl, batch);\n            }\n        }\n        catch (e) {\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\n        }\n    }\n    if (shouldStartWriteStream(remoteStoreImpl)) {\n        startWriteStream(remoteStoreImpl);\n    }\n}\n/**\n * Returns true if we can add to the write pipeline (i.e. the network is\n * enabled and the write pipeline is not full).\n */\nfunction canAddToWritePipeline(remoteStoreImpl) {\n    return (canUseNetwork(remoteStoreImpl) &&\n        remoteStoreImpl.writePipeline.length < MAX_PENDING_WRITES);\n}\n/**\n * Queues additional writes to be sent to the write stream, sending them\n * immediately if the write stream is established.\n */\nfunction addToWritePipeline(remoteStoreImpl, batch) {\n    remoteStoreImpl.writePipeline.push(batch);\n    const writeStream = ensureWriteStream(remoteStoreImpl);\n    if (writeStream.isOpen() && writeStream.handshakeComplete) {\n        writeStream.writeMutations(batch.mutations);\n    }\n}\nfunction shouldStartWriteStream(remoteStoreImpl) {\n    return (canUseNetwork(remoteStoreImpl) &&\n        !ensureWriteStream(remoteStoreImpl).isStarted() &&\n        remoteStoreImpl.writePipeline.length > 0);\n}\nfunction startWriteStream(remoteStoreImpl) {\n    ensureWriteStream(remoteStoreImpl).start();\n}\nasync function onWriteStreamOpen(remoteStoreImpl) {\n    ensureWriteStream(remoteStoreImpl).writeHandshake();\n}\nasync function onWriteHandshakeComplete(remoteStoreImpl) {\n    const writeStream = ensureWriteStream(remoteStoreImpl);\n    // Send the write pipeline now that the stream is established.\n    for (const batch of remoteStoreImpl.writePipeline) {\n        writeStream.writeMutations(batch.mutations);\n    }\n}\nasync function onMutationResult(remoteStoreImpl, commitVersion, results) {\n    const batch = remoteStoreImpl.writePipeline.shift();\n    const success = MutationBatchResult.from(batch, commitVersion, results);\n    await executeWithRecovery(remoteStoreImpl, () => remoteStoreImpl.remoteSyncer.applySuccessfulWrite(success));\n    // It's possible that with the completion of this mutation another\n    // slot has freed up.\n    await fillWritePipeline(remoteStoreImpl);\n}\nasync function onWriteStreamClose(remoteStoreImpl, error) {\n    // If the write stream closed after the write handshake completes, a write\n    // operation failed and we fail the pending operation.\n    if (error && ensureWriteStream(remoteStoreImpl).handshakeComplete) {\n        // This error affects the actual write.\n        await handleWriteError(remoteStoreImpl, error);\n    }\n    // The write stream might have been started by refilling the write\n    // pipeline for failed writes\n    if (shouldStartWriteStream(remoteStoreImpl)) {\n        startWriteStream(remoteStoreImpl);\n    }\n}\nasync function handleWriteError(remoteStoreImpl, error) {\n    // Only handle permanent errors here. If it's transient, just let the retry\n    // logic kick in.\n    if (isPermanentWriteError(error.code)) {\n        // This was a permanent error, the request itself was the problem\n        // so it's not going to succeed if we resend it.\n        const batch = remoteStoreImpl.writePipeline.shift();\n        // In this case it's also unlikely that the server itself is melting\n        // down -- this was just a bad request so inhibit backoff on the next\n        // restart.\n        ensureWriteStream(remoteStoreImpl).inhibitBackoff();\n        await executeWithRecovery(remoteStoreImpl, () => remoteStoreImpl.remoteSyncer.rejectFailedWrite(batch.batchId, error));\n        // It's possible that with the completion of this mutation\n        // another slot has freed up.\n        await fillWritePipeline(remoteStoreImpl);\n    }\n}\nasync function restartNetwork(remoteStore) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    remoteStoreImpl.offlineCauses.add(4 /* OfflineCause.ConnectivityChange */);\n    await disableNetworkInternal(remoteStoreImpl);\n    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n    remoteStoreImpl.offlineCauses.delete(4 /* OfflineCause.ConnectivityChange */);\n    await enableNetworkInternal(remoteStoreImpl);\n}\nasync function remoteStoreHandleCredentialChange(remoteStore, user) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    remoteStoreImpl.asyncQueue.verifyOperationInProgress();\n    logDebug(LOG_TAG$5, 'RemoteStore received new credentials');\n    const usesNetwork = canUseNetwork(remoteStoreImpl);\n    // Tear down and re-create our network streams. This will ensure we get a\n    // fresh auth token for the new user and re-fill the write pipeline with\n    // new mutations from the LocalStore (since mutations are per-user).\n    remoteStoreImpl.offlineCauses.add(3 /* OfflineCause.CredentialChange */);\n    await disableNetworkInternal(remoteStoreImpl);\n    if (usesNetwork) {\n        // Don't set the network status to Unknown if we are offline.\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n    }\n    await remoteStoreImpl.remoteSyncer.handleCredentialChange(user);\n    remoteStoreImpl.offlineCauses.delete(3 /* OfflineCause.CredentialChange */);\n    await enableNetworkInternal(remoteStoreImpl);\n}\n/**\n * Toggles the network state when the client gains or loses its primary lease.\n */\nasync function remoteStoreApplyPrimaryState(remoteStore, isPrimary) {\n    const remoteStoreImpl = debugCast(remoteStore);\n    if (isPrimary) {\n        remoteStoreImpl.offlineCauses.delete(2 /* OfflineCause.IsSecondary */);\n        await enableNetworkInternal(remoteStoreImpl);\n    }\n    else if (!isPrimary) {\n        remoteStoreImpl.offlineCauses.add(2 /* OfflineCause.IsSecondary */);\n        await disableNetworkInternal(remoteStoreImpl);\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n    }\n}\n/**\n * If not yet initialized, registers the WatchStream and its network state\n * callback with `remoteStoreImpl`. Returns the existing stream if one is\n * already available.\n *\n * PORTING NOTE: On iOS and Android, the WatchStream gets registered on startup.\n * This is not done on Web to allow it to be tree-shaken.\n */\nfunction ensureWatchStream(remoteStoreImpl) {\n    if (!remoteStoreImpl.watchStream) {\n        // Create stream (but note that it is not started yet).\n        remoteStoreImpl.watchStream = newPersistentWatchStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {\n            onConnected: onWatchStreamConnected.bind(null, remoteStoreImpl),\n            onOpen: onWatchStreamOpen.bind(null, remoteStoreImpl),\n            onClose: onWatchStreamClose.bind(null, remoteStoreImpl),\n            onWatchChange: onWatchStreamChange.bind(null, remoteStoreImpl)\n        });\n        remoteStoreImpl.onNetworkStatusChange.push(async (enabled) => {\n            if (enabled) {\n                remoteStoreImpl.watchStream.inhibitBackoff();\n                if (shouldStartWatchStream(remoteStoreImpl)) {\n                    startWatchStream(remoteStoreImpl);\n                }\n                else {\n                    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* OnlineState.Unknown */);\n                }\n            }\n            else {\n                await remoteStoreImpl.watchStream.stop();\n                cleanUpWatchStreamState(remoteStoreImpl);\n            }\n        });\n    }\n    return remoteStoreImpl.watchStream;\n}\n/**\n * If not yet initialized, registers the WriteStream and its network state\n * callback with `remoteStoreImpl`. Returns the existing stream if one is\n * already available.\n *\n * PORTING NOTE: On iOS and Android, the WriteStream gets registered on startup.\n * This is not done on Web to allow it to be tree-shaken.\n */\nfunction ensureWriteStream(remoteStoreImpl) {\n    if (!remoteStoreImpl.writeStream) {\n        // Create stream (but note that it is not started yet).\n        remoteStoreImpl.writeStream = newPersistentWriteStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {\n            onConnected: () => Promise.resolve(),\n            onOpen: onWriteStreamOpen.bind(null, remoteStoreImpl),\n            onClose: onWriteStreamClose.bind(null, remoteStoreImpl),\n            onHandshakeComplete: onWriteHandshakeComplete.bind(null, remoteStoreImpl),\n            onMutationResult: onMutationResult.bind(null, remoteStoreImpl)\n        });\n        remoteStoreImpl.onNetworkStatusChange.push(async (enabled) => {\n            if (enabled) {\n                remoteStoreImpl.writeStream.inhibitBackoff();\n                // This will start the write stream if necessary.\n                await fillWritePipeline(remoteStoreImpl);\n            }\n            else {\n                await remoteStoreImpl.writeStream.stop();\n                if (remoteStoreImpl.writePipeline.length > 0) {\n                    logDebug(LOG_TAG$5, `Stopping write stream with ${remoteStoreImpl.writePipeline.length} pending writes`);\n                    remoteStoreImpl.writePipeline = [];\n                }\n            }\n        });\n    }\n    return remoteStoreImpl.writeStream;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$4 = 'AsyncQueue';\n/**\n * Represents an operation scheduled to be run in the future on an AsyncQueue.\n *\n * It is created via DelayedOperation.createAndSchedule().\n *\n * Supports cancellation (via cancel()) and early execution (via skipDelay()).\n *\n * Note: We implement `PromiseLike` instead of `Promise`, as the `Promise` type\n * in newer versions of TypeScript defines `finally`, which is not available in\n * IE.\n */\nclass DelayedOperation {\n    constructor(asyncQueue, timerId, targetTimeMs, op, removalCallback) {\n        this.asyncQueue = asyncQueue;\n        this.timerId = timerId;\n        this.targetTimeMs = targetTimeMs;\n        this.op = op;\n        this.removalCallback = removalCallback;\n        this.deferred = new Deferred();\n        this.then = this.deferred.promise.then.bind(this.deferred.promise);\n        // It's normal for the deferred promise to be canceled (due to cancellation)\n        // and so we attach a dummy catch callback to avoid\n        // 'UnhandledPromiseRejectionWarning' log spam.\n        this.deferred.promise.catch(err => { });\n    }\n    get promise() {\n        return this.deferred.promise;\n    }\n    /**\n     * Creates and returns a DelayedOperation that has been scheduled to be\n     * executed on the provided asyncQueue after the provided delayMs.\n     *\n     * @param asyncQueue - The queue to schedule the operation on.\n     * @param id - A Timer ID identifying the type of operation this is.\n     * @param delayMs - The delay (ms) before the operation should be scheduled.\n     * @param op - The operation to run.\n     * @param removalCallback - A callback to be called synchronously once the\n     *   operation is executed or canceled, notifying the AsyncQueue to remove it\n     *   from its delayedOperations list.\n     *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and\n     *   the DelayedOperation class public.\n     */\n    static createAndSchedule(asyncQueue, timerId, delayMs, op, removalCallback) {\n        const targetTime = Date.now() + delayMs;\n        const delayedOp = new DelayedOperation(asyncQueue, timerId, targetTime, op, removalCallback);\n        delayedOp.start(delayMs);\n        return delayedOp;\n    }\n    /**\n     * Starts the timer. This is called immediately after construction by\n     * createAndSchedule().\n     */\n    start(delayMs) {\n        this.timerHandle = setTimeout(() => this.handleDelayElapsed(), delayMs);\n    }\n    /**\n     * Queues the operation to run immediately (if it hasn't already been run or\n     * canceled).\n     */\n    skipDelay() {\n        return this.handleDelayElapsed();\n    }\n    /**\n     * Cancels the operation if it hasn't already been executed or canceled. The\n     * promise will be rejected.\n     *\n     * As long as the operation has not yet been run, calling cancel() provides a\n     * guarantee that the operation will not be run.\n     */\n    cancel(reason) {\n        if (this.timerHandle !== null) {\n            this.clearTimeout();\n            this.deferred.reject(new FirestoreError(Code.CANCELLED, 'Operation cancelled' + (reason ? ': ' + reason : '')));\n        }\n    }\n    handleDelayElapsed() {\n        this.asyncQueue.enqueueAndForget(() => {\n            if (this.timerHandle !== null) {\n                this.clearTimeout();\n                return this.op().then(result => {\n                    return this.deferred.resolve(result);\n                });\n            }\n            else {\n                return Promise.resolve();\n            }\n        });\n    }\n    clearTimeout() {\n        if (this.timerHandle !== null) {\n            this.removalCallback(this);\n            clearTimeout(this.timerHandle);\n            this.timerHandle = null;\n        }\n    }\n}\n/**\n * Returns a FirestoreError that can be surfaced to the user if the provided\n * error is an IndexedDbTransactionError. Re-throws the error otherwise.\n */\nfunction wrapInUserErrorIfRecoverable(e, msg) {\n    logError(LOG_TAG$4, `${msg}: ${e}`);\n    if (isIndexedDbTransactionError(e)) {\n        return new FirestoreError(Code.UNAVAILABLE, `${msg}: ${e}`);\n    }\n    else {\n        throw e;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\n * in order specified by the provided comparator. We always add a document key\n * comparator on top of what is provided to guarantee document equality based on\n * the key.\n */\nclass DocumentSet {\n    /**\n     * Returns an empty copy of the existing DocumentSet, using the same\n     * comparator.\n     */\n    static emptySet(oldSet) {\n        return new DocumentSet(oldSet.comparator);\n    }\n    /** The default ordering is by key if the comparator is omitted */\n    constructor(comp) {\n        // We are adding document key comparator to the end as it's the only\n        // guaranteed unique property of a document.\n        if (comp) {\n            this.comparator = (d1, d2) => comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);\n        }\n        else {\n            this.comparator = (d1, d2) => DocumentKey.comparator(d1.key, d2.key);\n        }\n        this.keyedMap = documentMap();\n        this.sortedSet = new SortedMap(this.comparator);\n    }\n    has(key) {\n        return this.keyedMap.get(key) != null;\n    }\n    get(key) {\n        return this.keyedMap.get(key);\n    }\n    first() {\n        return this.sortedSet.minKey();\n    }\n    last() {\n        return this.sortedSet.maxKey();\n    }\n    isEmpty() {\n        return this.sortedSet.isEmpty();\n    }\n    /**\n     * Returns the index of the provided key in the document set, or -1 if the\n     * document key is not present in the set;\n     */\n    indexOf(key) {\n        const doc = this.keyedMap.get(key);\n        return doc ? this.sortedSet.indexOf(doc) : -1;\n    }\n    get size() {\n        return this.sortedSet.size;\n    }\n    /** Iterates documents in order defined by \"comparator\" */\n    forEach(cb) {\n        this.sortedSet.inorderTraversal((k, v) => {\n            cb(k);\n            return false;\n        });\n    }\n    /** Inserts or updates a document with the same key */\n    add(doc) {\n        // First remove the element if we have it.\n        const set = this.delete(doc.key);\n        return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));\n    }\n    /** Deletes a document with a given key */\n    delete(key) {\n        const doc = this.get(key);\n        if (!doc) {\n            return this;\n        }\n        return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\n    }\n    isEqual(other) {\n        if (!(other instanceof DocumentSet)) {\n            return false;\n        }\n        if (this.size !== other.size) {\n            return false;\n        }\n        const thisIt = this.sortedSet.getIterator();\n        const otherIt = other.sortedSet.getIterator();\n        while (thisIt.hasNext()) {\n            const thisDoc = thisIt.getNext().key;\n            const otherDoc = otherIt.getNext().key;\n            if (!thisDoc.isEqual(otherDoc)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    toString() {\n        const docStrings = [];\n        this.forEach(doc => {\n            docStrings.push(doc.toString());\n        });\n        if (docStrings.length === 0) {\n            return 'DocumentSet ()';\n        }\n        else {\n            return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\n        }\n    }\n    copy(keyedMap, sortedSet) {\n        const newSet = new DocumentSet();\n        newSet.comparator = this.comparator;\n        newSet.keyedMap = keyedMap;\n        newSet.sortedSet = sortedSet;\n        return newSet;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * DocumentChangeSet keeps track of a set of changes to docs in a query, merging\n * duplicate events for the same doc.\n */\nclass DocumentChangeSet {\n    constructor() {\n        this.changeMap = new SortedMap(DocumentKey.comparator);\n    }\n    track(change) {\n        const key = change.doc.key;\n        const oldChange = this.changeMap.get(key);\n        if (!oldChange) {\n            this.changeMap = this.changeMap.insert(key, change);\n            return;\n        }\n        // Merge the new change with the existing change.\n        if (change.type !== 0 /* ChangeType.Added */ &&\n            oldChange.type === 3 /* ChangeType.Metadata */) {\n            this.changeMap = this.changeMap.insert(key, change);\n        }\n        else if (change.type === 3 /* ChangeType.Metadata */ &&\n            oldChange.type !== 1 /* ChangeType.Removed */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: oldChange.type,\n                doc: change.doc\n            });\n        }\n        else if (change.type === 2 /* ChangeType.Modified */ &&\n            oldChange.type === 2 /* ChangeType.Modified */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: 2 /* ChangeType.Modified */,\n                doc: change.doc\n            });\n        }\n        else if (change.type === 2 /* ChangeType.Modified */ &&\n            oldChange.type === 0 /* ChangeType.Added */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: 0 /* ChangeType.Added */,\n                doc: change.doc\n            });\n        }\n        else if (change.type === 1 /* ChangeType.Removed */ &&\n            oldChange.type === 0 /* ChangeType.Added */) {\n            this.changeMap = this.changeMap.remove(key);\n        }\n        else if (change.type === 1 /* ChangeType.Removed */ &&\n            oldChange.type === 2 /* ChangeType.Modified */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: 1 /* ChangeType.Removed */,\n                doc: oldChange.doc\n            });\n        }\n        else if (change.type === 0 /* ChangeType.Added */ &&\n            oldChange.type === 1 /* ChangeType.Removed */) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: 2 /* ChangeType.Modified */,\n                doc: change.doc\n            });\n        }\n        else {\n            // This includes these cases, which don't make sense:\n            // Added->Added\n            // Removed->Removed\n            // Modified->Added\n            // Removed->Modified\n            // Metadata->Added\n            // Removed->Metadata\n            fail();\n        }\n    }\n    getChanges() {\n        const changes = [];\n        this.changeMap.inorderTraversal((key, change) => {\n            changes.push(change);\n        });\n        return changes;\n    }\n}\nclass ViewSnapshot {\n    constructor(query, docs, oldDocs, docChanges, mutatedKeys, fromCache, syncStateChanged, excludesMetadataChanges, hasCachedResults) {\n        this.query = query;\n        this.docs = docs;\n        this.oldDocs = oldDocs;\n        this.docChanges = docChanges;\n        this.mutatedKeys = mutatedKeys;\n        this.fromCache = fromCache;\n        this.syncStateChanged = syncStateChanged;\n        this.excludesMetadataChanges = excludesMetadataChanges;\n        this.hasCachedResults = hasCachedResults;\n    }\n    /** Returns a view snapshot as if all documents in the snapshot were added. */\n    static fromInitialDocuments(query, documents, mutatedKeys, fromCache, hasCachedResults) {\n        const changes = [];\n        documents.forEach(doc => {\n            changes.push({ type: 0 /* ChangeType.Added */, doc });\n        });\n        return new ViewSnapshot(query, documents, DocumentSet.emptySet(documents), changes, mutatedKeys, fromCache, \n        /* syncStateChanged= */ true, \n        /* excludesMetadataChanges= */ false, hasCachedResults);\n    }\n    get hasPendingWrites() {\n        return !this.mutatedKeys.isEmpty();\n    }\n    isEqual(other) {\n        if (this.fromCache !== other.fromCache ||\n            this.hasCachedResults !== other.hasCachedResults ||\n            this.syncStateChanged !== other.syncStateChanged ||\n            !this.mutatedKeys.isEqual(other.mutatedKeys) ||\n            !queryEquals(this.query, other.query) ||\n            !this.docs.isEqual(other.docs) ||\n            !this.oldDocs.isEqual(other.oldDocs)) {\n            return false;\n        }\n        const changes = this.docChanges;\n        const otherChanges = other.docChanges;\n        if (changes.length !== otherChanges.length) {\n            return false;\n        }\n        for (let i = 0; i < changes.length; i++) {\n            if (changes[i].type !== otherChanges[i].type ||\n                !changes[i].doc.isEqual(otherChanges[i].doc)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Holds the listeners and the last received ViewSnapshot for a query being\n * tracked by EventManager.\n */\nclass QueryListenersInfo {\n    constructor() {\n        this.viewSnap = undefined;\n        this.listeners = [];\n    }\n    // Helper methods that checks if the query has listeners that listening to remote store\n    hasRemoteListeners() {\n        return this.listeners.some(listener => listener.listensToRemoteStore());\n    }\n}\nfunction newEventManager() {\n    return new EventManagerImpl();\n}\nclass EventManagerImpl {\n    constructor() {\n        this.queries = newQueriesObjectMap();\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\n        this.snapshotsInSyncListeners = new Set();\n    }\n    terminate() {\n        errorAllTargets(this, new FirestoreError(Code.ABORTED, 'Firestore shutting down'));\n    }\n}\nfunction newQueriesObjectMap() {\n    return new ObjectMap(q => canonifyQuery(q), queryEquals);\n}\nasync function eventManagerListen(eventManager, listener) {\n    const eventManagerImpl = debugCast(eventManager);\n    let listenerAction = 3 /* ListenerSetupAction.NoActionRequired */;\n    const query = listener.query;\n    let queryInfo = eventManagerImpl.queries.get(query);\n    if (!queryInfo) {\n        queryInfo = new QueryListenersInfo();\n        listenerAction = listener.listensToRemoteStore()\n            ? 0 /* ListenerSetupAction.InitializeLocalListenAndRequireWatchConnection */\n            : 1 /* ListenerSetupAction.InitializeLocalListenOnly */;\n    }\n    else if (!queryInfo.hasRemoteListeners() &&\n        listener.listensToRemoteStore()) {\n        // Query has been listening to local cache, and tries to add a new listener sourced from watch.\n        listenerAction = 2 /* ListenerSetupAction.RequireWatchConnectionOnly */;\n    }\n    try {\n        switch (listenerAction) {\n            case 0 /* ListenerSetupAction.InitializeLocalListenAndRequireWatchConnection */:\n                queryInfo.viewSnap = await eventManagerImpl.onListen(query, \n                /** enableRemoteListen= */ true);\n                break;\n            case 1 /* ListenerSetupAction.InitializeLocalListenOnly */:\n                queryInfo.viewSnap = await eventManagerImpl.onListen(query, \n                /** enableRemoteListen= */ false);\n                break;\n            case 2 /* ListenerSetupAction.RequireWatchConnectionOnly */:\n                await eventManagerImpl.onFirstRemoteStoreListen(query);\n                break;\n            default:\n                break;\n        }\n    }\n    catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Initialization of query '${stringifyQuery(listener.query)}' failed`);\n        listener.onError(firestoreError);\n        return;\n    }\n    eventManagerImpl.queries.set(query, queryInfo);\n    queryInfo.listeners.push(listener);\n    // Run global snapshot listeners if a consistent snapshot has been emitted.\n    listener.applyOnlineStateChange(eventManagerImpl.onlineState);\n    if (queryInfo.viewSnap) {\n        const raisedEvent = listener.onViewSnapshot(queryInfo.viewSnap);\n        if (raisedEvent) {\n            raiseSnapshotsInSyncEvent(eventManagerImpl);\n        }\n    }\n}\nasync function eventManagerUnlisten(eventManager, listener) {\n    const eventManagerImpl = debugCast(eventManager);\n    const query = listener.query;\n    let listenerAction = 3 /* ListenerRemovalAction.NoActionRequired */;\n    const queryInfo = eventManagerImpl.queries.get(query);\n    if (queryInfo) {\n        const i = queryInfo.listeners.indexOf(listener);\n        if (i >= 0) {\n            queryInfo.listeners.splice(i, 1);\n            if (queryInfo.listeners.length === 0) {\n                listenerAction = listener.listensToRemoteStore()\n                    ? 0 /* ListenerRemovalAction.TerminateLocalListenAndRequireWatchDisconnection */\n                    : 1 /* ListenerRemovalAction.TerminateLocalListenOnly */;\n            }\n            else if (!queryInfo.hasRemoteListeners() &&\n                listener.listensToRemoteStore()) {\n                // The removed listener is the last one that sourced from watch.\n                listenerAction = 2 /* ListenerRemovalAction.RequireWatchDisconnectionOnly */;\n            }\n        }\n    }\n    switch (listenerAction) {\n        case 0 /* ListenerRemovalAction.TerminateLocalListenAndRequireWatchDisconnection */:\n            eventManagerImpl.queries.delete(query);\n            return eventManagerImpl.onUnlisten(query, \n            /** disableRemoteListen= */ true);\n        case 1 /* ListenerRemovalAction.TerminateLocalListenOnly */:\n            eventManagerImpl.queries.delete(query);\n            return eventManagerImpl.onUnlisten(query, \n            /** disableRemoteListen= */ false);\n        case 2 /* ListenerRemovalAction.RequireWatchDisconnectionOnly */:\n            return eventManagerImpl.onLastRemoteStoreUnlisten(query);\n        default:\n            return;\n    }\n}\nfunction eventManagerOnWatchChange(eventManager, viewSnaps) {\n    const eventManagerImpl = debugCast(eventManager);\n    let raisedEvent = false;\n    for (const viewSnap of viewSnaps) {\n        const query = viewSnap.query;\n        const queryInfo = eventManagerImpl.queries.get(query);\n        if (queryInfo) {\n            for (const listener of queryInfo.listeners) {\n                if (listener.onViewSnapshot(viewSnap)) {\n                    raisedEvent = true;\n                }\n            }\n            queryInfo.viewSnap = viewSnap;\n        }\n    }\n    if (raisedEvent) {\n        raiseSnapshotsInSyncEvent(eventManagerImpl);\n    }\n}\nfunction eventManagerOnWatchError(eventManager, query, error) {\n    const eventManagerImpl = debugCast(eventManager);\n    const queryInfo = eventManagerImpl.queries.get(query);\n    if (queryInfo) {\n        for (const listener of queryInfo.listeners) {\n            listener.onError(error);\n        }\n    }\n    // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()\n    // after an error.\n    eventManagerImpl.queries.delete(query);\n}\nfunction eventManagerOnOnlineStateChange(eventManager, onlineState) {\n    const eventManagerImpl = debugCast(eventManager);\n    eventManagerImpl.onlineState = onlineState;\n    let raisedEvent = false;\n    eventManagerImpl.queries.forEach((_, queryInfo) => {\n        for (const listener of queryInfo.listeners) {\n            // Run global snapshot listeners if a consistent snapshot has been emitted.\n            if (listener.applyOnlineStateChange(onlineState)) {\n                raisedEvent = true;\n            }\n        }\n    });\n    if (raisedEvent) {\n        raiseSnapshotsInSyncEvent(eventManagerImpl);\n    }\n}\nfunction addSnapshotsInSyncListener(eventManager, observer) {\n    const eventManagerImpl = debugCast(eventManager);\n    eventManagerImpl.snapshotsInSyncListeners.add(observer);\n    // Immediately fire an initial event, indicating all existing listeners\n    // are in-sync.\n    observer.next();\n}\nfunction removeSnapshotsInSyncListener(eventManager, observer) {\n    const eventManagerImpl = debugCast(eventManager);\n    eventManagerImpl.snapshotsInSyncListeners.delete(observer);\n}\nfunction errorAllTargets(eventManager, error) {\n    const eventManagerImpl = debugCast(eventManager);\n    const queries = eventManagerImpl.queries;\n    // Prevent further access by clearing ObjectMap.\n    eventManagerImpl.queries = newQueriesObjectMap();\n    queries.forEach((_, queryInfo) => {\n        for (const listener of queryInfo.listeners) {\n            listener.onError(error);\n        }\n    });\n}\n// Call all global snapshot listeners that have been set.\nfunction raiseSnapshotsInSyncEvent(eventManagerImpl) {\n    eventManagerImpl.snapshotsInSyncListeners.forEach(observer => {\n        observer.next();\n    });\n}\nvar ListenerDataSource;\n(function (ListenerDataSource) {\n    /** Listen to both cache and server changes */\n    ListenerDataSource[\"Default\"] = \"default\";\n    /** Listen to changes in cache only */\n    ListenerDataSource[\"Cache\"] = \"cache\";\n})(ListenerDataSource || (ListenerDataSource = {}));\n/**\n * QueryListener takes a series of internal view snapshots and determines\n * when to raise the event.\n *\n * It uses an Observer to dispatch events.\n */\nclass QueryListener {\n    constructor(query, queryObserver, options) {\n        this.query = query;\n        this.queryObserver = queryObserver;\n        /**\n         * Initial snapshots (e.g. from cache) may not be propagated to the wrapped\n         * observer. This flag is set to true once we've actually raised an event.\n         */\n        this.raisedInitialEvent = false;\n        this.snap = null;\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\n        this.options = options || {};\n    }\n    /**\n     * Applies the new ViewSnapshot to this listener, raising a user-facing event\n     * if applicable (depending on what changed, whether the user has opted into\n     * metadata-only changes, etc.). Returns true if a user-facing event was\n     * indeed raised.\n     */\n    onViewSnapshot(snap) {\n        if (!this.options.includeMetadataChanges) {\n            // Remove the metadata only changes.\n            const docChanges = [];\n            for (const docChange of snap.docChanges) {\n                if (docChange.type !== 3 /* ChangeType.Metadata */) {\n                    docChanges.push(docChange);\n                }\n            }\n            snap = new ViewSnapshot(snap.query, snap.docs, snap.oldDocs, docChanges, snap.mutatedKeys, snap.fromCache, snap.syncStateChanged, \n            /* excludesMetadataChanges= */ true, snap.hasCachedResults);\n        }\n        let raisedEvent = false;\n        if (!this.raisedInitialEvent) {\n            if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {\n                this.raiseInitialEvent(snap);\n                raisedEvent = true;\n            }\n        }\n        else if (this.shouldRaiseEvent(snap)) {\n            this.queryObserver.next(snap);\n            raisedEvent = true;\n        }\n        this.snap = snap;\n        return raisedEvent;\n    }\n    onError(error) {\n        this.queryObserver.error(error);\n    }\n    /** Returns whether a snapshot was raised. */\n    applyOnlineStateChange(onlineState) {\n        this.onlineState = onlineState;\n        let raisedEvent = false;\n        if (this.snap &&\n            !this.raisedInitialEvent &&\n            this.shouldRaiseInitialEvent(this.snap, onlineState)) {\n            this.raiseInitialEvent(this.snap);\n            raisedEvent = true;\n        }\n        return raisedEvent;\n    }\n    shouldRaiseInitialEvent(snap, onlineState) {\n        // Always raise the first event when we're synced\n        if (!snap.fromCache) {\n            return true;\n        }\n        // Always raise event if listening to cache\n        if (!this.listensToRemoteStore()) {\n            return true;\n        }\n        // NOTE: We consider OnlineState.Unknown as online (it should become Offline\n        // or Online if we wait long enough).\n        const maybeOnline = onlineState !== \"Offline\" /* OnlineState.Offline */;\n        // Don't raise the event if we're online, aren't synced yet (checked\n        // above) and are waiting for a sync.\n        if (this.options.waitForSyncWhenOnline && maybeOnline) {\n            return false;\n        }\n        // Raise data from cache if we have any documents, have cached results before,\n        // or we are offline.\n        return (!snap.docs.isEmpty() ||\n            snap.hasCachedResults ||\n            onlineState === \"Offline\" /* OnlineState.Offline */);\n    }\n    shouldRaiseEvent(snap) {\n        // We don't need to handle includeDocumentMetadataChanges here because\n        // the Metadata only changes have already been stripped out if needed.\n        // At this point the only changes we will see are the ones we should\n        // propagate.\n        if (snap.docChanges.length > 0) {\n            return true;\n        }\n        const hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;\n        if (snap.syncStateChanged || hasPendingWritesChanged) {\n            return this.options.includeMetadataChanges === true;\n        }\n        // Generally we should have hit one of the cases above, but it's possible\n        // to get here if there were only metadata docChanges and they got\n        // stripped out.\n        return false;\n    }\n    raiseInitialEvent(snap) {\n        snap = ViewSnapshot.fromInitialDocuments(snap.query, snap.docs, snap.mutatedKeys, snap.fromCache, snap.hasCachedResults);\n        this.raisedInitialEvent = true;\n        this.queryObserver.next(snap);\n    }\n    listensToRemoteStore() {\n        return this.options.source !== ListenerDataSource.Cache;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A set of changes to what documents are currently in view and out of view for\n * a given query. These changes are sent to the LocalStore by the View (via\n * the SyncEngine) and are used to pin / unpin documents as appropriate.\n */\nclass LocalViewChanges {\n    constructor(targetId, fromCache, addedKeys, removedKeys) {\n        this.targetId = targetId;\n        this.fromCache = fromCache;\n        this.addedKeys = addedKeys;\n        this.removedKeys = removedKeys;\n    }\n    static fromSnapshot(targetId, viewSnapshot) {\n        let addedKeys = documentKeySet();\n        let removedKeys = documentKeySet();\n        for (const docChange of viewSnapshot.docChanges) {\n            switch (docChange.type) {\n                case 0 /* ChangeType.Added */:\n                    addedKeys = addedKeys.add(docChange.doc.key);\n                    break;\n                case 1 /* ChangeType.Removed */:\n                    removedKeys = removedKeys.add(docChange.doc.key);\n                    break;\n                // do nothing\n            }\n        }\n        return new LocalViewChanges(targetId, viewSnapshot.fromCache, addedKeys, removedKeys);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Helper to convert objects from bundles to model objects in the SDK.\n */\nclass BundleConverterImpl {\n    constructor(serializer) {\n        this.serializer = serializer;\n    }\n    toDocumentKey(name) {\n        return fromName(this.serializer, name);\n    }\n    /**\n     * Converts a BundleDocument to a MutableDocument.\n     */\n    toMutableDocument(bundledDoc) {\n        if (bundledDoc.metadata.exists) {\n            return fromDocument(this.serializer, bundledDoc.document, false);\n        }\n        else {\n            return MutableDocument.newNoDocument(this.toDocumentKey(bundledDoc.metadata.name), this.toSnapshotVersion(bundledDoc.metadata.readTime));\n        }\n    }\n    toSnapshotVersion(time) {\n        return fromVersion(time);\n    }\n}\n/**\n * A class to process the elements from a bundle, load them into local\n * storage and provide progress update while loading.\n */\nclass BundleLoader {\n    constructor(bundleMetadata, localStore, serializer) {\n        this.bundleMetadata = bundleMetadata;\n        this.localStore = localStore;\n        this.serializer = serializer;\n        /** Batched queries to be saved into storage */\n        this.queries = [];\n        /** Batched documents to be saved into storage */\n        this.documents = [];\n        /** The collection groups affected by this bundle. */\n        this.collectionGroups = new Set();\n        this.progress = bundleInitialProgress(bundleMetadata);\n    }\n    /**\n     * Adds an element from the bundle to the loader.\n     *\n     * Returns a new progress if adding the element leads to a new progress,\n     * otherwise returns null.\n     */\n    addSizedElement(element) {\n        this.progress.bytesLoaded += element.byteLength;\n        let documentsLoaded = this.progress.documentsLoaded;\n        if (element.payload.namedQuery) {\n            this.queries.push(element.payload.namedQuery);\n        }\n        else if (element.payload.documentMetadata) {\n            this.documents.push({ metadata: element.payload.documentMetadata });\n            if (!element.payload.documentMetadata.exists) {\n                ++documentsLoaded;\n            }\n            const path = ResourcePath.fromString(element.payload.documentMetadata.name);\n            this.collectionGroups.add(path.get(path.length - 2));\n        }\n        else if (element.payload.document) {\n            this.documents[this.documents.length - 1].document =\n                element.payload.document;\n            ++documentsLoaded;\n        }\n        if (documentsLoaded !== this.progress.documentsLoaded) {\n            this.progress.documentsLoaded = documentsLoaded;\n            return Object.assign({}, this.progress);\n        }\n        return null;\n    }\n    getQueryDocumentMapping(documents) {\n        const queryDocumentMap = new Map();\n        const bundleConverter = new BundleConverterImpl(this.serializer);\n        for (const bundleDoc of documents) {\n            if (bundleDoc.metadata.queries) {\n                const documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);\n                for (const queryName of bundleDoc.metadata.queries) {\n                    const documentKeys = (queryDocumentMap.get(queryName) || documentKeySet()).add(documentKey);\n                    queryDocumentMap.set(queryName, documentKeys);\n                }\n            }\n        }\n        return queryDocumentMap;\n    }\n    /**\n     * Update the progress to 'Success' and return the updated progress.\n     */\n    async complete() {\n        const changedDocs = await localStoreApplyBundledDocuments(this.localStore, new BundleConverterImpl(this.serializer), this.documents, this.bundleMetadata.id);\n        const queryDocumentMap = this.getQueryDocumentMapping(this.documents);\n        for (const q of this.queries) {\n            await localStoreSaveNamedQuery(this.localStore, q, queryDocumentMap.get(q.name));\n        }\n        this.progress.taskState = 'Success';\n        return {\n            progress: this.progress,\n            changedCollectionGroups: this.collectionGroups,\n            changedDocs\n        };\n    }\n}\n/**\n * Returns a `LoadBundleTaskProgress` representing the initial progress of\n * loading a bundle.\n */\nfunction bundleInitialProgress(metadata) {\n    return {\n        taskState: 'Running',\n        documentsLoaded: 0,\n        bytesLoaded: 0,\n        totalDocuments: metadata.totalDocuments,\n        totalBytes: metadata.totalBytes\n    };\n}\n/**\n * Returns a `LoadBundleTaskProgress` representing the progress that the loading\n * has succeeded.\n */\nfunction bundleSuccessProgress(metadata) {\n    return {\n        taskState: 'Success',\n        documentsLoaded: metadata.totalDocuments,\n        bytesLoaded: metadata.totalBytes,\n        totalDocuments: metadata.totalDocuments,\n        totalBytes: metadata.totalBytes\n    };\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass AddedLimboDocument {\n    constructor(key) {\n        this.key = key;\n    }\n}\nclass RemovedLimboDocument {\n    constructor(key) {\n        this.key = key;\n    }\n}\n/**\n * View is responsible for computing the final merged truth of what docs are in\n * a query. It gets notified of local and remote changes to docs, and applies\n * the query filters and limits to determine the most correct possible results.\n */\nclass View {\n    constructor(query, \n    /** Documents included in the remote target */\n    _syncedDocuments) {\n        this.query = query;\n        this._syncedDocuments = _syncedDocuments;\n        this.syncState = null;\n        this.hasCachedResults = false;\n        /**\n         * A flag whether the view is current with the backend. A view is considered\n         * current after it has seen the current flag from the backend and did not\n         * lose consistency within the watch stream (e.g. because of an existence\n         * filter mismatch).\n         */\n        this.current = false;\n        /** Documents in the view but not in the remote target */\n        this.limboDocuments = documentKeySet();\n        /** Document Keys that have local changes */\n        this.mutatedKeys = documentKeySet();\n        this.docComparator = newQueryComparator(query);\n        this.documentSet = new DocumentSet(this.docComparator);\n    }\n    /**\n     * The set of remote documents that the server has told us belongs to the target associated with\n     * this view.\n     */\n    get syncedDocuments() {\n        return this._syncedDocuments;\n    }\n    /**\n     * Iterates over a set of doc changes, applies the query limit, and computes\n     * what the new results should be, what the changes were, and whether we may\n     * need to go back to the local cache for more results. Does not make any\n     * changes to the view.\n     * @param docChanges - The doc changes to apply to this view.\n     * @param previousChanges - If this is being called with a refill, then start\n     *        with this set of docs and changes instead of the current view.\n     * @returns a new set of docs, changes, and refill flag.\n     */\n    computeDocChanges(docChanges, previousChanges) {\n        const changeSet = previousChanges\n            ? previousChanges.changeSet\n            : new DocumentChangeSet();\n        const oldDocumentSet = previousChanges\n            ? previousChanges.documentSet\n            : this.documentSet;\n        let newMutatedKeys = previousChanges\n            ? previousChanges.mutatedKeys\n            : this.mutatedKeys;\n        let newDocumentSet = oldDocumentSet;\n        let needsRefill = false;\n        // Track the last doc in a (full) limit. This is necessary, because some\n        // update (a delete, or an update moving a doc past the old limit) might\n        // mean there is some other document in the local cache that either should\n        // come (1) between the old last limit doc and the new last document, in the\n        // case of updates, or (2) after the new last document, in the case of\n        // deletes. So we keep this doc at the old limit to compare the updates to.\n        //\n        // Note that this should never get used in a refill (when previousChanges is\n        // set), because there will only be adds -- no deletes or updates.\n        const lastDocInLimit = this.query.limitType === \"F\" /* LimitType.First */ &&\n            oldDocumentSet.size === this.query.limit\n            ? oldDocumentSet.last()\n            : null;\n        const firstDocInLimit = this.query.limitType === \"L\" /* LimitType.Last */ &&\n            oldDocumentSet.size === this.query.limit\n            ? oldDocumentSet.first()\n            : null;\n        docChanges.inorderTraversal((key, entry) => {\n            const oldDoc = oldDocumentSet.get(key);\n            const newDoc = queryMatches(this.query, entry) ? entry : null;\n            const oldDocHadPendingMutations = oldDoc\n                ? this.mutatedKeys.has(oldDoc.key)\n                : false;\n            const newDocHasPendingMutations = newDoc\n                ? newDoc.hasLocalMutations ||\n                    // We only consider committed mutations for documents that were\n                    // mutated during the lifetime of the view.\n                    (this.mutatedKeys.has(newDoc.key) && newDoc.hasCommittedMutations)\n                : false;\n            let changeApplied = false;\n            // Calculate change\n            if (oldDoc && newDoc) {\n                const docsEqual = oldDoc.data.isEqual(newDoc.data);\n                if (!docsEqual) {\n                    if (!this.shouldWaitForSyncedDocument(oldDoc, newDoc)) {\n                        changeSet.track({\n                            type: 2 /* ChangeType.Modified */,\n                            doc: newDoc\n                        });\n                        changeApplied = true;\n                        if ((lastDocInLimit &&\n                            this.docComparator(newDoc, lastDocInLimit) > 0) ||\n                            (firstDocInLimit &&\n                                this.docComparator(newDoc, firstDocInLimit) < 0)) {\n                            // This doc moved from inside the limit to outside the limit.\n                            // That means there may be some other doc in the local cache\n                            // that should be included instead.\n                            needsRefill = true;\n                        }\n                    }\n                }\n                else if (oldDocHadPendingMutations !== newDocHasPendingMutations) {\n                    changeSet.track({ type: 3 /* ChangeType.Metadata */, doc: newDoc });\n                    changeApplied = true;\n                }\n            }\n            else if (!oldDoc && newDoc) {\n                changeSet.track({ type: 0 /* ChangeType.Added */, doc: newDoc });\n                changeApplied = true;\n            }\n            else if (oldDoc && !newDoc) {\n                changeSet.track({ type: 1 /* ChangeType.Removed */, doc: oldDoc });\n                changeApplied = true;\n                if (lastDocInLimit || firstDocInLimit) {\n                    // A doc was removed from a full limit query. We'll need to\n                    // requery from the local cache to see if we know about some other\n                    // doc that should be in the results.\n                    needsRefill = true;\n                }\n            }\n            if (changeApplied) {\n                if (newDoc) {\n                    newDocumentSet = newDocumentSet.add(newDoc);\n                    if (newDocHasPendingMutations) {\n                        newMutatedKeys = newMutatedKeys.add(key);\n                    }\n                    else {\n                        newMutatedKeys = newMutatedKeys.delete(key);\n                    }\n                }\n                else {\n                    newDocumentSet = newDocumentSet.delete(key);\n                    newMutatedKeys = newMutatedKeys.delete(key);\n                }\n            }\n        });\n        // Drop documents out to meet limit/limitToLast requirement.\n        if (this.query.limit !== null) {\n            while (newDocumentSet.size > this.query.limit) {\n                const oldDoc = this.query.limitType === \"F\" /* LimitType.First */\n                    ? newDocumentSet.last()\n                    : newDocumentSet.first();\n                newDocumentSet = newDocumentSet.delete(oldDoc.key);\n                newMutatedKeys = newMutatedKeys.delete(oldDoc.key);\n                changeSet.track({ type: 1 /* ChangeType.Removed */, doc: oldDoc });\n            }\n        }\n        return {\n            documentSet: newDocumentSet,\n            changeSet,\n            needsRefill,\n            mutatedKeys: newMutatedKeys\n        };\n    }\n    shouldWaitForSyncedDocument(oldDoc, newDoc) {\n        // We suppress the initial change event for documents that were modified as\n        // part of a write acknowledgment (e.g. when the value of a server transform\n        // is applied) as Watch will send us the same document again.\n        // By suppressing the event, we only raise two user visible events (one with\n        // `hasPendingWrites` and the final state of the document) instead of three\n        // (one with `hasPendingWrites`, the modified document with\n        // `hasPendingWrites` and the final state of the document).\n        return (oldDoc.hasLocalMutations &&\n            newDoc.hasCommittedMutations &&\n            !newDoc.hasLocalMutations);\n    }\n    /**\n     * Updates the view with the given ViewDocumentChanges and optionally updates\n     * limbo docs and sync state from the provided target change.\n     * @param docChanges - The set of changes to make to the view's docs.\n     * @param limboResolutionEnabled - Whether to update limbo documents based on\n     *        this change.\n     * @param targetChange - A target change to apply for computing limbo docs and\n     *        sync state.\n     * @param targetIsPendingReset - Whether the target is pending to reset due to\n     *        existence filter mismatch. If not explicitly specified, it is treated\n     *        equivalently to `false`.\n     * @returns A new ViewChange with the given docs, changes, and sync state.\n     */\n    // PORTING NOTE: The iOS/Android clients always compute limbo document changes.\n    applyChanges(docChanges, limboResolutionEnabled, targetChange, targetIsPendingReset) {\n        const oldDocs = this.documentSet;\n        this.documentSet = docChanges.documentSet;\n        this.mutatedKeys = docChanges.mutatedKeys;\n        // Sort changes based on type and query comparator\n        const changes = docChanges.changeSet.getChanges();\n        changes.sort((c1, c2) => {\n            return (compareChangeType(c1.type, c2.type) ||\n                this.docComparator(c1.doc, c2.doc));\n        });\n        this.applyTargetChange(targetChange);\n        targetIsPendingReset = targetIsPendingReset !== null && targetIsPendingReset !== void 0 ? targetIsPendingReset : false;\n        const limboChanges = limboResolutionEnabled && !targetIsPendingReset\n            ? this.updateLimboDocuments()\n            : [];\n        // We are at synced state if there is no limbo docs are waiting to be resolved, view is current\n        // with the backend, and the query is not pending to reset due to existence filter mismatch.\n        const synced = this.limboDocuments.size === 0 && this.current && !targetIsPendingReset;\n        const newSyncState = synced ? 1 /* SyncState.Synced */ : 0 /* SyncState.Local */;\n        const syncStateChanged = newSyncState !== this.syncState;\n        this.syncState = newSyncState;\n        if (changes.length === 0 && !syncStateChanged) {\n            // no changes\n            return { limboChanges };\n        }\n        else {\n            const snap = new ViewSnapshot(this.query, docChanges.documentSet, oldDocs, changes, docChanges.mutatedKeys, newSyncState === 0 /* SyncState.Local */, syncStateChanged, \n            /* excludesMetadataChanges= */ false, targetChange\n                ? targetChange.resumeToken.approximateByteSize() > 0\n                : false);\n            return {\n                snapshot: snap,\n                limboChanges\n            };\n        }\n    }\n    /**\n     * Applies an OnlineState change to the view, potentially generating a\n     * ViewChange if the view's syncState changes as a result.\n     */\n    applyOnlineStateChange(onlineState) {\n        if (this.current && onlineState === \"Offline\" /* OnlineState.Offline */) {\n            // If we're offline, set `current` to false and then call applyChanges()\n            // to refresh our syncState and generate a ViewChange as appropriate. We\n            // are guaranteed to get a new TargetChange that sets `current` back to\n            // true once the client is back online.\n            this.current = false;\n            return this.applyChanges({\n                documentSet: this.documentSet,\n                changeSet: new DocumentChangeSet(),\n                mutatedKeys: this.mutatedKeys,\n                needsRefill: false\n            }, \n            /* limboResolutionEnabled= */ false);\n        }\n        else {\n            // No effect, just return a no-op ViewChange.\n            return { limboChanges: [] };\n        }\n    }\n    /**\n     * Returns whether the doc for the given key should be in limbo.\n     */\n    shouldBeInLimbo(key) {\n        // If the remote end says it's part of this query, it's not in limbo.\n        if (this._syncedDocuments.has(key)) {\n            return false;\n        }\n        // The local store doesn't think it's a result, so it shouldn't be in limbo.\n        if (!this.documentSet.has(key)) {\n            return false;\n        }\n        // If there are local changes to the doc, they might explain why the server\n        // doesn't know that it's part of the query. So don't put it in limbo.\n        // TODO(klimt): Ideally, we would only consider changes that might actually\n        // affect this specific query.\n        if (this.documentSet.get(key).hasLocalMutations) {\n            return false;\n        }\n        // Everything else is in limbo.\n        return true;\n    }\n    /**\n     * Updates syncedDocuments, current, and limbo docs based on the given change.\n     * Returns the list of changes to which docs are in limbo.\n     */\n    applyTargetChange(targetChange) {\n        if (targetChange) {\n            targetChange.addedDocuments.forEach(key => (this._syncedDocuments = this._syncedDocuments.add(key)));\n            targetChange.modifiedDocuments.forEach(key => {\n            });\n            targetChange.removedDocuments.forEach(key => (this._syncedDocuments = this._syncedDocuments.delete(key)));\n            this.current = targetChange.current;\n        }\n    }\n    updateLimboDocuments() {\n        // We can only determine limbo documents when we're in-sync with the server.\n        if (!this.current) {\n            return [];\n        }\n        // TODO(klimt): Do this incrementally so that it's not quadratic when\n        // updating many documents.\n        const oldLimboDocuments = this.limboDocuments;\n        this.limboDocuments = documentKeySet();\n        this.documentSet.forEach(doc => {\n            if (this.shouldBeInLimbo(doc.key)) {\n                this.limboDocuments = this.limboDocuments.add(doc.key);\n            }\n        });\n        // Diff the new limbo docs with the old limbo docs.\n        const changes = [];\n        oldLimboDocuments.forEach(key => {\n            if (!this.limboDocuments.has(key)) {\n                changes.push(new RemovedLimboDocument(key));\n            }\n        });\n        this.limboDocuments.forEach(key => {\n            if (!oldLimboDocuments.has(key)) {\n                changes.push(new AddedLimboDocument(key));\n            }\n        });\n        return changes;\n    }\n    /**\n     * Update the in-memory state of the current view with the state read from\n     * persistence.\n     *\n     * We update the query view whenever a client's primary status changes:\n     * - When a client transitions from primary to secondary, it can miss\n     *   LocalStorage updates and its query views may temporarily not be\n     *   synchronized with the state on disk.\n     * - For secondary to primary transitions, the client needs to update the list\n     *   of `syncedDocuments` since secondary clients update their query views\n     *   based purely on synthesized RemoteEvents.\n     *\n     * @param queryResult.documents - The documents that match the query according\n     * to the LocalStore.\n     * @param queryResult.remoteKeys - The keys of the documents that match the\n     * query according to the backend.\n     *\n     * @returns The ViewChange that resulted from this synchronization.\n     */\n    // PORTING NOTE: Multi-tab only.\n    synchronizeWithPersistedState(queryResult) {\n        this._syncedDocuments = queryResult.remoteKeys;\n        this.limboDocuments = documentKeySet();\n        const docChanges = this.computeDocChanges(queryResult.documents);\n        return this.applyChanges(docChanges, /* limboResolutionEnabled= */ true);\n    }\n    /**\n     * Returns a view snapshot as if this query was just listened to. Contains\n     * a document add for every existing document and the `fromCache` and\n     * `hasPendingWrites` status of the already established view.\n     */\n    // PORTING NOTE: Multi-tab only.\n    computeInitialSnapshot() {\n        return ViewSnapshot.fromInitialDocuments(this.query, this.documentSet, this.mutatedKeys, this.syncState === 0 /* SyncState.Local */, this.hasCachedResults);\n    }\n}\nfunction compareChangeType(c1, c2) {\n    const order = (change) => {\n        switch (change) {\n            case 0 /* ChangeType.Added */:\n                return 1;\n            case 2 /* ChangeType.Modified */:\n                return 2;\n            case 3 /* ChangeType.Metadata */:\n                // A metadata change is converted to a modified change at the public\n                // api layer.  Since we sort by document key and then change type,\n                // metadata and modified changes must be sorted equivalently.\n                return 2;\n            case 1 /* ChangeType.Removed */:\n                return 0;\n            default:\n                return fail();\n        }\n    };\n    return order(c1) - order(c2);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$3 = 'SyncEngine';\n/**\n * QueryView contains all of the data that SyncEngine needs to keep track of for\n * a particular query.\n */\nclass QueryView {\n    constructor(\n    /**\n     * The query itself.\n     */\n    query, \n    /**\n     * The target number created by the client that is used in the watch\n     * stream to identify this query.\n     */\n    targetId, \n    /**\n     * The view is responsible for computing the final merged truth of what\n     * docs are in the query. It gets notified of local and remote changes,\n     * and applies the query filters and limits to determine the most correct\n     * possible results.\n     */\n    view) {\n        this.query = query;\n        this.targetId = targetId;\n        this.view = view;\n    }\n}\n/** Tracks a limbo resolution. */\nclass LimboResolution {\n    constructor(key) {\n        this.key = key;\n        /**\n         * Set to true once we've received a document. This is used in\n         * getRemoteKeysForTarget() and ultimately used by WatchChangeAggregator to\n         * decide whether it needs to manufacture a delete event for the target once\n         * the target is CURRENT.\n         */\n        this.receivedDocument = false;\n    }\n}\n/**\n * An implementation of `SyncEngine` coordinating with other parts of SDK.\n *\n * The parts of SyncEngine that act as a callback to RemoteStore need to be\n * registered individually. This is done in `syncEngineWrite()` and\n * `syncEngineListen()` (as well as `applyPrimaryState()`) as these methods\n * serve as entry points to RemoteStore's functionality.\n *\n * Note: some field defined in this class might have public access level, but\n * the class is not exported so they are only accessible from this module.\n * This is useful to implement optional features (like bundles) in free\n * functions, such that they are tree-shakeable.\n */\nclass SyncEngineImpl {\n    constructor(localStore, remoteStore, eventManager, \n    // PORTING NOTE: Manages state synchronization in multi-tab environments.\n    sharedClientState, currentUser, maxConcurrentLimboResolutions) {\n        this.localStore = localStore;\n        this.remoteStore = remoteStore;\n        this.eventManager = eventManager;\n        this.sharedClientState = sharedClientState;\n        this.currentUser = currentUser;\n        this.maxConcurrentLimboResolutions = maxConcurrentLimboResolutions;\n        this.syncEngineListener = {};\n        this.queryViewsByQuery = new ObjectMap(q => canonifyQuery(q), queryEquals);\n        this.queriesByTarget = new Map();\n        /**\n         * The keys of documents that are in limbo for which we haven't yet started a\n         * limbo resolution query. The strings in this set are the result of calling\n         * `key.path.canonicalString()` where `key` is a `DocumentKey` object.\n         *\n         * The `Set` type was chosen because it provides efficient lookup and removal\n         * of arbitrary elements and it also maintains insertion order, providing the\n         * desired queue-like FIFO semantics.\n         */\n        this.enqueuedLimboResolutions = new Set();\n        /**\n         * Keeps track of the target ID for each document that is in limbo with an\n         * active target.\n         */\n        this.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);\n        /**\n         * Keeps track of the information about an active limbo resolution for each\n         * active target ID that was started for the purpose of limbo resolution.\n         */\n        this.activeLimboResolutionsByTarget = new Map();\n        this.limboDocumentRefs = new ReferenceSet();\n        /** Stores user completion handlers, indexed by User and BatchId. */\n        this.mutationUserCallbacks = {};\n        /** Stores user callbacks waiting for all pending writes to be acknowledged. */\n        this.pendingWritesCallbacks = new Map();\n        this.limboTargetIdGenerator = TargetIdGenerator.forSyncEngine();\n        this.onlineState = \"Unknown\" /* OnlineState.Unknown */;\n        // The primary state is set to `true` or `false` immediately after Firestore\n        // startup. In the interim, a client should only be considered primary if\n        // `isPrimary` is true.\n        this._isPrimaryClient = undefined;\n    }\n    get isPrimaryClient() {\n        return this._isPrimaryClient === true;\n    }\n}\nfunction newSyncEngine(localStore, remoteStore, eventManager, \n// PORTING NOTE: Manages state synchronization in multi-tab environments.\nsharedClientState, currentUser, maxConcurrentLimboResolutions, isPrimary) {\n    const syncEngine = new SyncEngineImpl(localStore, remoteStore, eventManager, sharedClientState, currentUser, maxConcurrentLimboResolutions);\n    if (isPrimary) {\n        syncEngine._isPrimaryClient = true;\n    }\n    return syncEngine;\n}\n/**\n * Initiates the new listen, resolves promise when listen enqueued to the\n * server. All the subsequent view snapshots or errors are sent to the\n * subscribed handlers. Returns the initial snapshot.\n */\nasync function syncEngineListen(syncEngine, query, shouldListenToRemote = true) {\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\n    let viewSnapshot;\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n    if (queryView) {\n        // PORTING NOTE: With Multi-Tab Web, it is possible that a query view\n        // already exists when EventManager calls us for the first time. This\n        // happens when the primary tab is already listening to this query on\n        // behalf of another tab and the user of the primary also starts listening\n        // to the query. EventManager will not have an assigned target ID in this\n        // case and calls `listen` to obtain this ID.\n        syncEngineImpl.sharedClientState.addLocalQueryTarget(queryView.targetId);\n        viewSnapshot = queryView.view.computeInitialSnapshot();\n    }\n    else {\n        viewSnapshot = await allocateTargetAndMaybeListen(syncEngineImpl, query, shouldListenToRemote, \n        /** shouldInitializeView= */ true);\n    }\n    return viewSnapshot;\n}\n/** Query has been listening to the cache, and tries to initiate the remote store listen */\nasync function triggerRemoteStoreListen(syncEngine, query) {\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\n    await allocateTargetAndMaybeListen(syncEngineImpl, query, \n    /** shouldListenToRemote= */ true, \n    /** shouldInitializeView= */ false);\n}\nasync function allocateTargetAndMaybeListen(syncEngineImpl, query, shouldListenToRemote, shouldInitializeView) {\n    const targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(query));\n    const targetId = targetData.targetId;\n    // PORTING NOTE: When the query is listening to cache only, we skip sending it over to Watch by\n    // not registering it in shared client state, and directly calculate initial snapshots and\n    // subsequent updates from cache. Otherwise, register the target ID with local Firestore client\n    // as active watch target.\n    const status = syncEngineImpl.sharedClientState.addLocalQueryTarget(targetId, \n    /* addToActiveTargetIds= */ shouldListenToRemote);\n    let viewSnapshot;\n    if (shouldInitializeView) {\n        viewSnapshot = await initializeViewAndComputeSnapshot(syncEngineImpl, query, targetId, status === 'current', targetData.resumeToken);\n    }\n    if (syncEngineImpl.isPrimaryClient && shouldListenToRemote) {\n        remoteStoreListen(syncEngineImpl.remoteStore, targetData);\n    }\n    return viewSnapshot;\n}\n/**\n * Registers a view for a previously unknown query and computes its initial\n * snapshot.\n */\nasync function initializeViewAndComputeSnapshot(syncEngineImpl, query, targetId, current, resumeToken) {\n    // PORTING NOTE: On Web only, we inject the code that registers new Limbo\n    // targets based on view changes. This allows us to only depend on Limbo\n    // changes when user code includes queries.\n    syncEngineImpl.applyDocChanges = (queryView, changes, remoteEvent) => applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent);\n    const queryResult = await localStoreExecuteQuery(syncEngineImpl.localStore, query, \n    /* usePreviousResults= */ true);\n    const view = new View(query, queryResult.remoteKeys);\n    const viewDocChanges = view.computeDocChanges(queryResult.documents);\n    const synthesizedTargetChange = TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current && syncEngineImpl.onlineState !== \"Offline\" /* OnlineState.Offline */, resumeToken);\n    const viewChange = view.applyChanges(viewDocChanges, \n    /* limboResolutionEnabled= */ syncEngineImpl.isPrimaryClient, synthesizedTargetChange);\n    updateTrackedLimbos(syncEngineImpl, targetId, viewChange.limboChanges);\n    const data = new QueryView(query, targetId, view);\n    syncEngineImpl.queryViewsByQuery.set(query, data);\n    if (syncEngineImpl.queriesByTarget.has(targetId)) {\n        syncEngineImpl.queriesByTarget.get(targetId).push(query);\n    }\n    else {\n        syncEngineImpl.queriesByTarget.set(targetId, [query]);\n    }\n    return viewChange.snapshot;\n}\n/** Stops listening to the query. */\nasync function syncEngineUnlisten(syncEngine, query, shouldUnlistenToRemote) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n    // Only clean up the query view and target if this is the only query mapped\n    // to the target.\n    const queries = syncEngineImpl.queriesByTarget.get(queryView.targetId);\n    if (queries.length > 1) {\n        syncEngineImpl.queriesByTarget.set(queryView.targetId, queries.filter(q => !queryEquals(q, query)));\n        syncEngineImpl.queryViewsByQuery.delete(query);\n        return;\n    }\n    // No other queries are mapped to the target, clean up the query and the target.\n    if (syncEngineImpl.isPrimaryClient) {\n        // We need to remove the local query target first to allow us to verify\n        // whether any other client is still interested in this target.\n        syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);\n        const targetRemainsActive = syncEngineImpl.sharedClientState.isActiveQueryTarget(queryView.targetId);\n        if (!targetRemainsActive) {\n            await localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, \n            /*keepPersistedTargetData=*/ false)\n                .then(() => {\n                syncEngineImpl.sharedClientState.clearQueryState(queryView.targetId);\n                if (shouldUnlistenToRemote) {\n                    remoteStoreUnlisten(syncEngineImpl.remoteStore, queryView.targetId);\n                }\n                removeAndCleanupTarget(syncEngineImpl, queryView.targetId);\n            })\n                .catch(ignoreIfPrimaryLeaseLoss);\n        }\n    }\n    else {\n        removeAndCleanupTarget(syncEngineImpl, queryView.targetId);\n        await localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, \n        /*keepPersistedTargetData=*/ true);\n    }\n}\n/** Unlistens to the remote store while still listening to the cache. */\nasync function triggerRemoteStoreUnlisten(syncEngine, query) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n    const queries = syncEngineImpl.queriesByTarget.get(queryView.targetId);\n    if (syncEngineImpl.isPrimaryClient && queries.length === 1) {\n        // PORTING NOTE: Unregister the target ID with local Firestore client as\n        // watch target.\n        syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);\n        remoteStoreUnlisten(syncEngineImpl.remoteStore, queryView.targetId);\n    }\n}\n/**\n * Initiates the write of local mutation batch which involves adding the\n * writes to the mutation queue, notifying the remote store about new\n * mutations and raising events for any changes this write caused.\n *\n * The promise returned by this call is resolved when the above steps\n * have completed, *not* when the write was acked by the backend. The\n * userCallback is resolved once the write was acked/rejected by the\n * backend (or failed locally for any other reason).\n */\nasync function syncEngineWrite(syncEngine, batch, userCallback) {\n    const syncEngineImpl = syncEngineEnsureWriteCallbacks(syncEngine);\n    try {\n        const result = await localStoreWriteLocally(syncEngineImpl.localStore, batch);\n        syncEngineImpl.sharedClientState.addPendingMutation(result.batchId);\n        addMutationCallback(syncEngineImpl, result.batchId, userCallback);\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.changes);\n        await fillWritePipeline(syncEngineImpl.remoteStore);\n    }\n    catch (e) {\n        // If we can't persist the mutation, we reject the user callback and\n        // don't send the mutation. The user can then retry the write.\n        const error = wrapInUserErrorIfRecoverable(e, `Failed to persist write`);\n        userCallback.reject(error);\n    }\n}\n/**\n * Applies one remote event to the sync engine, notifying any views of the\n * changes, and releasing any pending mutation batches that would become\n * visible because of the snapshot version the remote event contains.\n */\nasync function syncEngineApplyRemoteEvent(syncEngine, remoteEvent) {\n    const syncEngineImpl = debugCast(syncEngine);\n    try {\n        const changes = await localStoreApplyRemoteEventToLocalCache(syncEngineImpl.localStore, remoteEvent);\n        // Update `receivedDocument` as appropriate for any limbo targets.\n        remoteEvent.targetChanges.forEach((targetChange, targetId) => {\n            const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\n            if (limboResolution) {\n                // Since this is a limbo resolution lookup, it's for a single document\n                // and it could be added, modified, or removed, but not a combination.\n                hardAssert(targetChange.addedDocuments.size +\n                    targetChange.modifiedDocuments.size +\n                    targetChange.removedDocuments.size <=\n                    1);\n                if (targetChange.addedDocuments.size > 0) {\n                    limboResolution.receivedDocument = true;\n                }\n                else if (targetChange.modifiedDocuments.size > 0) {\n                    hardAssert(limboResolution.receivedDocument);\n                }\n                else if (targetChange.removedDocuments.size > 0) {\n                    hardAssert(limboResolution.receivedDocument);\n                    limboResolution.receivedDocument = false;\n                }\n                else {\n                    // This was probably just a CURRENT targetChange or similar.\n                }\n            }\n        });\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, remoteEvent);\n    }\n    catch (error) {\n        await ignoreIfPrimaryLeaseLoss(error);\n    }\n}\n/**\n * Applies an OnlineState change to the sync engine and notifies any views of\n * the change.\n */\nfunction syncEngineApplyOnlineStateChange(syncEngine, onlineState, source) {\n    const syncEngineImpl = debugCast(syncEngine);\n    // If we are the secondary client, we explicitly ignore the remote store's\n    // online state (the local client may go offline, even though the primary\n    // tab remains online) and only apply the primary tab's online state from\n    // SharedClientState.\n    if ((syncEngineImpl.isPrimaryClient &&\n        source === 0 /* OnlineStateSource.RemoteStore */) ||\n        (!syncEngineImpl.isPrimaryClient &&\n            source === 1 /* OnlineStateSource.SharedClientState */)) {\n        const newViewSnapshots = [];\n        syncEngineImpl.queryViewsByQuery.forEach((query, queryView) => {\n            const viewChange = queryView.view.applyOnlineStateChange(onlineState);\n            if (viewChange.snapshot) {\n                newViewSnapshots.push(viewChange.snapshot);\n            }\n        });\n        eventManagerOnOnlineStateChange(syncEngineImpl.eventManager, onlineState);\n        if (newViewSnapshots.length) {\n            syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);\n        }\n        syncEngineImpl.onlineState = onlineState;\n        if (syncEngineImpl.isPrimaryClient) {\n            syncEngineImpl.sharedClientState.setOnlineState(onlineState);\n        }\n    }\n}\n/**\n * Rejects the listen for the given targetID. This can be triggered by the\n * backend for any active target.\n *\n * @param syncEngine - The sync engine implementation.\n * @param targetId - The targetID corresponds to one previously initiated by the\n * user as part of TargetData passed to listen() on RemoteStore.\n * @param err - A description of the condition that has forced the rejection.\n * Nearly always this will be an indication that the user is no longer\n * authorized to see the data matching the target.\n */\nasync function syncEngineRejectListen(syncEngine, targetId, err) {\n    const syncEngineImpl = debugCast(syncEngine);\n    // PORTING NOTE: Multi-tab only.\n    syncEngineImpl.sharedClientState.updateQueryState(targetId, 'rejected', err);\n    const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\n    const limboKey = limboResolution && limboResolution.key;\n    if (limboKey) {\n        // TODO(klimt): We really only should do the following on permission\n        // denied errors, but we don't have the cause code here.\n        // It's a limbo doc. Create a synthetic event saying it was deleted.\n        // This is kind of a hack. Ideally, we would have a method in the local\n        // store to purge a document. However, it would be tricky to keep all of\n        // the local store's invariants with another method.\n        let documentUpdates = new SortedMap(DocumentKey.comparator);\n        // TODO(b/217189216): This limbo document should ideally have a read time,\n        // so that it is picked up by any read-time based scans. The backend,\n        // however, does not send a read time for target removals.\n        documentUpdates = documentUpdates.insert(limboKey, MutableDocument.newNoDocument(limboKey, SnapshotVersion.min()));\n        const resolvedLimboDocuments = documentKeySet().add(limboKey);\n        const event = new RemoteEvent(SnapshotVersion.min(), \n        /* targetChanges= */ new Map(), \n        /* targetMismatches= */ new SortedMap(primitiveComparator), documentUpdates, resolvedLimboDocuments);\n        await syncEngineApplyRemoteEvent(syncEngineImpl, event);\n        // Since this query failed, we won't want to manually unlisten to it.\n        // We only remove it from bookkeeping after we successfully applied the\n        // RemoteEvent. If `applyRemoteEvent()` throws, we want to re-listen to\n        // this query when the RemoteStore restarts the Watch stream, which should\n        // re-trigger the target failure.\n        syncEngineImpl.activeLimboTargetsByKey =\n            syncEngineImpl.activeLimboTargetsByKey.remove(limboKey);\n        syncEngineImpl.activeLimboResolutionsByTarget.delete(targetId);\n        pumpEnqueuedLimboResolutions(syncEngineImpl);\n    }\n    else {\n        await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \n        /* keepPersistedTargetData */ false)\n            .then(() => removeAndCleanupTarget(syncEngineImpl, targetId, err))\n            .catch(ignoreIfPrimaryLeaseLoss);\n    }\n}\nasync function syncEngineApplySuccessfulWrite(syncEngine, mutationBatchResult) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const batchId = mutationBatchResult.batch.batchId;\n    try {\n        const changes = await localStoreAcknowledgeBatch(syncEngineImpl.localStore, mutationBatchResult);\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught\n        // up), so we raise user callbacks first so that they consistently happen\n        // before listen events.\n        processUserCallback(syncEngineImpl, batchId, /*error=*/ null);\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\n        syncEngineImpl.sharedClientState.updateMutationState(batchId, 'acknowledged');\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);\n    }\n    catch (error) {\n        await ignoreIfPrimaryLeaseLoss(error);\n    }\n}\nasync function syncEngineRejectFailedWrite(syncEngine, batchId, error) {\n    const syncEngineImpl = debugCast(syncEngine);\n    try {\n        const changes = await localStoreRejectBatch(syncEngineImpl.localStore, batchId);\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught up),\n        // so we raise user callbacks first so that they consistently happen before\n        // listen events.\n        processUserCallback(syncEngineImpl, batchId, error);\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\n        syncEngineImpl.sharedClientState.updateMutationState(batchId, 'rejected', error);\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);\n    }\n    catch (error) {\n        await ignoreIfPrimaryLeaseLoss(error);\n    }\n}\n/**\n * Registers a user callback that resolves when all pending mutations at the moment of calling\n * are acknowledged .\n */\nasync function syncEngineRegisterPendingWritesCallback(syncEngine, callback) {\n    const syncEngineImpl = debugCast(syncEngine);\n    if (!canUseNetwork(syncEngineImpl.remoteStore)) {\n        logDebug(LOG_TAG$3, 'The network is disabled. The task returned by ' +\n            \"'awaitPendingWrites()' will not complete until the network is enabled.\");\n    }\n    try {\n        const highestBatchId = await localStoreGetHighestUnacknowledgedBatchId(syncEngineImpl.localStore);\n        if (highestBatchId === BATCHID_UNKNOWN) {\n            // Trigger the callback right away if there is no pending writes at the moment.\n            callback.resolve();\n            return;\n        }\n        const callbacks = syncEngineImpl.pendingWritesCallbacks.get(highestBatchId) || [];\n        callbacks.push(callback);\n        syncEngineImpl.pendingWritesCallbacks.set(highestBatchId, callbacks);\n    }\n    catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(e, 'Initialization of waitForPendingWrites() operation failed');\n        callback.reject(firestoreError);\n    }\n}\n/**\n * Triggers the callbacks that are waiting for this batch id to get acknowledged by server,\n * if there are any.\n */\nfunction triggerPendingWritesCallbacks(syncEngineImpl, batchId) {\n    (syncEngineImpl.pendingWritesCallbacks.get(batchId) || []).forEach(callback => {\n        callback.resolve();\n    });\n    syncEngineImpl.pendingWritesCallbacks.delete(batchId);\n}\n/** Reject all outstanding callbacks waiting for pending writes to complete. */\nfunction rejectOutstandingPendingWritesCallbacks(syncEngineImpl, errorMessage) {\n    syncEngineImpl.pendingWritesCallbacks.forEach(callbacks => {\n        callbacks.forEach(callback => {\n            callback.reject(new FirestoreError(Code.CANCELLED, errorMessage));\n        });\n    });\n    syncEngineImpl.pendingWritesCallbacks.clear();\n}\nfunction addMutationCallback(syncEngineImpl, batchId, callback) {\n    let newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];\n    if (!newCallbacks) {\n        newCallbacks = new SortedMap(primitiveComparator);\n    }\n    newCallbacks = newCallbacks.insert(batchId, callback);\n    syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] =\n        newCallbacks;\n}\n/**\n * Resolves or rejects the user callback for the given batch and then discards\n * it.\n */\nfunction processUserCallback(syncEngine, batchId, error) {\n    const syncEngineImpl = debugCast(syncEngine);\n    let newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];\n    // NOTE: Mutations restored from persistence won't have callbacks, so it's\n    // okay for there to be no callback for this ID.\n    if (newCallbacks) {\n        const callback = newCallbacks.get(batchId);\n        if (callback) {\n            if (error) {\n                callback.reject(error);\n            }\n            else {\n                callback.resolve();\n            }\n            newCallbacks = newCallbacks.remove(batchId);\n        }\n        syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] =\n            newCallbacks;\n    }\n}\nfunction removeAndCleanupTarget(syncEngineImpl, targetId, error = null) {\n    syncEngineImpl.sharedClientState.removeLocalQueryTarget(targetId);\n    for (const query of syncEngineImpl.queriesByTarget.get(targetId)) {\n        syncEngineImpl.queryViewsByQuery.delete(query);\n        if (error) {\n            syncEngineImpl.syncEngineListener.onWatchError(query, error);\n        }\n    }\n    syncEngineImpl.queriesByTarget.delete(targetId);\n    if (syncEngineImpl.isPrimaryClient) {\n        const limboKeys = syncEngineImpl.limboDocumentRefs.removeReferencesForId(targetId);\n        limboKeys.forEach(limboKey => {\n            const isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboKey);\n            if (!isReferenced) {\n                // We removed the last reference for this key\n                removeLimboTarget(syncEngineImpl, limboKey);\n            }\n        });\n    }\n}\nfunction removeLimboTarget(syncEngineImpl, key) {\n    syncEngineImpl.enqueuedLimboResolutions.delete(key.path.canonicalString());\n    // It's possible that the target already got removed because the query failed. In that case,\n    // the key won't exist in `limboTargetsByKey`. Only do the cleanup if we still have the target.\n    const limboTargetId = syncEngineImpl.activeLimboTargetsByKey.get(key);\n    if (limboTargetId === null) {\n        // This target already got removed, because the query failed.\n        return;\n    }\n    remoteStoreUnlisten(syncEngineImpl.remoteStore, limboTargetId);\n    syncEngineImpl.activeLimboTargetsByKey =\n        syncEngineImpl.activeLimboTargetsByKey.remove(key);\n    syncEngineImpl.activeLimboResolutionsByTarget.delete(limboTargetId);\n    pumpEnqueuedLimboResolutions(syncEngineImpl);\n}\nfunction updateTrackedLimbos(syncEngineImpl, targetId, limboChanges) {\n    for (const limboChange of limboChanges) {\n        if (limboChange instanceof AddedLimboDocument) {\n            syncEngineImpl.limboDocumentRefs.addReference(limboChange.key, targetId);\n            trackLimboChange(syncEngineImpl, limboChange);\n        }\n        else if (limboChange instanceof RemovedLimboDocument) {\n            logDebug(LOG_TAG$3, 'Document no longer in limbo: ' + limboChange.key);\n            syncEngineImpl.limboDocumentRefs.removeReference(limboChange.key, targetId);\n            const isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboChange.key);\n            if (!isReferenced) {\n                // We removed the last reference for this key\n                removeLimboTarget(syncEngineImpl, limboChange.key);\n            }\n        }\n        else {\n            fail();\n        }\n    }\n}\nfunction trackLimboChange(syncEngineImpl, limboChange) {\n    const key = limboChange.key;\n    const keyString = key.path.canonicalString();\n    if (!syncEngineImpl.activeLimboTargetsByKey.get(key) &&\n        !syncEngineImpl.enqueuedLimboResolutions.has(keyString)) {\n        logDebug(LOG_TAG$3, 'New document in limbo: ' + key);\n        syncEngineImpl.enqueuedLimboResolutions.add(keyString);\n        pumpEnqueuedLimboResolutions(syncEngineImpl);\n    }\n}\n/**\n * Starts listens for documents in limbo that are enqueued for resolution,\n * subject to a maximum number of concurrent resolutions.\n *\n * Without bounding the number of concurrent resolutions, the server can fail\n * with \"resource exhausted\" errors which can lead to pathological client\n * behavior as seen in https://github.com/firebase/firebase-js-sdk/issues/2683.\n */\nfunction pumpEnqueuedLimboResolutions(syncEngineImpl) {\n    while (syncEngineImpl.enqueuedLimboResolutions.size > 0 &&\n        syncEngineImpl.activeLimboTargetsByKey.size <\n            syncEngineImpl.maxConcurrentLimboResolutions) {\n        const keyString = syncEngineImpl.enqueuedLimboResolutions\n            .values()\n            .next().value;\n        syncEngineImpl.enqueuedLimboResolutions.delete(keyString);\n        const key = new DocumentKey(ResourcePath.fromString(keyString));\n        const limboTargetId = syncEngineImpl.limboTargetIdGenerator.next();\n        syncEngineImpl.activeLimboResolutionsByTarget.set(limboTargetId, new LimboResolution(key));\n        syncEngineImpl.activeLimboTargetsByKey =\n            syncEngineImpl.activeLimboTargetsByKey.insert(key, limboTargetId);\n        remoteStoreListen(syncEngineImpl.remoteStore, new TargetData(queryToTarget(newQueryForPath(key.path)), limboTargetId, \"TargetPurposeLimboResolution\" /* TargetPurpose.LimboResolution */, ListenSequence.INVALID));\n    }\n}\nasync function syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, changes, remoteEvent) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const newSnaps = [];\n    const docChangesInAllViews = [];\n    const queriesProcessed = [];\n    if (syncEngineImpl.queryViewsByQuery.isEmpty()) {\n        // Return early since `onWatchChange()` might not have been assigned yet.\n        return;\n    }\n    syncEngineImpl.queryViewsByQuery.forEach((_, queryView) => {\n        queriesProcessed.push(syncEngineImpl\n            .applyDocChanges(queryView, changes, remoteEvent)\n            .then(viewSnapshot => {\n            var _a;\n            // If there are changes, or we are handling a global snapshot, notify\n            // secondary clients to update query state.\n            if (viewSnapshot || remoteEvent) {\n                if (syncEngineImpl.isPrimaryClient) {\n                    // Query state is set to `current` if:\n                    // - There is a view change and it is up-to-date, or,\n                    // - There is a global snapshot, the Target is current, and no changes to be resolved\n                    const isCurrent = viewSnapshot\n                        ? !viewSnapshot.fromCache\n                        : (_a = remoteEvent === null || remoteEvent === void 0 ? void 0 : remoteEvent.targetChanges.get(queryView.targetId)) === null || _a === void 0 ? void 0 : _a.current;\n                    syncEngineImpl.sharedClientState.updateQueryState(queryView.targetId, isCurrent ? 'current' : 'not-current');\n                }\n            }\n            // Update views if there are actual changes.\n            if (!!viewSnapshot) {\n                newSnaps.push(viewSnapshot);\n                const docChanges = LocalViewChanges.fromSnapshot(queryView.targetId, viewSnapshot);\n                docChangesInAllViews.push(docChanges);\n            }\n        }));\n    });\n    await Promise.all(queriesProcessed);\n    syncEngineImpl.syncEngineListener.onWatchChange(newSnaps);\n    await localStoreNotifyLocalViewChanges(syncEngineImpl.localStore, docChangesInAllViews);\n}\nasync function applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent) {\n    let viewDocChanges = queryView.view.computeDocChanges(changes);\n    if (viewDocChanges.needsRefill) {\n        // The query has a limit and some docs were removed, so we need\n        // to re-run the query against the local store to make sure we\n        // didn't lose any good docs that had been past the limit.\n        viewDocChanges = await localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, \n        /* usePreviousResults= */ false).then(({ documents }) => {\n            return queryView.view.computeDocChanges(documents, viewDocChanges);\n        });\n    }\n    const targetChange = remoteEvent && remoteEvent.targetChanges.get(queryView.targetId);\n    const targetIsPendingReset = remoteEvent && remoteEvent.targetMismatches.get(queryView.targetId) != null;\n    const viewChange = queryView.view.applyChanges(viewDocChanges, \n    /* limboResolutionEnabled= */ syncEngineImpl.isPrimaryClient, targetChange, targetIsPendingReset);\n    updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewChange.limboChanges);\n    return viewChange.snapshot;\n}\nasync function syncEngineHandleCredentialChange(syncEngine, user) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const userChanged = !syncEngineImpl.currentUser.isEqual(user);\n    if (userChanged) {\n        logDebug(LOG_TAG$3, 'User change. New user:', user.toKey());\n        const result = await localStoreHandleUserChange(syncEngineImpl.localStore, user);\n        syncEngineImpl.currentUser = user;\n        // Fails tasks waiting for pending writes requested by previous user.\n        rejectOutstandingPendingWritesCallbacks(syncEngineImpl, \"'waitForPendingWrites' promise is rejected due to a user change.\");\n        // TODO(b/114226417): Consider calling this only in the primary tab.\n        syncEngineImpl.sharedClientState.handleUserChange(user, result.removedBatchIds, result.addedBatchIds);\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.affectedDocuments);\n    }\n}\nfunction syncEngineGetRemoteKeysForTarget(syncEngine, targetId) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\n    if (limboResolution && limboResolution.receivedDocument) {\n        return documentKeySet().add(limboResolution.key);\n    }\n    else {\n        let keySet = documentKeySet();\n        const queries = syncEngineImpl.queriesByTarget.get(targetId);\n        if (!queries) {\n            return keySet;\n        }\n        for (const query of queries) {\n            const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n            keySet = keySet.unionWith(queryView.view.syncedDocuments);\n        }\n        return keySet;\n    }\n}\n/**\n * Reconcile the list of synced documents in an existing view with those\n * from persistence.\n */\nasync function synchronizeViewAndComputeSnapshot(syncEngine, queryView) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const queryResult = await localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, \n    /* usePreviousResults= */ true);\n    const viewSnapshot = queryView.view.synchronizeWithPersistedState(queryResult);\n    if (syncEngineImpl.isPrimaryClient) {\n        updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewSnapshot.limboChanges);\n    }\n    return viewSnapshot;\n}\n/**\n * Retrieves newly changed documents from remote document cache and raises\n * snapshots if needed.\n */\n// PORTING NOTE: Multi-Tab only.\nasync function syncEngineSynchronizeWithChangedDocuments(syncEngine, collectionGroup) {\n    const syncEngineImpl = debugCast(syncEngine);\n    return localStoreGetNewDocumentChanges(syncEngineImpl.localStore, collectionGroup).then(changes => syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes));\n}\n/** Applies a mutation state to an existing batch.  */\n// PORTING NOTE: Multi-Tab only.\nasync function syncEngineApplyBatchState(syncEngine, batchId, batchState, error) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const documents = await localStoreLookupMutationDocuments(syncEngineImpl.localStore, batchId);\n    if (documents === null) {\n        // A throttled tab may not have seen the mutation before it was completed\n        // and removed from the mutation queue, in which case we won't have cached\n        // the affected documents. In this case we can safely ignore the update\n        // since that means we didn't apply the mutation locally at all (if we\n        // had, we would have cached the affected documents), and so we will just\n        // see any resulting document changes via normal remote document updates\n        // as applicable.\n        logDebug(LOG_TAG$3, 'Cannot apply mutation batch with id: ' + batchId);\n        return;\n    }\n    if (batchState === 'pending') {\n        // If we are the primary client, we need to send this write to the\n        // backend. Secondary clients will ignore these writes since their remote\n        // connection is disabled.\n        await fillWritePipeline(syncEngineImpl.remoteStore);\n    }\n    else if (batchState === 'acknowledged' || batchState === 'rejected') {\n        // NOTE: Both these methods are no-ops for batches that originated from\n        // other clients.\n        processUserCallback(syncEngineImpl, batchId, error ? error : null);\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\n        localStoreRemoveCachedMutationBatchMetadata(syncEngineImpl.localStore, batchId);\n    }\n    else {\n        fail();\n    }\n    await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, documents);\n}\n/** Applies a query target change from a different tab. */\n// PORTING NOTE: Multi-Tab only.\nasync function syncEngineApplyPrimaryState(syncEngine, isPrimary) {\n    const syncEngineImpl = debugCast(syncEngine);\n    ensureWatchCallbacks(syncEngineImpl);\n    syncEngineEnsureWriteCallbacks(syncEngineImpl);\n    if (isPrimary === true && syncEngineImpl._isPrimaryClient !== true) {\n        // Secondary tabs only maintain Views for their local listeners and the\n        // Views internal state may not be 100% populated (in particular\n        // secondary tabs don't track syncedDocuments, the set of documents the\n        // server considers to be in the target). So when a secondary becomes\n        // primary, we need to need to make sure that all views for all targets\n        // match the state on disk.\n        const activeTargets = syncEngineImpl.sharedClientState.getAllActiveQueryTargets();\n        const activeQueries = await synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets.toArray());\n        syncEngineImpl._isPrimaryClient = true;\n        await remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, true);\n        for (const targetData of activeQueries) {\n            remoteStoreListen(syncEngineImpl.remoteStore, targetData);\n        }\n    }\n    else if (isPrimary === false && syncEngineImpl._isPrimaryClient !== false) {\n        const activeTargets = [];\n        let p = Promise.resolve();\n        syncEngineImpl.queriesByTarget.forEach((_, targetId) => {\n            if (syncEngineImpl.sharedClientState.isLocalQueryTarget(targetId)) {\n                activeTargets.push(targetId);\n            }\n            else {\n                p = p.then(() => {\n                    removeAndCleanupTarget(syncEngineImpl, targetId);\n                    return localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \n                    /*keepPersistedTargetData=*/ true);\n                });\n            }\n            remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\n        });\n        await p;\n        await synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets);\n        resetLimboDocuments(syncEngineImpl);\n        syncEngineImpl._isPrimaryClient = false;\n        await remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, false);\n    }\n}\n// PORTING NOTE: Multi-Tab only.\nfunction resetLimboDocuments(syncEngine) {\n    const syncEngineImpl = debugCast(syncEngine);\n    syncEngineImpl.activeLimboResolutionsByTarget.forEach((_, targetId) => {\n        remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\n    });\n    syncEngineImpl.limboDocumentRefs.removeAllReferences();\n    syncEngineImpl.activeLimboResolutionsByTarget = new Map();\n    syncEngineImpl.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);\n}\n/**\n * Reconcile the query views of the provided query targets with the state from\n * persistence. Raises snapshots for any changes that affect the local\n * client and returns the updated state of all target's query data.\n *\n * @param syncEngine - The sync engine implementation\n * @param targets - the list of targets with views that need to be recomputed\n * @param transitionToPrimary - `true` iff the tab transitions from a secondary\n * tab to a primary tab\n */\n// PORTING NOTE: Multi-Tab only.\nasync function synchronizeQueryViewsAndRaiseSnapshots(syncEngine, targets, transitionToPrimary) {\n    const syncEngineImpl = debugCast(syncEngine);\n    const activeQueries = [];\n    const newViewSnapshots = [];\n    for (const targetId of targets) {\n        let targetData;\n        const queries = syncEngineImpl.queriesByTarget.get(targetId);\n        if (queries && queries.length !== 0) {\n            // For queries that have a local View, we fetch their current state\n            // from LocalStore (as the resume token and the snapshot version\n            // might have changed) and reconcile their views with the persisted\n            // state (the list of syncedDocuments may have gotten out of sync).\n            targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(queries[0]));\n            for (const query of queries) {\n                const queryView = syncEngineImpl.queryViewsByQuery.get(query);\n                const viewChange = await synchronizeViewAndComputeSnapshot(syncEngineImpl, queryView);\n                if (viewChange.snapshot) {\n                    newViewSnapshots.push(viewChange.snapshot);\n                }\n            }\n        }\n        else {\n            // For queries that never executed on this client, we need to\n            // allocate the target in LocalStore and initialize a new View.\n            const target = await localStoreGetCachedTarget(syncEngineImpl.localStore, targetId);\n            targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, target);\n            await initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetId, \n            /*current=*/ false, targetData.resumeToken);\n        }\n        activeQueries.push(targetData);\n    }\n    syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);\n    return activeQueries;\n}\n/**\n * Creates a `Query` object from the specified `Target`. There is no way to\n * obtain the original `Query`, so we synthesize a `Query` from the `Target`\n * object.\n *\n * The synthesized result might be different from the original `Query`, but\n * since the synthesized `Query` should return the same results as the\n * original one (only the presentation of results might differ), the potential\n * difference will not cause issues.\n */\n// PORTING NOTE: Multi-Tab only.\nfunction synthesizeTargetToQuery(target) {\n    return newQuery(target.path, target.collectionGroup, target.orderBy, target.filters, target.limit, \"F\" /* LimitType.First */, target.startAt, target.endAt);\n}\n/** Returns the IDs of the clients that are currently active. */\n// PORTING NOTE: Multi-Tab only.\nfunction syncEngineGetActiveClients(syncEngine) {\n    const syncEngineImpl = debugCast(syncEngine);\n    return localStoreGetActiveClients(syncEngineImpl.localStore);\n}\n/** Applies a query target change from a different tab. */\n// PORTING NOTE: Multi-Tab only.\nasync function syncEngineApplyTargetState(syncEngine, targetId, state, error) {\n    const syncEngineImpl = debugCast(syncEngine);\n    if (syncEngineImpl._isPrimaryClient) {\n        // If we receive a target state notification via WebStorage, we are\n        // either already secondary or another tab has taken the primary lease.\n        logDebug(LOG_TAG$3, 'Ignoring unexpected query state notification.');\n        return;\n    }\n    const query = syncEngineImpl.queriesByTarget.get(targetId);\n    if (query && query.length > 0) {\n        switch (state) {\n            case 'current':\n            case 'not-current': {\n                const changes = await localStoreGetNewDocumentChanges(syncEngineImpl.localStore, queryCollectionGroup(query[0]));\n                const synthesizedRemoteEvent = RemoteEvent.createSynthesizedRemoteEventForCurrentChange(targetId, state === 'current', ByteString.EMPTY_BYTE_STRING);\n                await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, synthesizedRemoteEvent);\n                break;\n            }\n            case 'rejected': {\n                await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \n                /* keepPersistedTargetData */ true);\n                removeAndCleanupTarget(syncEngineImpl, targetId, error);\n                break;\n            }\n            default:\n                fail();\n        }\n    }\n}\n/** Adds or removes Watch targets for queries from different tabs. */\nasync function syncEngineApplyActiveTargetsChange(syncEngine, added, removed) {\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\n    if (!syncEngineImpl._isPrimaryClient) {\n        return;\n    }\n    for (const targetId of added) {\n        // A target is already listening to remote store if it is already registered to\n        // sharedClientState.\n        const targetAlreadyListeningToRemoteStore = syncEngineImpl.queriesByTarget.has(targetId) &&\n            syncEngineImpl.sharedClientState.isActiveQueryTarget(targetId);\n        if (targetAlreadyListeningToRemoteStore) {\n            logDebug(LOG_TAG$3, 'Adding an already active target ' + targetId);\n            continue;\n        }\n        const target = await localStoreGetCachedTarget(syncEngineImpl.localStore, targetId);\n        const targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, target);\n        await initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetData.targetId, \n        /*current=*/ false, targetData.resumeToken);\n        remoteStoreListen(syncEngineImpl.remoteStore, targetData);\n    }\n    for (const targetId of removed) {\n        // Check that the target is still active since the target might have been\n        // removed if it has been rejected by the backend.\n        if (!syncEngineImpl.queriesByTarget.has(targetId)) {\n            continue;\n        }\n        // Release queries that are still active.\n        await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \n        /* keepPersistedTargetData */ false)\n            .then(() => {\n            remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\n            removeAndCleanupTarget(syncEngineImpl, targetId);\n        })\n            .catch(ignoreIfPrimaryLeaseLoss);\n    }\n}\nfunction ensureWatchCallbacks(syncEngine) {\n    const syncEngineImpl = debugCast(syncEngine);\n    syncEngineImpl.remoteStore.remoteSyncer.applyRemoteEvent =\n        syncEngineApplyRemoteEvent.bind(null, syncEngineImpl);\n    syncEngineImpl.remoteStore.remoteSyncer.getRemoteKeysForTarget =\n        syncEngineGetRemoteKeysForTarget.bind(null, syncEngineImpl);\n    syncEngineImpl.remoteStore.remoteSyncer.rejectListen =\n        syncEngineRejectListen.bind(null, syncEngineImpl);\n    syncEngineImpl.syncEngineListener.onWatchChange =\n        eventManagerOnWatchChange.bind(null, syncEngineImpl.eventManager);\n    syncEngineImpl.syncEngineListener.onWatchError =\n        eventManagerOnWatchError.bind(null, syncEngineImpl.eventManager);\n    return syncEngineImpl;\n}\nfunction syncEngineEnsureWriteCallbacks(syncEngine) {\n    const syncEngineImpl = debugCast(syncEngine);\n    syncEngineImpl.remoteStore.remoteSyncer.applySuccessfulWrite =\n        syncEngineApplySuccessfulWrite.bind(null, syncEngineImpl);\n    syncEngineImpl.remoteStore.remoteSyncer.rejectFailedWrite =\n        syncEngineRejectFailedWrite.bind(null, syncEngineImpl);\n    return syncEngineImpl;\n}\n/**\n * Loads a Firestore bundle into the SDK. The returned promise resolves when\n * the bundle finished loading.\n *\n * @param syncEngine - SyncEngine to use.\n * @param bundleReader - Bundle to load into the SDK.\n * @param task - LoadBundleTask used to update the loading progress to public API.\n */\nfunction syncEngineLoadBundle(syncEngine, bundleReader, task) {\n    const syncEngineImpl = debugCast(syncEngine);\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    loadBundleImpl(syncEngineImpl, bundleReader, task).then(collectionGroups => {\n        syncEngineImpl.sharedClientState.notifyBundleLoaded(collectionGroups);\n    });\n}\n/** Loads a bundle and returns the list of affected collection groups. */\nasync function loadBundleImpl(syncEngine, reader, task) {\n    try {\n        const metadata = await reader.getMetadata();\n        const skip = await localStoreHasNewerBundle(syncEngine.localStore, metadata);\n        if (skip) {\n            await reader.close();\n            task._completeWith(bundleSuccessProgress(metadata));\n            return Promise.resolve(new Set());\n        }\n        task._updateProgress(bundleInitialProgress(metadata));\n        const loader = new BundleLoader(metadata, syncEngine.localStore, reader.serializer);\n        let element = await reader.nextElement();\n        while (element) {\n            ;\n            const progress = await loader.addSizedElement(element);\n            if (progress) {\n                task._updateProgress(progress);\n            }\n            element = await reader.nextElement();\n        }\n        const result = await loader.complete();\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, result.changedDocs, \n        /* remoteEvent */ undefined);\n        // Save metadata, so loading the same bundle will skip.\n        await localStoreSaveBundle(syncEngine.localStore, metadata);\n        task._completeWith(result.progress);\n        return Promise.resolve(result.changedCollectionGroups);\n    }\n    catch (e) {\n        logWarn(LOG_TAG$3, `Loading bundle failed with ${e}`);\n        task._failWith(e);\n        return Promise.resolve(new Set());\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides all components needed for Firestore with in-memory persistence.\n * Uses EagerGC garbage collection.\n */\nclass MemoryOfflineComponentProvider {\n    constructor() {\n        this.kind = 'memory';\n        this.synchronizeTabs = false;\n    }\n    async initialize(cfg) {\n        this.serializer = newSerializer(cfg.databaseInfo.databaseId);\n        this.sharedClientState = this.createSharedClientState(cfg);\n        this.persistence = this.createPersistence(cfg);\n        await this.persistence.start();\n        this.localStore = this.createLocalStore(cfg);\n        this.gcScheduler = this.createGarbageCollectionScheduler(cfg, this.localStore);\n        this.indexBackfillerScheduler = this.createIndexBackfillerScheduler(cfg, this.localStore);\n    }\n    createGarbageCollectionScheduler(cfg, localStore) {\n        return null;\n    }\n    createIndexBackfillerScheduler(cfg, localStore) {\n        return null;\n    }\n    createLocalStore(cfg) {\n        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);\n    }\n    createPersistence(cfg) {\n        return new MemoryPersistence(MemoryEagerDelegate.factory, this.serializer);\n    }\n    createSharedClientState(cfg) {\n        return new MemorySharedClientState();\n    }\n    async terminate() {\n        var _a, _b;\n        (_a = this.gcScheduler) === null || _a === void 0 ? void 0 : _a.stop();\n        (_b = this.indexBackfillerScheduler) === null || _b === void 0 ? void 0 : _b.stop();\n        this.sharedClientState.shutdown();\n        await this.persistence.shutdown();\n    }\n}\nMemoryOfflineComponentProvider.provider = {\n    build: () => new MemoryOfflineComponentProvider()\n};\nclass LruGcMemoryOfflineComponentProvider extends MemoryOfflineComponentProvider {\n    constructor(cacheSizeBytes) {\n        super();\n        this.cacheSizeBytes = cacheSizeBytes;\n    }\n    createGarbageCollectionScheduler(cfg, localStore) {\n        hardAssert(this.persistence.referenceDelegate instanceof MemoryLruDelegate);\n        const garbageCollector = this.persistence.referenceDelegate.garbageCollector;\n        return new LruScheduler(garbageCollector, cfg.asyncQueue, localStore);\n    }\n    createPersistence(cfg) {\n        const lruParams = this.cacheSizeBytes !== undefined\n            ? LruParams.withCacheSize(this.cacheSizeBytes)\n            : LruParams.DEFAULT;\n        return new MemoryPersistence(p => MemoryLruDelegate.factory(p, lruParams), this.serializer);\n    }\n}\n/**\n * Provides all components needed for Firestore with IndexedDB persistence.\n */\nclass IndexedDbOfflineComponentProvider extends MemoryOfflineComponentProvider {\n    constructor(onlineComponentProvider, cacheSizeBytes, forceOwnership) {\n        super();\n        this.onlineComponentProvider = onlineComponentProvider;\n        this.cacheSizeBytes = cacheSizeBytes;\n        this.forceOwnership = forceOwnership;\n        this.kind = 'persistent';\n        this.synchronizeTabs = false;\n    }\n    async initialize(cfg) {\n        await super.initialize(cfg);\n        await this.onlineComponentProvider.initialize(this, cfg);\n        // Enqueue writes from a previous session\n        await syncEngineEnsureWriteCallbacks(this.onlineComponentProvider.syncEngine);\n        await fillWritePipeline(this.onlineComponentProvider.remoteStore);\n        // NOTE: This will immediately call the listener, so we make sure to\n        // set it after localStore / remoteStore are started.\n        await this.persistence.setPrimaryStateListener(() => {\n            if (this.gcScheduler && !this.gcScheduler.started) {\n                this.gcScheduler.start();\n            }\n            if (this.indexBackfillerScheduler &&\n                !this.indexBackfillerScheduler.started) {\n                this.indexBackfillerScheduler.start();\n            }\n            return Promise.resolve();\n        });\n    }\n    createLocalStore(cfg) {\n        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);\n    }\n    createGarbageCollectionScheduler(cfg, localStore) {\n        const garbageCollector = this.persistence.referenceDelegate.garbageCollector;\n        return new LruScheduler(garbageCollector, cfg.asyncQueue, localStore);\n    }\n    createIndexBackfillerScheduler(cfg, localStore) {\n        const indexBackfiller = new IndexBackfiller(localStore, this.persistence);\n        return new IndexBackfillerScheduler(cfg.asyncQueue, indexBackfiller);\n    }\n    createPersistence(cfg) {\n        const persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);\n        const lruParams = this.cacheSizeBytes !== undefined\n            ? LruParams.withCacheSize(this.cacheSizeBytes)\n            : LruParams.DEFAULT;\n        return new IndexedDbPersistence(this.synchronizeTabs, persistenceKey, cfg.clientId, lruParams, cfg.asyncQueue, getWindow(), getDocument(), this.serializer, this.sharedClientState, !!this.forceOwnership);\n    }\n    createSharedClientState(cfg) {\n        return new MemorySharedClientState();\n    }\n}\n/**\n * Provides all components needed for Firestore with multi-tab IndexedDB\n * persistence.\n *\n * In the legacy client, this provider is used to provide both multi-tab and\n * non-multi-tab persistence since we cannot tell at build time whether\n * `synchronizeTabs` will be enabled.\n */\nclass MultiTabOfflineComponentProvider extends IndexedDbOfflineComponentProvider {\n    constructor(onlineComponentProvider, cacheSizeBytes) {\n        super(onlineComponentProvider, cacheSizeBytes, /* forceOwnership= */ false);\n        this.onlineComponentProvider = onlineComponentProvider;\n        this.cacheSizeBytes = cacheSizeBytes;\n        this.synchronizeTabs = true;\n    }\n    async initialize(cfg) {\n        await super.initialize(cfg);\n        const syncEngine = this.onlineComponentProvider.syncEngine;\n        if (this.sharedClientState instanceof WebStorageSharedClientState) {\n            this.sharedClientState.syncEngine = {\n                applyBatchState: syncEngineApplyBatchState.bind(null, syncEngine),\n                applyTargetState: syncEngineApplyTargetState.bind(null, syncEngine),\n                applyActiveTargetsChange: syncEngineApplyActiveTargetsChange.bind(null, syncEngine),\n                getActiveClients: syncEngineGetActiveClients.bind(null, syncEngine),\n                synchronizeWithChangedDocuments: syncEngineSynchronizeWithChangedDocuments.bind(null, syncEngine)\n            };\n            await this.sharedClientState.start();\n        }\n        // NOTE: This will immediately call the listener, so we make sure to\n        // set it after localStore / remoteStore are started.\n        await this.persistence.setPrimaryStateListener(async (isPrimary) => {\n            await syncEngineApplyPrimaryState(this.onlineComponentProvider.syncEngine, isPrimary);\n            if (this.gcScheduler) {\n                if (isPrimary && !this.gcScheduler.started) {\n                    this.gcScheduler.start();\n                }\n                else if (!isPrimary) {\n                    this.gcScheduler.stop();\n                }\n            }\n            if (this.indexBackfillerScheduler) {\n                if (isPrimary && !this.indexBackfillerScheduler.started) {\n                    this.indexBackfillerScheduler.start();\n                }\n                else if (!isPrimary) {\n                    this.indexBackfillerScheduler.stop();\n                }\n            }\n        });\n    }\n    createSharedClientState(cfg) {\n        const window = getWindow();\n        if (!WebStorageSharedClientState.isAvailable(window)) {\n            throw new FirestoreError(Code.UNIMPLEMENTED, 'IndexedDB persistence is only available on platforms that support LocalStorage.');\n        }\n        const persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);\n        return new WebStorageSharedClientState(window, cfg.asyncQueue, persistenceKey, cfg.clientId, cfg.initialUser);\n    }\n}\n/**\n * Initializes and wires the components that are needed to interface with the\n * network.\n */\nclass OnlineComponentProvider {\n    async initialize(offlineComponentProvider, cfg) {\n        if (this.localStore) {\n            // OnlineComponentProvider may get initialized multiple times if\n            // multi-tab persistence is used.\n            return;\n        }\n        this.localStore = offlineComponentProvider.localStore;\n        this.sharedClientState = offlineComponentProvider.sharedClientState;\n        this.datastore = this.createDatastore(cfg);\n        this.remoteStore = this.createRemoteStore(cfg);\n        this.eventManager = this.createEventManager(cfg);\n        this.syncEngine = this.createSyncEngine(cfg, \n        /* startAsPrimary=*/ !offlineComponentProvider.synchronizeTabs);\n        this.sharedClientState.onlineStateHandler = onlineState => syncEngineApplyOnlineStateChange(this.syncEngine, onlineState, 1 /* OnlineStateSource.SharedClientState */);\n        this.remoteStore.remoteSyncer.handleCredentialChange =\n            syncEngineHandleCredentialChange.bind(null, this.syncEngine);\n        await remoteStoreApplyPrimaryState(this.remoteStore, this.syncEngine.isPrimaryClient);\n    }\n    createEventManager(cfg) {\n        return newEventManager();\n    }\n    createDatastore(cfg) {\n        const serializer = newSerializer(cfg.databaseInfo.databaseId);\n        const connection = newConnection(cfg.databaseInfo);\n        return newDatastore(cfg.authCredentials, cfg.appCheckCredentials, connection, serializer);\n    }\n    createRemoteStore(cfg) {\n        return newRemoteStore(this.localStore, this.datastore, cfg.asyncQueue, onlineState => syncEngineApplyOnlineStateChange(this.syncEngine, onlineState, 0 /* OnlineStateSource.RemoteStore */), newConnectivityMonitor());\n    }\n    createSyncEngine(cfg, startAsPrimary) {\n        return newSyncEngine(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, cfg.initialUser, cfg.maxConcurrentLimboResolutions, startAsPrimary);\n    }\n    async terminate() {\n        var _a, _b;\n        await remoteStoreShutdown(this.remoteStore);\n        (_a = this.datastore) === null || _a === void 0 ? void 0 : _a.terminate();\n        (_b = this.eventManager) === null || _b === void 0 ? void 0 : _b.terminate();\n    }\n}\nOnlineComponentProvider.provider = {\n    build: () => new OnlineComponentProvider()\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * How many bytes to read each time when `ReadableStreamReader.read()` is\n * called. Only applicable for byte streams that we control (e.g. those backed\n * by an UInt8Array).\n */\nconst DEFAULT_BYTES_PER_READ = 10240;\n/**\n * Builds a `ByteStreamReader` from a UInt8Array.\n * @param source - The data source to use.\n * @param bytesPerRead - How many bytes each `read()` from the returned reader\n *        will read.\n */\nfunction toByteStreamReaderHelper(source, bytesPerRead = DEFAULT_BYTES_PER_READ) {\n    let readFrom = 0;\n    // The TypeScript definition for ReadableStreamReader changed. We use\n    // `any` here to allow this code to compile with different versions.\n    // See https://github.com/microsoft/TypeScript/issues/42970\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const reader = {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        async read() {\n            if (readFrom < source.byteLength) {\n                const result = {\n                    value: source.slice(readFrom, readFrom + bytesPerRead),\n                    done: false\n                };\n                readFrom += bytesPerRead;\n                return result;\n            }\n            return { done: true };\n        },\n        async cancel() { },\n        releaseLock() { },\n        closed: Promise.resolve()\n    };\n    return reader;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction validateNonEmptyArgument(functionName, argumentName, argument) {\n    if (!argument) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() cannot be called with an empty ${argumentName}.`);\n    }\n}\n/**\n * Validates that two boolean options are not set at the same time.\n * @internal\n */\nfunction validateIsNotUsedTogether(optionName1, argument1, optionName2, argument2) {\n    if (argument1 === true && argument2 === true) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `${optionName1} and ${optionName2} cannot be used together.`);\n    }\n}\n/**\n * Validates that `path` refers to a document (indicated by the fact it contains\n * an even numbers of segments).\n */\nfunction validateDocumentPath(path) {\n    if (!DocumentKey.isDocumentKey(path)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${path} has ${path.length}.`);\n    }\n}\n/**\n * Validates that `path` refers to a collection (indicated by the fact it\n * contains an odd numbers of segments).\n */\nfunction validateCollectionPath(path) {\n    if (DocumentKey.isDocumentKey(path)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${path} has ${path.length}.`);\n    }\n}\n/**\n * Returns true if it's a non-null object without a custom prototype\n * (i.e. excludes Array, Date, etc.).\n */\nfunction isPlainObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        (Object.getPrototypeOf(input) === Object.prototype ||\n            Object.getPrototypeOf(input) === null));\n}\n/** Returns a string describing the type / value of the provided input. */\nfunction valueDescription(input) {\n    if (input === undefined) {\n        return 'undefined';\n    }\n    else if (input === null) {\n        return 'null';\n    }\n    else if (typeof input === 'string') {\n        if (input.length > 20) {\n            input = `${input.substring(0, 20)}...`;\n        }\n        return JSON.stringify(input);\n    }\n    else if (typeof input === 'number' || typeof input === 'boolean') {\n        return '' + input;\n    }\n    else if (typeof input === 'object') {\n        if (input instanceof Array) {\n            return 'an array';\n        }\n        else {\n            const customObjectName = tryGetCustomObjectType(input);\n            if (customObjectName) {\n                return `a custom ${customObjectName} object`;\n            }\n            else {\n                return 'an object';\n            }\n        }\n    }\n    else if (typeof input === 'function') {\n        return 'a function';\n    }\n    else {\n        return fail();\n    }\n}\n/** try to get the constructor name for an object. */\nfunction tryGetCustomObjectType(input) {\n    if (input.constructor) {\n        return input.constructor.name;\n    }\n    return null;\n}\n/**\n * Casts `obj` to `T`, optionally unwrapping Compat types to expose the\n * underlying instance. Throws if  `obj` is not an instance of `T`.\n *\n * This cast is used in the Lite and Full SDK to verify instance types for\n * arguments passed to the public API.\n * @internal\n */\nfunction cast(obj, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconstructor) {\n    if ('_delegate' in obj) {\n        // Unwrap Compat types\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        obj = obj._delegate;\n    }\n    if (!(obj instanceof constructor)) {\n        if (constructor.name === obj.constructor.name) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Type does not match the expected instance. Did you pass a ' +\n                `reference from a different Firestore SDK?`);\n        }\n        else {\n            const description = valueDescription(obj);\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Expected type '${constructor.name}', but it was: ${description}`);\n        }\n    }\n    return obj;\n}\nfunction validatePositiveNumber(functionName, n) {\n    if (n <= 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() requires a positive number, but it was: ${n}.`);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * On Node, only supported data source is a `Uint8Array` for now.\n */\nfunction toByteStreamReader(source, bytesPerRead) {\n    if (!(source instanceof Uint8Array)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `NodePlatform.toByteStreamReader expects source to be Uint8Array, got ${valueDescription(source)}`);\n    }\n    return toByteStreamReaderHelper(source, bytesPerRead);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * A wrapper implementation of Observer<T> that will dispatch events\n * asynchronously. To allow immediate silencing, a mute call is added which\n * causes events scheduled to no longer be raised.\n */\nclass AsyncObserver {\n    constructor(observer) {\n        this.observer = observer;\n        /**\n         * When set to true, will not raise future events. Necessary to deal with\n         * async detachment of listener.\n         */\n        this.muted = false;\n    }\n    next(value) {\n        if (this.muted) {\n            return;\n        }\n        if (this.observer.next) {\n            this.scheduleEvent(this.observer.next, value);\n        }\n    }\n    error(error) {\n        if (this.muted) {\n            return;\n        }\n        if (this.observer.error) {\n            this.scheduleEvent(this.observer.error, error);\n        }\n        else {\n            logError('Uncaught Error in snapshot listener:', error.toString());\n        }\n    }\n    mute() {\n        this.muted = true;\n    }\n    scheduleEvent(eventHandler, event) {\n        setTimeout(() => {\n            if (!this.muted) {\n                eventHandler(event);\n            }\n        }, 0);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A complete element in the bundle stream, together with the byte length it\n * occupies in the stream.\n */\nclass SizedBundleElement {\n    constructor(payload, \n    // How many bytes this element takes to store in the bundle.\n    byteLength) {\n        this.payload = payload;\n        this.byteLength = byteLength;\n    }\n    isBundleMetadata() {\n        return 'metadata' in this.payload;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A class representing a bundle.\n *\n * Takes a bundle stream or buffer, and presents abstractions to read bundled\n * elements out of the underlying content.\n */\nclass BundleReaderImpl {\n    constructor(\n    /** The reader to read from underlying binary bundle data source. */\n    reader, serializer) {\n        this.reader = reader;\n        this.serializer = serializer;\n        /** Cached bundle metadata. */\n        this.metadata = new Deferred();\n        /**\n         * Internal buffer to hold bundle content, accumulating incomplete element\n         * content.\n         */\n        this.buffer = new Uint8Array();\n        this.textDecoder = newTextDecoder();\n        // Read the metadata (which is the first element).\n        this.nextElementImpl().then(element => {\n            if (element && element.isBundleMetadata()) {\n                this.metadata.resolve(element.payload.metadata);\n            }\n            else {\n                this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is\n             ${JSON.stringify(element === null || element === void 0 ? void 0 : element.payload)}`));\n            }\n        }, error => this.metadata.reject(error));\n    }\n    close() {\n        return this.reader.cancel();\n    }\n    async getMetadata() {\n        return this.metadata.promise;\n    }\n    async nextElement() {\n        // Makes sure metadata is read before proceeding.\n        await this.getMetadata();\n        return this.nextElementImpl();\n    }\n    /**\n     * Reads from the head of internal buffer, and pulling more data from\n     * underlying stream if a complete element cannot be found, until an\n     * element(including the prefixed length and the JSON string) is found.\n     *\n     * Once a complete element is read, it is dropped from internal buffer.\n     *\n     * Returns either the bundled element, or null if we have reached the end of\n     * the stream.\n     */\n    async nextElementImpl() {\n        const lengthBuffer = await this.readLength();\n        if (lengthBuffer === null) {\n            return null;\n        }\n        const lengthString = this.textDecoder.decode(lengthBuffer);\n        const length = Number(lengthString);\n        if (isNaN(length)) {\n            this.raiseError(`length string (${lengthString}) is not valid number`);\n        }\n        const jsonString = await this.readJsonString(length);\n        return new SizedBundleElement(JSON.parse(jsonString), lengthBuffer.length + length);\n    }\n    /** First index of '{' from the underlying buffer. */\n    indexOfOpenBracket() {\n        return this.buffer.findIndex(v => v === '{'.charCodeAt(0));\n    }\n    /**\n     * Reads from the beginning of the internal buffer, until the first '{', and\n     * return the content.\n     *\n     * If reached end of the stream, returns a null.\n     */\n    async readLength() {\n        while (this.indexOfOpenBracket() < 0) {\n            const done = await this.pullMoreDataToBuffer();\n            if (done) {\n                break;\n            }\n        }\n        // Broke out of the loop because underlying stream is closed, and there\n        // happens to be no more data to process.\n        if (this.buffer.length === 0) {\n            return null;\n        }\n        const position = this.indexOfOpenBracket();\n        // Broke out of the loop because underlying stream is closed, but still\n        // cannot find an open bracket.\n        if (position < 0) {\n            this.raiseError('Reached the end of bundle when a length string is expected.');\n        }\n        const result = this.buffer.slice(0, position);\n        // Update the internal buffer to drop the read length.\n        this.buffer = this.buffer.slice(position);\n        return result;\n    }\n    /**\n     * Reads from a specified position from the internal buffer, for a specified\n     * number of bytes, pulling more data from the underlying stream if needed.\n     *\n     * Returns a string decoded from the read bytes.\n     */\n    async readJsonString(length) {\n        while (this.buffer.length < length) {\n            const done = await this.pullMoreDataToBuffer();\n            if (done) {\n                this.raiseError('Reached the end of bundle when more is expected.');\n            }\n        }\n        const result = this.textDecoder.decode(this.buffer.slice(0, length));\n        // Update the internal buffer to drop the read json string.\n        this.buffer = this.buffer.slice(length);\n        return result;\n    }\n    raiseError(message) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.reader.cancel();\n        throw new Error(`Invalid bundle format: ${message}`);\n    }\n    /**\n     * Pulls more data from underlying stream to internal buffer.\n     * Returns a boolean indicating whether the stream is finished.\n     */\n    async pullMoreDataToBuffer() {\n        const result = await this.reader.read();\n        if (!result.done) {\n            const newBuffer = new Uint8Array(this.buffer.length + result.value.length);\n            newBuffer.set(this.buffer);\n            newBuffer.set(result.value, this.buffer.length);\n            this.buffer = newBuffer;\n        }\n        return result.done;\n    }\n}\nfunction newBundleReader(reader, serializer) {\n    return new BundleReaderImpl(reader, serializer);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Internal transaction object responsible for accumulating the mutations to\n * perform and the base versions for any documents read.\n */\nclass Transaction$2 {\n    constructor(datastore) {\n        this.datastore = datastore;\n        // The version of each document that was read during this transaction.\n        this.readVersions = new Map();\n        this.mutations = [];\n        this.committed = false;\n        /**\n         * A deferred usage error that occurred previously in this transaction that\n         * will cause the transaction to fail once it actually commits.\n         */\n        this.lastTransactionError = null;\n        /**\n         * Set of documents that have been written in the transaction.\n         *\n         * When there's more than one write to the same key in a transaction, any\n         * writes after the first are handled differently.\n         */\n        this.writtenDocs = new Set();\n    }\n    async lookup(keys) {\n        this.ensureCommitNotCalled();\n        if (this.mutations.length > 0) {\n            this.lastTransactionError = new FirestoreError(Code.INVALID_ARGUMENT, 'Firestore transactions require all reads to be executed before all writes.');\n            throw this.lastTransactionError;\n        }\n        const docs = await invokeBatchGetDocumentsRpc(this.datastore, keys);\n        docs.forEach(doc => this.recordVersion(doc));\n        return docs;\n    }\n    set(key, data) {\n        this.write(data.toMutation(key, this.precondition(key)));\n        this.writtenDocs.add(key.toString());\n    }\n    update(key, data) {\n        try {\n            this.write(data.toMutation(key, this.preconditionForUpdate(key)));\n        }\n        catch (e) {\n            this.lastTransactionError = e;\n        }\n        this.writtenDocs.add(key.toString());\n    }\n    delete(key) {\n        this.write(new DeleteMutation(key, this.precondition(key)));\n        this.writtenDocs.add(key.toString());\n    }\n    async commit() {\n        this.ensureCommitNotCalled();\n        if (this.lastTransactionError) {\n            throw this.lastTransactionError;\n        }\n        const unwritten = this.readVersions;\n        // For each mutation, note that the doc was written.\n        this.mutations.forEach(mutation => {\n            unwritten.delete(mutation.key.toString());\n        });\n        // For each document that was read but not written to, we want to perform\n        // a `verify` operation.\n        unwritten.forEach((_, path) => {\n            const key = DocumentKey.fromPath(path);\n            this.mutations.push(new VerifyMutation(key, this.precondition(key)));\n        });\n        await invokeCommitRpc(this.datastore, this.mutations);\n        this.committed = true;\n    }\n    recordVersion(doc) {\n        let docVersion;\n        if (doc.isFoundDocument()) {\n            docVersion = doc.version;\n        }\n        else if (doc.isNoDocument()) {\n            // Represent a deleted doc using SnapshotVersion.min().\n            docVersion = SnapshotVersion.min();\n        }\n        else {\n            throw fail();\n        }\n        const existingVersion = this.readVersions.get(doc.key.toString());\n        if (existingVersion) {\n            if (!docVersion.isEqual(existingVersion)) {\n                // This transaction will fail no matter what.\n                throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');\n            }\n        }\n        else {\n            this.readVersions.set(doc.key.toString(), docVersion);\n        }\n    }\n    /**\n     * Returns the version of this document when it was read in this transaction,\n     * as a precondition, or no precondition if it was not read.\n     */\n    precondition(key) {\n        const version = this.readVersions.get(key.toString());\n        if (!this.writtenDocs.has(key.toString()) && version) {\n            if (version.isEqual(SnapshotVersion.min())) {\n                return Precondition.exists(false);\n            }\n            else {\n                return Precondition.updateTime(version);\n            }\n        }\n        else {\n            return Precondition.none();\n        }\n    }\n    /**\n     * Returns the precondition for a document if the operation is an update.\n     */\n    preconditionForUpdate(key) {\n        const version = this.readVersions.get(key.toString());\n        // The first time a document is written, we want to take into account the\n        // read time and existence\n        if (!this.writtenDocs.has(key.toString()) && version) {\n            if (version.isEqual(SnapshotVersion.min())) {\n                // The document doesn't exist, so fail the transaction.\n                // This has to be validated locally because you can't send a\n                // precondition that a document does not exist without changing the\n                // semantics of the backend write to be an insert. This is the reverse\n                // of what we want, since we want to assert that the document doesn't\n                // exist but then send the update and have it fail. Since we can't\n                // express that to the backend, we have to validate locally.\n                // Note: this can change once we can send separate verify writes in the\n                // transaction.\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't update a document that doesn't exist.\");\n            }\n            // Document exists, base precondition on document update time.\n            return Precondition.updateTime(version);\n        }\n        else {\n            // Document was not read, so we just use the preconditions for a blind\n            // update.\n            return Precondition.exists(true);\n        }\n    }\n    write(mutation) {\n        this.ensureCommitNotCalled();\n        this.mutations.push(mutation);\n    }\n    ensureCommitNotCalled() {\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * TransactionRunner encapsulates the logic needed to run and retry transactions\n * with backoff.\n */\nclass TransactionRunner {\n    constructor(asyncQueue, datastore, options, updateFunction, deferred) {\n        this.asyncQueue = asyncQueue;\n        this.datastore = datastore;\n        this.options = options;\n        this.updateFunction = updateFunction;\n        this.deferred = deferred;\n        this.attemptsRemaining = options.maxAttempts;\n        this.backoff = new ExponentialBackoff(this.asyncQueue, \"transaction_retry\" /* TimerId.TransactionRetry */);\n    }\n    /** Runs the transaction and sets the result on deferred. */\n    run() {\n        this.attemptsRemaining -= 1;\n        this.runWithBackOff();\n    }\n    runWithBackOff() {\n        this.backoff.backoffAndRun(async () => {\n            const transaction = new Transaction$2(this.datastore);\n            const userPromise = this.tryRunUpdateFunction(transaction);\n            if (userPromise) {\n                userPromise\n                    .then(result => {\n                    this.asyncQueue.enqueueAndForget(() => {\n                        return transaction\n                            .commit()\n                            .then(() => {\n                            this.deferred.resolve(result);\n                        })\n                            .catch(commitError => {\n                            this.handleTransactionError(commitError);\n                        });\n                    });\n                })\n                    .catch(userPromiseError => {\n                    this.handleTransactionError(userPromiseError);\n                });\n            }\n        });\n    }\n    tryRunUpdateFunction(transaction) {\n        try {\n            const userPromise = this.updateFunction(transaction);\n            if (isNullOrUndefined(userPromise) ||\n                !userPromise.catch ||\n                !userPromise.then) {\n                this.deferred.reject(Error('Transaction callback must return a Promise'));\n                return null;\n            }\n            return userPromise;\n        }\n        catch (error) {\n            // Do not retry errors thrown by user provided updateFunction.\n            this.deferred.reject(error);\n            return null;\n        }\n    }\n    handleTransactionError(error) {\n        if (this.attemptsRemaining > 0 && this.isRetryableTransactionError(error)) {\n            this.attemptsRemaining -= 1;\n            this.asyncQueue.enqueueAndForget(() => {\n                this.runWithBackOff();\n                return Promise.resolve();\n            });\n        }\n        else {\n            this.deferred.reject(error);\n        }\n    }\n    isRetryableTransactionError(error) {\n        if (error.name === 'FirebaseError') {\n            // In transactions, the backend will fail outdated reads with FAILED_PRECONDITION and\n            // non-matching document versions with ABORTED. These errors should be retried.\n            const code = error.code;\n            return (code === 'aborted' ||\n                code === 'failed-precondition' ||\n                code === 'already-exists' ||\n                !isPermanentError(code));\n        }\n        return false;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$2 = 'FirestoreClient';\nconst MAX_CONCURRENT_LIMBO_RESOLUTIONS = 100;\n/** DOMException error code constants. */\nconst DOM_EXCEPTION_INVALID_STATE = 11;\nconst DOM_EXCEPTION_ABORTED = 20;\nconst DOM_EXCEPTION_QUOTA_EXCEEDED = 22;\n/**\n * FirestoreClient is a top-level class that constructs and owns all of the //\n * pieces of the client SDK architecture. It is responsible for creating the //\n * async queue that is shared by all of the other components in the system. //\n */\nclass FirestoreClient {\n    constructor(authCredentials, appCheckCredentials, \n    /**\n     * Asynchronous queue responsible for all of our internal processing. When\n     * we get incoming work from the user (via public API) or the network\n     * (incoming GRPC messages), we should always schedule onto this queue.\n     * This ensures all of our work is properly serialized (e.g. we don't\n     * start processing a new operation while the previous one is waiting for\n     * an async I/O to complete).\n     */\n    asyncQueue, databaseInfo, componentProvider) {\n        this.authCredentials = authCredentials;\n        this.appCheckCredentials = appCheckCredentials;\n        this.asyncQueue = asyncQueue;\n        this.databaseInfo = databaseInfo;\n        this.user = User.UNAUTHENTICATED;\n        this.clientId = AutoId.newId();\n        this.authCredentialListener = () => Promise.resolve();\n        this.appCheckCredentialListener = () => Promise.resolve();\n        this._uninitializedComponentsProvider = componentProvider;\n        this.authCredentials.start(asyncQueue, async (user) => {\n            logDebug(LOG_TAG$2, 'Received user=', user.uid);\n            await this.authCredentialListener(user);\n            this.user = user;\n        });\n        this.appCheckCredentials.start(asyncQueue, newAppCheckToken => {\n            logDebug(LOG_TAG$2, 'Received new app check token=', newAppCheckToken);\n            return this.appCheckCredentialListener(newAppCheckToken, this.user);\n        });\n    }\n    get configuration() {\n        return {\n            asyncQueue: this.asyncQueue,\n            databaseInfo: this.databaseInfo,\n            clientId: this.clientId,\n            authCredentials: this.authCredentials,\n            appCheckCredentials: this.appCheckCredentials,\n            initialUser: this.user,\n            maxConcurrentLimboResolutions: MAX_CONCURRENT_LIMBO_RESOLUTIONS\n        };\n    }\n    setCredentialChangeListener(listener) {\n        this.authCredentialListener = listener;\n    }\n    setAppCheckTokenChangeListener(listener) {\n        this.appCheckCredentialListener = listener;\n    }\n    terminate() {\n        this.asyncQueue.enterRestrictedMode();\n        const deferred = new Deferred();\n        this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {\n            try {\n                if (this._onlineComponents) {\n                    await this._onlineComponents.terminate();\n                }\n                if (this._offlineComponents) {\n                    await this._offlineComponents.terminate();\n                }\n                // The credentials provider must be terminated after shutting down the\n                // RemoteStore as it will prevent the RemoteStore from retrieving auth\n                // tokens.\n                this.authCredentials.shutdown();\n                this.appCheckCredentials.shutdown();\n                deferred.resolve();\n            }\n            catch (e) {\n                const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to shutdown persistence`);\n                deferred.reject(firestoreError);\n            }\n        });\n        return deferred.promise;\n    }\n}\nasync function setOfflineComponentProvider(client, offlineComponentProvider) {\n    client.asyncQueue.verifyOperationInProgress();\n    logDebug(LOG_TAG$2, 'Initializing OfflineComponentProvider');\n    const configuration = client.configuration;\n    await offlineComponentProvider.initialize(configuration);\n    let currentUser = configuration.initialUser;\n    client.setCredentialChangeListener(async (user) => {\n        if (!currentUser.isEqual(user)) {\n            await localStoreHandleUserChange(offlineComponentProvider.localStore, user);\n            currentUser = user;\n        }\n    });\n    // When a user calls clearPersistence() in one client, all other clients\n    // need to be terminated to allow the delete to succeed.\n    offlineComponentProvider.persistence.setDatabaseDeletedListener(() => client.terminate());\n    client._offlineComponents = offlineComponentProvider;\n}\nasync function setOnlineComponentProvider(client, onlineComponentProvider) {\n    client.asyncQueue.verifyOperationInProgress();\n    const offlineComponents = await ensureOfflineComponents(client);\n    logDebug(LOG_TAG$2, 'Initializing OnlineComponentProvider');\n    await onlineComponentProvider.initialize(offlineComponents, client.configuration);\n    // The CredentialChangeListener of the online component provider takes\n    // precedence over the offline component provider.\n    client.setCredentialChangeListener(user => remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user));\n    client.setAppCheckTokenChangeListener((_, user) => remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user));\n    client._onlineComponents = onlineComponentProvider;\n}\n/**\n * Decides whether the provided error allows us to gracefully disable\n * persistence (as opposed to crashing the client).\n */\nfunction canFallbackFromIndexedDbError(error) {\n    if (error.name === 'FirebaseError') {\n        return (error.code === Code.FAILED_PRECONDITION ||\n            error.code === Code.UNIMPLEMENTED);\n    }\n    else if (typeof DOMException !== 'undefined' &&\n        error instanceof DOMException) {\n        // There are a few known circumstances where we can open IndexedDb but\n        // trying to read/write will fail (e.g. quota exceeded). For\n        // well-understood cases, we attempt to detect these and then gracefully\n        // fall back to memory persistence.\n        // NOTE: Rather than continue to add to this list, we could decide to\n        // always fall back, with the risk that we might accidentally hide errors\n        // representing actual SDK bugs.\n        return (\n        // When the browser is out of quota we could get either quota exceeded\n        // or an aborted error depending on whether the error happened during\n        // schema migration.\n        error.code === DOM_EXCEPTION_QUOTA_EXCEEDED ||\n            error.code === DOM_EXCEPTION_ABORTED ||\n            // Firefox Private Browsing mode disables IndexedDb and returns\n            // INVALID_STATE for any usage.\n            error.code === DOM_EXCEPTION_INVALID_STATE);\n    }\n    return true;\n}\nasync function ensureOfflineComponents(client) {\n    if (!client._offlineComponents) {\n        if (client._uninitializedComponentsProvider) {\n            logDebug(LOG_TAG$2, 'Using user provided OfflineComponentProvider');\n            try {\n                await setOfflineComponentProvider(client, client._uninitializedComponentsProvider._offline);\n            }\n            catch (e) {\n                const error = e;\n                if (!canFallbackFromIndexedDbError(error)) {\n                    throw error;\n                }\n                logWarn('Error using user provided cache. Falling back to ' +\n                    'memory cache: ' +\n                    error);\n                await setOfflineComponentProvider(client, new MemoryOfflineComponentProvider());\n            }\n        }\n        else {\n            logDebug(LOG_TAG$2, 'Using default OfflineComponentProvider');\n            await setOfflineComponentProvider(client, new LruGcMemoryOfflineComponentProvider(undefined));\n        }\n    }\n    return client._offlineComponents;\n}\nasync function ensureOnlineComponents(client) {\n    if (!client._onlineComponents) {\n        if (client._uninitializedComponentsProvider) {\n            logDebug(LOG_TAG$2, 'Using user provided OnlineComponentProvider');\n            await setOnlineComponentProvider(client, client._uninitializedComponentsProvider._online);\n        }\n        else {\n            logDebug(LOG_TAG$2, 'Using default OnlineComponentProvider');\n            await setOnlineComponentProvider(client, new OnlineComponentProvider());\n        }\n    }\n    return client._onlineComponents;\n}\nfunction getPersistence(client) {\n    return ensureOfflineComponents(client).then(c => c.persistence);\n}\nfunction getLocalStore(client) {\n    return ensureOfflineComponents(client).then(c => c.localStore);\n}\nfunction getRemoteStore(client) {\n    return ensureOnlineComponents(client).then(c => c.remoteStore);\n}\nfunction getSyncEngine(client) {\n    return ensureOnlineComponents(client).then(c => c.syncEngine);\n}\nfunction getDatastore(client) {\n    return ensureOnlineComponents(client).then(c => c.datastore);\n}\nasync function getEventManager(client) {\n    const onlineComponentProvider = await ensureOnlineComponents(client);\n    const eventManager = onlineComponentProvider.eventManager;\n    eventManager.onListen = syncEngineListen.bind(null, onlineComponentProvider.syncEngine);\n    eventManager.onUnlisten = syncEngineUnlisten.bind(null, onlineComponentProvider.syncEngine);\n    eventManager.onFirstRemoteStoreListen = triggerRemoteStoreListen.bind(null, onlineComponentProvider.syncEngine);\n    eventManager.onLastRemoteStoreUnlisten = triggerRemoteStoreUnlisten.bind(null, onlineComponentProvider.syncEngine);\n    return eventManager;\n}\n/** Enables the network connection and re-enqueues all pending operations. */\nfunction firestoreClientEnableNetwork(client) {\n    return client.asyncQueue.enqueue(async () => {\n        const persistence = await getPersistence(client);\n        const remoteStore = await getRemoteStore(client);\n        persistence.setNetworkEnabled(true);\n        return remoteStoreEnableNetwork(remoteStore);\n    });\n}\n/** Disables the network connection. Pending operations will not complete. */\nfunction firestoreClientDisableNetwork(client) {\n    return client.asyncQueue.enqueue(async () => {\n        const persistence = await getPersistence(client);\n        const remoteStore = await getRemoteStore(client);\n        persistence.setNetworkEnabled(false);\n        return remoteStoreDisableNetwork(remoteStore);\n    });\n}\n/**\n * Returns a Promise that resolves when all writes that were pending at the time\n * this method was called received server acknowledgement. An acknowledgement\n * can be either acceptance or rejection.\n */\nfunction firestoreClientWaitForPendingWrites(client) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const syncEngine = await getSyncEngine(client);\n        return syncEngineRegisterPendingWritesCallback(syncEngine, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientListen(client, query, options, observer) {\n    const wrappedObserver = new AsyncObserver(observer);\n    const listener = new QueryListener(query, wrappedObserver, options);\n    client.asyncQueue.enqueueAndForget(async () => {\n        const eventManager = await getEventManager(client);\n        return eventManagerListen(eventManager, listener);\n    });\n    return () => {\n        wrappedObserver.mute();\n        client.asyncQueue.enqueueAndForget(async () => {\n            const eventManager = await getEventManager(client);\n            return eventManagerUnlisten(eventManager, listener);\n        });\n    };\n}\nfunction firestoreClientGetDocumentFromLocalCache(client, docKey) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const localStore = await getLocalStore(client);\n        return readDocumentFromCache(localStore, docKey, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientGetDocumentViaSnapshotListener(client, key, options = {}) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const eventManager = await getEventManager(client);\n        return readDocumentViaSnapshotListener(eventManager, client.asyncQueue, key, options, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientGetDocumentsFromLocalCache(client, query) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const localStore = await getLocalStore(client);\n        return executeQueryFromCache(localStore, query, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientGetDocumentsViaSnapshotListener(client, query, options = {}) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const eventManager = await getEventManager(client);\n        return executeQueryViaSnapshotListener(eventManager, client.asyncQueue, query, options, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientRunAggregateQuery(client, query, aggregates) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        // Implement and call executeAggregateQueryViaSnapshotListener, similar\n        // to the implementation in firestoreClientGetDocumentsViaSnapshotListener\n        // above\n        try {\n            // TODO(b/277628384): check `canUseNetwork()` and handle multi-tab.\n            const datastore = await getDatastore(client);\n            deferred.resolve(invokeRunAggregationQueryRpc(datastore, query, aggregates));\n        }\n        catch (e) {\n            deferred.reject(e);\n        }\n    });\n    return deferred.promise;\n}\nfunction firestoreClientWrite(client, mutations) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const syncEngine = await getSyncEngine(client);\n        return syncEngineWrite(syncEngine, mutations, deferred);\n    });\n    return deferred.promise;\n}\nfunction firestoreClientAddSnapshotsInSyncListener(client, observer) {\n    const wrappedObserver = new AsyncObserver(observer);\n    client.asyncQueue.enqueueAndForget(async () => {\n        const eventManager = await getEventManager(client);\n        return addSnapshotsInSyncListener(eventManager, wrappedObserver);\n    });\n    return () => {\n        wrappedObserver.mute();\n        client.asyncQueue.enqueueAndForget(async () => {\n            const eventManager = await getEventManager(client);\n            return removeSnapshotsInSyncListener(eventManager, wrappedObserver);\n        });\n    };\n}\n/**\n * Takes an updateFunction in which a set of reads and writes can be performed\n * atomically. In the updateFunction, the client can read and write values\n * using the supplied transaction object. After the updateFunction, all\n * changes will be committed. If a retryable error occurs (ex: some other\n * client has changed any of the data referenced), then the updateFunction\n * will be called again after a backoff. If the updateFunction still fails\n * after all retries, then the transaction will be rejected.\n *\n * The transaction object passed to the updateFunction contains methods for\n * accessing documents and collections. Unlike other datastore access, data\n * accessed with the transaction will not reflect local changes that have not\n * been committed. For this reason, it is required that all reads are\n * performed before any writes. Transactions must be performed while online.\n */\nfunction firestoreClientTransaction(client, updateFunction, options) {\n    const deferred = new Deferred();\n    client.asyncQueue.enqueueAndForget(async () => {\n        const datastore = await getDatastore(client);\n        new TransactionRunner(client.asyncQueue, datastore, options, updateFunction, deferred).run();\n    });\n    return deferred.promise;\n}\nasync function readDocumentFromCache(localStore, docKey, result) {\n    try {\n        const document = await localStoreReadDocument(localStore, docKey);\n        if (document.isFoundDocument()) {\n            result.resolve(document);\n        }\n        else if (document.isNoDocument()) {\n            result.resolve(null);\n        }\n        else {\n            result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from cache. (However, this document may ' +\n                \"exist on the server. Run again without setting 'source' in \" +\n                'the GetOptions to attempt to retrieve the document from the ' +\n                'server.)'));\n        }\n    }\n    catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to get document '${docKey} from cache`);\n        result.reject(firestoreError);\n    }\n}\n/**\n * Retrieves a latency-compensated document from the backend via a\n * SnapshotListener.\n */\nfunction readDocumentViaSnapshotListener(eventManager, asyncQueue, key, options, result) {\n    const wrappedObserver = new AsyncObserver({\n        next: (snap) => {\n            // Mute and remove query first before passing event to user to avoid\n            // user actions affecting the now stale query.\n            wrappedObserver.mute();\n            asyncQueue.enqueueAndForget(() => eventManagerUnlisten(eventManager, listener));\n            const exists = snap.docs.has(key);\n            if (!exists && snap.fromCache) {\n                // TODO(dimond): If we're online and the document doesn't\n                // exist then we resolve with a doc.exists set to false. If\n                // we're offline however, we reject the Promise in this\n                // case. Two options: 1) Cache the negative response from\n                // the server so we can deliver that even when you're\n                // offline 2) Actually reject the Promise in the online case\n                // if the document doesn't exist.\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document because the client is offline.'));\n            }\n            else if (exists &&\n                snap.fromCache &&\n                options &&\n                options.source === 'server') {\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from server. (However, this ' +\n                    'document does exist in the local cache. Run again ' +\n                    'without setting source to \"server\" to ' +\n                    'retrieve the cached document.)'));\n            }\n            else {\n                result.resolve(snap);\n            }\n        },\n        error: e => result.reject(e)\n    });\n    const listener = new QueryListener(newQueryForPath(key.path), wrappedObserver, {\n        includeMetadataChanges: true,\n        waitForSyncWhenOnline: true\n    });\n    return eventManagerListen(eventManager, listener);\n}\nasync function executeQueryFromCache(localStore, query, result) {\n    try {\n        const queryResult = await localStoreExecuteQuery(localStore, query, \n        /* usePreviousResults= */ true);\n        const view = new View(query, queryResult.remoteKeys);\n        const viewDocChanges = view.computeDocChanges(queryResult.documents);\n        const viewChange = view.applyChanges(viewDocChanges, \n        /* limboResolutionEnabled= */ false);\n        result.resolve(viewChange.snapshot);\n    }\n    catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to execute query '${query} against cache`);\n        result.reject(firestoreError);\n    }\n}\n/**\n * Retrieves a latency-compensated query snapshot from the backend via a\n * SnapshotListener.\n */\nfunction executeQueryViaSnapshotListener(eventManager, asyncQueue, query, options, result) {\n    const wrappedObserver = new AsyncObserver({\n        next: snapshot => {\n            // Mute and remove query first before passing event to user to avoid\n            // user actions affecting the now stale query.\n            wrappedObserver.mute();\n            asyncQueue.enqueueAndForget(() => eventManagerUnlisten(eventManager, listener));\n            if (snapshot.fromCache && options.source === 'server') {\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get documents from server. (However, these ' +\n                    'documents may exist in the local cache. Run again ' +\n                    'without setting source to \"server\" to ' +\n                    'retrieve the cached documents.)'));\n            }\n            else {\n                result.resolve(snapshot);\n            }\n        },\n        error: e => result.reject(e)\n    });\n    const listener = new QueryListener(query, wrappedObserver, {\n        includeMetadataChanges: true,\n        waitForSyncWhenOnline: true\n    });\n    return eventManagerListen(eventManager, listener);\n}\nfunction firestoreClientLoadBundle(client, databaseId, data, resultTask) {\n    const reader = createBundleReader(data, newSerializer(databaseId));\n    client.asyncQueue.enqueueAndForget(async () => {\n        syncEngineLoadBundle(await getSyncEngine(client), reader, resultTask);\n    });\n}\nfunction firestoreClientGetNamedQuery(client, queryName) {\n    return client.asyncQueue.enqueue(async () => localStoreGetNamedQuery(await getLocalStore(client), queryName));\n}\nfunction createBundleReader(data, serializer) {\n    let content;\n    if (typeof data === 'string') {\n        content = newTextEncoder().encode(data);\n    }\n    else {\n        content = data;\n    }\n    return newBundleReader(toByteStreamReader(content), serializer);\n}\nfunction firestoreClientSetIndexConfiguration(client, indexes) {\n    return client.asyncQueue.enqueue(async () => {\n        return localStoreConfigureFieldIndexes(await getLocalStore(client), indexes);\n    });\n}\nfunction firestoreClientSetPersistentCacheIndexAutoCreationEnabled(client, isEnabled) {\n    return client.asyncQueue.enqueue(async () => {\n        return localStoreSetIndexAutoCreationEnabled(await getLocalStore(client), isEnabled);\n    });\n}\nfunction firestoreClientDeleteAllFieldIndexes(client) {\n    return client.asyncQueue.enqueue(async () => {\n        return localStoreDeleteAllFieldIndexes(await getLocalStore(client));\n    });\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Compares two `ExperimentalLongPollingOptions` objects for equality.\n */\nfunction longPollingOptionsEqual(options1, options2) {\n    return options1.timeoutSeconds === options2.timeoutSeconds;\n}\n/**\n * Creates and returns a new `ExperimentalLongPollingOptions` with the same\n * option values as the given instance.\n */\nfunction cloneLongPollingOptions(options) {\n    const clone = {};\n    if (options.timeoutSeconds !== undefined) {\n        clone.timeoutSeconds = options.timeoutSeconds;\n    }\n    return clone;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG$1 = 'ComponentProvider';\n/**\n * An instance map that ensures only one Datastore exists per Firestore\n * instance.\n */\nconst datastoreInstances = new Map();\n/**\n * Removes all components associated with the provided instance. Must be called\n * when the `Firestore` instance is terminated.\n */\nfunction removeComponents(firestore) {\n    const datastore = datastoreInstances.get(firestore);\n    if (datastore) {\n        logDebug(LOG_TAG$1, 'Removing Datastore');\n        datastoreInstances.delete(firestore);\n        datastore.terminate();\n    }\n}\nfunction makeDatabaseInfo(databaseId, appId, persistenceKey, settings) {\n    return new DatabaseInfo(databaseId, appId, persistenceKey, settings.host, settings.ssl, settings.experimentalForceLongPolling, settings.experimentalAutoDetectLongPolling, cloneLongPollingOptions(settings.experimentalLongPollingOptions), settings.useFetchStreams);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// settings() defaults:\nconst DEFAULT_HOST = 'firestore.googleapis.com';\nconst DEFAULT_SSL = true;\n// The minimum long-polling timeout is hardcoded on the server. The value here\n// should be kept in sync with the value used by the server, as the server will\n// silently ignore a value below the minimum and fall back to the default.\n// Googlers see b/266868871 for relevant discussion.\nconst MIN_LONG_POLLING_TIMEOUT_SECONDS = 5;\n// No maximum long-polling timeout is configured in the server, and defaults to\n// 30 seconds, which is what Watch appears to use.\n// Googlers see b/266868871 for relevant discussion.\nconst MAX_LONG_POLLING_TIMEOUT_SECONDS = 30;\n// Whether long-polling auto-detected is enabled by default.\nconst DEFAULT_AUTO_DETECT_LONG_POLLING = true;\n/**\n * A concrete type describing all the values that can be applied via a\n * user-supplied `FirestoreSettings` object. This is a separate type so that\n * defaults can be supplied and the value can be checked for equality.\n */\nclass FirestoreSettingsImpl {\n    constructor(settings) {\n        var _a, _b;\n        if (settings.host === undefined) {\n            if (settings.ssl !== undefined) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\n            }\n            this.host = DEFAULT_HOST;\n            this.ssl = DEFAULT_SSL;\n        }\n        else {\n            this.host = settings.host;\n            this.ssl = (_a = settings.ssl) !== null && _a !== void 0 ? _a : DEFAULT_SSL;\n        }\n        this.credentials = settings.credentials;\n        this.ignoreUndefinedProperties = !!settings.ignoreUndefinedProperties;\n        this.localCache = settings.localCache;\n        if (settings.cacheSizeBytes === undefined) {\n            this.cacheSizeBytes = LRU_DEFAULT_CACHE_SIZE_BYTES;\n        }\n        else {\n            if (settings.cacheSizeBytes !== LRU_COLLECTION_DISABLED &&\n                settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);\n            }\n            else {\n                this.cacheSizeBytes = settings.cacheSizeBytes;\n            }\n        }\n        validateIsNotUsedTogether('experimentalForceLongPolling', settings.experimentalForceLongPolling, 'experimentalAutoDetectLongPolling', settings.experimentalAutoDetectLongPolling);\n        this.experimentalForceLongPolling = !!settings.experimentalForceLongPolling;\n        if (this.experimentalForceLongPolling) {\n            this.experimentalAutoDetectLongPolling = false;\n        }\n        else if (settings.experimentalAutoDetectLongPolling === undefined) {\n            this.experimentalAutoDetectLongPolling = DEFAULT_AUTO_DETECT_LONG_POLLING;\n        }\n        else {\n            // For backwards compatibility, coerce the value to boolean even though\n            // the TypeScript compiler has narrowed the type to boolean already.\n            // noinspection PointlessBooleanExpressionJS\n            this.experimentalAutoDetectLongPolling =\n                !!settings.experimentalAutoDetectLongPolling;\n        }\n        this.experimentalLongPollingOptions = cloneLongPollingOptions((_b = settings.experimentalLongPollingOptions) !== null && _b !== void 0 ? _b : {});\n        validateLongPollingOptions(this.experimentalLongPollingOptions);\n        this.useFetchStreams = !!settings.useFetchStreams;\n    }\n    isEqual(other) {\n        return (this.host === other.host &&\n            this.ssl === other.ssl &&\n            this.credentials === other.credentials &&\n            this.cacheSizeBytes === other.cacheSizeBytes &&\n            this.experimentalForceLongPolling ===\n                other.experimentalForceLongPolling &&\n            this.experimentalAutoDetectLongPolling ===\n                other.experimentalAutoDetectLongPolling &&\n            longPollingOptionsEqual(this.experimentalLongPollingOptions, other.experimentalLongPollingOptions) &&\n            this.ignoreUndefinedProperties === other.ignoreUndefinedProperties &&\n            this.useFetchStreams === other.useFetchStreams);\n    }\n}\nfunction validateLongPollingOptions(options) {\n    if (options.timeoutSeconds !== undefined) {\n        if (isNaN(options.timeoutSeconds)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ` +\n                `${options.timeoutSeconds} (must not be NaN)`);\n        }\n        if (options.timeoutSeconds < MIN_LONG_POLLING_TIMEOUT_SECONDS) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} ` +\n                `(minimum allowed value is ${MIN_LONG_POLLING_TIMEOUT_SECONDS})`);\n        }\n        if (options.timeoutSeconds > MAX_LONG_POLLING_TIMEOUT_SECONDS) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `invalid long polling timeout: ${options.timeoutSeconds} ` +\n                `(maximum allowed value is ${MAX_LONG_POLLING_TIMEOUT_SECONDS})`);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The Cloud Firestore service interface.\n *\n * Do not call this constructor directly. Instead, use {@link (getFirestore:1)}.\n */\nclass Firestore$1 {\n    /** @hideconstructor */\n    constructor(_authCredentials, _appCheckCredentials, _databaseId, _app) {\n        this._authCredentials = _authCredentials;\n        this._appCheckCredentials = _appCheckCredentials;\n        this._databaseId = _databaseId;\n        this._app = _app;\n        /**\n         * Whether it's a Firestore or Firestore Lite instance.\n         */\n        this.type = 'firestore-lite';\n        this._persistenceKey = '(lite)';\n        this._settings = new FirestoreSettingsImpl({});\n        this._settingsFrozen = false;\n        this._emulatorOptions = {};\n        // A task that is assigned when the terminate() is invoked and resolved when\n        // all components have shut down. Otherwise, Firestore is not terminated,\n        // which can mean either the FirestoreClient is in the process of starting,\n        // or restarting.\n        this._terminateTask = 'notTerminated';\n    }\n    /**\n     * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service\n     * instance.\n     */\n    get app() {\n        if (!this._app) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is \" +\n                'not available');\n        }\n        return this._app;\n    }\n    get _initialized() {\n        return this._settingsFrozen;\n    }\n    get _terminated() {\n        return this._terminateTask !== 'notTerminated';\n    }\n    _setSettings(settings) {\n        if (this._settingsFrozen) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' +\n                'be changed. You can only modify settings before calling any other ' +\n                'methods on a Firestore object.');\n        }\n        this._settings = new FirestoreSettingsImpl(settings);\n        this._emulatorOptions = settings.emulatorOptions || {};\n        if (settings.credentials !== undefined) {\n            this._authCredentials = makeAuthCredentialsProvider(settings.credentials);\n        }\n    }\n    _getSettings() {\n        return this._settings;\n    }\n    _getEmulatorOptions() {\n        return this._emulatorOptions;\n    }\n    _freezeSettings() {\n        this._settingsFrozen = true;\n        return this._settings;\n    }\n    _delete() {\n        // The `_terminateTask` must be assigned future that completes when\n        // terminate is complete. The existence of this future puts SDK in state\n        // that will not accept further API interaction.\n        if (this._terminateTask === 'notTerminated') {\n            this._terminateTask = this._terminate();\n        }\n        return this._terminateTask;\n    }\n    async _restart() {\n        // The `_terminateTask` must equal 'notTerminated' after restart to\n        // signal that client is in a state that accepts API calls.\n        if (this._terminateTask === 'notTerminated') {\n            await this._terminate();\n        }\n        else {\n            this._terminateTask = 'notTerminated';\n        }\n    }\n    /** Returns a JSON-serializable representation of this `Firestore` instance. */\n    toJSON() {\n        return {\n            app: this._app,\n            databaseId: this._databaseId,\n            settings: this._settings\n        };\n    }\n    /**\n     * Terminates all components used by this client. Subclasses can override\n     * this method to clean up their own dependencies, but must also call this\n     * method.\n     *\n     * Only ever called once.\n     */\n    _terminate() {\n        removeComponents(this);\n        return Promise.resolve();\n    }\n}\n/**\n * Modify this instance to communicate with the Cloud Firestore emulator.\n *\n * Note: This must be called before this instance has been used to do any\n * operations.\n *\n * @param firestore - The `Firestore` instance to configure to connect to the\n * emulator.\n * @param host - the emulator host (ex: localhost).\n * @param port - the emulator port (ex: 9000).\n * @param options.mockUserToken - the mock auth token to use for unit testing\n * Security Rules.\n */\nfunction connectFirestoreEmulator(firestore, host, port, options = {}) {\n    var _a;\n    firestore = cast(firestore, Firestore$1);\n    const settings = firestore._getSettings();\n    const existingConfig = Object.assign(Object.assign({}, settings), { emulatorOptions: firestore._getEmulatorOptions() });\n    const newHostSetting = `${host}:${port}`;\n    if (settings.host !== DEFAULT_HOST && settings.host !== newHostSetting) {\n        logWarn('Host has been set in both settings() and connectFirestoreEmulator(), emulator host ' +\n            'will be used.');\n    }\n    const newConfig = Object.assign(Object.assign({}, settings), { host: newHostSetting, ssl: false, emulatorOptions: options });\n    // No-op if the new configuration matches the current configuration. This supports SSR\n    // enviornments which might call `connectFirestoreEmulator` multiple times as a standard practice.\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(newConfig, existingConfig)) {\n        return;\n    }\n    firestore._setSettings(newConfig);\n    if (options.mockUserToken) {\n        let token;\n        let user;\n        if (typeof options.mockUserToken === 'string') {\n            token = options.mockUserToken;\n            user = User.MOCK_USER;\n        }\n        else {\n            // Let createMockUserToken validate first (catches common mistakes like\n            // invalid field \"uid\" and missing field \"sub\" / \"user_id\".)\n            token = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.createMockUserToken)(options.mockUserToken, (_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.projectId);\n            const uid = options.mockUserToken.sub || options.mockUserToken.user_id;\n            if (!uid) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"mockUserToken must contain 'sub' or 'user_id' field!\");\n            }\n            user = new User(uid);\n        }\n        firestore._authCredentials = new EmulatorAuthCredentialsProvider(new OAuthToken(token, user));\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `Query` refers to a query which you can read or listen to. You can also\n * construct refined `Query` objects by adding filters and ordering.\n */\nclass Query {\n    // This is the lite version of the Query class in the main SDK.\n    /** @hideconstructor protected */\n    constructor(firestore, \n    /**\n     * If provided, the `FirestoreDataConverter` associated with this instance.\n     */\n    converter, _query) {\n        this.converter = converter;\n        this._query = _query;\n        /** The type of this Firestore reference. */\n        this.type = 'query';\n        this.firestore = firestore;\n    }\n    withConverter(converter) {\n        return new Query(this.firestore, converter, this._query);\n    }\n}\n/**\n * A `DocumentReference` refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist.\n */\nclass DocumentReference {\n    /** @hideconstructor */\n    constructor(firestore, \n    /**\n     * If provided, the `FirestoreDataConverter` associated with this instance.\n     */\n    converter, _key) {\n        this.converter = converter;\n        this._key = _key;\n        /** The type of this Firestore reference. */\n        this.type = 'document';\n        this.firestore = firestore;\n    }\n    get _path() {\n        return this._key.path;\n    }\n    /**\n     * The document's identifier within its collection.\n     */\n    get id() {\n        return this._key.path.lastSegment();\n    }\n    /**\n     * A string representing the path of the referenced document (relative\n     * to the root of the database).\n     */\n    get path() {\n        return this._key.path.canonicalString();\n    }\n    /**\n     * The collection this `DocumentReference` belongs to.\n     */\n    get parent() {\n        return new CollectionReference(this.firestore, this.converter, this._key.path.popLast());\n    }\n    withConverter(converter) {\n        return new DocumentReference(this.firestore, converter, this._key);\n    }\n}\n/**\n * A `CollectionReference` object can be used for adding documents, getting\n * document references, and querying for documents (using {@link (query:1)}).\n */\nclass CollectionReference extends Query {\n    /** @hideconstructor */\n    constructor(firestore, converter, _path) {\n        super(firestore, converter, newQueryForPath(_path));\n        this._path = _path;\n        /** The type of this Firestore reference. */\n        this.type = 'collection';\n    }\n    /** The collection's identifier. */\n    get id() {\n        return this._query.path.lastSegment();\n    }\n    /**\n     * A string representing the path of the referenced collection (relative\n     * to the root of the database).\n     */\n    get path() {\n        return this._query.path.canonicalString();\n    }\n    /**\n     * A reference to the containing `DocumentReference` if this is a\n     * subcollection. If this isn't a subcollection, the reference is null.\n     */\n    get parent() {\n        const parentPath = this._path.popLast();\n        if (parentPath.isEmpty()) {\n            return null;\n        }\n        else {\n            return new DocumentReference(this.firestore, \n            /* converter= */ null, new DocumentKey(parentPath));\n        }\n    }\n    withConverter(converter) {\n        return new CollectionReference(this.firestore, converter, this._path);\n    }\n}\nfunction collection(parent, path, ...pathSegments) {\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(parent);\n    validateNonEmptyArgument('collection', 'path', path);\n    if (parent instanceof Firestore$1) {\n        const absolutePath = ResourcePath.fromString(path, ...pathSegments);\n        validateCollectionPath(absolutePath);\n        return new CollectionReference(parent, /* converter= */ null, absolutePath);\n    }\n    else {\n        if (!(parent instanceof DocumentReference) &&\n            !(parent instanceof CollectionReference)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Expected first argument to collection() to be a CollectionReference, ' +\n                'a DocumentReference or FirebaseFirestore');\n        }\n        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));\n        validateCollectionPath(absolutePath);\n        return new CollectionReference(parent.firestore, \n        /* converter= */ null, absolutePath);\n    }\n}\n// TODO(firestorelite): Consider using ErrorFactory -\n// https://github.com/firebase/firebase-js-sdk/blob/0131e1f/packages/util/src/errors.ts#L106\n/**\n * Creates and returns a new `Query` instance that includes all documents in the\n * database that are contained in a collection or subcollection with the\n * given `collectionId`.\n *\n * @param firestore - A reference to the root `Firestore` instance.\n * @param collectionId - Identifies the collections to query over. Every\n * collection or subcollection with this ID as the last segment of its path\n * will be included. Cannot contain a slash.\n * @returns The created `Query`.\n */\nfunction collectionGroup(firestore, collectionId) {\n    firestore = cast(firestore, Firestore$1);\n    validateNonEmptyArgument('collectionGroup', 'collection id', collectionId);\n    if (collectionId.indexOf('/') >= 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection ID '${collectionId}' passed to function ` +\n            `collectionGroup(). Collection IDs must not contain '/'.`);\n    }\n    return new Query(firestore, \n    /* converter= */ null, newQueryForCollectionGroup(collectionId));\n}\nfunction doc(parent, path, ...pathSegments) {\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(parent);\n    // We allow omission of 'pathString' but explicitly prohibit passing in both\n    // 'undefined' and 'null'.\n    if (arguments.length === 1) {\n        path = AutoId.newId();\n    }\n    validateNonEmptyArgument('doc', 'path', path);\n    if (parent instanceof Firestore$1) {\n        const absolutePath = ResourcePath.fromString(path, ...pathSegments);\n        validateDocumentPath(absolutePath);\n        return new DocumentReference(parent, \n        /* converter= */ null, new DocumentKey(absolutePath));\n    }\n    else {\n        if (!(parent instanceof DocumentReference) &&\n            !(parent instanceof CollectionReference)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Expected first argument to collection() to be a CollectionReference, ' +\n                'a DocumentReference or FirebaseFirestore');\n        }\n        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));\n        validateDocumentPath(absolutePath);\n        return new DocumentReference(parent.firestore, parent instanceof CollectionReference ? parent.converter : null, new DocumentKey(absolutePath));\n    }\n}\n/**\n * Returns true if the provided references are equal.\n *\n * @param left - A reference to compare.\n * @param right - A reference to compare.\n * @returns true if the references point to the same location in the same\n * Firestore database.\n */\nfunction refEqual(left, right) {\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(left);\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(right);\n    if ((left instanceof DocumentReference ||\n        left instanceof CollectionReference) &&\n        (right instanceof DocumentReference || right instanceof CollectionReference)) {\n        return (left.firestore === right.firestore &&\n            left.path === right.path &&\n            left.converter === right.converter);\n    }\n    return false;\n}\n/**\n * Returns true if the provided queries point to the same collection and apply\n * the same constraints.\n *\n * @param left - A `Query` to compare.\n * @param right - A `Query` to compare.\n * @returns true if the references point to the same location in the same\n * Firestore database.\n */\nfunction queryEqual(left, right) {\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(left);\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(right);\n    if (left instanceof Query && right instanceof Query) {\n        return (left.firestore === right.firestore &&\n            queryEquals(left._query, right._query) &&\n            left.converter === right.converter);\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst LOG_TAG = 'AsyncQueue';\nclass AsyncQueueImpl {\n    constructor(tail = Promise.resolve()) {\n        // A list of retryable operations. Retryable operations are run in order and\n        // retried with backoff.\n        this.retryableOps = [];\n        // Is this AsyncQueue being shut down? Once it is set to true, it will not\n        // be changed again.\n        this._isShuttingDown = false;\n        // Operations scheduled to be queued in the future. Operations are\n        // automatically removed after they are run or canceled.\n        this.delayedOperations = [];\n        // visible for testing\n        this.failure = null;\n        // Flag set while there's an outstanding AsyncQueue operation, used for\n        // assertion sanity-checks.\n        this.operationInProgress = false;\n        // Enabled during shutdown on Safari to prevent future access to IndexedDB.\n        this.skipNonRestrictedTasks = false;\n        // List of TimerIds to fast-forward delays for.\n        this.timerIdsToSkip = [];\n        // Backoff timer used to schedule retries for retryable operations\n        this.backoff = new ExponentialBackoff(this, \"async_queue_retry\" /* TimerId.AsyncQueueRetry */);\n        // Visibility handler that triggers an immediate retry of all retryable\n        // operations. Meant to speed up recovery when we regain file system access\n        // after page comes into foreground.\n        this.visibilityHandler = () => {\n            this.backoff.skipBackoff();\n        };\n        this.tail = tail;\n    }\n    get isShuttingDown() {\n        return this._isShuttingDown;\n    }\n    /**\n     * Adds a new operation to the queue without waiting for it to complete (i.e.\n     * we ignore the Promise result).\n     */\n    enqueueAndForget(op) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.enqueue(op);\n    }\n    enqueueAndForgetEvenWhileRestricted(op) {\n        this.verifyNotFailed();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.enqueueInternal(op);\n    }\n    enterRestrictedMode(purgeExistingTasks) {\n        if (!this._isShuttingDown) {\n            this._isShuttingDown = true;\n            this.skipNonRestrictedTasks = purgeExistingTasks || false;\n        }\n    }\n    enqueue(op) {\n        this.verifyNotFailed();\n        if (this._isShuttingDown) {\n            // Return a Promise which never resolves.\n            return new Promise(() => { });\n        }\n        // Create a deferred Promise that we can return to the callee. This\n        // allows us to return a \"hanging Promise\" only to the callee and still\n        // advance the queue even when the operation is not run.\n        const task = new Deferred();\n        return this.enqueueInternal(() => {\n            if (this._isShuttingDown && this.skipNonRestrictedTasks) {\n                // We do not resolve 'task'\n                return Promise.resolve();\n            }\n            op().then(task.resolve, task.reject);\n            return task.promise;\n        }).then(() => task.promise);\n    }\n    enqueueRetryable(op) {\n        this.enqueueAndForget(() => {\n            this.retryableOps.push(op);\n            return this.retryNextOp();\n        });\n    }\n    /**\n     * Runs the next operation from the retryable queue. If the operation fails,\n     * reschedules with backoff.\n     */\n    async retryNextOp() {\n        if (this.retryableOps.length === 0) {\n            return;\n        }\n        try {\n            await this.retryableOps[0]();\n            this.retryableOps.shift();\n            this.backoff.reset();\n        }\n        catch (e) {\n            if (isIndexedDbTransactionError(e)) {\n                logDebug(LOG_TAG, 'Operation failed with retryable error: ' + e);\n            }\n            else {\n                throw e; // Failure will be handled by AsyncQueue\n            }\n        }\n        if (this.retryableOps.length > 0) {\n            // If there are additional operations, we re-schedule `retryNextOp()`.\n            // This is necessary to run retryable operations that failed during\n            // their initial attempt since we don't know whether they are already\n            // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`\n            // needs to  be re-run, we will run `op1`, `op1`, `op2` using the\n            // already enqueued calls to `retryNextOp()`. `op3()` will then run in the\n            // call scheduled here.\n            // Since `backoffAndRun()` cancels an existing backoff and schedules a\n            // new backoff on every call, there is only ever a single additional\n            // operation in the queue.\n            this.backoff.backoffAndRun(() => this.retryNextOp());\n        }\n    }\n    enqueueInternal(op) {\n        const newTail = this.tail.then(() => {\n            this.operationInProgress = true;\n            return op()\n                .catch((error) => {\n                this.failure = error;\n                this.operationInProgress = false;\n                const message = getMessageOrStack(error);\n                logError('INTERNAL UNHANDLED ERROR: ', message);\n                // Re-throw the error so that this.tail becomes a rejected Promise and\n                // all further attempts to chain (via .then) will just short-circuit\n                // and return the rejected Promise.\n                throw error;\n            })\n                .then(result => {\n                this.operationInProgress = false;\n                return result;\n            });\n        });\n        this.tail = newTail;\n        return newTail;\n    }\n    enqueueAfterDelay(timerId, delayMs, op) {\n        this.verifyNotFailed();\n        // Fast-forward delays for timerIds that have been overridden.\n        if (this.timerIdsToSkip.indexOf(timerId) > -1) {\n            delayMs = 0;\n        }\n        const delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, removedOp => this.removeDelayedOperation(removedOp));\n        this.delayedOperations.push(delayedOp);\n        return delayedOp;\n    }\n    verifyNotFailed() {\n        if (this.failure) {\n            fail();\n        }\n    }\n    verifyOperationInProgress() {\n    }\n    /**\n     * Waits until all currently queued tasks are finished executing. Delayed\n     * operations are not run.\n     */\n    async drain() {\n        // Operations in the queue prior to draining may have enqueued additional\n        // operations. Keep draining the queue until the tail is no longer advanced,\n        // which indicates that no more new operations were enqueued and that all\n        // operations were executed.\n        let currentTail;\n        do {\n            currentTail = this.tail;\n            await currentTail;\n        } while (currentTail !== this.tail);\n    }\n    /**\n     * For Tests: Determine if a delayed operation with a particular TimerId\n     * exists.\n     */\n    containsDelayedOperation(timerId) {\n        for (const op of this.delayedOperations) {\n            if (op.timerId === timerId) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * For Tests: Runs some or all delayed operations early.\n     *\n     * @param lastTimerId - Delayed operations up to and including this TimerId\n     * will be drained. Pass TimerId.All to run all delayed operations.\n     * @returns a Promise that resolves once all operations have been run.\n     */\n    runAllDelayedOperationsUntil(lastTimerId) {\n        // Note that draining may generate more delayed ops, so we do that first.\n        return this.drain().then(() => {\n            // Run ops in the same order they'd run if they ran naturally.\n            /* eslint-disable-next-line @typescript-eslint/no-floating-promises */\n            this.delayedOperations.sort((a, b) => a.targetTimeMs - b.targetTimeMs);\n            for (const op of this.delayedOperations) {\n                op.skipDelay();\n                if (lastTimerId !== \"all\" /* TimerId.All */ && op.timerId === lastTimerId) {\n                    break;\n                }\n            }\n            return this.drain();\n        });\n    }\n    /**\n     * For Tests: Skip all subsequent delays for a timer id.\n     */\n    skipDelaysForTimerId(timerId) {\n        this.timerIdsToSkip.push(timerId);\n    }\n    /** Called once a DelayedOperation is run or canceled. */\n    removeDelayedOperation(op) {\n        // NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.\n        const index = this.delayedOperations.indexOf(op);\n        /* eslint-disable-next-line @typescript-eslint/no-floating-promises */\n        this.delayedOperations.splice(index, 1);\n    }\n}\n/**\n * Chrome includes Error.message in Error.stack. Other browsers do not.\n * This returns expected output of message + stack when available.\n * @param error - Error or FirestoreError\n */\nfunction getMessageOrStack(error) {\n    let message = error.message || '';\n    if (error.stack) {\n        if (error.stack.includes(error.message)) {\n            message = error.stack;\n        }\n        else {\n            message = error.message + '\\n' + error.stack;\n        }\n    }\n    return message;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents the task of loading a Firestore bundle. It provides progress of bundle\n * loading, as well as task completion and error events.\n *\n * The API is compatible with `Promise<LoadBundleTaskProgress>`.\n */\nclass LoadBundleTask {\n    constructor() {\n        this._progressObserver = {};\n        this._taskCompletionResolver = new Deferred();\n        this._lastProgress = {\n            taskState: 'Running',\n            totalBytes: 0,\n            totalDocuments: 0,\n            bytesLoaded: 0,\n            documentsLoaded: 0\n        };\n    }\n    /**\n     * Registers functions to listen to bundle loading progress events.\n     * @param next - Called when there is a progress update from bundle loading. Typically `next` calls occur\n     *   each time a Firestore document is loaded from the bundle.\n     * @param error - Called when an error occurs during bundle loading. The task aborts after reporting the\n     *   error, and there should be no more updates after this.\n     * @param complete - Called when the loading task is complete.\n     */\n    onProgress(next, error, complete) {\n        this._progressObserver = {\n            next,\n            error,\n            complete\n        };\n    }\n    /**\n     * Implements the `Promise<LoadBundleTaskProgress>.catch` interface.\n     *\n     * @param onRejected - Called when an error occurs during bundle loading.\n     */\n    catch(onRejected) {\n        return this._taskCompletionResolver.promise.catch(onRejected);\n    }\n    /**\n     * Implements the `Promise<LoadBundleTaskProgress>.then` interface.\n     *\n     * @param onFulfilled - Called on the completion of the loading task with a final `LoadBundleTaskProgress` update.\n     *   The update will always have its `taskState` set to `\"Success\"`.\n     * @param onRejected - Called when an error occurs during bundle loading.\n     */\n    then(onFulfilled, onRejected) {\n        return this._taskCompletionResolver.promise.then(onFulfilled, onRejected);\n    }\n    /**\n     * Notifies all observers that bundle loading has completed, with a provided\n     * `LoadBundleTaskProgress` object.\n     *\n     * @private\n     */\n    _completeWith(progress) {\n        this._updateProgress(progress);\n        if (this._progressObserver.complete) {\n            this._progressObserver.complete();\n        }\n        this._taskCompletionResolver.resolve(progress);\n    }\n    /**\n     * Notifies all observers that bundle loading has failed, with a provided\n     * `Error` as the reason.\n     *\n     * @private\n     */\n    _failWith(error) {\n        this._lastProgress.taskState = 'Error';\n        if (this._progressObserver.next) {\n            this._progressObserver.next(this._lastProgress);\n        }\n        if (this._progressObserver.error) {\n            this._progressObserver.error(error);\n        }\n        this._taskCompletionResolver.reject(error);\n    }\n    /**\n     * Notifies a progress update of loading a bundle.\n     * @param progress - The new progress.\n     *\n     * @private\n     */\n    _updateProgress(progress) {\n        this._lastProgress = progress;\n        if (this._progressObserver.next) {\n            this._progressObserver.next(progress);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Constant used to indicate the LRU garbage collection should be disabled.\n * Set this value as the `cacheSizeBytes` on the settings passed to the\n * {@link Firestore} instance.\n */\nconst CACHE_SIZE_UNLIMITED = LRU_COLLECTION_DISABLED;\n/**\n * The Cloud Firestore service interface.\n *\n * Do not call this constructor directly. Instead, use {@link (getFirestore:1)}.\n */\nclass Firestore extends Firestore$1 {\n    /** @hideconstructor */\n    constructor(authCredentialsProvider, appCheckCredentialsProvider, databaseId, app) {\n        super(authCredentialsProvider, appCheckCredentialsProvider, databaseId, app);\n        /**\n         * Whether it's a {@link Firestore} or Firestore Lite instance.\n         */\n        this.type = 'firestore';\n        this._queue = new AsyncQueueImpl();\n        this._persistenceKey = (app === null || app === void 0 ? void 0 : app.name) || '[DEFAULT]';\n    }\n    async _terminate() {\n        if (this._firestoreClient) {\n            const terminate = this._firestoreClient.terminate();\n            this._queue = new AsyncQueueImpl(terminate);\n            this._firestoreClient = undefined;\n            await terminate;\n        }\n    }\n}\n/**\n * Initializes a new instance of {@link Firestore} with the provided settings.\n * Can only be called before any other function, including\n * {@link (getFirestore:1)}. If the custom settings are empty, this function is\n * equivalent to calling {@link (getFirestore:1)}.\n *\n * @param app - The {@link @firebase/app#FirebaseApp} with which the {@link Firestore} instance will\n * be associated.\n * @param settings - A settings object to configure the {@link Firestore} instance.\n * @param databaseId - The name of the database.\n * @returns A newly initialized {@link Firestore} instance.\n */\nfunction initializeFirestore(app, settings, databaseId) {\n    if (!databaseId) {\n        databaseId = DEFAULT_DATABASE_NAME;\n    }\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'firestore');\n    if (provider.isInitialized(databaseId)) {\n        const existingInstance = provider.getImmediate({\n            identifier: databaseId\n        });\n        const initialSettings = provider.getOptions(databaseId);\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(initialSettings, settings)) {\n            return existingInstance;\n        }\n        else {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'initializeFirestore() has already been called with ' +\n                'different options. To avoid this error, call initializeFirestore() with the ' +\n                'same options as when it was originally called, or call getFirestore() to return the' +\n                ' already initialized instance.');\n        }\n    }\n    if (settings.cacheSizeBytes !== undefined &&\n        settings.localCache !== undefined) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `cache and cacheSizeBytes cannot be specified at the same time as cacheSizeBytes will` +\n            `be deprecated. Instead, specify the cache size in the cache object`);\n    }\n    if (settings.cacheSizeBytes !== undefined &&\n        settings.cacheSizeBytes !== CACHE_SIZE_UNLIMITED &&\n        settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);\n    }\n    return provider.initialize({\n        options: settings,\n        instanceIdentifier: databaseId\n    });\n}\nfunction getFirestore(appOrDatabaseId, optionalDatabaseId) {\n    const app = typeof appOrDatabaseId === 'object' ? appOrDatabaseId : (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)();\n    const databaseId = typeof appOrDatabaseId === 'string'\n        ? appOrDatabaseId\n        : optionalDatabaseId || DEFAULT_DATABASE_NAME;\n    const db = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'firestore').getImmediate({\n        identifier: databaseId\n    });\n    if (!db._initialized) {\n        const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getDefaultEmulatorHostnameAndPort)('firestore');\n        if (emulator) {\n            connectFirestoreEmulator(db, ...emulator);\n        }\n    }\n    return db;\n}\n/**\n * @internal\n */\nfunction ensureFirestoreConfigured(firestore) {\n    if (firestore._terminated) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');\n    }\n    if (!firestore._firestoreClient) {\n        configureFirestore(firestore);\n    }\n    return firestore._firestoreClient;\n}\nfunction configureFirestore(firestore) {\n    var _a, _b, _c;\n    const settings = firestore._freezeSettings();\n    const databaseInfo = makeDatabaseInfo(firestore._databaseId, ((_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.appId) || '', firestore._persistenceKey, settings);\n    if (!firestore._componentsProvider) {\n        if (((_b = settings.localCache) === null || _b === void 0 ? void 0 : _b._offlineComponentProvider) &&\n            ((_c = settings.localCache) === null || _c === void 0 ? void 0 : _c._onlineComponentProvider)) {\n            firestore._componentsProvider = {\n                _offline: settings.localCache._offlineComponentProvider,\n                _online: settings.localCache._onlineComponentProvider\n            };\n        }\n    }\n    firestore._firestoreClient = new FirestoreClient(firestore._authCredentials, firestore._appCheckCredentials, firestore._queue, databaseInfo, firestore._componentsProvider &&\n        buildComponentProvider(firestore._componentsProvider));\n}\nfunction buildComponentProvider(componentsProvider) {\n    const online = componentsProvider === null || componentsProvider === void 0 ? void 0 : componentsProvider._online.build();\n    return {\n        _offline: componentsProvider === null || componentsProvider === void 0 ? void 0 : componentsProvider._offline.build(online),\n        _online: online\n    };\n}\n/**\n * Attempts to enable persistent storage, if possible.\n *\n * On failure, `enableIndexedDbPersistence()` will reject the promise or\n * throw an exception. There are several reasons why this can fail, which can be\n * identified by the `code` on the error.\n *\n *   * failed-precondition: The app is already open in another browser tab.\n *   * unimplemented: The browser is incompatible with the offline persistence\n *     implementation.\n *\n * Note that even after a failure, the {@link Firestore} instance will remain\n * usable, however offline persistence will be disabled.\n *\n * Note: `enableIndexedDbPersistence()` must be called before any other functions\n * (other than {@link initializeFirestore}, {@link (getFirestore:1)} or\n * {@link clearIndexedDbPersistence}.\n *\n * Persistence cannot be used in a Node.js environment.\n *\n * @param firestore - The {@link Firestore} instance to enable persistence for.\n * @param persistenceSettings - Optional settings object to configure\n * persistence.\n * @returns A `Promise` that represents successfully enabling persistent storage.\n * @deprecated This function will be removed in a future major release. Instead, set\n * `FirestoreSettings.localCache` to an instance of `PersistentLocalCache` to\n * turn on IndexedDb cache. Calling this function when `FirestoreSettings.localCache`\n * is already specified will throw an exception.\n */\nfunction enableIndexedDbPersistence(firestore, persistenceSettings) {\n    logWarn('enableIndexedDbPersistence() will be deprecated in the future, ' +\n        'you can use `FirestoreSettings.cache` instead.');\n    const settings = firestore._freezeSettings();\n    setPersistenceProviders(firestore, OnlineComponentProvider.provider, {\n        build: (onlineComponents) => new IndexedDbOfflineComponentProvider(onlineComponents, settings.cacheSizeBytes, persistenceSettings === null || persistenceSettings === void 0 ? void 0 : persistenceSettings.forceOwnership)\n    });\n    return Promise.resolve();\n}\n/**\n * Attempts to enable multi-tab persistent storage, if possible. If enabled\n * across all tabs, all operations share access to local persistence, including\n * shared execution of queries and latency-compensated local document updates\n * across all connected instances.\n *\n * On failure, `enableMultiTabIndexedDbPersistence()` will reject the promise or\n * throw an exception. There are several reasons why this can fail, which can be\n * identified by the `code` on the error.\n *\n *   * failed-precondition: The app is already open in another browser tab and\n *     multi-tab is not enabled.\n *   * unimplemented: The browser is incompatible with the offline persistence\n *     implementation.\n *\n * Note that even after a failure, the {@link Firestore} instance will remain\n * usable, however offline persistence will be disabled.\n *\n * @param firestore - The {@link Firestore} instance to enable persistence for.\n * @returns A `Promise` that represents successfully enabling persistent\n * storage.\n * @deprecated This function will be removed in a future major release. Instead, set\n * `FirestoreSettings.localCache` to an instance of `PersistentLocalCache` to\n * turn on indexeddb cache. Calling this function when `FirestoreSettings.localCache`\n * is already specified will throw an exception.\n */\nasync function enableMultiTabIndexedDbPersistence(firestore) {\n    logWarn('enableMultiTabIndexedDbPersistence() will be deprecated in the future, ' +\n        'you can use `FirestoreSettings.cache` instead.');\n    const settings = firestore._freezeSettings();\n    setPersistenceProviders(firestore, OnlineComponentProvider.provider, {\n        build: (onlineComponents) => new MultiTabOfflineComponentProvider(onlineComponents, settings.cacheSizeBytes)\n    });\n}\n/**\n * Registers both the `OfflineComponentProvider` and `OnlineComponentProvider`.\n * If the operation fails with a recoverable error (see\n * `canRecoverFromIndexedDbError()` below), the returned Promise is rejected\n * but the client remains usable.\n */\nfunction setPersistenceProviders(firestore, onlineComponentProvider, offlineComponentProvider) {\n    firestore = cast(firestore, Firestore);\n    if (firestore._firestoreClient || firestore._terminated) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and persistence can no longer be ' +\n            'enabled. You can only enable persistence before calling any other ' +\n            'methods on a Firestore object.');\n    }\n    if (firestore._componentsProvider || firestore._getSettings().localCache) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'SDK cache is already specified.');\n    }\n    firestore._componentsProvider = {\n        _online: onlineComponentProvider,\n        _offline: offlineComponentProvider\n    };\n    configureFirestore(firestore);\n}\n/**\n * Clears the persistent storage. This includes pending writes and cached\n * documents.\n *\n * Must be called while the {@link Firestore} instance is not started (after the app is\n * terminated or when the app is first initialized). On startup, this function\n * must be called before other functions (other than {@link\n * initializeFirestore} or {@link (getFirestore:1)})). If the {@link Firestore}\n * instance is still running, the promise will be rejected with the error code\n * of `failed-precondition`.\n *\n * Note: `clearIndexedDbPersistence()` is primarily intended to help write\n * reliable tests that use Cloud Firestore. It uses an efficient mechanism for\n * dropping existing data but does not attempt to securely overwrite or\n * otherwise make cached data unrecoverable. For applications that are sensitive\n * to the disclosure of cached data in between user sessions, we strongly\n * recommend not enabling persistence at all.\n *\n * @param firestore - The {@link Firestore} instance to clear persistence for.\n * @returns A `Promise` that is resolved when the persistent storage is\n * cleared. Otherwise, the promise is rejected with an error.\n */\nfunction clearIndexedDbPersistence(firestore) {\n    if (firestore._initialized && !firestore._terminated) {\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'Persistence can only be cleared before a Firestore instance is ' +\n            'initialized or after it is terminated.');\n    }\n    const deferred = new Deferred();\n    firestore._queue.enqueueAndForgetEvenWhileRestricted(async () => {\n        try {\n            await indexedDbClearPersistence(indexedDbStoragePrefix(firestore._databaseId, firestore._persistenceKey));\n            deferred.resolve();\n        }\n        catch (e) {\n            deferred.reject(e);\n        }\n    });\n    return deferred.promise;\n}\n/**\n * Waits until all currently pending writes for the active user have been\n * acknowledged by the backend.\n *\n * The returned promise resolves immediately if there are no outstanding writes.\n * Otherwise, the promise waits for all previously issued writes (including\n * those written in a previous app session), but it does not wait for writes\n * that were added after the function is called. If you want to wait for\n * additional writes, call `waitForPendingWrites()` again.\n *\n * Any outstanding `waitForPendingWrites()` promises are rejected during user\n * changes.\n *\n * @returns A `Promise` which resolves when all currently pending writes have been\n * acknowledged by the backend.\n */\nfunction waitForPendingWrites(firestore) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientWaitForPendingWrites(client);\n}\n/**\n * Re-enables use of the network for this {@link Firestore} instance after a prior\n * call to {@link disableNetwork}.\n *\n * @returns A `Promise` that is resolved once the network has been enabled.\n */\nfunction enableNetwork(firestore) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientEnableNetwork(client);\n}\n/**\n * Disables network usage for this instance. It can be re-enabled via {@link\n * enableNetwork}. While the network is disabled, any snapshot listeners,\n * `getDoc()` or `getDocs()` calls will return results from cache, and any write\n * operations will be queued until the network is restored.\n *\n * @returns A `Promise` that is resolved once the network has been disabled.\n */\nfunction disableNetwork(firestore) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientDisableNetwork(client);\n}\n/**\n * Terminates the provided {@link Firestore} instance.\n *\n * After calling `terminate()` only the `clearIndexedDbPersistence()` function\n * may be used. Any other function will throw a `FirestoreError`.\n *\n * To restart after termination, create a new instance of FirebaseFirestore with\n * {@link (getFirestore:1)}.\n *\n * Termination does not cancel any pending writes, and any promises that are\n * awaiting a response from the server will not be resolved. If you have\n * persistence enabled, the next time you start this instance, it will resume\n * sending these writes to the server.\n *\n * Note: Under normal circumstances, calling `terminate()` is not required. This\n * function is useful only when you want to force this instance to release all\n * of its resources or in combination with `clearIndexedDbPersistence()` to\n * ensure that all local state is destroyed between test runs.\n *\n * @returns A `Promise` that is resolved when the instance has been successfully\n * terminated.\n */\nfunction terminate(firestore) {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._removeServiceInstance)(firestore.app, 'firestore', firestore._databaseId.database);\n    return firestore._delete();\n}\n/**\n * Loads a Firestore bundle into the local cache.\n *\n * @param firestore - The {@link Firestore} instance to load bundles for.\n * @param bundleData - An object representing the bundle to be loaded. Valid\n * objects are `ArrayBuffer`, `ReadableStream<Uint8Array>` or `string`.\n *\n * @returns A `LoadBundleTask` object, which notifies callers with progress\n * updates, and completion or error events. It can be used as a\n * `Promise<LoadBundleTaskProgress>`.\n */\nfunction loadBundle(firestore, bundleData) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const resultTask = new LoadBundleTask();\n    firestoreClientLoadBundle(client, firestore._databaseId, bundleData, resultTask);\n    return resultTask;\n}\n/**\n * Reads a Firestore {@link Query} from local cache, identified by the given\n * name.\n *\n * The named queries are packaged  into bundles on the server side (along\n * with resulting documents), and loaded to local cache using `loadBundle`. Once\n * in local cache, use this method to extract a {@link Query} by name.\n *\n * @param firestore - The {@link Firestore} instance to read the query from.\n * @param name - The name of the query.\n * @returns A `Promise` that is resolved with the Query or `null`.\n */\nfunction namedQuery(firestore, name) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientGetNamedQuery(client, name).then(namedQuery => {\n        if (!namedQuery) {\n            return null;\n        }\n        return new Query(firestore, null, namedQuery.query);\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction registerFirestore(variant, useFetchStreams = true) {\n    setSDKVersion(_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION);\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component('firestore', (container, { instanceIdentifier: databaseId, options: settings }) => {\n        const app = container.getProvider('app').getImmediate();\n        const firestoreInstance = new Firestore(new FirebaseAuthCredentialsProvider(container.getProvider('auth-internal')), new FirebaseAppCheckTokenProvider(app, container.getProvider('app-check-internal')), databaseIdFromApp(app, databaseId), app);\n        settings = Object.assign({ useFetchStreams }, settings);\n        firestoreInstance._setSettings(settings);\n        return firestoreInstance;\n    }, 'PUBLIC').setMultipleInstances(true));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version$1, variant);\n    // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version$1, 'esm2017');\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Concrete implementation of the Aggregate type.\n */\nclass AggregateImpl {\n    constructor(alias, aggregateType, fieldPath) {\n        this.alias = alias;\n        this.aggregateType = aggregateType;\n        this.fieldPath = fieldPath;\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents an aggregation that can be performed by Firestore.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nclass AggregateField {\n    /**\n     * Create a new AggregateField<T>\n     * @param aggregateType Specifies the type of aggregation operation to perform.\n     * @param _internalFieldPath Optionally specifies the field that is aggregated.\n     * @internal\n     */\n    constructor(aggregateType = 'count', _internalFieldPath) {\n        this._internalFieldPath = _internalFieldPath;\n        /** A type string to uniquely identify instances of this class. */\n        this.type = 'AggregateField';\n        this.aggregateType = aggregateType;\n    }\n}\n/**\n * The results of executing an aggregation query.\n */\nclass AggregateQuerySnapshot {\n    /** @hideconstructor */\n    constructor(query, _userDataWriter, _data) {\n        this._userDataWriter = _userDataWriter;\n        this._data = _data;\n        /** A type string to uniquely identify instances of this class. */\n        this.type = 'AggregateQuerySnapshot';\n        this.query = query;\n    }\n    /**\n     * Returns the results of the aggregations performed over the underlying\n     * query.\n     *\n     * The keys of the returned object will be the same as those of the\n     * `AggregateSpec` object specified to the aggregation method, and the values\n     * will be the corresponding aggregation result.\n     *\n     * @returns The results of the aggregations performed over the underlying\n     * query.\n     */\n    data() {\n        return this._userDataWriter.convertObjectMap(this._data);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An immutable object representing an array of bytes.\n */\nclass Bytes {\n    /** @hideconstructor */\n    constructor(byteString) {\n        this._byteString = byteString;\n    }\n    /**\n     * Creates a new `Bytes` object from the given Base64 string, converting it to\n     * bytes.\n     *\n     * @param base64 - The Base64 string used to create the `Bytes` object.\n     */\n    static fromBase64String(base64) {\n        try {\n            return new Bytes(ByteString.fromBase64String(base64));\n        }\n        catch (e) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to construct data from Base64 string: ' + e);\n        }\n    }\n    /**\n     * Creates a new `Bytes` object from the given Uint8Array.\n     *\n     * @param array - The Uint8Array used to create the `Bytes` object.\n     */\n    static fromUint8Array(array) {\n        return new Bytes(ByteString.fromUint8Array(array));\n    }\n    /**\n     * Returns the underlying bytes as a Base64-encoded string.\n     *\n     * @returns The Base64-encoded string created from the `Bytes` object.\n     */\n    toBase64() {\n        return this._byteString.toBase64();\n    }\n    /**\n     * Returns the underlying bytes in a new `Uint8Array`.\n     *\n     * @returns The Uint8Array created from the `Bytes` object.\n     */\n    toUint8Array() {\n        return this._byteString.toUint8Array();\n    }\n    /**\n     * Returns a string representation of the `Bytes` object.\n     *\n     * @returns A string representation of the `Bytes` object.\n     */\n    toString() {\n        return 'Bytes(base64: ' + this.toBase64() + ')';\n    }\n    /**\n     * Returns true if this `Bytes` object is equal to the provided one.\n     *\n     * @param other - The `Bytes` object to compare against.\n     * @returns true if this `Bytes` object is equal to the provided one.\n     */\n    isEqual(other) {\n        return this._byteString.isEqual(other._byteString);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `FieldPath` refers to a field in a document. The path may consist of a\n * single field name (referring to a top-level field in the document), or a\n * list of field names (referring to a nested field in the document).\n *\n * Create a `FieldPath` by providing field names. If more than one field\n * name is provided, the path will point to a nested field in a document.\n */\nclass FieldPath {\n    /**\n     * Creates a `FieldPath` from the provided field names. If more than one field\n     * name is provided, the path will point to a nested field in a document.\n     *\n     * @param fieldNames - A list of field names.\n     */\n    constructor(...fieldNames) {\n        for (let i = 0; i < fieldNames.length; ++i) {\n            if (fieldNames[i].length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field name at argument $(i + 1). ` +\n                    'Field names must not be empty.');\n            }\n        }\n        this._internalPath = new FieldPath$1(fieldNames);\n    }\n    /**\n     * Returns true if this `FieldPath` is equal to the provided one.\n     *\n     * @param other - The `FieldPath` to compare against.\n     * @returns true if this `FieldPath` is equal to the provided one.\n     */\n    isEqual(other) {\n        return this._internalPath.isEqual(other._internalPath);\n    }\n}\n/**\n * Returns a special sentinel `FieldPath` to refer to the ID of a document.\n * It can be used in queries to sort or filter by the document ID.\n */\nfunction documentId() {\n    return new FieldPath(DOCUMENT_KEY_NAME);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Sentinel values that can be used when writing document fields with `set()`\n * or `update()`.\n */\nclass FieldValue {\n    /**\n     * @param _methodName - The public API endpoint that returns this class.\n     * @hideconstructor\n     */\n    constructor(_methodName) {\n        this._methodName = _methodName;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An immutable object representing a geographic location in Firestore. The\n * location is represented as latitude/longitude pair.\n *\n * Latitude values are in the range of [-90, 90].\n * Longitude values are in the range of [-180, 180].\n */\nclass GeoPoint {\n    /**\n     * Creates a new immutable `GeoPoint` object with the provided latitude and\n     * longitude values.\n     * @param latitude - The latitude as number between -90 and 90.\n     * @param longitude - The longitude as number between -180 and 180.\n     */\n    constructor(latitude, longitude) {\n        if (!isFinite(latitude) || latitude < -90 || latitude > 90) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Latitude must be a number between -90 and 90, but was: ' + latitude);\n        }\n        if (!isFinite(longitude) || longitude < -180 || longitude > 180) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Longitude must be a number between -180 and 180, but was: ' + longitude);\n        }\n        this._lat = latitude;\n        this._long = longitude;\n    }\n    /**\n     * The latitude of this `GeoPoint` instance.\n     */\n    get latitude() {\n        return this._lat;\n    }\n    /**\n     * The longitude of this `GeoPoint` instance.\n     */\n    get longitude() {\n        return this._long;\n    }\n    /**\n     * Returns true if this `GeoPoint` is equal to the provided one.\n     *\n     * @param other - The `GeoPoint` to compare against.\n     * @returns true if this `GeoPoint` is equal to the provided one.\n     */\n    isEqual(other) {\n        return this._lat === other._lat && this._long === other._long;\n    }\n    /** Returns a JSON-serializable representation of this GeoPoint. */\n    toJSON() {\n        return { latitude: this._lat, longitude: this._long };\n    }\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n    _compareTo(other) {\n        return (primitiveComparator(this._lat, other._lat) ||\n            primitiveComparator(this._long, other._long));\n    }\n}\n\n/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a vector type in Firestore documents.\n * Create an instance with <code>{@link vector}</code>.\n *\n * @class VectorValue\n */\nclass VectorValue {\n    /**\n     * @private\n     * @internal\n     */\n    constructor(values) {\n        // Making a copy of the parameter.\n        this._values = (values || []).map(n => n);\n    }\n    /**\n     * Returns a copy of the raw number array form of the vector.\n     */\n    toArray() {\n        return this._values.map(n => n);\n    }\n    /**\n     * Returns `true` if the two `VectorValue` values have the same raw number arrays, returns `false` otherwise.\n     */\n    isEqual(other) {\n        return isPrimitiveArrayEqual(this._values, other._values);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst RESERVED_FIELD_REGEX = /^__.*__$/;\n/** The result of parsing document data (e.g. for a setData call). */\nclass ParsedSetData {\n    constructor(data, fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    toMutation(key, precondition) {\n        if (this.fieldMask !== null) {\n            return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);\n        }\n        else {\n            return new SetMutation(key, this.data, precondition, this.fieldTransforms);\n        }\n    }\n}\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\nclass ParsedUpdateData {\n    constructor(data, \n    // The fieldMask does not include document transforms.\n    fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    toMutation(key, precondition) {\n        return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);\n    }\n}\nfunction isWrite(dataSource) {\n    switch (dataSource) {\n        case 0 /* UserDataSource.Set */: // fall through\n        case 2 /* UserDataSource.MergeSet */: // fall through\n        case 1 /* UserDataSource.Update */:\n            return true;\n        case 3 /* UserDataSource.Argument */:\n        case 4 /* UserDataSource.ArrayArgument */:\n            return false;\n        default:\n            throw fail();\n    }\n}\n/** A \"context\" object passed around while parsing user data. */\nclass ParseContextImpl {\n    /**\n     * Initializes a ParseContext with the given source and path.\n     *\n     * @param settings - The settings for the parser.\n     * @param databaseId - The database ID of the Firestore instance.\n     * @param serializer - The serializer to use to generate the Value proto.\n     * @param ignoreUndefinedProperties - Whether to ignore undefined properties\n     * rather than throw.\n     * @param fieldTransforms - A mutable list of field transforms encountered\n     * while parsing the data.\n     * @param fieldMask - A mutable list of field paths encountered while parsing\n     * the data.\n     *\n     * TODO(b/34871131): We don't support array paths right now, so path can be\n     * null to indicate the context represents any location within an array (in\n     * which case certain features will not work and errors will be somewhat\n     * compromised).\n     */\n    constructor(settings, databaseId, serializer, ignoreUndefinedProperties, fieldTransforms, fieldMask) {\n        this.settings = settings;\n        this.databaseId = databaseId;\n        this.serializer = serializer;\n        this.ignoreUndefinedProperties = ignoreUndefinedProperties;\n        // Minor hack: If fieldTransforms is undefined, we assume this is an\n        // external call and we need to validate the entire path.\n        if (fieldTransforms === undefined) {\n            this.validatePath();\n        }\n        this.fieldTransforms = fieldTransforms || [];\n        this.fieldMask = fieldMask || [];\n    }\n    get path() {\n        return this.settings.path;\n    }\n    get dataSource() {\n        return this.settings.dataSource;\n    }\n    /** Returns a new context with the specified settings overwritten. */\n    contextWith(configuration) {\n        return new ParseContextImpl(Object.assign(Object.assign({}, this.settings), configuration), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);\n    }\n    childContextForField(field) {\n        var _a;\n        const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);\n        const context = this.contextWith({ path: childPath, arrayElement: false });\n        context.validatePathSegment(field);\n        return context;\n    }\n    childContextForFieldPath(field) {\n        var _a;\n        const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);\n        const context = this.contextWith({ path: childPath, arrayElement: false });\n        context.validatePath();\n        return context;\n    }\n    childContextForArray(index) {\n        // TODO(b/34871131): We don't support array paths right now; so make path\n        // undefined.\n        return this.contextWith({ path: undefined, arrayElement: true });\n    }\n    createError(reason) {\n        return createError(reason, this.settings.methodName, this.settings.hasConverter || false, this.path, this.settings.targetDoc);\n    }\n    /** Returns 'true' if 'fieldPath' was traversed when creating this context. */\n    contains(fieldPath) {\n        return (this.fieldMask.find(field => fieldPath.isPrefixOf(field)) !== undefined ||\n            this.fieldTransforms.find(transform => fieldPath.isPrefixOf(transform.field)) !== undefined);\n    }\n    validatePath() {\n        // TODO(b/34871131): Remove null check once we have proper paths for fields\n        // within arrays.\n        if (!this.path) {\n            return;\n        }\n        for (let i = 0; i < this.path.length; i++) {\n            this.validatePathSegment(this.path.get(i));\n        }\n    }\n    validatePathSegment(segment) {\n        if (segment.length === 0) {\n            throw this.createError('Document fields must not be empty');\n        }\n        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {\n            throw this.createError('Document fields cannot begin and end with \"__\"');\n        }\n    }\n}\n/**\n * Helper for parsing raw user input (provided via the API) into internal model\n * classes.\n */\nclass UserDataReader {\n    constructor(databaseId, ignoreUndefinedProperties, serializer) {\n        this.databaseId = databaseId;\n        this.ignoreUndefinedProperties = ignoreUndefinedProperties;\n        this.serializer = serializer || newSerializer(databaseId);\n    }\n    /** Creates a new top-level parse context. */\n    createContext(dataSource, methodName, targetDoc, hasConverter = false) {\n        return new ParseContextImpl({\n            dataSource,\n            methodName,\n            targetDoc,\n            path: FieldPath$1.emptyPath(),\n            arrayElement: false,\n            hasConverter\n        }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);\n    }\n}\nfunction newUserDataReader(firestore) {\n    const settings = firestore._freezeSettings();\n    const serializer = newSerializer(firestore._databaseId);\n    return new UserDataReader(firestore._databaseId, !!settings.ignoreUndefinedProperties, serializer);\n}\n/** Parse document data from a set() call. */\nfunction parseSetData(userDataReader, methodName, targetDoc, input, hasConverter, options = {}) {\n    const context = userDataReader.createContext(options.merge || options.mergeFields\n        ? 2 /* UserDataSource.MergeSet */\n        : 0 /* UserDataSource.Set */, methodName, targetDoc, hasConverter);\n    validatePlainObject('Data must be an object, but it was:', context, input);\n    const updateData = parseObject(input, context);\n    let fieldMask;\n    let fieldTransforms;\n    if (options.merge) {\n        fieldMask = new FieldMask(context.fieldMask);\n        fieldTransforms = context.fieldTransforms;\n    }\n    else if (options.mergeFields) {\n        const validatedFieldPaths = [];\n        for (const stringOrFieldPath of options.mergeFields) {\n            const fieldPath = fieldPathFromArgument$1(methodName, stringOrFieldPath, targetDoc);\n            if (!context.contains(fieldPath)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Field '${fieldPath}' is specified in your field mask but missing from your input data.`);\n            }\n            if (!fieldMaskContains(validatedFieldPaths, fieldPath)) {\n                validatedFieldPaths.push(fieldPath);\n            }\n        }\n        fieldMask = new FieldMask(validatedFieldPaths);\n        fieldTransforms = context.fieldTransforms.filter(transform => fieldMask.covers(transform.field));\n    }\n    else {\n        fieldMask = null;\n        fieldTransforms = context.fieldTransforms;\n    }\n    return new ParsedSetData(new ObjectValue(updateData), fieldMask, fieldTransforms);\n}\nclass DeleteFieldValueImpl extends FieldValue {\n    _toFieldTransform(context) {\n        if (context.dataSource === 2 /* UserDataSource.MergeSet */) {\n            // No transform to add for a delete, but we need to add it to our\n            // fieldMask so it gets deleted.\n            context.fieldMask.push(context.path);\n        }\n        else if (context.dataSource === 1 /* UserDataSource.Update */) {\n            throw context.createError(`${this._methodName}() can only appear at the top level ` +\n                'of your update data');\n        }\n        else {\n            // We shouldn't encounter delete sentinels for queries or non-merge set() calls.\n            throw context.createError(`${this._methodName}() cannot be used with set() unless you pass ` +\n                '{merge:true}');\n        }\n        return null;\n    }\n    isEqual(other) {\n        return other instanceof DeleteFieldValueImpl;\n    }\n}\n/**\n * Creates a child context for parsing SerializableFieldValues.\n *\n * This is different than calling `ParseContext.contextWith` because it keeps\n * the fieldTransforms and fieldMask separate.\n *\n * The created context has its `dataSource` set to `UserDataSource.Argument`.\n * Although these values are used with writes, any elements in these FieldValues\n * are not considered writes since they cannot contain any FieldValue sentinels,\n * etc.\n *\n * @param fieldValue - The sentinel FieldValue for which to create a child\n *     context.\n * @param context - The parent context.\n * @param arrayElement - Whether or not the FieldValue has an array.\n */\nfunction createSentinelChildContext(fieldValue, context, arrayElement) {\n    return new ParseContextImpl({\n        dataSource: 3 /* UserDataSource.Argument */,\n        targetDoc: context.settings.targetDoc,\n        methodName: fieldValue._methodName,\n        arrayElement\n    }, context.databaseId, context.serializer, context.ignoreUndefinedProperties);\n}\nclass ServerTimestampFieldValueImpl extends FieldValue {\n    _toFieldTransform(context) {\n        return new FieldTransform(context.path, new ServerTimestampTransform());\n    }\n    isEqual(other) {\n        return other instanceof ServerTimestampFieldValueImpl;\n    }\n}\nclass ArrayUnionFieldValueImpl extends FieldValue {\n    constructor(methodName, _elements) {\n        super(methodName);\n        this._elements = _elements;\n    }\n    _toFieldTransform(context) {\n        const parseContext = createSentinelChildContext(this, context, \n        /*array=*/ true);\n        const parsedElements = this._elements.map(element => parseData(element, parseContext));\n        const arrayUnion = new ArrayUnionTransformOperation(parsedElements);\n        return new FieldTransform(context.path, arrayUnion);\n    }\n    isEqual(other) {\n        return (other instanceof ArrayUnionFieldValueImpl &&\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(this._elements, other._elements));\n    }\n}\nclass ArrayRemoveFieldValueImpl extends FieldValue {\n    constructor(methodName, _elements) {\n        super(methodName);\n        this._elements = _elements;\n    }\n    _toFieldTransform(context) {\n        const parseContext = createSentinelChildContext(this, context, \n        /*array=*/ true);\n        const parsedElements = this._elements.map(element => parseData(element, parseContext));\n        const arrayUnion = new ArrayRemoveTransformOperation(parsedElements);\n        return new FieldTransform(context.path, arrayUnion);\n    }\n    isEqual(other) {\n        return (other instanceof ArrayRemoveFieldValueImpl &&\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(this._elements, other._elements));\n    }\n}\nclass NumericIncrementFieldValueImpl extends FieldValue {\n    constructor(methodName, _operand) {\n        super(methodName);\n        this._operand = _operand;\n    }\n    _toFieldTransform(context) {\n        const numericIncrement = new NumericIncrementTransformOperation(context.serializer, toNumber(context.serializer, this._operand));\n        return new FieldTransform(context.path, numericIncrement);\n    }\n    isEqual(other) {\n        return (other instanceof NumericIncrementFieldValueImpl &&\n            this._operand === other._operand);\n    }\n}\n/** Parse update data from an update() call. */\nfunction parseUpdateData(userDataReader, methodName, targetDoc, input) {\n    const context = userDataReader.createContext(1 /* UserDataSource.Update */, methodName, targetDoc);\n    validatePlainObject('Data must be an object, but it was:', context, input);\n    const fieldMaskPaths = [];\n    const updateData = ObjectValue.empty();\n    forEach(input, (key, value) => {\n        const path = fieldPathFromDotSeparatedString(methodName, key, targetDoc);\n        // For Compat types, we have to \"extract\" the underlying types before\n        // performing validation.\n        value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\n        const childContext = context.childContextForFieldPath(path);\n        if (value instanceof DeleteFieldValueImpl) {\n            // Add it to the field mask, but don't add anything to updateData.\n            fieldMaskPaths.push(path);\n        }\n        else {\n            const parsedValue = parseData(value, childContext);\n            if (parsedValue != null) {\n                fieldMaskPaths.push(path);\n                updateData.set(path, parsedValue);\n            }\n        }\n    });\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n}\n/** Parse update data from a list of field/value arguments. */\nfunction parseUpdateVarargs(userDataReader, methodName, targetDoc, field, value, moreFieldsAndValues) {\n    const context = userDataReader.createContext(1 /* UserDataSource.Update */, methodName, targetDoc);\n    const keys = [fieldPathFromArgument$1(methodName, field, targetDoc)];\n    const values = [value];\n    if (moreFieldsAndValues.length % 2 !== 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${methodName}() needs to be called with an even number ` +\n            'of arguments that alternate between field names and values.');\n    }\n    for (let i = 0; i < moreFieldsAndValues.length; i += 2) {\n        keys.push(fieldPathFromArgument$1(methodName, moreFieldsAndValues[i]));\n        values.push(moreFieldsAndValues[i + 1]);\n    }\n    const fieldMaskPaths = [];\n    const updateData = ObjectValue.empty();\n    // We iterate in reverse order to pick the last value for a field if the\n    // user specified the field multiple times.\n    for (let i = keys.length - 1; i >= 0; --i) {\n        if (!fieldMaskContains(fieldMaskPaths, keys[i])) {\n            const path = keys[i];\n            let value = values[i];\n            // For Compat types, we have to \"extract\" the underlying types before\n            // performing validation.\n            value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\n            const childContext = context.childContextForFieldPath(path);\n            if (value instanceof DeleteFieldValueImpl) {\n                // Add it to the field mask, but don't add anything to updateData.\n                fieldMaskPaths.push(path);\n            }\n            else {\n                const parsedValue = parseData(value, childContext);\n                if (parsedValue != null) {\n                    fieldMaskPaths.push(path);\n                    updateData.set(path, parsedValue);\n                }\n            }\n        }\n    }\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n}\n/**\n * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\n * bound).\n *\n * @param allowArrays - Whether the query value is an array that may directly\n * contain additional arrays (e.g. the operand of an `in` query).\n */\nfunction parseQueryValue(userDataReader, methodName, input, allowArrays = false) {\n    const context = userDataReader.createContext(allowArrays ? 4 /* UserDataSource.ArrayArgument */ : 3 /* UserDataSource.Argument */, methodName);\n    const parsed = parseData(input, context);\n    return parsed;\n}\n/**\n * Parses user data to Protobuf Values.\n *\n * @param input - Data to be parsed.\n * @param context - A context object representing the current path being parsed,\n * the source of the data being parsed, etc.\n * @returns The parsed value, or null if the value was a FieldValue sentinel\n * that should not be included in the resulting parsed data.\n */\nfunction parseData(input, context) {\n    // Unwrap the API type from the Compat SDK. This will return the API type\n    // from firestore-exp.\n    input = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(input);\n    if (looksLikeJsonObject(input)) {\n        validatePlainObject('Unsupported field value:', context, input);\n        return parseObject(input, context);\n    }\n    else if (input instanceof FieldValue) {\n        // FieldValues usually parse into transforms (except deleteField())\n        // in which case we do not want to include this field in our parsed data\n        // (as doing so will overwrite the field directly prior to the transform\n        // trying to transform it). So we don't add this location to\n        // context.fieldMask and we return null as our parsing result.\n        parseSentinelFieldValue(input, context);\n        return null;\n    }\n    else if (input === undefined && context.ignoreUndefinedProperties) {\n        // If the input is undefined it can never participate in the fieldMask, so\n        // don't handle this below. If `ignoreUndefinedProperties` is false,\n        // `parseScalarValue` will reject an undefined value.\n        return null;\n    }\n    else {\n        // If context.path is null we are inside an array and we don't support\n        // field mask paths more granular than the top-level array.\n        if (context.path) {\n            context.fieldMask.push(context.path);\n        }\n        if (input instanceof Array) {\n            // TODO(b/34871131): Include the path containing the array in the error\n            // message.\n            // In the case of IN queries, the parsed data is an array (representing\n            // the set of values to be included for the IN query) that may directly\n            // contain additional arrays (each representing an individual field\n            // value), so we disable this validation.\n            if (context.settings.arrayElement &&\n                context.dataSource !== 4 /* UserDataSource.ArrayArgument */) {\n                throw context.createError('Nested arrays are not supported');\n            }\n            return parseArray(input, context);\n        }\n        else {\n            return parseScalarValue(input, context);\n        }\n    }\n}\nfunction parseObject(obj, context) {\n    const fields = {};\n    if (isEmpty(obj)) {\n        // If we encounter an empty object, we explicitly add it to the update\n        // mask to ensure that the server creates a map entry.\n        if (context.path && context.path.length > 0) {\n            context.fieldMask.push(context.path);\n        }\n    }\n    else {\n        forEach(obj, (key, val) => {\n            const parsedValue = parseData(val, context.childContextForField(key));\n            if (parsedValue != null) {\n                fields[key] = parsedValue;\n            }\n        });\n    }\n    return { mapValue: { fields } };\n}\nfunction parseArray(array, context) {\n    const values = [];\n    let entryIndex = 0;\n    for (const entry of array) {\n        let parsedEntry = parseData(entry, context.childContextForArray(entryIndex));\n        if (parsedEntry == null) {\n            // Just include nulls in the array for fields being replaced with a\n            // sentinel.\n            parsedEntry = { nullValue: 'NULL_VALUE' };\n        }\n        values.push(parsedEntry);\n        entryIndex++;\n    }\n    return { arrayValue: { values } };\n}\n/**\n * \"Parses\" the provided FieldValueImpl, adding any necessary transforms to\n * context.fieldTransforms.\n */\nfunction parseSentinelFieldValue(value, context) {\n    // Sentinels are only supported with writes, and not within arrays.\n    if (!isWrite(context.dataSource)) {\n        throw context.createError(`${value._methodName}() can only be used with update() and set()`);\n    }\n    if (!context.path) {\n        throw context.createError(`${value._methodName}() is not currently supported inside arrays`);\n    }\n    const fieldTransform = value._toFieldTransform(context);\n    if (fieldTransform) {\n        context.fieldTransforms.push(fieldTransform);\n    }\n}\n/**\n * Helper to parse a scalar value (i.e. not an Object, Array, or FieldValue)\n *\n * @returns The parsed value\n */\nfunction parseScalarValue(value, context) {\n    value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\n    if (value === null) {\n        return { nullValue: 'NULL_VALUE' };\n    }\n    else if (typeof value === 'number') {\n        return toNumber(context.serializer, value);\n    }\n    else if (typeof value === 'boolean') {\n        return { booleanValue: value };\n    }\n    else if (typeof value === 'string') {\n        return { stringValue: value };\n    }\n    else if (value instanceof Date) {\n        const timestamp = Timestamp.fromDate(value);\n        return {\n            timestampValue: toTimestamp(context.serializer, timestamp)\n        };\n    }\n    else if (value instanceof Timestamp) {\n        // Firestore backend truncates precision down to microseconds. To ensure\n        // offline mode works the same with regards to truncation, perform the\n        // truncation immediately without waiting for the backend to do that.\n        const timestamp = new Timestamp(value.seconds, Math.floor(value.nanoseconds / 1000) * 1000);\n        return {\n            timestampValue: toTimestamp(context.serializer, timestamp)\n        };\n    }\n    else if (value instanceof GeoPoint) {\n        return {\n            geoPointValue: {\n                latitude: value.latitude,\n                longitude: value.longitude\n            }\n        };\n    }\n    else if (value instanceof Bytes) {\n        return { bytesValue: toBytes(context.serializer, value._byteString) };\n    }\n    else if (value instanceof DocumentReference) {\n        const thisDb = context.databaseId;\n        const otherDb = value.firestore._databaseId;\n        if (!otherDb.isEqual(thisDb)) {\n            throw context.createError('Document reference is for database ' +\n                `${otherDb.projectId}/${otherDb.database} but should be ` +\n                `for database ${thisDb.projectId}/${thisDb.database}`);\n        }\n        return {\n            referenceValue: toResourceName(value.firestore._databaseId || context.databaseId, value._key.path)\n        };\n    }\n    else if (value instanceof VectorValue) {\n        return parseVectorValue(value, context);\n    }\n    else {\n        throw context.createError(`Unsupported field value: ${valueDescription(value)}`);\n    }\n}\n/**\n * Creates a new VectorValue proto value (using the internal format).\n */\nfunction parseVectorValue(value, context) {\n    const mapValue = {\n        fields: {\n            [TYPE_KEY]: {\n                stringValue: VECTOR_VALUE_SENTINEL\n            },\n            [VECTOR_MAP_VECTORS_KEY]: {\n                arrayValue: {\n                    values: value.toArray().map(value => {\n                        if (typeof value !== 'number') {\n                            throw context.createError('VectorValues must only contain numeric values.');\n                        }\n                        return toDouble(context.serializer, value);\n                    })\n                }\n            }\n        }\n    };\n    return { mapValue };\n}\n/**\n * Checks whether an object looks like a JSON object that should be converted\n * into a struct. Normal class/prototype instances are considered to look like\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\n * GeoPoints, etc. are not considered to look like JSON objects since they map\n * to specific FieldValue types other than ObjectValue.\n */\nfunction looksLikeJsonObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        !(input instanceof Array) &&\n        !(input instanceof Date) &&\n        !(input instanceof Timestamp) &&\n        !(input instanceof GeoPoint) &&\n        !(input instanceof Bytes) &&\n        !(input instanceof DocumentReference) &&\n        !(input instanceof FieldValue) &&\n        !(input instanceof VectorValue));\n}\nfunction validatePlainObject(message, context, input) {\n    if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\n        const description = valueDescription(input);\n        if (description === 'an object') {\n            // Massage the error if it was an object.\n            throw context.createError(message + ' a custom object');\n        }\n        else {\n            throw context.createError(message + ' ' + description);\n        }\n    }\n}\n/**\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\n */\nfunction fieldPathFromArgument$1(methodName, path, targetDoc) {\n    // If required, replace the FieldPath Compat class with the firestore-exp\n    // FieldPath.\n    path = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(path);\n    if (path instanceof FieldPath) {\n        return path._internalPath;\n    }\n    else if (typeof path === 'string') {\n        return fieldPathFromDotSeparatedString(methodName, path);\n    }\n    else {\n        const message = 'Field path arguments must be of type string or ';\n        throw createError(message, methodName, \n        /* hasConverter= */ false, \n        /* path= */ undefined, targetDoc);\n    }\n}\n/**\n * Matches any characters in a field path string that are reserved.\n */\nconst FIELD_PATH_RESERVED = new RegExp('[~\\\\*/\\\\[\\\\]]');\n/**\n * Wraps fromDotSeparatedString with an error message about the method that\n * was thrown.\n * @param methodName - The publicly visible method name\n * @param path - The dot-separated string form of a field path which will be\n * split on dots.\n * @param targetDoc - The document against which the field path will be\n * evaluated.\n */\nfunction fieldPathFromDotSeparatedString(methodName, path, targetDoc) {\n    const found = path.search(FIELD_PATH_RESERVED);\n    if (found >= 0) {\n        throw createError(`Invalid field path (${path}). Paths must not contain ` +\n            `'~', '*', '/', '[', or ']'`, methodName, \n        /* hasConverter= */ false, \n        /* path= */ undefined, targetDoc);\n    }\n    try {\n        return new FieldPath(...path.split('.'))._internalPath;\n    }\n    catch (e) {\n        throw createError(`Invalid field path (${path}). Paths must not be empty, ` +\n            `begin with '.', end with '.', or contain '..'`, methodName, \n        /* hasConverter= */ false, \n        /* path= */ undefined, targetDoc);\n    }\n}\nfunction createError(reason, methodName, hasConverter, path, targetDoc) {\n    const hasPath = path && !path.isEmpty();\n    const hasDocument = targetDoc !== undefined;\n    let message = `Function ${methodName}() called with invalid data`;\n    if (hasConverter) {\n        message += ' (via `toFirestore()`)';\n    }\n    message += '. ';\n    let description = '';\n    if (hasPath || hasDocument) {\n        description += ' (found';\n        if (hasPath) {\n            description += ` in field ${path}`;\n        }\n        if (hasDocument) {\n            description += ` in document ${targetDoc}`;\n        }\n        description += ')';\n    }\n    return new FirestoreError(Code.INVALID_ARGUMENT, message + reason + description);\n}\n/** Checks `haystack` if FieldPath `needle` is present. Runs in O(n). */\nfunction fieldMaskContains(haystack, needle) {\n    return haystack.some(v => v.isEqual(needle));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `DocumentSnapshot` contains data read from a document in your Firestore\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\n * get a specific field.\n *\n * For a `DocumentSnapshot` that points to a non-existing document, any data\n * access will return 'undefined'. You can use the `exists()` method to\n * explicitly verify a document's existence.\n */\nclass DocumentSnapshot$1 {\n    // Note: This class is stripped down version of the DocumentSnapshot in\n    // the legacy SDK. The changes are:\n    // - No support for SnapshotMetadata.\n    // - No support for SnapshotOptions.\n    /** @hideconstructor protected */\n    constructor(_firestore, _userDataWriter, _key, _document, _converter) {\n        this._firestore = _firestore;\n        this._userDataWriter = _userDataWriter;\n        this._key = _key;\n        this._document = _document;\n        this._converter = _converter;\n    }\n    /** Property of the `DocumentSnapshot` that provides the document's ID. */\n    get id() {\n        return this._key.path.lastSegment();\n    }\n    /**\n     * The `DocumentReference` for the document included in the `DocumentSnapshot`.\n     */\n    get ref() {\n        return new DocumentReference(this._firestore, this._converter, this._key);\n    }\n    /**\n     * Signals whether or not the document at the snapshot's location exists.\n     *\n     * @returns true if the document exists.\n     */\n    exists() {\n        return this._document !== null;\n    }\n    /**\n     * Retrieves all fields in the document as an `Object`. Returns `undefined` if\n     * the document doesn't exist.\n     *\n     * @returns An `Object` containing all fields in the document or `undefined`\n     * if the document doesn't exist.\n     */\n    data() {\n        if (!this._document) {\n            return undefined;\n        }\n        else if (this._converter) {\n            // We only want to use the converter and create a new DocumentSnapshot\n            // if a converter has been provided.\n            const snapshot = new QueryDocumentSnapshot$1(this._firestore, this._userDataWriter, this._key, this._document, \n            /* converter= */ null);\n            return this._converter.fromFirestore(snapshot);\n        }\n        else {\n            return this._userDataWriter.convertValue(this._document.data.value);\n        }\n    }\n    /**\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\n     * document or field doesn't exist.\n     *\n     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\n     * field.\n     * @returns The data at the specified field location or undefined if no such\n     * field exists in the document.\n     */\n    // We are using `any` here to avoid an explicit cast by our users.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(fieldPath) {\n        if (this._document) {\n            const value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\n            if (value !== null) {\n                return this._userDataWriter.convertValue(value);\n            }\n        }\n        return undefined;\n    }\n}\n/**\n * A `QueryDocumentSnapshot` contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\n * specific field.\n *\n * A `QueryDocumentSnapshot` offers the same API surface as a\n * `DocumentSnapshot`. Since query results contain only existing documents, the\n * `exists` property will always be true and `data()` will never return\n * 'undefined'.\n */\nclass QueryDocumentSnapshot$1 extends DocumentSnapshot$1 {\n    /**\n     * Retrieves all fields in the document as an `Object`.\n     *\n     * @override\n     * @returns An `Object` containing all fields in the document.\n     */\n    data() {\n        return super.data();\n    }\n}\n/**\n * Helper that calls `fromDotSeparatedString()` but wraps any error thrown.\n */\nfunction fieldPathFromArgument(methodName, arg) {\n    if (typeof arg === 'string') {\n        return fieldPathFromDotSeparatedString(methodName, arg);\n    }\n    else if (arg instanceof FieldPath) {\n        return arg._internalPath;\n    }\n    else {\n        return arg._delegate._internalPath;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction validateHasExplicitOrderByForLimitToLast(query) {\n    if (query.limitType === \"L\" /* LimitType.Last */ &&\n        query.explicitOrderBy.length === 0) {\n        throw new FirestoreError(Code.UNIMPLEMENTED, 'limitToLast() queries require specifying at least one orderBy() clause');\n    }\n}\n/**\n * An `AppliableConstraint` is an abstraction of a constraint that can be applied\n * to a Firestore query.\n */\nclass AppliableConstraint {\n}\n/**\n * A `QueryConstraint` is used to narrow the set of documents returned by a\n * Firestore query. `QueryConstraint`s are created by invoking {@link where},\n * {@link orderBy}, {@link (startAt:1)}, {@link (startAfter:1)}, {@link\n * (endBefore:1)}, {@link (endAt:1)}, {@link limit}, {@link limitToLast} and\n * can then be passed to {@link (query:1)} to create a new query instance that\n * also contains this `QueryConstraint`.\n */\nclass QueryConstraint extends AppliableConstraint {\n}\nfunction query(query, queryConstraint, ...additionalQueryConstraints) {\n    let queryConstraints = [];\n    if (queryConstraint instanceof AppliableConstraint) {\n        queryConstraints.push(queryConstraint);\n    }\n    queryConstraints = queryConstraints.concat(additionalQueryConstraints);\n    validateQueryConstraintArray(queryConstraints);\n    for (const constraint of queryConstraints) {\n        query = constraint._apply(query);\n    }\n    return query;\n}\n/**\n * A `QueryFieldFilterConstraint` is used to narrow the set of documents returned by\n * a Firestore query by filtering on one or more document fields.\n * `QueryFieldFilterConstraint`s are created by invoking {@link where} and can then\n * be passed to {@link (query:1)} to create a new query instance that also contains\n * this `QueryFieldFilterConstraint`.\n */\nclass QueryFieldFilterConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(_field, _op, _value) {\n        super();\n        this._field = _field;\n        this._op = _op;\n        this._value = _value;\n        /** The type of this query constraint */\n        this.type = 'where';\n    }\n    static _create(_field, _op, _value) {\n        return new QueryFieldFilterConstraint(_field, _op, _value);\n    }\n    _apply(query) {\n        const filter = this._parse(query);\n        validateNewFieldFilter(query._query, filter);\n        return new Query(query.firestore, query.converter, queryWithAddedFilter(query._query, filter));\n    }\n    _parse(query) {\n        const reader = newUserDataReader(query.firestore);\n        const filter = newQueryFilter(query._query, 'where', reader, query.firestore._databaseId, this._field, this._op, this._value);\n        return filter;\n    }\n}\n/**\n * Creates a {@link QueryFieldFilterConstraint} that enforces that documents\n * must contain the specified field and that the value should satisfy the\n * relation constraint provided.\n *\n * @param fieldPath - The path to compare\n * @param opStr - The operation string (e.g \"&lt;\", \"&lt;=\", \"==\", \"&lt;\",\n *   \"&lt;=\", \"!=\").\n * @param value - The value for comparison\n * @returns The created {@link QueryFieldFilterConstraint}.\n */\nfunction where(fieldPath, opStr, value) {\n    const op = opStr;\n    const field = fieldPathFromArgument('where', fieldPath);\n    return QueryFieldFilterConstraint._create(field, op, value);\n}\n/**\n * A `QueryCompositeFilterConstraint` is used to narrow the set of documents\n * returned by a Firestore query by performing the logical OR or AND of multiple\n * {@link QueryFieldFilterConstraint}s or {@link QueryCompositeFilterConstraint}s.\n * `QueryCompositeFilterConstraint`s are created by invoking {@link or} or\n * {@link and} and can then be passed to {@link (query:1)} to create a new query\n * instance that also contains the `QueryCompositeFilterConstraint`.\n */\nclass QueryCompositeFilterConstraint extends AppliableConstraint {\n    /**\n     * @internal\n     */\n    constructor(\n    /** The type of this query constraint */\n    type, _queryConstraints) {\n        super();\n        this.type = type;\n        this._queryConstraints = _queryConstraints;\n    }\n    static _create(type, _queryConstraints) {\n        return new QueryCompositeFilterConstraint(type, _queryConstraints);\n    }\n    _parse(query) {\n        const parsedFilters = this._queryConstraints\n            .map(queryConstraint => {\n            return queryConstraint._parse(query);\n        })\n            .filter(parsedFilter => parsedFilter.getFilters().length > 0);\n        if (parsedFilters.length === 1) {\n            return parsedFilters[0];\n        }\n        return CompositeFilter.create(parsedFilters, this._getOperator());\n    }\n    _apply(query) {\n        const parsedFilter = this._parse(query);\n        if (parsedFilter.getFilters().length === 0) {\n            // Return the existing query if not adding any more filters (e.g. an empty\n            // composite filter).\n            return query;\n        }\n        validateNewFilter(query._query, parsedFilter);\n        return new Query(query.firestore, query.converter, queryWithAddedFilter(query._query, parsedFilter));\n    }\n    _getQueryConstraints() {\n        return this._queryConstraints;\n    }\n    _getOperator() {\n        return this.type === 'and' ? \"and\" /* CompositeOperator.AND */ : \"or\" /* CompositeOperator.OR */;\n    }\n}\n/**\n * Creates a new {@link QueryCompositeFilterConstraint} that is a disjunction of\n * the given filter constraints. A disjunction filter includes a document if it\n * satisfies any of the given filters.\n *\n * @param queryConstraints - Optional. The list of\n * {@link QueryFilterConstraint}s to perform a disjunction for. These must be\n * created with calls to {@link where}, {@link or}, or {@link and}.\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\n */\nfunction or(...queryConstraints) {\n    // Only support QueryFilterConstraints\n    queryConstraints.forEach(queryConstraint => validateQueryFilterConstraint('or', queryConstraint));\n    return QueryCompositeFilterConstraint._create(\"or\" /* CompositeOperator.OR */, queryConstraints);\n}\n/**\n * Creates a new {@link QueryCompositeFilterConstraint} that is a conjunction of\n * the given filter constraints. A conjunction filter includes a document if it\n * satisfies all of the given filters.\n *\n * @param queryConstraints - Optional. The list of\n * {@link QueryFilterConstraint}s to perform a conjunction for. These must be\n * created with calls to {@link where}, {@link or}, or {@link and}.\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\n */\nfunction and(...queryConstraints) {\n    // Only support QueryFilterConstraints\n    queryConstraints.forEach(queryConstraint => validateQueryFilterConstraint('and', queryConstraint));\n    return QueryCompositeFilterConstraint._create(\"and\" /* CompositeOperator.AND */, queryConstraints);\n}\n/**\n * A `QueryOrderByConstraint` is used to sort the set of documents returned by a\n * Firestore query. `QueryOrderByConstraint`s are created by invoking\n * {@link orderBy} and can then be passed to {@link (query:1)} to create a new query\n * instance that also contains this `QueryOrderByConstraint`.\n *\n * Note: Documents that do not contain the orderBy field will not be present in\n * the query result.\n */\nclass QueryOrderByConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(_field, _direction) {\n        super();\n        this._field = _field;\n        this._direction = _direction;\n        /** The type of this query constraint */\n        this.type = 'orderBy';\n    }\n    static _create(_field, _direction) {\n        return new QueryOrderByConstraint(_field, _direction);\n    }\n    _apply(query) {\n        const orderBy = newQueryOrderBy(query._query, this._field, this._direction);\n        return new Query(query.firestore, query.converter, queryWithAddedOrderBy(query._query, orderBy));\n    }\n}\n/**\n * Creates a {@link QueryOrderByConstraint} that sorts the query result by the\n * specified field, optionally in descending order instead of ascending.\n *\n * Note: Documents that do not contain the specified field will not be present\n * in the query result.\n *\n * @param fieldPath - The field to sort by.\n * @param directionStr - Optional direction to sort by ('asc' or 'desc'). If\n * not specified, order will be ascending.\n * @returns The created {@link QueryOrderByConstraint}.\n */\nfunction orderBy(fieldPath, directionStr = 'asc') {\n    const direction = directionStr;\n    const path = fieldPathFromArgument('orderBy', fieldPath);\n    return QueryOrderByConstraint._create(path, direction);\n}\n/**\n * A `QueryLimitConstraint` is used to limit the number of documents returned by\n * a Firestore query.\n * `QueryLimitConstraint`s are created by invoking {@link limit} or\n * {@link limitToLast} and can then be passed to {@link (query:1)} to create a new\n * query instance that also contains this `QueryLimitConstraint`.\n */\nclass QueryLimitConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(\n    /** The type of this query constraint */\n    type, _limit, _limitType) {\n        super();\n        this.type = type;\n        this._limit = _limit;\n        this._limitType = _limitType;\n    }\n    static _create(type, _limit, _limitType) {\n        return new QueryLimitConstraint(type, _limit, _limitType);\n    }\n    _apply(query) {\n        return new Query(query.firestore, query.converter, queryWithLimit(query._query, this._limit, this._limitType));\n    }\n}\n/**\n * Creates a {@link QueryLimitConstraint} that only returns the first matching\n * documents.\n *\n * @param limit - The maximum number of items to return.\n * @returns The created {@link QueryLimitConstraint}.\n */\nfunction limit(limit) {\n    validatePositiveNumber('limit', limit);\n    return QueryLimitConstraint._create('limit', limit, \"F\" /* LimitType.First */);\n}\n/**\n * Creates a {@link QueryLimitConstraint} that only returns the last matching\n * documents.\n *\n * You must specify at least one `orderBy` clause for `limitToLast` queries,\n * otherwise an exception will be thrown during execution.\n *\n * @param limit - The maximum number of items to return.\n * @returns The created {@link QueryLimitConstraint}.\n */\nfunction limitToLast(limit) {\n    validatePositiveNumber('limitToLast', limit);\n    return QueryLimitConstraint._create('limitToLast', limit, \"L\" /* LimitType.Last */);\n}\n/**\n * A `QueryStartAtConstraint` is used to exclude documents from the start of a\n * result set returned by a Firestore query.\n * `QueryStartAtConstraint`s are created by invoking {@link (startAt:1)} or\n * {@link (startAfter:1)} and can then be passed to {@link (query:1)} to create a\n * new query instance that also contains this `QueryStartAtConstraint`.\n */\nclass QueryStartAtConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(\n    /** The type of this query constraint */\n    type, _docOrFields, _inclusive) {\n        super();\n        this.type = type;\n        this._docOrFields = _docOrFields;\n        this._inclusive = _inclusive;\n    }\n    static _create(type, _docOrFields, _inclusive) {\n        return new QueryStartAtConstraint(type, _docOrFields, _inclusive);\n    }\n    _apply(query) {\n        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);\n        return new Query(query.firestore, query.converter, queryWithStartAt(query._query, bound));\n    }\n}\nfunction startAt(...docOrFields) {\n    return QueryStartAtConstraint._create('startAt', docOrFields, \n    /*inclusive=*/ true);\n}\nfunction startAfter(...docOrFields) {\n    return QueryStartAtConstraint._create('startAfter', docOrFields, \n    /*inclusive=*/ false);\n}\n/**\n * A `QueryEndAtConstraint` is used to exclude documents from the end of a\n * result set returned by a Firestore query.\n * `QueryEndAtConstraint`s are created by invoking {@link (endAt:1)} or\n * {@link (endBefore:1)} and can then be passed to {@link (query:1)} to create a new\n * query instance that also contains this `QueryEndAtConstraint`.\n */\nclass QueryEndAtConstraint extends QueryConstraint {\n    /**\n     * @internal\n     */\n    constructor(\n    /** The type of this query constraint */\n    type, _docOrFields, _inclusive) {\n        super();\n        this.type = type;\n        this._docOrFields = _docOrFields;\n        this._inclusive = _inclusive;\n    }\n    static _create(type, _docOrFields, _inclusive) {\n        return new QueryEndAtConstraint(type, _docOrFields, _inclusive);\n    }\n    _apply(query) {\n        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);\n        return new Query(query.firestore, query.converter, queryWithEndAt(query._query, bound));\n    }\n}\nfunction endBefore(...docOrFields) {\n    return QueryEndAtConstraint._create('endBefore', docOrFields, \n    /*inclusive=*/ false);\n}\nfunction endAt(...docOrFields) {\n    return QueryEndAtConstraint._create('endAt', docOrFields, \n    /*inclusive=*/ true);\n}\n/** Helper function to create a bound from a document or fields */\nfunction newQueryBoundFromDocOrFields(query, methodName, docOrFields, inclusive) {\n    docOrFields[0] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(docOrFields[0]);\n    if (docOrFields[0] instanceof DocumentSnapshot$1) {\n        return newQueryBoundFromDocument(query._query, query.firestore._databaseId, methodName, docOrFields[0]._document, inclusive);\n    }\n    else {\n        const reader = newUserDataReader(query.firestore);\n        return newQueryBoundFromFields(query._query, query.firestore._databaseId, reader, methodName, docOrFields, inclusive);\n    }\n}\nfunction newQueryFilter(query, methodName, dataReader, databaseId, fieldPath, op, value) {\n    let fieldValue;\n    if (fieldPath.isKeyField()) {\n        if (op === \"array-contains\" /* Operator.ARRAY_CONTAINS */ || op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid Query. You can't perform '${op}' queries on documentId().`);\n        }\n        else if (op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */) {\n            validateDisjunctiveFilterElements(value, op);\n            const referenceList = [];\n            for (const arrayValue of value) {\n                referenceList.push(parseDocumentIdValue(databaseId, query, arrayValue));\n            }\n            fieldValue = { arrayValue: { values: referenceList } };\n        }\n        else {\n            fieldValue = parseDocumentIdValue(databaseId, query, value);\n        }\n    }\n    else {\n        if (op === \"in\" /* Operator.IN */ ||\n            op === \"not-in\" /* Operator.NOT_IN */ ||\n            op === \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */) {\n            validateDisjunctiveFilterElements(value, op);\n        }\n        fieldValue = parseQueryValue(dataReader, methodName, value, \n        /* allowArrays= */ op === \"in\" /* Operator.IN */ || op === \"not-in\" /* Operator.NOT_IN */);\n    }\n    const filter = FieldFilter.create(fieldPath, op, fieldValue);\n    return filter;\n}\nfunction newQueryOrderBy(query, fieldPath, direction) {\n    if (query.startAt !== null) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call startAt() or startAfter() before ' +\n            'calling orderBy().');\n    }\n    if (query.endAt !== null) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call endAt() or endBefore() before ' +\n            'calling orderBy().');\n    }\n    const orderBy = new OrderBy(fieldPath, direction);\n    return orderBy;\n}\n/**\n * Create a `Bound` from a query and a document.\n *\n * Note that the `Bound` will always include the key of the document\n * and so only the provided document will compare equal to the returned\n * position.\n *\n * Will throw if the document does not contain all fields of the order by\n * of the query or if any of the fields in the order by are an uncommitted\n * server timestamp.\n */\nfunction newQueryBoundFromDocument(query, databaseId, methodName, doc, inclusive) {\n    if (!doc) {\n        throw new FirestoreError(Code.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ` +\n            `${methodName}().`);\n    }\n    const components = [];\n    // Because people expect to continue/end a query at the exact document\n    // provided, we need to use the implicit sort order rather than the explicit\n    // sort order, because it's guaranteed to contain the document key. That way\n    // the position becomes unambiguous and the query continues/ends exactly at\n    // the provided document. Without the key (by using the explicit sort\n    // orders), multiple documents could match the position, yielding duplicate\n    // results.\n    for (const orderBy of queryNormalizedOrderBy(query)) {\n        if (orderBy.field.isKeyField()) {\n            components.push(refValue(databaseId, doc.key));\n        }\n        else {\n            const value = doc.data.field(orderBy.field);\n            if (isServerTimestamp(value)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a ' +\n                    'document for which the field \"' +\n                    orderBy.field +\n                    '\" is an uncommitted server timestamp. (Since the value of ' +\n                    'this field is unknown, you cannot start/end a query with it.)');\n            }\n            else if (value !== null) {\n                components.push(value);\n            }\n            else {\n                const field = orderBy.field.canonicalString();\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a ` +\n                    `document for which the field '${field}' (used as the ` +\n                    `orderBy) does not exist.`);\n            }\n        }\n    }\n    return new Bound(components, inclusive);\n}\n/**\n * Converts a list of field values to a `Bound` for the given query.\n */\nfunction newQueryBoundFromFields(query, databaseId, dataReader, methodName, values, inclusive) {\n    // Use explicit order by's because it has to match the query the user made\n    const orderBy = query.explicitOrderBy;\n    if (values.length > orderBy.length) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Too many arguments provided to ${methodName}(). ` +\n            `The number of arguments must be less than or equal to the ` +\n            `number of orderBy() clauses`);\n    }\n    const components = [];\n    for (let i = 0; i < values.length; i++) {\n        const rawValue = values[i];\n        const orderByComponent = orderBy[i];\n        if (orderByComponent.field.isKeyField()) {\n            if (typeof rawValue !== 'string') {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ` +\n                    `${methodName}(), but got a ${typeof rawValue}`);\n            }\n            if (!isCollectionGroupQuery(query) && rawValue.indexOf('/') !== -1) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), ` +\n                    `the value passed to ${methodName}() must be a plain document ID, but ` +\n                    `'${rawValue}' contains a slash.`);\n            }\n            const path = query.path.child(ResourcePath.fromString(rawValue));\n            if (!DocumentKey.isDocumentKey(path)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by ` +\n                    `documentId(), the value passed to ${methodName}() must result in a ` +\n                    `valid document path, but '${path}' is not because it contains an odd number ` +\n                    `of segments.`);\n            }\n            const key = new DocumentKey(path);\n            components.push(refValue(databaseId, key));\n        }\n        else {\n            const wrapped = parseQueryValue(dataReader, methodName, rawValue);\n            components.push(wrapped);\n        }\n    }\n    return new Bound(components, inclusive);\n}\n/**\n * Parses the given `documentIdValue` into a `ReferenceValue`, throwing\n * appropriate errors if the value is anything other than a `DocumentReference`\n * or `string`, or if the string is malformed.\n */\nfunction parseDocumentIdValue(databaseId, query, documentIdValue) {\n    documentIdValue = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(documentIdValue);\n    if (typeof documentIdValue === 'string') {\n        if (documentIdValue === '') {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. When querying with documentId(), you ' +\n                'must provide a valid document ID, but it was an empty string.');\n        }\n        if (!isCollectionGroupQuery(query) && documentIdValue.indexOf('/') !== -1) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection by ` +\n                `documentId(), you must provide a plain document ID, but ` +\n                `'${documentIdValue}' contains a '/' character.`);\n        }\n        const path = query.path.child(ResourcePath.fromString(documentIdValue));\n        if (!DocumentKey.isDocumentKey(path)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group by ` +\n                `documentId(), the value provided must result in a valid document path, ` +\n                `but '${path}' is not because it has an odd number of segments (${path.length}).`);\n        }\n        return refValue(databaseId, new DocumentKey(path));\n    }\n    else if (documentIdValue instanceof DocumentReference) {\n        return refValue(databaseId, documentIdValue._key);\n    }\n    else {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid ` +\n            `string or a DocumentReference, but it was: ` +\n            `${valueDescription(documentIdValue)}.`);\n    }\n}\n/**\n * Validates that the value passed into a disjunctive filter satisfies all\n * array requirements.\n */\nfunction validateDisjunctiveFilterElements(value, operator) {\n    if (!Array.isArray(value) || value.length === 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid Query. A non-empty array is required for ' +\n            `'${operator.toString()}' filters.`);\n    }\n}\n/**\n * Given an operator, returns the set of operators that cannot be used with it.\n *\n * This is not a comprehensive check, and this function should be removed in the\n * long term. Validations should occur in the Firestore backend.\n *\n * Operators in a query must adhere to the following set of rules:\n * 1. Only one inequality per query.\n * 2. `NOT_IN` cannot be used with array, disjunctive, or `NOT_EQUAL` operators.\n */\nfunction conflictingOps(op) {\n    switch (op) {\n        case \"!=\" /* Operator.NOT_EQUAL */:\n            return [\"!=\" /* Operator.NOT_EQUAL */, \"not-in\" /* Operator.NOT_IN */];\n        case \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */:\n        case \"in\" /* Operator.IN */:\n            return [\"not-in\" /* Operator.NOT_IN */];\n        case \"not-in\" /* Operator.NOT_IN */:\n            return [\n                \"array-contains-any\" /* Operator.ARRAY_CONTAINS_ANY */,\n                \"in\" /* Operator.IN */,\n                \"not-in\" /* Operator.NOT_IN */,\n                \"!=\" /* Operator.NOT_EQUAL */\n            ];\n        default:\n            return [];\n    }\n}\nfunction validateNewFieldFilter(query, fieldFilter) {\n    const conflictingOp = findOpInsideFilters(query.filters, conflictingOps(fieldFilter.op));\n    if (conflictingOp !== null) {\n        // Special case when it's a duplicate op to give a slightly clearer error message.\n        if (conflictingOp === fieldFilter.op) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You cannot use more than one ' +\n                `'${fieldFilter.op.toString()}' filter.`);\n        }\n        else {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You cannot use '${fieldFilter.op.toString()}' filters ` +\n                `with '${conflictingOp.toString()}' filters.`);\n        }\n    }\n}\nfunction validateNewFilter(query, filter) {\n    let testQuery = query;\n    const subFilters = filter.getFlattenedFilters();\n    for (const subFilter of subFilters) {\n        validateNewFieldFilter(testQuery, subFilter);\n        testQuery = queryWithAddedFilter(testQuery, subFilter);\n    }\n}\n// Checks if any of the provided filter operators are included in the given list of filters and\n// returns the first one that is, or null if none are.\nfunction findOpInsideFilters(filters, operators) {\n    for (const filter of filters) {\n        for (const fieldFilter of filter.getFlattenedFilters()) {\n            if (operators.indexOf(fieldFilter.op) >= 0) {\n                return fieldFilter.op;\n            }\n        }\n    }\n    return null;\n}\nfunction validateQueryFilterConstraint(functionName, queryConstraint) {\n    if (!(queryConstraint instanceof QueryFieldFilterConstraint) &&\n        !(queryConstraint instanceof QueryCompositeFilterConstraint)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`);\n    }\n}\nfunction validateQueryConstraintArray(queryConstraint) {\n    const compositeFilterCount = queryConstraint.filter(filter => filter instanceof QueryCompositeFilterConstraint).length;\n    const fieldFilterCount = queryConstraint.filter(filter => filter instanceof QueryFieldFilterConstraint).length;\n    if (compositeFilterCount > 1 ||\n        (compositeFilterCount > 0 && fieldFilterCount > 0)) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'InvalidQuery. When using composite filters, you cannot use ' +\n            'more than one filter at the top level. Consider nesting the multiple ' +\n            'filters within an `and(...)` statement. For example: ' +\n            'change `query(query, where(...), or(...))` to ' +\n            '`query(query, and(where(...), or(...)))`.');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Converts Firestore's internal types to the JavaScript types that we expose\n * to the user.\n *\n * @internal\n */\nclass AbstractUserDataWriter {\n    convertValue(value, serverTimestampBehavior = 'none') {\n        switch (typeOrder(value)) {\n            case 0 /* TypeOrder.NullValue */:\n                return null;\n            case 1 /* TypeOrder.BooleanValue */:\n                return value.booleanValue;\n            case 2 /* TypeOrder.NumberValue */:\n                return normalizeNumber(value.integerValue || value.doubleValue);\n            case 3 /* TypeOrder.TimestampValue */:\n                return this.convertTimestamp(value.timestampValue);\n            case 4 /* TypeOrder.ServerTimestampValue */:\n                return this.convertServerTimestamp(value, serverTimestampBehavior);\n            case 5 /* TypeOrder.StringValue */:\n                return value.stringValue;\n            case 6 /* TypeOrder.BlobValue */:\n                return this.convertBytes(normalizeByteString(value.bytesValue));\n            case 7 /* TypeOrder.RefValue */:\n                return this.convertReference(value.referenceValue);\n            case 8 /* TypeOrder.GeoPointValue */:\n                return this.convertGeoPoint(value.geoPointValue);\n            case 9 /* TypeOrder.ArrayValue */:\n                return this.convertArray(value.arrayValue, serverTimestampBehavior);\n            case 11 /* TypeOrder.ObjectValue */:\n                return this.convertObject(value.mapValue, serverTimestampBehavior);\n            case 10 /* TypeOrder.VectorValue */:\n                return this.convertVectorValue(value.mapValue);\n            default:\n                throw fail();\n        }\n    }\n    convertObject(mapValue, serverTimestampBehavior) {\n        return this.convertObjectMap(mapValue.fields, serverTimestampBehavior);\n    }\n    /**\n     * @internal\n     */\n    convertObjectMap(fields, serverTimestampBehavior = 'none') {\n        const result = {};\n        forEach(fields, (key, value) => {\n            result[key] = this.convertValue(value, serverTimestampBehavior);\n        });\n        return result;\n    }\n    /**\n     * @internal\n     */\n    convertVectorValue(mapValue) {\n        var _a, _b, _c;\n        const values = (_c = (_b = (_a = mapValue.fields) === null || _a === void 0 ? void 0 : _a[VECTOR_MAP_VECTORS_KEY].arrayValue) === null || _b === void 0 ? void 0 : _b.values) === null || _c === void 0 ? void 0 : _c.map(value => {\n            return normalizeNumber(value.doubleValue);\n        });\n        return new VectorValue(values);\n    }\n    convertGeoPoint(value) {\n        return new GeoPoint(normalizeNumber(value.latitude), normalizeNumber(value.longitude));\n    }\n    convertArray(arrayValue, serverTimestampBehavior) {\n        return (arrayValue.values || []).map(value => this.convertValue(value, serverTimestampBehavior));\n    }\n    convertServerTimestamp(value, serverTimestampBehavior) {\n        switch (serverTimestampBehavior) {\n            case 'previous':\n                const previousValue = getPreviousValue(value);\n                if (previousValue == null) {\n                    return null;\n                }\n                return this.convertValue(previousValue, serverTimestampBehavior);\n            case 'estimate':\n                return this.convertTimestamp(getLocalWriteTime(value));\n            default:\n                return null;\n        }\n    }\n    convertTimestamp(value) {\n        const normalizedValue = normalizeTimestamp(value);\n        return new Timestamp(normalizedValue.seconds, normalizedValue.nanos);\n    }\n    convertDocumentKey(name, expectedDatabaseId) {\n        const resourcePath = ResourcePath.fromString(name);\n        hardAssert(isValidResourceName(resourcePath));\n        const databaseId = new DatabaseId(resourcePath.get(1), resourcePath.get(3));\n        const key = new DocumentKey(resourcePath.popFirst(5));\n        if (!databaseId.isEqual(expectedDatabaseId)) {\n            // TODO(b/64130202): Somehow support foreign references.\n            logError(`Document ${key} contains a document ` +\n                `reference within a different database (` +\n                `${databaseId.projectId}/${databaseId.database}) which is not ` +\n                `supported. It will be treated as a reference in the current ` +\n                `database (${expectedDatabaseId.projectId}/${expectedDatabaseId.database}) ` +\n                `instead.`);\n        }\n        return key;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Converts custom model object of type T into `DocumentData` by applying the\n * converter if it exists.\n *\n * This function is used when converting user objects to `DocumentData`\n * because we want to provide the user with a more specific error message if\n * their `set()` or fails due to invalid data originating from a `toFirestore()`\n * call.\n */\nfunction applyFirestoreDataConverter(converter, value, options) {\n    let convertedValue;\n    if (converter) {\n        if (options && (options.merge || options.mergeFields)) {\n            // Cast to `any` in order to satisfy the union type constraint on\n            // toFirestore().\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            convertedValue = converter.toFirestore(value, options);\n        }\n        else {\n            convertedValue = converter.toFirestore(value);\n        }\n    }\n    else {\n        convertedValue = value;\n    }\n    return convertedValue;\n}\nclass LiteUserDataWriter extends AbstractUserDataWriter {\n    constructor(firestore) {\n        super();\n        this.firestore = firestore;\n    }\n    convertBytes(bytes) {\n        return new Bytes(bytes);\n    }\n    convertReference(name) {\n        const key = this.convertDocumentKey(name, this.firestore._databaseId);\n        return new DocumentReference(this.firestore, /* converter= */ null, key);\n    }\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Create an AggregateField object that can be used to compute the sum of\n * a specified field over a range of documents in the result set of a query.\n * @param field Specifies the field to sum across the result set.\n */\nfunction sum(field) {\n    return new AggregateField('sum', fieldPathFromArgument$1('sum', field));\n}\n/**\n * Create an AggregateField object that can be used to compute the average of\n * a specified field over a range of documents in the result set of a query.\n * @param field Specifies the field to average across the result set.\n */\nfunction average(field) {\n    return new AggregateField('avg', fieldPathFromArgument$1('average', field));\n}\n/**\n * Create an AggregateField object that can be used to compute the count of\n * documents in the result set of a query.\n */\nfunction count() {\n    return new AggregateField('count');\n}\n/**\n * Compares two 'AggregateField` instances for equality.\n *\n * @param left Compare this AggregateField to the `right`.\n * @param right Compare this AggregateField to the `left`.\n */\nfunction aggregateFieldEqual(left, right) {\n    var _a, _b;\n    return (left instanceof AggregateField &&\n        right instanceof AggregateField &&\n        left.aggregateType === right.aggregateType &&\n        ((_a = left._internalFieldPath) === null || _a === void 0 ? void 0 : _a.canonicalString()) ===\n            ((_b = right._internalFieldPath) === null || _b === void 0 ? void 0 : _b.canonicalString()));\n}\n/**\n * Compares two `AggregateQuerySnapshot` instances for equality.\n *\n * Two `AggregateQuerySnapshot` instances are considered \"equal\" if they have\n * underlying queries that compare equal, and the same data.\n *\n * @param left - The first `AggregateQuerySnapshot` to compare.\n * @param right - The second `AggregateQuerySnapshot` to compare.\n *\n * @returns `true` if the objects are \"equal\", as defined above, or `false`\n * otherwise.\n */\nfunction aggregateQuerySnapshotEqual(left, right) {\n    return (queryEqual(left.query, right.query) && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(left.data(), right.data()));\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isPartialObserver(obj) {\n    return implementsAnyMethods(obj, ['next', 'error', 'complete']);\n}\n/**\n * Returns true if obj is an object and contains at least one of the specified\n * methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n    if (typeof obj !== 'object' || obj === null) {\n        return false;\n    }\n    const object = obj;\n    for (const method of methods) {\n        if (method in object && typeof object[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Metadata about a snapshot, describing the state of the snapshot.\n */\nclass SnapshotMetadata {\n    /** @hideconstructor */\n    constructor(hasPendingWrites, fromCache) {\n        this.hasPendingWrites = hasPendingWrites;\n        this.fromCache = fromCache;\n    }\n    /**\n     * Returns true if this `SnapshotMetadata` is equal to the provided one.\n     *\n     * @param other - The `SnapshotMetadata` to compare against.\n     * @returns true if this `SnapshotMetadata` is equal to the provided one.\n     */\n    isEqual(other) {\n        return (this.hasPendingWrites === other.hasPendingWrites &&\n            this.fromCache === other.fromCache);\n    }\n}\n/**\n * A `DocumentSnapshot` contains data read from a document in your Firestore\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\n * get a specific field.\n *\n * For a `DocumentSnapshot` that points to a non-existing document, any data\n * access will return 'undefined'. You can use the `exists()` method to\n * explicitly verify a document's existence.\n */\nclass DocumentSnapshot extends DocumentSnapshot$1 {\n    /** @hideconstructor protected */\n    constructor(_firestore, userDataWriter, key, document, metadata, converter) {\n        super(_firestore, userDataWriter, key, document, converter);\n        this._firestore = _firestore;\n        this._firestoreImpl = _firestore;\n        this.metadata = metadata;\n    }\n    /**\n     * Returns whether or not the data exists. True if the document exists.\n     */\n    exists() {\n        return super.exists();\n    }\n    /**\n     * Retrieves all fields in the document as an `Object`. Returns `undefined` if\n     * the document doesn't exist.\n     *\n     * By default, `serverTimestamp()` values that have not yet been\n     * set to their final value will be returned as `null`. You can override\n     * this by passing an options object.\n     *\n     * @param options - An options object to configure how data is retrieved from\n     * the snapshot (for example the desired behavior for server timestamps that\n     * have not yet been set to their final value).\n     * @returns An `Object` containing all fields in the document or `undefined` if\n     * the document doesn't exist.\n     */\n    data(options = {}) {\n        if (!this._document) {\n            return undefined;\n        }\n        else if (this._converter) {\n            // We only want to use the converter and create a new DocumentSnapshot\n            // if a converter has been provided.\n            const snapshot = new QueryDocumentSnapshot(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, \n            /* converter= */ null);\n            return this._converter.fromFirestore(snapshot, options);\n        }\n        else {\n            return this._userDataWriter.convertValue(this._document.data.value, options.serverTimestamps);\n        }\n    }\n    /**\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\n     * document or field doesn't exist.\n     *\n     * By default, a `serverTimestamp()` that has not yet been set to\n     * its final value will be returned as `null`. You can override this by\n     * passing an options object.\n     *\n     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\n     * field.\n     * @param options - An options object to configure how the field is retrieved\n     * from the snapshot (for example the desired behavior for server timestamps\n     * that have not yet been set to their final value).\n     * @returns The data at the specified field location or undefined if no such\n     * field exists in the document.\n     */\n    // We are using `any` here to avoid an explicit cast by our users.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(fieldPath, options = {}) {\n        if (this._document) {\n            const value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\n            if (value !== null) {\n                return this._userDataWriter.convertValue(value, options.serverTimestamps);\n            }\n        }\n        return undefined;\n    }\n}\n/**\n * A `QueryDocumentSnapshot` contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\n * specific field.\n *\n * A `QueryDocumentSnapshot` offers the same API surface as a\n * `DocumentSnapshot`. Since query results contain only existing documents, the\n * `exists` property will always be true and `data()` will never return\n * 'undefined'.\n */\nclass QueryDocumentSnapshot extends DocumentSnapshot {\n    /**\n     * Retrieves all fields in the document as an `Object`.\n     *\n     * By default, `serverTimestamp()` values that have not yet been\n     * set to their final value will be returned as `null`. You can override\n     * this by passing an options object.\n     *\n     * @override\n     * @param options - An options object to configure how data is retrieved from\n     * the snapshot (for example the desired behavior for server timestamps that\n     * have not yet been set to their final value).\n     * @returns An `Object` containing all fields in the document.\n     */\n    data(options = {}) {\n        return super.data(options);\n    }\n}\n/**\n * A `QuerySnapshot` contains zero or more `DocumentSnapshot` objects\n * representing the results of a query. The documents can be accessed as an\n * array via the `docs` property or enumerated using the `forEach` method. The\n * number of documents can be determined via the `empty` and `size`\n * properties.\n */\nclass QuerySnapshot {\n    /** @hideconstructor */\n    constructor(_firestore, _userDataWriter, query, _snapshot) {\n        this._firestore = _firestore;\n        this._userDataWriter = _userDataWriter;\n        this._snapshot = _snapshot;\n        this.metadata = new SnapshotMetadata(_snapshot.hasPendingWrites, _snapshot.fromCache);\n        this.query = query;\n    }\n    /** An array of all the documents in the `QuerySnapshot`. */\n    get docs() {\n        const result = [];\n        this.forEach(doc => result.push(doc));\n        return result;\n    }\n    /** The number of documents in the `QuerySnapshot`. */\n    get size() {\n        return this._snapshot.docs.size;\n    }\n    /** True if there are no documents in the `QuerySnapshot`. */\n    get empty() {\n        return this.size === 0;\n    }\n    /**\n     * Enumerates all of the documents in the `QuerySnapshot`.\n     *\n     * @param callback - A callback to be called with a `QueryDocumentSnapshot` for\n     * each document in the snapshot.\n     * @param thisArg - The `this` binding for the callback.\n     */\n    forEach(callback, thisArg) {\n        this._snapshot.docs.forEach(doc => {\n            callback.call(thisArg, new QueryDocumentSnapshot(this._firestore, this._userDataWriter, doc.key, doc, new SnapshotMetadata(this._snapshot.mutatedKeys.has(doc.key), this._snapshot.fromCache), this.query.converter));\n        });\n    }\n    /**\n     * Returns an array of the documents changes since the last snapshot. If this\n     * is the first snapshot, all documents will be in the list as 'added'\n     * changes.\n     *\n     * @param options - `SnapshotListenOptions` that control whether metadata-only\n     * changes (i.e. only `DocumentSnapshot.metadata` changed) should trigger\n     * snapshot events.\n     */\n    docChanges(options = {}) {\n        const includeMetadataChanges = !!options.includeMetadataChanges;\n        if (includeMetadataChanges && this._snapshot.excludesMetadataChanges) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'To include metadata changes with your document changes, you must ' +\n                'also pass { includeMetadataChanges:true } to onSnapshot().');\n        }\n        if (!this._cachedChanges ||\n            this._cachedChangesIncludeMetadataChanges !== includeMetadataChanges) {\n            this._cachedChanges = changesFromSnapshot(this, includeMetadataChanges);\n            this._cachedChangesIncludeMetadataChanges = includeMetadataChanges;\n        }\n        return this._cachedChanges;\n    }\n}\n/** Calculates the array of `DocumentChange`s for a given `ViewSnapshot`. */\nfunction changesFromSnapshot(querySnapshot, includeMetadataChanges) {\n    if (querySnapshot._snapshot.oldDocs.isEmpty()) {\n        let index = 0;\n        return querySnapshot._snapshot.docChanges.map(change => {\n            const doc = new QueryDocumentSnapshot(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);\n            change.doc;\n            return {\n                type: 'added',\n                doc,\n                oldIndex: -1,\n                newIndex: index++\n            };\n        });\n    }\n    else {\n        // A `DocumentSet` that is updated incrementally as changes are applied to use\n        // to lookup the index of a document.\n        let indexTracker = querySnapshot._snapshot.oldDocs;\n        return querySnapshot._snapshot.docChanges\n            .filter(change => includeMetadataChanges || change.type !== 3 /* ChangeType.Metadata */)\n            .map(change => {\n            const doc = new QueryDocumentSnapshot(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);\n            let oldIndex = -1;\n            let newIndex = -1;\n            if (change.type !== 0 /* ChangeType.Added */) {\n                oldIndex = indexTracker.indexOf(change.doc.key);\n                indexTracker = indexTracker.delete(change.doc.key);\n            }\n            if (change.type !== 1 /* ChangeType.Removed */) {\n                indexTracker = indexTracker.add(change.doc);\n                newIndex = indexTracker.indexOf(change.doc.key);\n            }\n            return {\n                type: resultChangeType(change.type),\n                doc,\n                oldIndex,\n                newIndex\n            };\n        });\n    }\n}\nfunction resultChangeType(type) {\n    switch (type) {\n        case 0 /* ChangeType.Added */:\n            return 'added';\n        case 2 /* ChangeType.Modified */:\n        case 3 /* ChangeType.Metadata */:\n            return 'modified';\n        case 1 /* ChangeType.Removed */:\n            return 'removed';\n        default:\n            return fail();\n    }\n}\n// TODO(firestoreexp): Add tests for snapshotEqual with different snapshot\n// metadata\n/**\n * Returns true if the provided snapshots are equal.\n *\n * @param left - A snapshot to compare.\n * @param right - A snapshot to compare.\n * @returns true if the snapshots are equal.\n */\nfunction snapshotEqual(left, right) {\n    if (left instanceof DocumentSnapshot && right instanceof DocumentSnapshot) {\n        return (left._firestore === right._firestore &&\n            left._key.isEqual(right._key) &&\n            (left._document === null\n                ? right._document === null\n                : left._document.isEqual(right._document)) &&\n            left._converter === right._converter);\n    }\n    else if (left instanceof QuerySnapshot && right instanceof QuerySnapshot) {\n        return (left._firestore === right._firestore &&\n            queryEqual(left.query, right.query) &&\n            left.metadata.isEqual(right.metadata) &&\n            left._snapshot.isEqual(right._snapshot));\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Reads the document referred to by this `DocumentReference`.\n *\n * Note: `getDoc()` attempts to provide up-to-date data when possible by waiting\n * for data from the server, but it may return cached data or fail if you are\n * offline and the server cannot be reached. To specify this behavior, invoke\n * {@link getDocFromCache} or {@link getDocFromServer}.\n *\n * @param reference - The reference of the document to fetch.\n * @returns A Promise resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nfunction getDoc(reference) {\n    reference = cast(reference, DocumentReference);\n    const firestore = cast(reference.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientGetDocumentViaSnapshotListener(client, reference._key).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\n}\nclass ExpUserDataWriter extends AbstractUserDataWriter {\n    constructor(firestore) {\n        super();\n        this.firestore = firestore;\n    }\n    convertBytes(bytes) {\n        return new Bytes(bytes);\n    }\n    convertReference(name) {\n        const key = this.convertDocumentKey(name, this.firestore._databaseId);\n        return new DocumentReference(this.firestore, /* converter= */ null, key);\n    }\n}\n/**\n * Reads the document referred to by this `DocumentReference` from cache.\n * Returns an error if the document is not currently cached.\n *\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nfunction getDocFromCache(reference) {\n    reference = cast(reference, DocumentReference);\n    const firestore = cast(reference.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    return firestoreClientGetDocumentFromLocalCache(client, reference._key).then(doc => new DocumentSnapshot(firestore, userDataWriter, reference._key, doc, new SnapshotMetadata(doc !== null && doc.hasLocalMutations, \n    /* fromCache= */ true), reference.converter));\n}\n/**\n * Reads the document referred to by this `DocumentReference` from the server.\n * Returns an error if the network is not available.\n *\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nfunction getDocFromServer(reference) {\n    reference = cast(reference, DocumentReference);\n    const firestore = cast(reference.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientGetDocumentViaSnapshotListener(client, reference._key, {\n        source: 'server'\n    }).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\n}\n/**\n * Executes the query and returns the results as a `QuerySnapshot`.\n *\n * Note: `getDocs()` attempts to provide up-to-date data when possible by\n * waiting for data from the server, but it may return cached data or fail if\n * you are offline and the server cannot be reached. To specify this behavior,\n * invoke {@link getDocsFromCache} or {@link getDocsFromServer}.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nfunction getDocs(query) {\n    query = cast(query, Query);\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    validateHasExplicitOrderByForLimitToLast(query._query);\n    return firestoreClientGetDocumentsViaSnapshotListener(client, query._query).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\n}\n/**\n * Executes the query and returns the results as a `QuerySnapshot` from cache.\n * Returns an empty result set if no documents matching the query are currently\n * cached.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nfunction getDocsFromCache(query) {\n    query = cast(query, Query);\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    return firestoreClientGetDocumentsFromLocalCache(client, query._query).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\n}\n/**\n * Executes the query and returns the results as a `QuerySnapshot` from the\n * server. Returns an error if the network is not available.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nfunction getDocsFromServer(query) {\n    query = cast(query, Query);\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    return firestoreClientGetDocumentsViaSnapshotListener(client, query._query, {\n        source: 'server'\n    }).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\n}\nfunction setDoc(reference, data, options) {\n    reference = cast(reference, DocumentReference);\n    const firestore = cast(reference.firestore, Firestore);\n    const convertedValue = applyFirestoreDataConverter(reference.converter, data, options);\n    const dataReader = newUserDataReader(firestore);\n    const parsed = parseSetData(dataReader, 'setDoc', reference._key, convertedValue, reference.converter !== null, options);\n    const mutation = parsed.toMutation(reference._key, Precondition.none());\n    return executeWrite(firestore, [mutation]);\n}\nfunction updateDoc(reference, fieldOrUpdateData, value, ...moreFieldsAndValues) {\n    reference = cast(reference, DocumentReference);\n    const firestore = cast(reference.firestore, Firestore);\n    const dataReader = newUserDataReader(firestore);\n    // For Compat types, we have to \"extract\" the underlying types before\n    // performing validation.\n    fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\n    let parsed;\n    if (typeof fieldOrUpdateData === 'string' ||\n        fieldOrUpdateData instanceof FieldPath) {\n        parsed = parseUpdateVarargs(dataReader, 'updateDoc', reference._key, fieldOrUpdateData, value, moreFieldsAndValues);\n    }\n    else {\n        parsed = parseUpdateData(dataReader, 'updateDoc', reference._key, fieldOrUpdateData);\n    }\n    const mutation = parsed.toMutation(reference._key, Precondition.exists(true));\n    return executeWrite(firestore, [mutation]);\n}\n/**\n * Deletes the document referred to by the specified `DocumentReference`.\n *\n * @param reference - A reference to the document to delete.\n * @returns A Promise resolved once the document has been successfully\n * deleted from the backend (note that it won't resolve while you're offline).\n */\nfunction deleteDoc(reference) {\n    const firestore = cast(reference.firestore, Firestore);\n    const mutations = [new DeleteMutation(reference._key, Precondition.none())];\n    return executeWrite(firestore, mutations);\n}\n/**\n * Add a new document to specified `CollectionReference` with the given data,\n * assigning it a document ID automatically.\n *\n * @param reference - A reference to the collection to add this document to.\n * @param data - An Object containing the data for the new document.\n * @returns A `Promise` resolved with a `DocumentReference` pointing to the\n * newly created document after it has been written to the backend (Note that it\n * won't resolve while you're offline).\n */\nfunction addDoc(reference, data) {\n    const firestore = cast(reference.firestore, Firestore);\n    const docRef = doc(reference);\n    const convertedValue = applyFirestoreDataConverter(reference.converter, data);\n    const dataReader = newUserDataReader(reference.firestore);\n    const parsed = parseSetData(dataReader, 'addDoc', docRef._key, convertedValue, reference.converter !== null, {});\n    const mutation = parsed.toMutation(docRef._key, Precondition.exists(false));\n    return executeWrite(firestore, [mutation]).then(() => docRef);\n}\nfunction onSnapshot(reference, ...args) {\n    var _a, _b, _c;\n    reference = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(reference);\n    let options = {\n        includeMetadataChanges: false,\n        source: 'default'\n    };\n    let currArg = 0;\n    if (typeof args[currArg] === 'object' && !isPartialObserver(args[currArg])) {\n        options = args[currArg];\n        currArg++;\n    }\n    const internalOptions = {\n        includeMetadataChanges: options.includeMetadataChanges,\n        source: options.source\n    };\n    if (isPartialObserver(args[currArg])) {\n        const userObserver = args[currArg];\n        args[currArg] = (_a = userObserver.next) === null || _a === void 0 ? void 0 : _a.bind(userObserver);\n        args[currArg + 1] = (_b = userObserver.error) === null || _b === void 0 ? void 0 : _b.bind(userObserver);\n        args[currArg + 2] = (_c = userObserver.complete) === null || _c === void 0 ? void 0 : _c.bind(userObserver);\n    }\n    let observer;\n    let firestore;\n    let internalQuery;\n    if (reference instanceof DocumentReference) {\n        firestore = cast(reference.firestore, Firestore);\n        internalQuery = newQueryForPath(reference._key.path);\n        observer = {\n            next: snapshot => {\n                if (args[currArg]) {\n                    args[currArg](convertToDocSnapshot(firestore, reference, snapshot));\n                }\n            },\n            error: args[currArg + 1],\n            complete: args[currArg + 2]\n        };\n    }\n    else {\n        const query = cast(reference, Query);\n        firestore = cast(query.firestore, Firestore);\n        internalQuery = query._query;\n        const userDataWriter = new ExpUserDataWriter(firestore);\n        observer = {\n            next: snapshot => {\n                if (args[currArg]) {\n                    args[currArg](new QuerySnapshot(firestore, userDataWriter, query, snapshot));\n                }\n            },\n            error: args[currArg + 1],\n            complete: args[currArg + 2]\n        };\n        validateHasExplicitOrderByForLimitToLast(reference._query);\n    }\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientListen(client, internalQuery, internalOptions, observer);\n}\nfunction onSnapshotsInSync(firestore, arg) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const observer = isPartialObserver(arg)\n        ? arg\n        : {\n            next: arg\n        };\n    return firestoreClientAddSnapshotsInSyncListener(client, observer);\n}\n/**\n * Locally writes `mutations` on the async queue.\n * @internal\n */\nfunction executeWrite(firestore, mutations) {\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientWrite(client, mutations);\n}\n/**\n * Converts a {@link ViewSnapshot} that contains the single document specified by `ref`\n * to a {@link DocumentSnapshot}.\n */\nfunction convertToDocSnapshot(firestore, ref, snapshot) {\n    const doc = snapshot.docs.get(ref._key);\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    return new DocumentSnapshot(firestore, userDataWriter, ref._key, doc, new SnapshotMetadata(snapshot.hasPendingWrites, snapshot.fromCache), ref.converter);\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Calculates the number of documents in the result set of the given query\n * without actually downloading the documents.\n *\n * Using this function to count the documents is efficient because only the\n * final count, not the documents' data, is downloaded. This function can\n * count the documents in cases where the result set is prohibitively large to\n * download entirely (thousands of documents).\n *\n * The result received from the server is presented, unaltered, without\n * considering any local state. That is, documents in the local cache are not\n * taken into consideration, neither are local modifications not yet\n * synchronized with the server. Previously-downloaded results, if any, are not\n * used. Every invocation of this function necessarily involves a round trip to\n * the server.\n *\n * @param query The query whose result set size is calculated.\n * @returns A Promise that will be resolved with the count; the count can be\n * retrieved from `snapshot.data().count`, where `snapshot` is the\n * `AggregateQuerySnapshot` to which the returned Promise resolves.\n */\nfunction getCountFromServer(query) {\n    const countQuerySpec = {\n        count: count()\n    };\n    return getAggregateFromServer(query, countQuerySpec);\n}\n/**\n * Calculates the specified aggregations over the documents in the result\n * set of the given query without actually downloading the documents.\n *\n * Using this function to perform aggregations is efficient because only the\n * final aggregation values, not the documents' data, are downloaded. This\n * function can perform aggregations of the documents in cases where the result\n * set is prohibitively large to download entirely (thousands of documents).\n *\n * The result received from the server is presented, unaltered, without\n * considering any local state. That is, documents in the local cache are not\n * taken into consideration, neither are local modifications not yet\n * synchronized with the server. Previously-downloaded results, if any, are not\n * used. Every invocation of this function necessarily involves a round trip to\n * the server.\n *\n * @param query The query whose result set is aggregated over.\n * @param aggregateSpec An `AggregateSpec` object that specifies the aggregates\n * to perform over the result set. The AggregateSpec specifies aliases for each\n * aggregate, which can be used to retrieve the aggregate result.\n * @example\n * ```typescript\n * const aggregateSnapshot = await getAggregateFromServer(query, {\n *   countOfDocs: count(),\n *   totalHours: sum('hours'),\n *   averageScore: average('score')\n * });\n *\n * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;\n * const totalHours: number = aggregateSnapshot.data().totalHours;\n * const averageScore: number | null = aggregateSnapshot.data().averageScore;\n * ```\n */\nfunction getAggregateFromServer(query, aggregateSpec) {\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const internalAggregates = mapToArray(aggregateSpec, (aggregate, alias) => {\n        return new AggregateImpl(alias, aggregate.aggregateType, aggregate._internalFieldPath);\n    });\n    // Run the aggregation and convert the results\n    return firestoreClientRunAggregateQuery(client, query._query, internalAggregates).then(aggregateResult => convertToAggregateQuerySnapshot(firestore, query, aggregateResult));\n}\n/**\n * Converts the core aggregation result to an `AggregateQuerySnapshot`\n * that can be returned to the consumer.\n * @param query\n * @param aggregateResult Core aggregation result\n * @internal\n */\nfunction convertToAggregateQuerySnapshot(firestore, query, aggregateResult) {\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    const querySnapshot = new AggregateQuerySnapshot(query, userDataWriter, aggregateResult);\n    return querySnapshot;\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MemoryLocalCacheImpl {\n    constructor(settings) {\n        this.kind = 'memory';\n        this._onlineComponentProvider = OnlineComponentProvider.provider;\n        if (settings === null || settings === void 0 ? void 0 : settings.garbageCollector) {\n            this._offlineComponentProvider =\n                settings.garbageCollector._offlineComponentProvider;\n        }\n        else {\n            this._offlineComponentProvider = {\n                build: () => new LruGcMemoryOfflineComponentProvider(undefined)\n            };\n        }\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n}\nclass PersistentLocalCacheImpl {\n    constructor(settings) {\n        this.kind = 'persistent';\n        let tabManager;\n        if (settings === null || settings === void 0 ? void 0 : settings.tabManager) {\n            settings.tabManager._initialize(settings);\n            tabManager = settings.tabManager;\n        }\n        else {\n            tabManager = persistentSingleTabManager(undefined);\n            tabManager._initialize(settings);\n        }\n        this._onlineComponentProvider = tabManager._onlineComponentProvider;\n        this._offlineComponentProvider = tabManager._offlineComponentProvider;\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n}\nclass MemoryEagerGarbageCollectorImpl {\n    constructor() {\n        this.kind = 'memoryEager';\n        this._offlineComponentProvider = MemoryOfflineComponentProvider.provider;\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n}\nclass MemoryLruGarbageCollectorImpl {\n    constructor(cacheSize) {\n        this.kind = 'memoryLru';\n        this._offlineComponentProvider = {\n            build: () => new LruGcMemoryOfflineComponentProvider(cacheSize)\n        };\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n}\n/**\n * Creates an instance of `MemoryEagerGarbageCollector`. This is also the\n * default garbage collector unless it is explicitly specified otherwise.\n */\nfunction memoryEagerGarbageCollector() {\n    return new MemoryEagerGarbageCollectorImpl();\n}\n/**\n * Creates an instance of `MemoryLruGarbageCollector`.\n *\n * A target size can be specified as part of the setting parameter. The\n * collector will start deleting documents once the cache size exceeds\n * the given size. The default cache size is 40MB (40 * 1024 * 1024 bytes).\n */\nfunction memoryLruGarbageCollector(settings) {\n    return new MemoryLruGarbageCollectorImpl(settings === null || settings === void 0 ? void 0 : settings.cacheSizeBytes);\n}\n/**\n * Creates an instance of `MemoryLocalCache`. The instance can be set to\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\n */\nfunction memoryLocalCache(settings) {\n    return new MemoryLocalCacheImpl(settings);\n}\n/**\n * Creates an instance of `PersistentLocalCache`. The instance can be set to\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\n *\n * Persistent cache cannot be used in a Node.js environment.\n */\nfunction persistentLocalCache(settings) {\n    return new PersistentLocalCacheImpl(settings);\n}\nclass SingleTabManagerImpl {\n    constructor(forceOwnership) {\n        this.forceOwnership = forceOwnership;\n        this.kind = 'persistentSingleTab';\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n    /**\n     * @internal\n     */\n    _initialize(settings) {\n        this._onlineComponentProvider = OnlineComponentProvider.provider;\n        this._offlineComponentProvider = {\n            build: (onlineComponents) => new IndexedDbOfflineComponentProvider(onlineComponents, settings === null || settings === void 0 ? void 0 : settings.cacheSizeBytes, this.forceOwnership)\n        };\n    }\n}\nclass MultiTabManagerImpl {\n    constructor() {\n        this.kind = 'PersistentMultipleTab';\n    }\n    toJSON() {\n        return { kind: this.kind };\n    }\n    /**\n     * @internal\n     */\n    _initialize(settings) {\n        this._onlineComponentProvider = OnlineComponentProvider.provider;\n        this._offlineComponentProvider = {\n            build: (onlineComponents) => new MultiTabOfflineComponentProvider(onlineComponents, settings === null || settings === void 0 ? void 0 : settings.cacheSizeBytes)\n        };\n    }\n}\n/**\n * Creates an instance of `PersistentSingleTabManager`.\n *\n * @param settings Configures the created tab manager.\n */\nfunction persistentSingleTabManager(settings) {\n    return new SingleTabManagerImpl(settings === null || settings === void 0 ? void 0 : settings.forceOwnership);\n}\n/**\n * Creates an instance of `PersistentMultipleTabManager`.\n */\nfunction persistentMultipleTabManager() {\n    return new MultiTabManagerImpl();\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_TRANSACTION_OPTIONS = {\n    maxAttempts: 5\n};\nfunction validateTransactionOptions(options) {\n    if (options.maxAttempts < 1) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Max attempts must be at least 1');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A write batch, used to perform multiple writes as a single atomic unit.\n *\n * A `WriteBatch` object can be acquired by calling {@link writeBatch}. It\n * provides methods for adding writes to the write batch. None of the writes\n * will be committed (or visible locally) until {@link WriteBatch.commit} is\n * called.\n */\nclass WriteBatch {\n    /** @hideconstructor */\n    constructor(_firestore, _commitHandler) {\n        this._firestore = _firestore;\n        this._commitHandler = _commitHandler;\n        this._mutations = [];\n        this._committed = false;\n        this._dataReader = newUserDataReader(_firestore);\n    }\n    set(documentRef, data, options) {\n        this._verifyNotCommitted();\n        const ref = validateReference(documentRef, this._firestore);\n        const convertedValue = applyFirestoreDataConverter(ref.converter, data, options);\n        const parsed = parseSetData(this._dataReader, 'WriteBatch.set', ref._key, convertedValue, ref.converter !== null, options);\n        this._mutations.push(parsed.toMutation(ref._key, Precondition.none()));\n        return this;\n    }\n    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {\n        this._verifyNotCommitted();\n        const ref = validateReference(documentRef, this._firestore);\n        // For Compat types, we have to \"extract\" the underlying types before\n        // performing validation.\n        fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\n        let parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof FieldPath) {\n            parsed = parseUpdateVarargs(this._dataReader, 'WriteBatch.update', ref._key, fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            parsed = parseUpdateData(this._dataReader, 'WriteBatch.update', ref._key, fieldOrUpdateData);\n        }\n        this._mutations.push(parsed.toMutation(ref._key, Precondition.exists(true)));\n        return this;\n    }\n    /**\n     * Deletes the document referred to by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be deleted.\n     * @returns This `WriteBatch` instance. Used for chaining method calls.\n     */\n    delete(documentRef) {\n        this._verifyNotCommitted();\n        const ref = validateReference(documentRef, this._firestore);\n        this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.none()));\n        return this;\n    }\n    /**\n     * Commits all of the writes in this write batch as a single atomic unit.\n     *\n     * The result of these writes will only be reflected in document reads that\n     * occur after the returned promise resolves. If the client is offline, the\n     * write fails. If you would like to see local modifications or buffer writes\n     * until the client is online, use the full Firestore SDK.\n     *\n     * @returns A `Promise` resolved once all of the writes in the batch have been\n     * successfully written to the backend as an atomic unit (note that it won't\n     * resolve while you're offline).\n     */\n    commit() {\n        this._verifyNotCommitted();\n        this._committed = true;\n        if (this._mutations.length > 0) {\n            return this._commitHandler(this._mutations);\n        }\n        return Promise.resolve();\n    }\n    _verifyNotCommitted() {\n        if (this._committed) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' +\n                'has been called.');\n        }\n    }\n}\nfunction validateReference(documentRef, firestore) {\n    documentRef = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(documentRef);\n    if (documentRef.firestore !== firestore) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');\n    }\n    else {\n        return documentRef;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// TODO(mrschmidt) Consider using `BaseTransaction` as the base class in the\n// legacy SDK.\n/**\n * A reference to a transaction.\n *\n * The `Transaction` object passed to a transaction's `updateFunction` provides\n * the methods to read and write data within the transaction context. See\n * {@link runTransaction}.\n */\nclass Transaction$1 {\n    /** @hideconstructor */\n    constructor(_firestore, _transaction) {\n        this._firestore = _firestore;\n        this._transaction = _transaction;\n        this._dataReader = newUserDataReader(_firestore);\n    }\n    /**\n     * Reads the document referenced by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be read.\n     * @returns A `DocumentSnapshot` with the read data.\n     */\n    get(documentRef) {\n        const ref = validateReference(documentRef, this._firestore);\n        const userDataWriter = new LiteUserDataWriter(this._firestore);\n        return this._transaction.lookup([ref._key]).then(docs => {\n            if (!docs || docs.length !== 1) {\n                return fail();\n            }\n            const doc = docs[0];\n            if (doc.isFoundDocument()) {\n                return new DocumentSnapshot$1(this._firestore, userDataWriter, doc.key, doc, ref.converter);\n            }\n            else if (doc.isNoDocument()) {\n                return new DocumentSnapshot$1(this._firestore, userDataWriter, ref._key, null, ref.converter);\n            }\n            else {\n                throw fail();\n            }\n        });\n    }\n    set(documentRef, value, options) {\n        const ref = validateReference(documentRef, this._firestore);\n        const convertedValue = applyFirestoreDataConverter(ref.converter, value, options);\n        const parsed = parseSetData(this._dataReader, 'Transaction.set', ref._key, convertedValue, ref.converter !== null, options);\n        this._transaction.set(ref._key, parsed);\n        return this;\n    }\n    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {\n        const ref = validateReference(documentRef, this._firestore);\n        // For Compat types, we have to \"extract\" the underlying types before\n        // performing validation.\n        fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\n        let parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof FieldPath) {\n            parsed = parseUpdateVarargs(this._dataReader, 'Transaction.update', ref._key, fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            parsed = parseUpdateData(this._dataReader, 'Transaction.update', ref._key, fieldOrUpdateData);\n        }\n        this._transaction.update(ref._key, parsed);\n        return this;\n    }\n    /**\n     * Deletes the document referred to by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be deleted.\n     * @returns This `Transaction` instance. Used for chaining method calls.\n     */\n    delete(documentRef) {\n        const ref = validateReference(documentRef, this._firestore);\n        this._transaction.delete(ref._key);\n        return this;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A reference to a transaction.\n *\n * The `Transaction` object passed to a transaction's `updateFunction` provides\n * the methods to read and write data within the transaction context. See\n * {@link runTransaction}.\n */\nclass Transaction extends Transaction$1 {\n    // This class implements the same logic as the Transaction API in the Lite SDK\n    // but is subclassed in order to return its own DocumentSnapshot types.\n    /** @hideconstructor */\n    constructor(_firestore, _transaction) {\n        super(_firestore, _transaction);\n        this._firestore = _firestore;\n    }\n    /**\n     * Reads the document referenced by the provided {@link DocumentReference}.\n     *\n     * @param documentRef - A reference to the document to be read.\n     * @returns A `DocumentSnapshot` with the read data.\n     */\n    get(documentRef) {\n        const ref = validateReference(documentRef, this._firestore);\n        const userDataWriter = new ExpUserDataWriter(this._firestore);\n        return super\n            .get(documentRef)\n            .then(liteDocumentSnapshot => new DocumentSnapshot(this._firestore, userDataWriter, ref._key, liteDocumentSnapshot._document, new SnapshotMetadata(\n        /* hasPendingWrites= */ false, \n        /* fromCache= */ false), ref.converter));\n    }\n}\n/**\n * Executes the given `updateFunction` and then attempts to commit the changes\n * applied within the transaction. If any document read within the transaction\n * has changed, Cloud Firestore retries the `updateFunction`. If it fails to\n * commit after 5 attempts, the transaction fails.\n *\n * The maximum number of writes allowed in a single transaction is 500.\n *\n * @param firestore - A reference to the Firestore database to run this\n * transaction against.\n * @param updateFunction - The function to execute within the transaction\n * context.\n * @param options - An options object to configure maximum number of attempts to\n * commit.\n * @returns If the transaction completed successfully or was explicitly aborted\n * (the `updateFunction` returned a failed promise), the promise returned by the\n * `updateFunction `is returned here. Otherwise, if the transaction failed, a\n * rejected promise with the corresponding failure error is returned.\n */\nfunction runTransaction(firestore, updateFunction, options) {\n    firestore = cast(firestore, Firestore);\n    const optionsWithDefaults = Object.assign(Object.assign({}, DEFAULT_TRANSACTION_OPTIONS), options);\n    validateTransactionOptions(optionsWithDefaults);\n    const client = ensureFirestoreConfigured(firestore);\n    return firestoreClientTransaction(client, internalTransaction => updateFunction(new Transaction(firestore, internalTransaction)), optionsWithDefaults);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a sentinel for use with {@link @firebase/firestore/lite#(updateDoc:1)} or\n * {@link @firebase/firestore/lite#(setDoc:1)} with `{merge: true}` to mark a field for deletion.\n */\nfunction deleteField() {\n    return new DeleteFieldValueImpl('deleteField');\n}\n/**\n * Returns a sentinel used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link @firebase/firestore/lite#(updateDoc:1)} to\n * include a server-generated timestamp in the written data.\n */\nfunction serverTimestamp() {\n    return new ServerTimestampFieldValueImpl('serverTimestamp');\n}\n/**\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to union the given elements with any array\n * value that already exists on the server. Each specified element that doesn't\n * already exist in the array will be added to the end. If the field being\n * modified is not already an array it will be overwritten with an array\n * containing exactly the specified elements.\n *\n * @param elements - The elements to union into the array.\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\n * `updateDoc()`.\n */\nfunction arrayUnion(...elements) {\n    // NOTE: We don't actually parse the data until it's used in set() or\n    // update() since we'd need the Firestore instance to do this.\n    return new ArrayUnionFieldValueImpl('arrayUnion', elements);\n}\n/**\n * Returns a special value that can be used with {@link (setDoc:1)} or {@link\n * updateDoc:1} that tells the server to remove the given elements from any\n * array value that already exists on the server. All instances of each element\n * specified will be removed from the array. If the field being modified is not\n * already an array it will be overwritten with an empty array.\n *\n * @param elements - The elements to remove from the array.\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\n * `updateDoc()`\n */\nfunction arrayRemove(...elements) {\n    // NOTE: We don't actually parse the data until it's used in set() or\n    // update() since we'd need the Firestore instance to do this.\n    return new ArrayRemoveFieldValueImpl('arrayRemove', elements);\n}\n/**\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to increment the field's current value by\n * the given value.\n *\n * If either the operand or the current field value uses floating point\n * precision, all arithmetic follows IEEE 754 semantics. If both values are\n * integers, values outside of JavaScript's safe number range\n * (`Number.MIN_SAFE_INTEGER` to `Number.MAX_SAFE_INTEGER`) are also subject to\n * precision loss. Furthermore, once processed by the Firestore backend, all\n * integer operations are capped between -2^63 and 2^63-1.\n *\n * If the current field value is not of type `number`, or if the field does not\n * yet exist, the transformation sets the field to the given value.\n *\n * @param n - The value to increment by.\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\n * `updateDoc()`\n */\nfunction increment(n) {\n    return new NumericIncrementFieldValueImpl('increment', n);\n}\n/**\n * Creates a new `VectorValue` constructed with a copy of the given array of numbers.\n *\n * @param values - Create a `VectorValue` instance with a copy of this array of numbers.\n *\n * @returns A new `VectorValue` constructed with a copy of the given array of numbers.\n */\nfunction vector(values) {\n    return new VectorValue(values);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Creates a write batch, used for performing multiple writes as a single\n * atomic operation. The maximum number of writes allowed in a single {@link WriteBatch}\n * is 500.\n *\n * Unlike transactions, write batches are persisted offline and therefore are\n * preferable when you don't need to condition your writes on read data.\n *\n * @returns A {@link WriteBatch} that can be used to atomically execute multiple\n * writes.\n */\nfunction writeBatch(firestore) {\n    firestore = cast(firestore, Firestore);\n    ensureFirestoreConfigured(firestore);\n    return new WriteBatch(firestore, mutations => executeWrite(firestore, mutations));\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction setIndexConfiguration(firestore, jsonOrConfiguration) {\n    firestore = cast(firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    if (!client._uninitializedComponentsProvider ||\n        client._uninitializedComponentsProvider._offline.kind === 'memory') {\n        // PORTING NOTE: We don't return an error if the user has not enabled\n        // persistence since `enableIndexeddbPersistence()` can fail on the Web.\n        logWarn('Cannot enable indexes when persistence is disabled');\n        return Promise.resolve();\n    }\n    const parsedIndexes = parseIndexes(jsonOrConfiguration);\n    return firestoreClientSetIndexConfiguration(client, parsedIndexes);\n}\nfunction parseIndexes(jsonOrConfiguration) {\n    const indexConfiguration = typeof jsonOrConfiguration === 'string'\n        ? tryParseJson(jsonOrConfiguration)\n        : jsonOrConfiguration;\n    const parsedIndexes = [];\n    if (Array.isArray(indexConfiguration.indexes)) {\n        for (const index of indexConfiguration.indexes) {\n            const collectionGroup = tryGetString(index, 'collectionGroup');\n            const segments = [];\n            if (Array.isArray(index.fields)) {\n                for (const field of index.fields) {\n                    const fieldPathString = tryGetString(field, 'fieldPath');\n                    const fieldPath = fieldPathFromDotSeparatedString('setIndexConfiguration', fieldPathString);\n                    if (field.arrayConfig === 'CONTAINS') {\n                        segments.push(new IndexSegment(fieldPath, 2 /* IndexKind.CONTAINS */));\n                    }\n                    else if (field.order === 'ASCENDING') {\n                        segments.push(new IndexSegment(fieldPath, 0 /* IndexKind.ASCENDING */));\n                    }\n                    else if (field.order === 'DESCENDING') {\n                        segments.push(new IndexSegment(fieldPath, 1 /* IndexKind.DESCENDING */));\n                    }\n                }\n            }\n            parsedIndexes.push(new FieldIndex(FieldIndex.UNKNOWN_ID, collectionGroup, segments, IndexState.empty()));\n        }\n    }\n    return parsedIndexes;\n}\nfunction tryParseJson(json) {\n    try {\n        return JSON.parse(json);\n    }\n    catch (e) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to parse JSON: ' + (e === null || e === void 0 ? void 0 : e.message));\n    }\n}\nfunction tryGetString(data, property) {\n    if (typeof data[property] !== 'string') {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Missing string value for: ' + property);\n    }\n    return data[property];\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A `PersistentCacheIndexManager` for configuring persistent cache indexes used\n * for local query execution.\n *\n * To use, call `getPersistentCacheIndexManager()` to get an instance.\n */\nclass PersistentCacheIndexManager {\n    /** @hideconstructor */\n    constructor(_firestore) {\n        this._firestore = _firestore;\n        /** A type string to uniquely identify instances of this class. */\n        this.type = 'PersistentCacheIndexManager';\n    }\n}\n/**\n * Returns the PersistentCache Index Manager used by the given `Firestore`\n * object.\n *\n * @return The `PersistentCacheIndexManager` instance, or `null` if local\n * persistent storage is not in use.\n */\nfunction getPersistentCacheIndexManager(firestore) {\n    var _a;\n    firestore = cast(firestore, Firestore);\n    const cachedInstance = persistentCacheIndexManagerByFirestore.get(firestore);\n    if (cachedInstance) {\n        return cachedInstance;\n    }\n    const client = ensureFirestoreConfigured(firestore);\n    if (((_a = client._uninitializedComponentsProvider) === null || _a === void 0 ? void 0 : _a._offline.kind) !== 'persistent') {\n        return null;\n    }\n    const instance = new PersistentCacheIndexManager(firestore);\n    persistentCacheIndexManagerByFirestore.set(firestore, instance);\n    return instance;\n}\n/**\n * Enables the SDK to create persistent cache indexes automatically for local\n * query execution when the SDK believes cache indexes can help improve\n * performance.\n *\n * This feature is disabled by default.\n */\nfunction enablePersistentCacheIndexAutoCreation(indexManager) {\n    setPersistentCacheIndexAutoCreationEnabled(indexManager, true);\n}\n/**\n * Stops creating persistent cache indexes automatically for local query\n * execution. The indexes which have been created by calling\n * `enablePersistentCacheIndexAutoCreation()` still take effect.\n */\nfunction disablePersistentCacheIndexAutoCreation(indexManager) {\n    setPersistentCacheIndexAutoCreationEnabled(indexManager, false);\n}\n/**\n * Removes all persistent cache indexes.\n *\n * Please note this function will also deletes indexes generated by\n * `setIndexConfiguration()`, which is deprecated.\n */\nfunction deleteAllPersistentCacheIndexes(indexManager) {\n    const client = ensureFirestoreConfigured(indexManager._firestore);\n    const promise = firestoreClientDeleteAllFieldIndexes(client);\n    promise\n        .then(_ => logDebug('deleting all persistent cache indexes succeeded'))\n        .catch(error => logWarn('deleting all persistent cache indexes failed', error));\n}\nfunction setPersistentCacheIndexAutoCreationEnabled(indexManager, isEnabled) {\n    const client = ensureFirestoreConfigured(indexManager._firestore);\n    const promise = firestoreClientSetPersistentCacheIndexAutoCreationEnabled(client, isEnabled);\n    promise\n        .then(_ => logDebug(`setting persistent cache index auto creation ` +\n        `isEnabled=${isEnabled} succeeded`))\n        .catch(error => logWarn(`setting persistent cache index auto creation ` +\n        `isEnabled=${isEnabled} failed`, error));\n}\n/**\n * Maps `Firestore` instances to their corresponding\n * `PersistentCacheIndexManager` instances.\n *\n * Use a `WeakMap` so that the mapping will be automatically dropped when the\n * `Firestore` instance is garbage collected. This emulates a private member\n * as described in https://goo.gle/454yvug.\n */\nconst persistentCacheIndexManagerByFirestore = new WeakMap();\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @internal\n * @private\n *\n * This function is for internal use only.\n *\n * Returns the `QueryTarget` representation of the given query. Returns `null`\n * if the Firestore client associated with the given query has not been\n * initialized or has been terminated.\n *\n * @param query - The Query to convert to proto representation.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _internalQueryToProtoQueryTarget(query) {\n    var _a;\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const serializer = (_a = client._onlineComponents) === null || _a === void 0 ? void 0 : _a.datastore.serializer;\n    if (serializer === undefined) {\n        return null;\n    }\n    return toQueryTarget(serializer, queryToTarget(query._query)).queryTarget;\n}\n/**\n * @internal\n * @private\n *\n * This function is for internal use only.\n *\n * Returns `RunAggregationQueryRequest` which contains the proto representation\n * of the given aggregation query request. Returns null if the Firestore client\n * associated with the given query has not been initialized or has been\n * terminated.\n *\n * @param query - The Query to convert to proto representation.\n * @param aggregateSpec - The set of aggregations and their aliases.\n */\nfunction _internalAggregationQueryToProtoRunAggregationQueryRequest(query, aggregateSpec) {\n    var _a;\n    const aggregates = mapToArray(aggregateSpec, (aggregate, alias) => {\n        return new AggregateImpl(alias, aggregate.aggregateType, aggregate._internalFieldPath);\n    });\n    const firestore = cast(query.firestore, Firestore);\n    const client = ensureFirestoreConfigured(firestore);\n    const serializer = (_a = client._onlineComponents) === null || _a === void 0 ? void 0 : _a.datastore.serializer;\n    if (serializer === undefined) {\n        return null;\n    }\n    return toRunAggregationQueryRequest(serializer, queryToAggregateTarget(query._query), aggregates, \n    /* skipAliasing= */ true).request;\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Testing hooks for use by Firestore's integration test suite to reach into the\n * SDK internals to validate logic and behavior that is not visible from the\n * public API surface.\n *\n * @internal\n */\nclass TestingHooks {\n    constructor() {\n        throw new Error('instances of this class should not be created');\n    }\n    /**\n     * Registers a callback to be notified when an existence filter mismatch\n     * occurs in the Watch listen stream.\n     *\n     * The relative order in which callbacks are notified is unspecified; do not\n     * rely on any particular ordering. If a given callback is registered multiple\n     * times then it will be notified multiple times, once per registration.\n     *\n     * @param callback the callback to invoke upon existence filter mismatch.\n     *\n     * @return a function that, when called, unregisters the given callback; only\n     * the first invocation of the returned function does anything; all subsequent\n     * invocations do nothing.\n     */\n    static onExistenceFilterMismatch(callback) {\n        return TestingHooksSpiImpl.instance.onExistenceFilterMismatch(callback);\n    }\n}\n/**\n * The implementation of `TestingHooksSpi`.\n */\nclass TestingHooksSpiImpl {\n    constructor() {\n        this.existenceFilterMismatchCallbacksById = new Map();\n    }\n    static get instance() {\n        if (!testingHooksSpiImplInstance) {\n            testingHooksSpiImplInstance = new TestingHooksSpiImpl();\n            setTestingHooksSpi(testingHooksSpiImplInstance);\n        }\n        return testingHooksSpiImplInstance;\n    }\n    notifyOnExistenceFilterMismatch(info) {\n        this.existenceFilterMismatchCallbacksById.forEach(callback => callback(info));\n    }\n    onExistenceFilterMismatch(callback) {\n        const id = Symbol();\n        const callbacks = this.existenceFilterMismatchCallbacksById;\n        callbacks.set(id, callback);\n        return () => callbacks.delete(id);\n    }\n}\nlet testingHooksSpiImplInstance = null;\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nregisterFirestore('node');\n\n\n//# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9maXJlc3RvcmUvZGlzdC9pbmRleC5ub2RlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzSztBQUN0SDtBQUNJO0FBQ0s7QUFDb0g7QUFDdkg7QUFDaUI7QUFDakM7QUFDWTs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZDQUFPLFVBQVUsWUFBWTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQVE7QUFDdEM7QUFDQSxzQ0FBc0MsWUFBWSxLQUFLLElBQUk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNEQUFRO0FBQ3RDO0FBQ0Esc0NBQXNDLFlBQVksS0FBSyxJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzREFBUTtBQUN0QztBQUNBLHFDQUFxQyxZQUFZLEtBQUssSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlEQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVUsVUFBVSxVQUFVLEtBQUssYUFBYTtBQUNqRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1FQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRiwwQ0FBMEMsMEJBQTBCO0FBQzlKO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxtQ0FBbUM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsZ0JBQWdCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1EQUFhO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUFXO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdIQUFnSDtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0RUFBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLEtBQUs7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLEtBQUs7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQXVEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUIsTUFBTSwyQkFBMkIsS0FBSyw4QkFBOEIsWUFBWSxHQUFHLE9BQU8sYUFBYTtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0VBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxREFBSztBQUN4QjtBQUNBLDBDQUEwQyxXQUFXLGdCQUFnQjtBQUNyRTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscURBQUs7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVcsWUFBWSxNQUFNO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMscURBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsVUFBVTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxtQkFBbUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdCQUFnQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFVBQVU7QUFDbEU7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxFQUFFLEdBQUcsRUFBRTtBQUN4QztBQUNBLFNBQVM7QUFDVCxpQkFBaUIsRUFBRSx5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNEQUFzRCxZQUFZO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEVBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQXFEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUErQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCLEdBQUcsMEJBQTBCO0FBQzVFO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCLEdBQUcsbUJBQW1CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUksR0FBRyxvQ0FBb0M7QUFDaEU7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUIsYUFBYSxvQkFBb0IsYUFBYSwyQkFBMkI7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkMsd0JBQXdCLDZDQUE2QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSx3REFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EsbUNBQW1DLGNBQWMsbUJBQW1CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0NBQW9DO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQsa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUyxJQUFJLGFBQWEsSUFBSSxnQ0FBZ0M7QUFDMUYsY0FBYyxjQUFjLGlCQUFpQjtBQUM3QyxjQUFjLGdCQUFnQixtQkFBbUI7QUFDakQsY0FBYyxpQkFBaUIsb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlDQUFpQyxHQUFHLFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVSxHQUFHLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjLGdDQUFnQyxFQUFFLFdBQVcsRUFBRSwwQkFBMEI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx5QkFBeUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCLElBQUksZ0RBQWdEO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0JBQWtCLElBQUksZ0RBQWdEO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0IsSUFBSSxnREFBZ0Q7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0IsSUFBSSxnREFBZ0Q7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQ0FBcUMsTUFBTSxnQkFBZ0I7QUFDekU7QUFDQTtBQUNBLDJCQUEyQix3Q0FBd0MsWUFBWSxnQkFBZ0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUNBQW1DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDLGtCQUFrQjtBQUNsQixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNEVBQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdFQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEVBQU87QUFDaEMseUJBQXlCLDRFQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsUUFBUTtBQUNuRTtBQUNBO0FBQ0EsOERBQThELFVBQVU7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsOERBQThELFVBQVU7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFFBQVE7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRFQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNEVBQU87QUFDdEQ7QUFDQTtBQUNBLDRCQUE0Qiw0RUFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRLDBCQUEwQixrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFLDhCQUE4QixvQkFBb0I7QUFDbEQsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCLEdBQUcsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZLDJCQUEyQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWSw0QkFBNEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtDQUFrQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQSx1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUNBQXFDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkJBQTJCLGFBQWEsdUJBQXVCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBaUQ7QUFDeEU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQWlEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdFQUFnRTtBQUN2RjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsT0FBTztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1DQUFtQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2Q0FBNkM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjtBQUN0RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsYUFBYSxXQUFXO0FBQ3JHLCtDQUErQyx5Q0FBeUM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNkNBQTZDO0FBQ3RGLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUNBQWlDLHNEQUFRO0FBQ3pDO0FBQ0EsNENBQTRDLDJCQUEyQjtBQUN2RSx3REFBd0QsMEJBQTBCO0FBQ2xGLHVCQUF1QixxQ0FBcUM7QUFDNUQsaUNBQWlDLGdCQUFnQjtBQUNqRCx1QkFBdUIscUNBQXFDO0FBQzVELGlDQUFpQyxrQkFBa0I7QUFDbkQsdUJBQXVCLHNDQUFzQztBQUM3RCx1Q0FBdUMsNkJBQTZCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUF5QixzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQWdEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQTZDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsWUFBWTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWMsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtHQUErRyxjQUFjO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZHQUE2RyxjQUFjO0FBQzNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUhBQXFILGNBQWM7QUFDbkk7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBGQUEwRixjQUFjO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtJQUFrSSxlQUFlO0FBQ2pKO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0dBQXdHLGVBQWU7QUFDdkg7QUFDQTtBQUNBLEtBQUs7QUFDTCxrR0FBa0csZUFBZTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxSUFBcUksZUFBZTtBQUNwSix1SUFBdUksZUFBZTtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSw4Q0FBOEMsbUNBQW1DO0FBQ2pGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsK0VBQStFLE9BQU87QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjLElBQUksY0FBYztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUyxJQUFJLDZCQUE2QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkIsR0FBRyxvQkFBb0IsR0FBRyxTQUFTO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0NBQXdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLFNBQVMsSUFBSSxFQUFFO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsV0FBVztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBUTtBQUNoQjtBQUNBO0FBQ0EsK0JBQStCLHFEQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzREFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzREFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCLEdBQUcsZUFBZSxHQUFHLFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQkFBMEIsR0FBRyxlQUFlLEdBQUcsUUFBUTtBQUNoRjtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QixHQUFHLGVBQWUsR0FBRyxTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0IsR0FBRyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QixHQUFHLGVBQWU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkIsR0FBRyxlQUFlO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsUUFBUSxLQUFLLE1BQU07QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsU0FBUyxLQUFLLE1BQU07QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBcUQ7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsU0FBUyxLQUFLLE1BQU07QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsTUFBTTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdCQUF3QixHQUFHLHNCQUFzQjtBQUNoRyxpREFBaUQsMEJBQTBCLEdBQUcsc0JBQXNCO0FBQ3BHLCtDQUErQyx3QkFBd0IsR0FBRyxzQkFBc0I7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSx1QkFBdUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1QkFBdUIsT0FBTyxhQUFhLE9BQU8sWUFBWTtBQUN6RztBQUNBO0FBQ0EseUJBQXlCLG1EQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtDQUFrQyxhQUFhLGlDQUFpQztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFnQjtBQUNsQyxrQkFBa0Isc0RBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsNkJBQTZCO0FBQ3pFO0FBQ0Esd0NBQXdDLFFBQVEsSUFBSSxVQUFVO0FBQzlEO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUSxJQUFJLFVBQVU7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVEsSUFBSSxVQUFVO0FBQ3RFO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUSxJQUFJLFVBQVU7QUFDMUQ7QUFDQTtBQUNBLDBEQUEwRCxjQUFjLDZCQUE2QjtBQUNyRztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUyxFQUFFLFVBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0NBQXdDLFFBQVEsSUFBSSxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0NBQXdDLFFBQVEsSUFBSSxVQUFVO0FBQzlEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUSxXQUFXLFVBQVU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVEsV0FBVyxVQUFVO0FBQzdFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0Q0FBNEMsUUFBUSxXQUFXLFVBQVU7QUFDekU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSxXQUFXLFVBQVU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3Q0FBd0MsUUFBUSxXQUFXLFVBQVU7QUFDckU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJDQUEyQyxRQUFRLFdBQVcsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNENBQTRDLFFBQVEsV0FBVyxVQUFVO0FBQ3pFLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywyQ0FBMkM7QUFDckYsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQ0FBMkM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZDQUE2QyxFQUFFLGNBQWM7QUFDdkcsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2Q0FBNkMsRUFBRSxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxvREFBb0Q7QUFDaEc7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0RBQW9EO0FBQzlFO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkNBQTJDO0FBQ3hGO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQ0FBMkM7QUFDeEU7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHdDQUF3QztBQUNuRjtBQUNBLCtEQUErRCw2Q0FBNkM7QUFDNUc7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUE2QztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0NBQXdDO0FBQ25GO0FBQ0EsK0RBQStELDZDQUE2QztBQUM1RztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQXdDO0FBQ2pFO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQTZDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0NBQXdDO0FBQ25GO0FBQ0EsK0RBQStELDZDQUE2QztBQUM1RztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQXdDO0FBQ2pFO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQTZDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3Q0FBd0M7QUFDbkY7QUFDQSwrREFBK0QsNkNBQTZDO0FBQzVHO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUE2QztBQUN2RTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkNBQTJDLEVBQUUsY0FBYztBQUN0RztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkNBQTJDLEVBQUUsY0FBYztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3REFBb0I7QUFDbEQsV0FBVyxnRUFBMEI7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtCQUFrQjtBQUNyRSxnQ0FBZ0Msb0JBQW9CO0FBQ3BELHNDQUFzQywwQkFBMEI7QUFDaEUsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE1BQU07QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsZ0NBQWdDO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSwyQkFBMkI7QUFDeEcsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxRQUFRO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usc0NBQXNDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSSxJQUFJLEVBQUU7QUFDckM7QUFDQSx1REFBdUQsSUFBSSxJQUFJLEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFDQUFxQztBQUNoRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRiwrQkFBK0I7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRDQUE0QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdEQUFnRDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2Q0FBNkM7QUFDL0U7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtDQUErQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsK0NBQStDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxhQUFhLG9DQUFvQyxhQUFhO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYSxNQUFNLGFBQWE7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFKQUFxSixNQUFNLE1BQU0sWUFBWTtBQUM3SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0pBQXdKLE1BQU0sTUFBTSxZQUFZO0FBQ2hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsaUJBQWlCLGlCQUFpQixZQUFZO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxhQUFhLDZDQUE2QyxFQUFFO0FBQ2hJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0lBQWdJLHlCQUF5QjtBQUN6SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtGQUFrRjtBQUNqRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsUUFBUTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsT0FBTztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsNkJBQTZCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SkFBd0o7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0EsNkZBQTZGLHdCQUF3QjtBQUNySCw2Q0FBNkMsaUNBQWlDO0FBQzlFO0FBQ0E7QUFDQSw2RkFBNkYsd0JBQXdCO0FBQ3JILDZDQUE2QyxpQ0FBaUM7QUFDOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHVCQUF1QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxlQUFlLGtEQUFrRDtBQUMxSCw4QkFBOEIsS0FBSyxHQUFHLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZUFBZSw0REFBNEQ7QUFDL0g7QUFDQTtBQUNBLFFBQVEseURBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUVBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0JBQWdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0VBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsYUFBYTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtFQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0IsWUFBWSxrRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QixZQUFZLGtFQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQkFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1QkFBdUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0EsSUFBSSx1QkFBdUI7QUFDM0IsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBLHFCQUFxQixpQ0FBaUMsZ0JBQWdCLGlCQUFpQjtBQUN2RjtBQUNBLHlEQUF5RCxpQkFBaUI7QUFDMUU7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkRBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsWUFBWSx5REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLDZCQUE2QjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0VBQXdFLHFEQUFNO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkRBQVk7QUFDM0I7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5QkFBeUIsaUZBQWlDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCLEdBQUcsd0JBQXdCO0FBQ3JFLElBQUksZ0NBQWdDO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0Esc0RBQXNEO0FBQ3RELHdCQUF3QixJQUFJLHVCQUF1QixZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpQkFBaUI7QUFDNUQsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx1QkFBdUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxRUFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFhO0FBQy9CLElBQUksaUVBQWtCLEtBQUssMERBQVMsNEJBQTRCLG1EQUFtRDtBQUNuSDtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksOERBQWU7QUFDbkI7QUFDQSxJQUFJLDhEQUFlO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsc0NBQXNDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzQ0FBc0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQSxrQ0FBa0MscUNBQXFDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlCQUFpQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpQkFBaUI7QUFDMUQsa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrRUFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxXQUFXO0FBQy9FO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrRUFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0VBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtFQUFrQjtBQUM5QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQixHQUFHLGtCQUFrQjtBQUMxRCxnQ0FBZ0MsaUJBQWlCLEdBQUcsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx3QkFBd0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3QztBQUNBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsWUFBWTtBQUM1RSxJQUFJLGNBQWMsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRztBQUNsRSxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsbUJBQW1CO0FBQ3pFLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsYUFBYTtBQUN2RSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtDQUFrQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRLGVBQWU7QUFDeEUsVUFBVTtBQUNWO0FBQ0EseUJBQXlCLGlDQUFpQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlDQUFpQyxNQUFNLHFDQUFxQztBQUNoRiw4REFBOEQsVUFBVTtBQUN4RSxJQUFJLFdBQVcsMkJBQTJCLGlCQUFpQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQ0FBc0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQywwQkFBMEIsWUFBWSxHQUFHLFNBQVMsTUFBTSxVQUFVO0FBQ2xFLCtCQUErQixxQ0FBcUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0NBQXNDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0QkFBNEI7QUFDaEMsMEJBQTBCLFlBQVksR0FBRyxTQUFTLE1BQU0sVUFBVTtBQUNsRSwrQkFBK0IscUNBQXFDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZSwyQkFBMkIsaUJBQWlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakUsSUFBSSxtQkFBbUIsMkJBQTJCLGlCQUFpQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG1CQUFtQjtBQUN6RSxJQUFJLHNCQUFzQiwyQkFBMkIsaUJBQWlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxpQkFBaUI7QUFDckUsSUFBSSxxQkFBcUIsMkJBQTJCLGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtFQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsR0FBRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE1BQU07QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsV0FBVztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXLGdCQUFnQixnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQsd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsV0FBVztBQUNwRSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0VBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBSyxxREFBcUQsWUFBWTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtDQUFrQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBLDhGQUE4RiwwQkFBMEI7QUFDeEgseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGFBQWE7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0EsbUJBQW1CLHFCQUFxQixHQUFHLG9CQUFvQjtBQUMvRDtBQUNBLDZCQUE2Qiw2QkFBNkIsR0FBRyw0QkFBNEI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx5REFBUztBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx1QkFBdUIsSUFBSSx1QkFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QixJQUFJLHdCQUF3QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1IO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLFNBQVMsdUJBQXVCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxpQkFBaUI7QUFDdEU7QUFDQSxpREFBaUQseUJBQXlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRUFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHdCQUF3QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtFQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHdCQUF3QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtFQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsd0JBQXdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHdCQUF3QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOENBQThDO0FBQ2xGLElBQUksMkNBQTJDLE9BQU8sWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJDQUEyQyxJQUFJLDhDQUE4QztBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMkNBQTJDLElBQUk7QUFDakcsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQkFBa0IsSUFBSTtBQUN4RSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwyQ0FBMkMsSUFBSTtBQUNqRywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0c0U7QUFDNXNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGFsa190b190ZXh0Ly4uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZmlyZXN0b3JlL2Rpc3QvaW5kZXgubm9kZS5tanM/NWI0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfZ2V0UHJvdmlkZXIsIGdldEFwcCwgX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSwgX3JlZ2lzdGVyQ29tcG9uZW50LCByZWdpc3RlclZlcnNpb24sIF9pc0ZpcmViYXNlU2VydmVyQXBwLCBTREtfVkVSU0lPTiBhcyBTREtfVkVSU0lPTiQxIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IExvZ2dlciwgTG9nTGV2ZWwgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcbmltcG9ydCB7IGluc3BlY3QsIFRleHRFbmNvZGVyLCBUZXh0RGVjb2RlciB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciwgZGVlcEVxdWFsLCBjcmVhdGVNb2NrVXNlclRva2VuLCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCwgaXNJbmRleGVkREJBdmFpbGFibGUsIGdldFVBLCBpc1NhZmFyaSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIGFzIHJhbmRvbUJ5dGVzJDEgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgSW50ZWdlciwgTWQ1IH0gZnJvbSAnQGZpcmViYXNlL3dlYmNoYW5uZWwtd3JhcHBlci9ibG9vbS1ibG9iJztcbmltcG9ydCAqIGFzIGdycGMgZnJvbSAnQGdycGMvZ3JwYy1qcyc7XG5pbXBvcnQgKiBhcyBwcm90b0xvYWRlciBmcm9tICdAZ3JwYy9wcm90by1sb2FkZXInO1xuXG5jb25zdCBuYW1lID0gXCJAZmlyZWJhc2UvZmlyZXN0b3JlXCI7XG5jb25zdCB2ZXJzaW9uJDEgPSBcIjQuNy4xMFwiO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBTaW1wbGUgd3JhcHBlciBhcm91bmQgYSBudWxsYWJsZSBVSUQuIE1vc3RseSBleGlzdHMgdG8gbWFrZSBjb2RlIG1vcmVcbiAqIHJlYWRhYmxlLlxuICovXG5jbGFzcyBVc2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih1aWQpIHtcbiAgICAgICAgdGhpcy51aWQgPSB1aWQ7XG4gICAgfVxuICAgIGlzQXV0aGVudGljYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWlkICE9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBrZXkgcmVwcmVzZW50aW5nIHRoaXMgdXNlciwgc3VpdGFibGUgZm9yIGluY2x1c2lvbiBpbiBhXG4gICAgICogZGljdGlvbmFyeS5cbiAgICAgKi9cbiAgICB0b0tleSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAndWlkOicgKyB0aGlzLnVpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnYW5vbnltb3VzLXVzZXInO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXJVc2VyKSB7XG4gICAgICAgIHJldHVybiBvdGhlclVzZXIudWlkID09PSB0aGlzLnVpZDtcbiAgICB9XG59XG4vKiogQSB1c2VyIHdpdGggYSBudWxsIFVJRC4gKi9cblVzZXIuVU5BVVRIRU5USUNBVEVEID0gbmV3IFVzZXIobnVsbCk7XG4vLyBUT0RPKG1pa2VsZWhlbik6IExvb2sgaW50byBnZXR0aW5nIGEgcHJvcGVyIHVpZC1lcXVpdmFsZW50IGZvclxuLy8gbm9uLUZpcmViYXNlQXV0aCBwcm92aWRlcnMuXG5Vc2VyLkdPT0dMRV9DUkVERU5USUFMUyA9IG5ldyBVc2VyKCdnb29nbGUtY3JlZGVudGlhbHMtdWlkJyk7XG5Vc2VyLkZJUlNUX1BBUlRZID0gbmV3IFVzZXIoJ2ZpcnN0LXBhcnR5LXVpZCcpO1xuVXNlci5NT0NLX1VTRVIgPSBuZXcgVXNlcignbW9jay11c2VyJyk7XG5cbmNvbnN0IHZlcnNpb24gPSBcIjExLjUuMFwiO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xubGV0IFNES19WRVJTSU9OID0gdmVyc2lvbjtcbmZ1bmN0aW9uIHNldFNES1ZlcnNpb24odmVyc2lvbikge1xuICAgIFNES19WRVJTSU9OID0gdmVyc2lvbjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBGb3JtYXRzIGFuIG9iamVjdCBhcyBhIEpTT04gc3RyaW5nLCBzdWl0YWJsZSBmb3IgbG9nZ2luZy4gKi9cbmZ1bmN0aW9uIGZvcm1hdEpTT04odmFsdWUpIHtcbiAgICAvLyB1dGlsLmluc3BlY3QoKSByZXN1bHRzIGluIG11Y2ggbW9yZSByZWFkYWJsZSBvdXRwdXQgdGhhbiBKU09OLnN0cmluZ2lmeSgpXG4gICAgcmV0dXJuIGluc3BlY3QodmFsdWUsIHsgZGVwdGg6IDEwMCB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGxvZ0NsaWVudCA9IG5ldyBMb2dnZXIoJ0BmaXJlYmFzZS9maXJlc3RvcmUnKTtcbi8vIEhlbHBlciBtZXRob2RzIGFyZSBuZWVkZWQgYmVjYXVzZSB2YXJpYWJsZXMgY2FuJ3QgYmUgZXhwb3J0ZWQgYXMgcmVhZC93cml0ZVxuZnVuY3Rpb24gZ2V0TG9nTGV2ZWwoKSB7XG4gICAgcmV0dXJuIGxvZ0NsaWVudC5sb2dMZXZlbDtcbn1cbi8qKlxuICogU2V0cyB0aGUgdmVyYm9zaXR5IG9mIENsb3VkIEZpcmVzdG9yZSBsb2dzIChkZWJ1ZywgZXJyb3IsIG9yIHNpbGVudCkuXG4gKlxuICogQHBhcmFtIGxvZ0xldmVsIC0gVGhlIHZlcmJvc2l0eSB5b3Ugc2V0IGZvciBhY3Rpdml0eSBhbmQgZXJyb3IgbG9nZ2luZy4gQ2FuXG4gKiAgIGJlIGFueSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAqXG4gKiAgIDx1bD5cbiAqICAgICA8bGk+YGRlYnVnYCBmb3IgdGhlIG1vc3QgdmVyYm9zZSBsb2dnaW5nIGxldmVsLCBwcmltYXJpbHkgZm9yXG4gKiAgICAgZGVidWdnaW5nLjwvbGk+XG4gKiAgICAgPGxpPmBlcnJvcmAgdG8gbG9nIGVycm9ycyBvbmx5LjwvbGk+XG4gKiAgICAgPGxpPjxjb2RlPmBzaWxlbnRgIHRvIHR1cm4gb2ZmIGxvZ2dpbmcuPC9saT5cbiAqICAgPC91bD5cbiAqL1xuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobG9nTGV2ZWwpIHtcbiAgICBsb2dDbGllbnQuc2V0TG9nTGV2ZWwobG9nTGV2ZWwpO1xufVxuZnVuY3Rpb24gbG9nRGVidWcobXNnLCAuLi5vYmopIHtcbiAgICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLkRFQlVHKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBvYmoubWFwKGFyZ1RvU3RyaW5nKTtcbiAgICAgICAgbG9nQ2xpZW50LmRlYnVnKGBGaXJlc3RvcmUgKCR7U0RLX1ZFUlNJT059KTogJHttc2d9YCwgLi4uYXJncyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbG9nRXJyb3IobXNnLCAuLi5vYmopIHtcbiAgICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLkVSUk9SKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBvYmoubWFwKGFyZ1RvU3RyaW5nKTtcbiAgICAgICAgbG9nQ2xpZW50LmVycm9yKGBGaXJlc3RvcmUgKCR7U0RLX1ZFUlNJT059KTogJHttc2d9YCwgLi4uYXJncyk7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gbG9nV2Fybihtc2csIC4uLm9iaikge1xuICAgIGlmIChsb2dDbGllbnQubG9nTGV2ZWwgPD0gTG9nTGV2ZWwuV0FSTikge1xuICAgICAgICBjb25zdCBhcmdzID0gb2JqLm1hcChhcmdUb1N0cmluZyk7XG4gICAgICAgIGxvZ0NsaWVudC53YXJuKGBGaXJlc3RvcmUgKCR7U0RLX1ZFUlNJT059KTogJHttc2d9YCwgLi4uYXJncyk7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhZGRpdGlvbmFsIGxvZyBwYXJhbWV0ZXIgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIGFyZ1RvU3RyaW5nKG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRKU09OKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnRpbmcgdG8gSlNPTiBmYWlsZWQsIGp1c3QgbG9nIHRoZSBvYmplY3QgZGlyZWN0bHlcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFVuY29uZGl0aW9uYWxseSBmYWlscywgdGhyb3dpbmcgYW4gRXJyb3Igd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZS5cbiAqIE1lc3NhZ2VzIGFyZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uIGJ1aWxkcy5cbiAqXG4gKiBSZXR1cm5zIGBuZXZlcmAgYW5kIGNhbiBiZSB1c2VkIGluIGV4cHJlc3Npb25zOlxuICogQGV4YW1wbGVcbiAqIGxldCBmdXR1cmVWYXIgPSBmYWlsKCdub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gKi9cbmZ1bmN0aW9uIGZhaWwoZmFpbHVyZSA9ICdVbmV4cGVjdGVkIHN0YXRlJykge1xuICAgIC8vIExvZyB0aGUgZmFpbHVyZSBpbiBhZGRpdGlvbiB0byB0aHJvdyBhbiBleGNlcHRpb24sIGp1c3QgaW4gY2FzZSB0aGVcbiAgICAvLyBleGNlcHRpb24gaXMgc3dhbGxvd2VkLlxuICAgIGNvbnN0IG1lc3NhZ2UgPSBgRklSRVNUT1JFICgke1NES19WRVJTSU9OfSkgSU5URVJOQUwgQVNTRVJUSU9OIEZBSUxFRDogYCArIGZhaWx1cmU7XG4gICAgbG9nRXJyb3IobWVzc2FnZSk7XG4gICAgLy8gTk9URTogV2UgZG9uJ3QgdXNlIEZpcmVzdG9yZUVycm9yIGhlcmUgYmVjYXVzZSB0aGVzZSBhcmUgaW50ZXJuYWwgZmFpbHVyZXNcbiAgICAvLyB0aGF0IGNhbm5vdCBiZSBoYW5kbGVkIGJ5IHRoZSB1c2VyLiAoQWxzbyBpdCB3b3VsZCBjcmVhdGUgYSBjaXJjdWxhclxuICAgIC8vIGRlcGVuZGVuY3kgYmV0d2VlbiB0aGUgZXJyb3IgYW5kIGFzc2VydCBtb2R1bGVzIHdoaWNoIGRvZXNuJ3Qgd29yay4pXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuLyoqXG4gKiBGYWlscyBpZiB0aGUgZ2l2ZW4gYXNzZXJ0aW9uIGNvbmRpdGlvbiBpcyBmYWxzZSwgdGhyb3dpbmcgYW4gRXJyb3Igd2l0aCB0aGVcbiAqIGdpdmVuIG1lc3NhZ2UgaWYgaXQgZGlkLlxuICpcbiAqIE1lc3NhZ2VzIGFyZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uIGJ1aWxkcy5cbiAqL1xuZnVuY3Rpb24gaGFyZEFzc2VydChhc3NlcnRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWFzc2VydGlvbikge1xuICAgICAgICBmYWlsKCk7XG4gICAgfVxufVxuLyoqXG4gKiBGYWlscyBpZiB0aGUgZ2l2ZW4gYXNzZXJ0aW9uIGNvbmRpdGlvbiBpcyBmYWxzZSwgdGhyb3dpbmcgYW4gRXJyb3Igd2l0aCB0aGVcbiAqIGdpdmVuIG1lc3NhZ2UgaWYgaXQgZGlkLlxuICpcbiAqIFRoZSBjb2RlIG9mIGNhbGxzaXRlcyBpbnZva2luZyB0aGlzIGZ1bmN0aW9uIGFyZSBzdHJpcHBlZCBvdXQgaW4gcHJvZHVjdGlvblxuICogYnVpbGRzLiBBbnkgc2lkZS1lZmZlY3RzIG9mIGNvZGUgd2l0aGluIHRoZSBkZWJ1Z0Fzc2VydCgpIGludm9jYXRpb24gd2lsbCBub3RcbiAqIGhhcHBlbiBpbiB0aGlzIGNhc2UuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGRlYnVnQXNzZXJ0KGFzc2VydGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghYXNzZXJ0aW9uKSB7XG4gICAgICAgIGZhaWwoKTtcbiAgICB9XG59XG4vKipcbiAqIENhc3RzIGBvYmpgIHRvIGBUYC4gSW4gbm9uLXByb2R1Y3Rpb24gYnVpbGRzLCB2ZXJpZmllcyB0aGF0IGBvYmpgIGlzIGFuXG4gKiBpbnN0YW5jZSBvZiBgVGAgYmVmb3JlIGNhc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIGRlYnVnQ2FzdChvYmosIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IENvZGUgPSB7XG4gICAgLy8gQ2F1c2VzIGFyZSBjb3BpZWQgZnJvbTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvYmNlZWM5NGVhNGZjNWYwMDg1ZDgxMjM1ZDhlMWMwNjc5OGRjMzQxYS9pbmNsdWRlL2dycGMlMkIlMkIvaW1wbC9jb2RlZ2VuL3N0YXR1c19jb2RlX2VudW0uaFxuICAgIC8qKiBOb3QgYW4gZXJyb3I7IHJldHVybmVkIG9uIHN1Y2Nlc3MuICovXG4gICAgT0s6ICdvaycsXG4gICAgLyoqIFRoZSBvcGVyYXRpb24gd2FzIGNhbmNlbGxlZCAodHlwaWNhbGx5IGJ5IHRoZSBjYWxsZXIpLiAqL1xuICAgIENBTkNFTExFRDogJ2NhbmNlbGxlZCcsXG4gICAgLyoqIFVua25vd24gZXJyb3Igb3IgYW4gZXJyb3IgZnJvbSBhIGRpZmZlcmVudCBlcnJvciBkb21haW4uICovXG4gICAgVU5LTk9XTjogJ3Vua25vd24nLFxuICAgIC8qKlxuICAgICAqIENsaWVudCBzcGVjaWZpZWQgYW4gaW52YWxpZCBhcmd1bWVudC4gTm90ZSB0aGF0IHRoaXMgZGlmZmVycyBmcm9tXG4gICAgICogRkFJTEVEX1BSRUNPTkRJVElPTi4gSU5WQUxJRF9BUkdVTUVOVCBpbmRpY2F0ZXMgYXJndW1lbnRzIHRoYXQgYXJlXG4gICAgICogcHJvYmxlbWF0aWMgcmVnYXJkbGVzcyBvZiB0aGUgc3RhdGUgb2YgdGhlIHN5c3RlbSAoZS5nLiwgYSBtYWxmb3JtZWQgZmlsZVxuICAgICAqIG5hbWUpLlxuICAgICAqL1xuICAgIElOVkFMSURfQVJHVU1FTlQ6ICdpbnZhbGlkLWFyZ3VtZW50JyxcbiAgICAvKipcbiAgICAgKiBEZWFkbGluZSBleHBpcmVkIGJlZm9yZSBvcGVyYXRpb24gY291bGQgY29tcGxldGUuIEZvciBvcGVyYXRpb25zIHRoYXRcbiAgICAgKiBjaGFuZ2UgdGhlIHN0YXRlIG9mIHRoZSBzeXN0ZW0sIHRoaXMgZXJyb3IgbWF5IGJlIHJldHVybmVkIGV2ZW4gaWYgdGhlXG4gICAgICogb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBGb3IgZXhhbXBsZSwgYSBzdWNjZXNzZnVsIHJlc3BvbnNlXG4gICAgICogZnJvbSBhIHNlcnZlciBjb3VsZCBoYXZlIGJlZW4gZGVsYXllZCBsb25nIGVub3VnaCBmb3IgdGhlIGRlYWRsaW5lIHRvXG4gICAgICogZXhwaXJlLlxuICAgICAqL1xuICAgIERFQURMSU5FX0VYQ0VFREVEOiAnZGVhZGxpbmUtZXhjZWVkZWQnLFxuICAgIC8qKiBTb21lIHJlcXVlc3RlZCBlbnRpdHkgKGUuZy4sIGZpbGUgb3IgZGlyZWN0b3J5KSB3YXMgbm90IGZvdW5kLiAqL1xuICAgIE5PVF9GT1VORDogJ25vdC1mb3VuZCcsXG4gICAgLyoqXG4gICAgICogU29tZSBlbnRpdHkgdGhhdCB3ZSBhdHRlbXB0ZWQgdG8gY3JlYXRlIChlLmcuLCBmaWxlIG9yIGRpcmVjdG9yeSkgYWxyZWFkeVxuICAgICAqIGV4aXN0cy5cbiAgICAgKi9cbiAgICBBTFJFQURZX0VYSVNUUzogJ2FscmVhZHktZXhpc3RzJyxcbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbGVyIGRvZXMgbm90IGhhdmUgcGVybWlzc2lvbiB0byBleGVjdXRlIHRoZSBzcGVjaWZpZWQgb3BlcmF0aW9uLlxuICAgICAqIFBFUk1JU1NJT05fREVOSUVEIG11c3Qgbm90IGJlIHVzZWQgZm9yIHJlamVjdGlvbnMgY2F1c2VkIGJ5IGV4aGF1c3RpbmdcbiAgICAgKiBzb21lIHJlc291cmNlICh1c2UgUkVTT1VSQ0VfRVhIQVVTVEVEIGluc3RlYWQgZm9yIHRob3NlIGVycm9ycykuXG4gICAgICogUEVSTUlTU0lPTl9ERU5JRUQgbXVzdCBub3QgYmUgdXNlZCBpZiB0aGUgY2FsbGVyIGNhbm5vdCBiZSBpZGVudGlmaWVkXG4gICAgICogKHVzZSBVTkFVVEhFTlRJQ0FURUQgaW5zdGVhZCBmb3IgdGhvc2UgZXJyb3JzKS5cbiAgICAgKi9cbiAgICBQRVJNSVNTSU9OX0RFTklFRDogJ3Blcm1pc3Npb24tZGVuaWVkJyxcbiAgICAvKipcbiAgICAgKiBUaGUgcmVxdWVzdCBkb2VzIG5vdCBoYXZlIHZhbGlkIGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGZvciB0aGVcbiAgICAgKiBvcGVyYXRpb24uXG4gICAgICovXG4gICAgVU5BVVRIRU5USUNBVEVEOiAndW5hdXRoZW50aWNhdGVkJyxcbiAgICAvKipcbiAgICAgKiBTb21lIHJlc291cmNlIGhhcyBiZWVuIGV4aGF1c3RlZCwgcGVyaGFwcyBhIHBlci11c2VyIHF1b3RhLCBvciBwZXJoYXBzIHRoZVxuICAgICAqIGVudGlyZSBmaWxlIHN5c3RlbSBpcyBvdXQgb2Ygc3BhY2UuXG4gICAgICovXG4gICAgUkVTT1VSQ0VfRVhIQVVTVEVEOiAncmVzb3VyY2UtZXhoYXVzdGVkJyxcbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb24gd2FzIHJlamVjdGVkIGJlY2F1c2UgdGhlIHN5c3RlbSBpcyBub3QgaW4gYSBzdGF0ZSByZXF1aXJlZCBmb3JcbiAgICAgKiB0aGUgb3BlcmF0aW9uJ3MgZXhlY3V0aW9uLiBGb3IgZXhhbXBsZSwgZGlyZWN0b3J5IHRvIGJlIGRlbGV0ZWQgbWF5IGJlXG4gICAgICogbm9uLWVtcHR5LCBhbiBybWRpciBvcGVyYXRpb24gaXMgYXBwbGllZCB0byBhIG5vbi1kaXJlY3RvcnksIGV0Yy5cbiAgICAgKlxuICAgICAqIEEgbGl0bXVzIHRlc3QgdGhhdCBtYXkgaGVscCBhIHNlcnZpY2UgaW1wbGVtZW50b3IgaW4gZGVjaWRpbmdcbiAgICAgKiBiZXR3ZWVuIEZBSUxFRF9QUkVDT05ESVRJT04sIEFCT1JURUQsIGFuZCBVTkFWQUlMQUJMRTpcbiAgICAgKiAgKGEpIFVzZSBVTkFWQUlMQUJMRSBpZiB0aGUgY2xpZW50IGNhbiByZXRyeSBqdXN0IHRoZSBmYWlsaW5nIGNhbGwuXG4gICAgICogIChiKSBVc2UgQUJPUlRFRCBpZiB0aGUgY2xpZW50IHNob3VsZCByZXRyeSBhdCBhIGhpZ2hlci1sZXZlbFxuICAgICAqICAgICAgKGUuZy4sIHJlc3RhcnRpbmcgYSByZWFkLW1vZGlmeS13cml0ZSBzZXF1ZW5jZSkuXG4gICAgICogIChjKSBVc2UgRkFJTEVEX1BSRUNPTkRJVElPTiBpZiB0aGUgY2xpZW50IHNob3VsZCBub3QgcmV0cnkgdW50aWxcbiAgICAgKiAgICAgIHRoZSBzeXN0ZW0gc3RhdGUgaGFzIGJlZW4gZXhwbGljaXRseSBmaXhlZC4gRS5nLiwgaWYgYW4gXCJybWRpclwiXG4gICAgICogICAgICBmYWlscyBiZWNhdXNlIHRoZSBkaXJlY3RvcnkgaXMgbm9uLWVtcHR5LCBGQUlMRURfUFJFQ09ORElUSU9OXG4gICAgICogICAgICBzaG91bGQgYmUgcmV0dXJuZWQgc2luY2UgdGhlIGNsaWVudCBzaG91bGQgbm90IHJldHJ5IHVubGVzc1xuICAgICAqICAgICAgdGhleSBoYXZlIGZpcnN0IGZpeGVkIHVwIHRoZSBkaXJlY3RvcnkgYnkgZGVsZXRpbmcgZmlsZXMgZnJvbSBpdC5cbiAgICAgKiAgKGQpIFVzZSBGQUlMRURfUFJFQ09ORElUSU9OIGlmIHRoZSBjbGllbnQgcGVyZm9ybXMgY29uZGl0aW9uYWxcbiAgICAgKiAgICAgIFJFU1QgR2V0L1VwZGF0ZS9EZWxldGUgb24gYSByZXNvdXJjZSBhbmQgdGhlIHJlc291cmNlIG9uIHRoZVxuICAgICAqICAgICAgc2VydmVyIGRvZXMgbm90IG1hdGNoIHRoZSBjb25kaXRpb24uIEUuZy4sIGNvbmZsaWN0aW5nXG4gICAgICogICAgICByZWFkLW1vZGlmeS13cml0ZSBvbiB0aGUgc2FtZSByZXNvdXJjZS5cbiAgICAgKi9cbiAgICBGQUlMRURfUFJFQ09ORElUSU9OOiAnZmFpbGVkLXByZWNvbmRpdGlvbicsXG4gICAgLyoqXG4gICAgICogVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZCwgdHlwaWNhbGx5IGR1ZSB0byBhIGNvbmN1cnJlbmN5IGlzc3VlIGxpa2VcbiAgICAgKiBzZXF1ZW5jZXIgY2hlY2sgZmFpbHVyZXMsIHRyYW5zYWN0aW9uIGFib3J0cywgZXRjLlxuICAgICAqXG4gICAgICogU2VlIGxpdG11cyB0ZXN0IGFib3ZlIGZvciBkZWNpZGluZyBiZXR3ZWVuIEZBSUxFRF9QUkVDT05ESVRJT04sIEFCT1JURUQsXG4gICAgICogYW5kIFVOQVZBSUxBQkxFLlxuICAgICAqL1xuICAgIEFCT1JURUQ6ICdhYm9ydGVkJyxcbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb24gd2FzIGF0dGVtcHRlZCBwYXN0IHRoZSB2YWxpZCByYW5nZS4gRS5nLiwgc2Vla2luZyBvciByZWFkaW5nXG4gICAgICogcGFzdCBlbmQgb2YgZmlsZS5cbiAgICAgKlxuICAgICAqIFVubGlrZSBJTlZBTElEX0FSR1VNRU5ULCB0aGlzIGVycm9yIGluZGljYXRlcyBhIHByb2JsZW0gdGhhdCBtYXkgYmUgZml4ZWRcbiAgICAgKiBpZiB0aGUgc3lzdGVtIHN0YXRlIGNoYW5nZXMuIEZvciBleGFtcGxlLCBhIDMyLWJpdCBmaWxlIHN5c3RlbSB3aWxsXG4gICAgICogZ2VuZXJhdGUgSU5WQUxJRF9BUkdVTUVOVCBpZiBhc2tlZCB0byByZWFkIGF0IGFuIG9mZnNldCB0aGF0IGlzIG5vdCBpbiB0aGVcbiAgICAgKiByYW5nZSBbMCwyXjMyLTFdLCBidXQgaXQgd2lsbCBnZW5lcmF0ZSBPVVRfT0ZfUkFOR0UgaWYgYXNrZWQgdG8gcmVhZCBmcm9tXG4gICAgICogYW4gb2Zmc2V0IHBhc3QgdGhlIGN1cnJlbnQgZmlsZSBzaXplLlxuICAgICAqXG4gICAgICogVGhlcmUgaXMgYSBmYWlyIGJpdCBvZiBvdmVybGFwIGJldHdlZW4gRkFJTEVEX1BSRUNPTkRJVElPTiBhbmRcbiAgICAgKiBPVVRfT0ZfUkFOR0UuIFdlIHJlY29tbWVuZCB1c2luZyBPVVRfT0ZfUkFOR0UgKHRoZSBtb3JlIHNwZWNpZmljIGVycm9yKVxuICAgICAqIHdoZW4gaXQgYXBwbGllcyBzbyB0aGF0IGNhbGxlcnMgd2hvIGFyZSBpdGVyYXRpbmcgdGhyb3VnaCBhIHNwYWNlIGNhblxuICAgICAqIGVhc2lseSBsb29rIGZvciBhbiBPVVRfT0ZfUkFOR0UgZXJyb3IgdG8gZGV0ZWN0IHdoZW4gdGhleSBhcmUgZG9uZS5cbiAgICAgKi9cbiAgICBPVVRfT0ZfUkFOR0U6ICdvdXQtb2YtcmFuZ2UnLFxuICAgIC8qKiBPcGVyYXRpb24gaXMgbm90IGltcGxlbWVudGVkIG9yIG5vdCBzdXBwb3J0ZWQvZW5hYmxlZCBpbiB0aGlzIHNlcnZpY2UuICovXG4gICAgVU5JTVBMRU1FTlRFRDogJ3VuaW1wbGVtZW50ZWQnLFxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGVycm9ycy4gTWVhbnMgc29tZSBpbnZhcmlhbnRzIGV4cGVjdGVkIGJ5IHVuZGVybHlpbmcgU3lzdGVtIGhhc1xuICAgICAqIGJlZW4gYnJva2VuLiBJZiB5b3Ugc2VlIG9uZSBvZiB0aGVzZSBlcnJvcnMsIFNvbWV0aGluZyBpcyB2ZXJ5IGJyb2tlbi5cbiAgICAgKi9cbiAgICBJTlRFUk5BTDogJ2ludGVybmFsJyxcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmljZSBpcyBjdXJyZW50bHkgdW5hdmFpbGFibGUuIFRoaXMgaXMgYSBtb3N0IGxpa2VseSBhIHRyYW5zaWVudFxuICAgICAqIGNvbmRpdGlvbiBhbmQgbWF5IGJlIGNvcnJlY3RlZCBieSByZXRyeWluZyB3aXRoIGEgYmFja29mZi5cbiAgICAgKlxuICAgICAqIFNlZSBsaXRtdXMgdGVzdCBhYm92ZSBmb3IgZGVjaWRpbmcgYmV0d2VlbiBGQUlMRURfUFJFQ09ORElUSU9OLCBBQk9SVEVELFxuICAgICAqIGFuZCBVTkFWQUlMQUJMRS5cbiAgICAgKi9cbiAgICBVTkFWQUlMQUJMRTogJ3VuYXZhaWxhYmxlJyxcbiAgICAvKiogVW5yZWNvdmVyYWJsZSBkYXRhIGxvc3Mgb3IgY29ycnVwdGlvbi4gKi9cbiAgICBEQVRBX0xPU1M6ICdkYXRhLWxvc3MnXG59O1xuLyoqIEFuIGVycm9yIHJldHVybmVkIGJ5IGEgRmlyZXN0b3JlIG9wZXJhdGlvbi4gKi9cbmNsYXNzIEZpcmVzdG9yZUVycm9yIGV4dGVuZHMgRmlyZWJhc2VFcnJvciB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgYmFja2VuZCBlcnJvciBjb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGVycm9yLlxuICAgICAqL1xuICAgIGNvZGUsIFxuICAgIC8qKlxuICAgICAqIEEgY3VzdG9tIGVycm9yIGRlc2NyaXB0aW9uLlxuICAgICAqL1xuICAgIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoY29kZSwgbWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIC8vIEhBQ0s6IFdlIHdyaXRlIGEgdG9TdHJpbmcgcHJvcGVydHkgZGlyZWN0bHkgYmVjYXVzZSBFcnJvciBpcyBub3QgYSByZWFsXG4gICAgICAgIC8vIGNsYXNzIGFuZCBzbyBpbmhlcml0YW5jZSBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseS4gV2UgY291bGQgYWx0ZXJuYXRpdmVseVxuICAgICAgICAvLyBkbyB0aGUgc2FtZSBcImJhY2stZG9vciBpbmhlcml0YW5jZVwiIHRyaWNrIHRoYXQgRmlyZWJhc2VFcnJvciBkb2VzLlxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4gYCR7dGhpcy5uYW1lfTogW2NvZGU9JHt0aGlzLmNvZGV9XTogJHt0aGlzLm1lc3NhZ2V9YDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBEZWZlcnJlZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgT0F1dGhUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHVzZXIpIHtcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcbiAgICAgICAgdGhpcy50eXBlID0gJ09BdXRoJztcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgYEJlYXJlciAke3ZhbHVlfWApO1xuICAgIH1cbn1cbi8qKlxuICogQSBDcmVkZW50aWFsc1Byb3ZpZGVyIHRoYXQgYWx3YXlzIHlpZWxkcyBhbiBlbXB0eSB0b2tlbi5cbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBFbXB0eUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIHtcbiAgICBnZXRUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZVRva2VuKCkgeyB9XG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgLy8gRmlyZSB3aXRoIGluaXRpYWwgdXNlci5cbiAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IGNoYW5nZUxpc3RlbmVyKFVzZXIuVU5BVVRIRU5USUNBVEVEKSk7XG4gICAgfVxuICAgIHNodXRkb3duKCkgeyB9XG59XG4vKipcbiAqIEEgQ3JlZGVudGlhbHNQcm92aWRlciB0aGF0IGFsd2F5cyByZXR1cm5zIGEgY29uc3RhbnQgdG9rZW4uIFVzZWQgZm9yXG4gKiBlbXVsYXRvciB0b2tlbiBtb2NraW5nLlxuICovXG5jbGFzcyBFbXVsYXRvckF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbikge1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgdGhlIGxpc3RlbmVyIHJlZ2lzdGVyZWQgd2l0aCBzZXRDaGFuZ2VMaXN0ZW5lcigpXG4gICAgICAgICAqIFRoaXMgaXNuJ3QgYWN0dWFsbHkgbmVjZXNzYXJ5IHNpbmNlIHRoZSBVSUQgbmV2ZXIgY2hhbmdlcywgYnV0IHdlIHVzZSB0aGlzXG4gICAgICAgICAqIHRvIHZlcmlmeSB0aGUgbGlzdGVuIGNvbnRyYWN0IGlzIGFkaGVyZWQgdG8gaW4gdGVzdHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5nZUxpc3RlbmVyID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0VG9rZW4oKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy50b2tlbik7XG4gICAgfVxuICAgIGludmFsaWRhdGVUb2tlbigpIHsgfVxuICAgIHN0YXJ0KGFzeW5jUXVldWUsIGNoYW5nZUxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIgPSBjaGFuZ2VMaXN0ZW5lcjtcbiAgICAgICAgLy8gRmlyZSB3aXRoIGluaXRpYWwgdXNlci5cbiAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IGNoYW5nZUxpc3RlbmVyKHRoaXMudG9rZW4udXNlcikpO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IG51bGw7XG4gICAgfVxufVxuY2xhc3MgRmlyZWJhc2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoYXV0aFByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyID0gYXV0aFByb3ZpZGVyO1xuICAgICAgICAvKiogVHJhY2tzIHRoZSBjdXJyZW50IFVzZXIuICovXG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSBVc2VyLlVOQVVUSEVOVElDQVRFRDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50ZXIgdXNlZCB0byBkZXRlY3QgaWYgdGhlIHRva2VuIGNoYW5nZWQgd2hpbGUgYSBnZXRUb2tlbiByZXF1ZXN0IHdhc1xuICAgICAgICAgKiBvdXRzdGFuZGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG9rZW5Db3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdXRoID0gbnVsbDtcbiAgICB9XG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgaGFyZEFzc2VydCh0aGlzLnRva2VuTGlzdGVuZXIgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGxldCBsYXN0VG9rZW5JZCA9IHRoaXMudG9rZW5Db3VudGVyO1xuICAgICAgICAvLyBBIGNoYW5nZSBsaXN0ZW5lciB0aGF0IHByZXZlbnRzIGRvdWJsZS1maXJpbmcgZm9yIHRoZSBzYW1lIHRva2VuIGNoYW5nZS5cbiAgICAgICAgY29uc3QgZ3VhcmRlZENoYW5nZUxpc3RlbmVyID0gdXNlciA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbkNvdW50ZXIgIT09IGxhc3RUb2tlbklkKSB7XG4gICAgICAgICAgICAgICAgbGFzdFRva2VuSWQgPSB0aGlzLnRva2VuQ291bnRlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlTGlzdGVuZXIodXNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIEEgcHJvbWlzZSB0aGF0IGNhbiBiZSB3YWl0ZWQgb24gdG8gYmxvY2sgb24gdGhlIG5leHQgdG9rZW4gY2hhbmdlLlxuICAgICAgICAvLyBUaGlzIHByb21pc2UgaXMgcmUtY3JlYXRlZCBhZnRlciBlYWNoIGNoYW5nZS5cbiAgICAgICAgbGV0IG5leHRUb2tlbiA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnRva2VuTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRva2VuQ291bnRlcisrO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VXNlciA9IHRoaXMuZ2V0VXNlcigpO1xuICAgICAgICAgICAgbmV4dFRva2VuLnJlc29sdmUoKTtcbiAgICAgICAgICAgIG5leHRUb2tlbiA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IGd1YXJkZWRDaGFuZ2VMaXN0ZW5lcih0aGlzLmN1cnJlbnRVc2VyKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGF3YWl0TmV4dFRva2VuID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRva2VuQXR0ZW1wdCA9IG5leHRUb2tlbjtcbiAgICAgICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY3VycmVudFRva2VuQXR0ZW1wdC5wcm9taXNlO1xuICAgICAgICAgICAgICAgIGF3YWl0IGd1YXJkZWRDaGFuZ2VMaXN0ZW5lcih0aGlzLmN1cnJlbnRVc2VyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWdpc3RlckF1dGggPSAoYXV0aCkgPT4ge1xuICAgICAgICAgICAgbG9nRGVidWcoJ0ZpcmViYXNlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXInLCAnQXV0aCBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGguYWRkQXV0aFRva2VuTGlzdGVuZXIodGhpcy50b2tlbkxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICBhd2FpdE5leHRUb2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmF1dGhQcm92aWRlci5vbkluaXQoYXV0aCA9PiByZWdpc3RlckF1dGgoYXV0aCkpO1xuICAgICAgICAvLyBPdXIgdXNlcnMgY2FuIGluaXRpYWxpemUgQXV0aCByaWdodCBhZnRlciBGaXJlc3RvcmUsIHNvIHdlIGdpdmUgaXRcbiAgICAgICAgLy8gYSBjaGFuY2UgdG8gcmVnaXN0ZXIgaXRzZWxmIHdpdGggdGhlIGNvbXBvbmVudCBmcmFtZXdvcmsgYmVmb3JlIHdlXG4gICAgICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRvIHN0YXJ0IHVwIGluIHVuYXV0aGVudGljYXRlZCBtb2RlLlxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hdXRoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXV0aCA9IHRoaXMuYXV0aFByb3ZpZGVyLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGlmIChhdXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyQXV0aChhdXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGF1dGggaXMgc3RpbGwgbm90IGF2YWlsYWJsZSwgcHJvY2VlZCB3aXRoIGBudWxsYCB1c2VyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdGaXJlYmFzZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyJywgJ0F1dGggbm90IHlldCBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW4ucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW4gPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgICBhd2FpdE5leHRUb2tlbigpO1xuICAgIH1cbiAgICBnZXRUb2tlbigpIHtcbiAgICAgICAgLy8gVGFrZSBub3RlIG9mIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSB0b2tlbkNvdW50ZXIgc28gdGhhdCB0aGlzIG1ldGhvZFxuICAgICAgICAvLyBjYW4gZmFpbCAod2l0aCBhbiBBQk9SVEVEIGVycm9yKSBpZiB0aGVyZSBpcyBhIHRva2VuIGNoYW5nZSB3aGlsZSB0aGVcbiAgICAgICAgLy8gcmVxdWVzdCBpcyBvdXRzdGFuZGluZy5cbiAgICAgICAgY29uc3QgaW5pdGlhbFRva2VuQ291bnRlciA9IHRoaXMudG9rZW5Db3VudGVyO1xuICAgICAgICBjb25zdCBmb3JjZVJlZnJlc2ggPSB0aGlzLmZvcmNlUmVmcmVzaDtcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmF1dGgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aC5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLnRoZW4odG9rZW5EYXRhID0+IHtcbiAgICAgICAgICAgIC8vIENhbmNlbCB0aGUgcmVxdWVzdCBzaW5jZSB0aGUgdG9rZW4gY2hhbmdlZCB3aGlsZSB0aGUgcmVxdWVzdCB3YXNcbiAgICAgICAgICAgIC8vIG91dHN0YW5kaW5nIHNvIHRoZSByZXNwb25zZSBpcyBwb3RlbnRpYWxseSBmb3IgYSBwcmV2aW91cyB1c2VyICh3aGljaFxuICAgICAgICAgICAgLy8gdXNlciwgd2UgY2FuJ3QgYmUgc3VyZSkuXG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbkNvdW50ZXIgIT09IGluaXRpYWxUb2tlbkNvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlcicsICdnZXRUb2tlbiBhYm9ydGVkIGR1ZSB0byB0b2tlbiBjaGFuZ2UuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFyZEFzc2VydCh0eXBlb2YgdG9rZW5EYXRhLmFjY2Vzc1Rva2VuID09PSAnc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT0F1dGhUb2tlbih0b2tlbkRhdGEuYWNjZXNzVG9rZW4sIHRoaXMuY3VycmVudFVzZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZVRva2VuKCkge1xuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaCA9IHRydWU7XG4gICAgfVxuICAgIHNodXRkb3duKCkge1xuICAgICAgICBpZiAodGhpcy5hdXRoICYmIHRoaXMudG9rZW5MaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5hdXRoLnJlbW92ZUF1dGhUb2tlbkxpc3RlbmVyKHRoaXMudG9rZW5MaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2tlbkxpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBBdXRoLmdldFVpZCgpIGNhbiByZXR1cm4gbnVsbCBldmVuIHdpdGggYSB1c2VyIGxvZ2dlZCBpbi4gSXQgaXMgYmVjYXVzZVxuICAgIC8vIGdldFVpZCgpIGlzIHN5bmNocm9ub3VzLCBidXQgdGhlIGF1dGggY29kZSBwb3B1bGF0aW5nIFVpZCBpcyBhc3luY2hyb25vdXMuXG4gICAgLy8gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGluIHRoZSBBdXRoVG9rZW5MaXN0ZW5lciBjYWxsYmFja1xuICAgIC8vIHRvIGd1YXJhbnRlZSB0byBnZXQgdGhlIGFjdHVhbCB1c2VyLlxuICAgIGdldFVzZXIoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRVaWQgPSB0aGlzLmF1dGggJiYgdGhpcy5hdXRoLmdldFVpZCgpO1xuICAgICAgICBoYXJkQXNzZXJ0KGN1cnJlbnRVaWQgPT09IG51bGwgfHwgdHlwZW9mIGN1cnJlbnRVaWQgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVc2VyKGN1cnJlbnRVaWQpO1xuICAgIH1cbn1cbi8qXG4gKiBGaXJzdFBhcnR5VG9rZW4gcHJvdmlkZXMgYSBmcmVzaCB0b2tlbiBlYWNoIHRpbWUgaXRzIHZhbHVlXG4gKiBpcyByZXF1ZXN0ZWQsIGJlY2F1c2UgaWYgdGhlIHRva2VuIGlzIHRvbyBvbGQsIHJlcXVlc3RzIHdpbGwgYmUgcmVqZWN0ZWQuXG4gKiBUZWNobmljYWxseSB0aGlzIG1heSBubyBsb25nZXIgYmUgbmVjZXNzYXJ5IHNpbmNlIHRoZSBTREsgc2hvdWxkIGdyYWNlZnVsbHlcbiAqIHJlY292ZXIgZnJvbSB1bmF1dGhlbnRpY2F0ZWQgZXJyb3JzIChzZWUgYi8zMzE0NzgxOCBmb3IgY29udGV4dCksIGJ1dCBpdCdzXG4gKiBzYWZlciB0byBrZWVwIHRoZSBpbXBsZW1lbnRhdGlvbiBhcy1pcy5cbiAqL1xuY2xhc3MgRmlyc3RQYXJ0eVRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcihzZXNzaW9uSW5kZXgsIGlhbVRva2VuLCBhdXRoVG9rZW5GYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbkluZGV4ID0gc2Vzc2lvbkluZGV4O1xuICAgICAgICB0aGlzLmlhbVRva2VuID0gaWFtVG9rZW47XG4gICAgICAgIHRoaXMuYXV0aFRva2VuRmFjdG9yeSA9IGF1dGhUb2tlbkZhY3Rvcnk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdGaXJzdFBhcnR5JztcbiAgICAgICAgdGhpcy51c2VyID0gVXNlci5GSVJTVF9QQVJUWTtcbiAgICAgICAgdGhpcy5faGVhZGVycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBhdXRob3JpemF0aW9uIHRva2VuLCB1c2luZyBhIHByb3ZpZGVkIGZhY3RvcnkgZnVuY3Rpb24sIG9yIHJldHVyblxuICAgICAqIG51bGwuXG4gICAgICovXG4gICAgZ2V0QXV0aFRva2VuKCkge1xuICAgICAgICBpZiAodGhpcy5hdXRoVG9rZW5GYWN0b3J5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRoVG9rZW5GYWN0b3J5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgdGhpcy5faGVhZGVycy5zZXQoJ1gtR29vZy1BdXRoVXNlcicsIHRoaXMuc2Vzc2lvbkluZGV4KTtcbiAgICAgICAgLy8gVXNlIGFycmF5IG5vdGF0aW9uIHRvIHByZXZlbnQgbWluaWZpY2F0aW9uXG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXJUb2tlblZhbHVlID0gdGhpcy5nZXRBdXRoVG9rZW4oKTtcbiAgICAgICAgaWYgKGF1dGhIZWFkZXJUb2tlblZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGF1dGhIZWFkZXJUb2tlblZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pYW1Ub2tlbikge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVycy5zZXQoJ1gtR29vZy1JYW0tQXV0aG9yaXphdGlvbi1Ub2tlbicsIHRoaXMuaWFtVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJzO1xuICAgIH1cbn1cbi8qXG4gKiBQcm92aWRlcyB1c2VyIGNyZWRlbnRpYWxzIHJlcXVpcmVkIGZvciB0aGUgRmlyZXN0b3JlIEphdmFTY3JpcHQgU0RLXG4gKiB0byBhdXRoZW50aWNhdGUgdGhlIHVzZXIsIHVzaW5nIHRlY2huaXF1ZSB0aGF0IGlzIG9ubHkgYXZhaWxhYmxlXG4gKiB0byBhcHBsaWNhdGlvbnMgaG9zdGVkIGJ5IEdvb2dsZS5cbiAqL1xuY2xhc3MgRmlyc3RQYXJ0eUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXNzaW9uSW5kZXgsIGlhbVRva2VuLCBhdXRoVG9rZW5GYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbkluZGV4ID0gc2Vzc2lvbkluZGV4O1xuICAgICAgICB0aGlzLmlhbVRva2VuID0gaWFtVG9rZW47XG4gICAgICAgIHRoaXMuYXV0aFRva2VuRmFjdG9yeSA9IGF1dGhUb2tlbkZhY3Rvcnk7XG4gICAgfVxuICAgIGdldFRva2VuKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBGaXJzdFBhcnR5VG9rZW4odGhpcy5zZXNzaW9uSW5kZXgsIHRoaXMuaWFtVG9rZW4sIHRoaXMuYXV0aFRva2VuRmFjdG9yeSkpO1xuICAgIH1cbiAgICBzdGFydChhc3luY1F1ZXVlLCBjaGFuZ2VMaXN0ZW5lcikge1xuICAgICAgICAvLyBGaXJlIHdpdGggaW5pdGlhbCB1aWQuXG4gICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiBjaGFuZ2VMaXN0ZW5lcihVc2VyLkZJUlNUX1BBUlRZKSk7XG4gICAgfVxuICAgIHNodXRkb3duKCkgeyB9XG4gICAgaW52YWxpZGF0ZVRva2VuKCkgeyB9XG59XG5jbGFzcyBBcHBDaGVja1Rva2VuIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudHlwZSA9ICdBcHBDaGVjayc7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ3gtZmlyZWJhc2UtYXBwY2hlY2snLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEZpcmViYXNlQXBwQ2hlY2tUb2tlblByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIGFwcENoZWNrUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5hcHBDaGVja1Byb3ZpZGVyID0gYXBwQ2hlY2tQcm92aWRlcjtcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hcHBDaGVjayA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0QXBwQ2hlY2tUb2tlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VydmVyQXBwQXBwQ2hlY2tUb2tlbiA9IG51bGw7XG4gICAgICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhcHApICYmIGFwcC5zZXR0aW5ncy5hcHBDaGVja1Rva2VuKSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZlckFwcEFwcENoZWNrVG9rZW4gPSBhcHAuc2V0dGluZ3MuYXBwQ2hlY2tUb2tlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydChhc3luY1F1ZXVlLCBjaGFuZ2VMaXN0ZW5lcikge1xuICAgICAgICBoYXJkQXNzZXJ0KHRoaXMudG9rZW5MaXN0ZW5lciA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3Qgb25Ub2tlbkNoYW5nZWQgPSB0b2tlblJlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAodG9rZW5SZXN1bHQuZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdGaXJlYmFzZUFwcENoZWNrVG9rZW5Qcm92aWRlcicsIGBFcnJvciBnZXR0aW5nIEFwcCBDaGVjayB0b2tlbjsgdXNpbmcgcGxhY2Vob2xkZXIgdG9rZW4gaW5zdGVhZC4gRXJyb3I6ICR7dG9rZW5SZXN1bHQuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRva2VuVXBkYXRlZCA9IHRva2VuUmVzdWx0LnRva2VuICE9PSB0aGlzLmxhdGVzdEFwcENoZWNrVG9rZW47XG4gICAgICAgICAgICB0aGlzLmxhdGVzdEFwcENoZWNrVG9rZW4gPSB0b2tlblJlc3VsdC50b2tlbjtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdGaXJlYmFzZUFwcENoZWNrVG9rZW5Qcm92aWRlcicsIGBSZWNlaXZlZCAke3Rva2VuVXBkYXRlZCA/ICduZXcnIDogJ2V4aXN0aW5nJ30gdG9rZW4uYCk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5VcGRhdGVkXG4gICAgICAgICAgICAgICAgPyBjaGFuZ2VMaXN0ZW5lcih0b2tlblJlc3VsdC50b2tlbilcbiAgICAgICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRva2VuTGlzdGVuZXIgPSAodG9rZW5SZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiBvblRva2VuQ2hhbmdlZCh0b2tlblJlc3VsdCkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWdpc3RlckFwcENoZWNrID0gKGFwcENoZWNrKSA9PiB7XG4gICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBcHBDaGVja1Rva2VuUHJvdmlkZXInLCAnQXBwQ2hlY2sgZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2sgPSBhcHBDaGVjaztcbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcENoZWNrLmFkZFRva2VuTGlzdGVuZXIodGhpcy50b2tlbkxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcHBDaGVja1Byb3ZpZGVyLm9uSW5pdChhcHBDaGVjayA9PiByZWdpc3RlckFwcENoZWNrKGFwcENoZWNrKSk7XG4gICAgICAgIC8vIE91ciB1c2VycyBjYW4gaW5pdGlhbGl6ZSBBcHBDaGVjayBhZnRlciBGaXJlc3RvcmUsIHNvIHdlIGdpdmUgaXRcbiAgICAgICAgLy8gYSBjaGFuY2UgdG8gcmVnaXN0ZXIgaXRzZWxmIHdpdGggdGhlIGNvbXBvbmVudCBmcmFtZXdvcmsuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFwcENoZWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwQ2hlY2sgPSB0aGlzLmFwcENoZWNrUHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGFwcENoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyQXBwQ2hlY2soYXBwQ2hlY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgQXBwQ2hlY2sgaXMgc3RpbGwgbm90IGF2YWlsYWJsZSwgcHJvY2VlZCB3aXRob3V0IGl0LlxuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnRmlyZWJhc2VBcHBDaGVja1Rva2VuUHJvdmlkZXInLCAnQXBwQ2hlY2sgbm90IHlldCBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIGdldFRva2VuKCkge1xuICAgICAgICBpZiAodGhpcy5zZXJ2ZXJBcHBBcHBDaGVja1Rva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBBcHBDaGVja1Rva2VuKHRoaXMuc2VydmVyQXBwQXBwQ2hlY2tUb2tlbikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcmNlUmVmcmVzaCA9IHRoaXMuZm9yY2VSZWZyZXNoO1xuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuYXBwQ2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwQ2hlY2suZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKS50aGVuKHRva2VuUmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmICh0b2tlblJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIHRva2VuUmVzdWx0LnRva2VuID09PSAnc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RBcHBDaGVja1Rva2VuID0gdG9rZW5SZXN1bHQudG9rZW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcHBDaGVja1Rva2VuKHRva2VuUmVzdWx0LnRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZVRva2VuKCkge1xuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaCA9IHRydWU7XG4gICAgfVxuICAgIHNodXRkb3duKCkge1xuICAgICAgICBpZiAodGhpcy5hcHBDaGVjayAmJiB0aGlzLnRva2VuTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2sucmVtb3ZlVG9rZW5MaXN0ZW5lcih0aGlzLnRva2VuTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9rZW5MaXN0ZW5lciA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKipcbiAqIEFuIEFwcENoZWNrIHRva2VuIHByb3ZpZGVyIHRoYXQgYWx3YXlzIHlpZWxkcyBhbiBlbXB0eSB0b2tlbi5cbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBFbXB0eUFwcENoZWNrVG9rZW5Qcm92aWRlciB7XG4gICAgZ2V0VG9rZW4oKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEFwcENoZWNrVG9rZW4oJycpKTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZVRva2VuKCkgeyB9XG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHsgfVxuICAgIHNodXRkb3duKCkgeyB9XG59XG4vKipcbiAqIEJ1aWxkcyBhIENyZWRlbnRpYWxzUHJvdmlkZXIgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mXG4gKiB0aGUgY3JlZGVudGlhbHMgcGFzc2VkIGluLlxuICovXG5mdW5jdGlvbiBtYWtlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXIoY3JlZGVudGlhbHMpIHtcbiAgICBpZiAoIWNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1wdHlBdXRoQ3JlZGVudGlhbHNQcm92aWRlcigpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGNyZWRlbnRpYWxzWyd0eXBlJ10pIHtcbiAgICAgICAgY2FzZSAnZmlyc3RQYXJ0eSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpcnN0UGFydHlBdXRoQ3JlZGVudGlhbHNQcm92aWRlcihjcmVkZW50aWFsc1snc2Vzc2lvbkluZGV4J10gfHwgJzAnLCBjcmVkZW50aWFsc1snaWFtVG9rZW4nXSB8fCBudWxsLCBjcmVkZW50aWFsc1snYXV0aFRva2VuRmFjdG9yeSddIHx8IG51bGwpO1xuICAgICAgICBjYXNlICdwcm92aWRlcic6XG4gICAgICAgICAgICByZXR1cm4gY3JlZGVudGlhbHNbJ2NsaWVudCddO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ21ha2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlciBmYWlsZWQgZHVlIHRvIGludmFsaWQgY3JlZGVudGlhbCB0eXBlJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBHZW5lcmF0ZXMgYG5CeXRlc2Agb2YgcmFuZG9tIGJ5dGVzLlxuICpcbiAqIElmIGBuQnl0ZXMgPCAwYCAsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICovXG5mdW5jdGlvbiByYW5kb21CeXRlcyhuQnl0ZXMpIHtcbiAgICByZXR1cm4gcmFuZG9tQnl0ZXMkMShuQnl0ZXMpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgUGxhdGZvcm0ncyAnVGV4dEVuY29kZXInIGltcGxlbWVudGF0aW9uLlxuICovXG5mdW5jdGlvbiBuZXdUZXh0RW5jb2RlcigpIHtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCk7XG59XG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBQbGF0Zm9ybSdzICdUZXh0RGVjb2RlcicgaW1wbGVtZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIG5ld1RleHREZWNvZGVyKCkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyBmb3IgZ2VuZXJhdGluZyB1bmlxdWUgYWxwaGFudW1lcmljIElEcyBvZiBhIHNwZWNpZmllZCBsZW5ndGguXG4gKlxuICogQGludGVybmFsXG4gKiBFeHBvcnRlZCBpbnRlcm5hbGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICovXG5jbGFzcyBBdXRvSWQge1xuICAgIHN0YXRpYyBuZXdJZCgpIHtcbiAgICAgICAgLy8gQWxwaGFudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgICAgY29uc3QgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknO1xuICAgICAgICAvLyBUaGUgbGFyZ2VzdCBieXRlIHZhbHVlIHRoYXQgaXMgYSBtdWx0aXBsZSBvZiBgY2hhci5sZW5ndGhgLlxuICAgICAgICBjb25zdCBtYXhNdWx0aXBsZSA9IE1hdGguZmxvb3IoMjU2IC8gY2hhcnMubGVuZ3RoKSAqIGNoYXJzLmxlbmd0aDtcbiAgICAgICAgbGV0IGF1dG9JZCA9ICcnO1xuICAgICAgICBjb25zdCB0YXJnZXRMZW5ndGggPSAyMDtcbiAgICAgICAgd2hpbGUgKGF1dG9JZC5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gcmFuZG9tQnl0ZXMoNDApO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYWNjZXB0IHZhbHVlcyB0aGF0IGFyZSBbMCwgbWF4TXVsdGlwbGUpLCB0aGlzIGVuc3VyZXMgdGhleSBjYW5cbiAgICAgICAgICAgICAgICAvLyBiZSBldmVubHkgbWFwcGVkIHRvIGluZGljZXMgb2YgYGNoYXJzYCB2aWEgYSBtb2R1bG8gb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChhdXRvSWQubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoICYmIGJ5dGVzW2ldIDwgbWF4TXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0b0lkICs9IGNoYXJzLmNoYXJBdChieXRlc1tpXSAlIGNoYXJzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdXRvSWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAobGVmdCA+IHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbi8qKiBDb21wYXJlIHN0cmluZ3MgaW4gVVRGLTggZW5jb2RlZCBieXRlIG9yZGVyICovXG5mdW5jdGlvbiBjb21wYXJlVXRmOFN0cmluZ3MobGVmdCwgcmlnaHQpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBsZWZ0Lmxlbmd0aCAmJiBpIDwgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGxlZnRDb2RlUG9pbnQgPSBsZWZ0LmNvZGVQb2ludEF0KGkpO1xuICAgICAgICBjb25zdCByaWdodENvZGVQb2ludCA9IHJpZ2h0LmNvZGVQb2ludEF0KGkpO1xuICAgICAgICBpZiAobGVmdENvZGVQb2ludCAhPT0gcmlnaHRDb2RlUG9pbnQpIHtcbiAgICAgICAgICAgIGlmIChsZWZ0Q29kZVBvaW50IDwgMTI4ICYmIHJpZ2h0Q29kZVBvaW50IDwgMTI4KSB7XG4gICAgICAgICAgICAgICAgLy8gQVNDSUkgY29tcGFyaXNvblxuICAgICAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRDb2RlUG9pbnQsIHJpZ2h0Q29kZVBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExhenkgaW5zdGFudGlhdGUgVGV4dEVuY29kZXJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3VGV4dEVuY29kZXIoKTtcbiAgICAgICAgICAgICAgICAvLyBVVEYtOCBlbmNvZGUgdGhlIGNoYXJhY3RlciBhdCBpbmRleCBpIGZvciBieXRlIGNvbXBhcmlzb24uXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdEJ5dGVzID0gZW5jb2Rlci5lbmNvZGUoZ2V0VXRmOFNhZmVTdWJzdHJpbmcobGVmdCwgaSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0Qnl0ZXMgPSBlbmNvZGVyLmVuY29kZShnZXRVdGY4U2FmZVN1YnN0cmluZyhyaWdodCwgaSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXAgPSBjb21wYXJlQnl0ZUFycmF5cyQxKGxlZnRCeXRlcywgcmlnaHRCeXRlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXAgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFWFRSRU1FTFkgUkFSRSBDQVNFOiBDb2RlIHBvaW50cyBkaWZmZXIsIGJ1dCB0aGVpciBVVEYtOCBieXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcHJlc2VudGF0aW9ucyBhcmUgaWRlbnRpY2FsLiBUaGlzIGNhbiBoYXBwZW4gd2l0aCBtYWxmb3JtZWQgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgLy8gKGludmFsaWQgc3Vycm9nYXRlIHBhaXJzKS4gVGhlIGJhY2tlbmQgYWxzbyBhY3RpdmVseSBwcmV2ZW50cyBpbnZhbGlkXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1cnJvZ2F0ZXMgYXMgSU5WQUxJRF9BUkdVTUVOVCBlcnJvcnMsIHNvIHdlIGFsbW9zdCBuZXZlciByZWNlaXZlXG4gICAgICAgICAgICAgICAgICAgIC8vIGludmFsaWQgc3RyaW5ncyBmcm9tIGJhY2tlbmQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvZGUgcG9pbnQgY29tcGFyaXNvbiBmb3IgZ3JhY2VmdWwgaGFuZGxpbmcuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRDb2RlUG9pbnQsIHJpZ2h0Q29kZVBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5jcmVtZW50IGJ5IDIgZm9yIHN1cnJvZ2F0ZSBwYWlycywgMSBvdGhlcndpc2VcbiAgICAgICAgaSArPSBsZWZ0Q29kZVBvaW50ID4gMHhmZmZmID8gMiA6IDE7XG4gICAgfVxuICAgIC8vIENvbXBhcmUgbGVuZ3RocyBpZiBhbGwgY2hhcmFjdGVycyBhcmUgZXF1YWxcbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0Lmxlbmd0aCwgcmlnaHQubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGdldFV0ZjhTYWZlU3Vic3RyaW5nKHN0ciwgaW5kZXgpIHtcbiAgICBjb25zdCBmaXJzdENvZGVQb2ludCA9IHN0ci5jb2RlUG9pbnRBdChpbmRleCk7XG4gICAgaWYgKGZpcnN0Q29kZVBvaW50ID4gMHhmZmZmKSB7XG4gICAgICAgIC8vIEl0J3MgYSBzdXJyb2dhdGUgcGFpciwgcmV0dXJuIHRoZSB3aG9sZSBwYWlyXG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKGluZGV4LCBpbmRleCArIDIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSXQncyBhIHNpbmdsZSBjb2RlIHBvaW50LCByZXR1cm4gaXRcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoaW5kZXgsIGluZGV4ICsgMSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZUJ5dGVBcnJheXMkMShsZWZ0LCByaWdodCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5sZW5ndGggJiYgaSA8IHJpZ2h0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChsZWZ0W2ldICE9PSByaWdodFtpXSkge1xuICAgICAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFtpXSwgcmlnaHRbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQubGVuZ3RoLCByaWdodC5sZW5ndGgpO1xufVxuLyoqIEhlbHBlciB0byBjb21wYXJlIGFycmF5cyB1c2luZyBpc0VxdWFsKCkuICovXG5mdW5jdGlvbiBhcnJheUVxdWFscyhsZWZ0LCByaWdodCwgY29tcGFyYXRvcikge1xuICAgIGlmIChsZWZ0Lmxlbmd0aCAhPT0gcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQuZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gY29tcGFyYXRvcih2YWx1ZSwgcmlnaHRbaW5kZXhdKSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGltbWVkaWF0ZSBsZXhpY29ncmFwaGljYWxseS1mb2xsb3dpbmcgc3RyaW5nLiBUaGlzIGlzIHVzZWZ1bCB0b1xuICogY29uc3RydWN0IGFuIGluY2x1c2l2ZSByYW5nZSBmb3IgaW5kZXhlZGRiIGl0ZXJhdG9ycy5cbiAqL1xuZnVuY3Rpb24gaW1tZWRpYXRlU3VjY2Vzc29yKHMpIHtcbiAgICAvLyBSZXR1cm4gdGhlIGlucHV0IHN0cmluZywgd2l0aCBhbiBhZGRpdGlvbmFsIE5VTCBieXRlIGFwcGVuZGVkLlxuICAgIHJldHVybiBzICsgJ1xcMCc7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBUaGUgZWFybGllc3QgZGF0ZSBzdXBwb3J0ZWQgYnkgRmlyZXN0b3JlIHRpbWVzdGFtcHMgKDAwMDEtMDEtMDFUMDA6MDA6MDBaKS5cbmNvbnN0IE1JTl9TRUNPTkRTID0gLTYyMTM1NTk2ODAwO1xuLy8gTnVtYmVyIG9mIG5hbm9zZWNvbmRzIGluIGEgbWlsbGlzZWNvbmQuXG5jb25zdCBNU19UT19OQU5PUyA9IDFlNjtcbi8qKlxuICogQSBgVGltZXN0YW1wYCByZXByZXNlbnRzIGEgcG9pbnQgaW4gdGltZSBpbmRlcGVuZGVudCBvZiBhbnkgdGltZSB6b25lIG9yXG4gKiBjYWxlbmRhciwgcmVwcmVzZW50ZWQgYXMgc2Vjb25kcyBhbmQgZnJhY3Rpb25zIG9mIHNlY29uZHMgYXQgbmFub3NlY29uZFxuICogcmVzb2x1dGlvbiBpbiBVVEMgRXBvY2ggdGltZS5cbiAqXG4gKiBJdCBpcyBlbmNvZGVkIHVzaW5nIHRoZSBQcm9sZXB0aWMgR3JlZ29yaWFuIENhbGVuZGFyIHdoaWNoIGV4dGVuZHMgdGhlXG4gKiBHcmVnb3JpYW4gY2FsZW5kYXIgYmFja3dhcmRzIHRvIHllYXIgb25lLiBJdCBpcyBlbmNvZGVkIGFzc3VtaW5nIGFsbCBtaW51dGVzXG4gKiBhcmUgNjAgc2Vjb25kcyBsb25nLCBpLmUuIGxlYXAgc2Vjb25kcyBhcmUgXCJzbWVhcmVkXCIgc28gdGhhdCBubyBsZWFwIHNlY29uZFxuICogdGFibGUgaXMgbmVlZGVkIGZvciBpbnRlcnByZXRhdGlvbi4gUmFuZ2UgaXMgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0b1xuICogOTk5OS0xMi0zMVQyMzo1OTo1OS45OTk5OTk5OTlaLlxuICpcbiAqIEZvciBleGFtcGxlcyBhbmQgZnVydGhlciBzcGVjaWZpY2F0aW9ucywgcmVmZXIgdG8gdGhlXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9wcm90b2J1Zi9ibG9iL21hc3Rlci9zcmMvZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcC5wcm90byB8IFRpbWVzdGFtcCBkZWZpbml0aW9ufS5cbiAqL1xuY2xhc3MgVGltZXN0YW1wIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRpbWVzdGFtcCB3aXRoIHRoZSBjdXJyZW50IGRhdGUsIHdpdGggbWlsbGlzZWNvbmQgcHJlY2lzaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBuZXcgdGltZXN0YW1wIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBkYXRlLlxuICAgICAqL1xuICAgIHN0YXRpYyBub3coKSB7XG4gICAgICAgIHJldHVybiBUaW1lc3RhbXAuZnJvbU1pbGxpcyhEYXRlLm5vdygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0aW1lc3RhbXAgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gaW5pdGlhbGl6ZSB0aGUgYFRpbWVzdGFtcGAgZnJvbS5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBgVGltZXN0YW1wYCByZXByZXNlbnRpbmcgdGhlIHNhbWUgcG9pbnQgaW4gdGltZSBhcyB0aGUgZ2l2ZW5cbiAgICAgKiAgICAgZGF0ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbURhdGUoZGF0ZSkge1xuICAgICAgICByZXR1cm4gVGltZXN0YW1wLmZyb21NaWxsaXMoZGF0ZS5nZXRUaW1lKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRpbWVzdGFtcCBmcm9tIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1pbGxpc2Vjb25kcyAtIE51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgVW5peCBlcG9jaFxuICAgICAqICAgICAxOTcwLTAxLTAxVDAwOjAwOjAwWi5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBgVGltZXN0YW1wYCByZXByZXNlbnRpbmcgdGhlIHNhbWUgcG9pbnQgaW4gdGltZSBhcyB0aGUgZ2l2ZW5cbiAgICAgKiAgICAgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU1pbGxpcyhtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgY29uc3Qgc2Vjb25kcyA9IE1hdGguZmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGNvbnN0IG5hbm9zID0gTWF0aC5mbG9vcigobWlsbGlzZWNvbmRzIC0gc2Vjb25kcyAqIDEwMDApICogTVNfVE9fTkFOT1MpO1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChzZWNvbmRzLCBuYW5vcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGltZXN0YW1wLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlY29uZHMgLSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgb2YgVVRDIHRpbWUgc2luY2UgVW5peCBlcG9jaFxuICAgICAqICAgICAxOTcwLTAxLTAxVDAwOjAwOjAwWi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvXG4gICAgICogICAgIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZS5cbiAgICAgKiBAcGFyYW0gbmFub3NlY29uZHMgLSBUaGUgbm9uLW5lZ2F0aXZlIGZyYWN0aW9ucyBvZiBhIHNlY29uZCBhdCBuYW5vc2Vjb25kXG4gICAgICogICAgIHJlc29sdXRpb24uIE5lZ2F0aXZlIHNlY29uZCB2YWx1ZXMgd2l0aCBmcmFjdGlvbnMgbXVzdCBzdGlsbCBoYXZlXG4gICAgICogICAgIG5vbi1uZWdhdGl2ZSBuYW5vc2Vjb25kcyB2YWx1ZXMgdGhhdCBjb3VudCBmb3J3YXJkIGluIHRpbWUuIE11c3QgYmVcbiAgICAgKiAgICAgZnJvbSAwIHRvIDk5OSw5OTksOTk5IGluY2x1c2l2ZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHNlY29uZHMgb2YgVVRDIHRpbWUgc2luY2UgVW5peCBlcG9jaCAxOTcwLTAxLTAxVDAwOjAwOjAwWi5cbiAgICAgKi9cbiAgICBzZWNvbmRzLCBcbiAgICAvKipcbiAgICAgKiBUaGUgZnJhY3Rpb25zIG9mIGEgc2Vjb25kIGF0IG5hbm9zZWNvbmQgcmVzb2x1dGlvbi4qXG4gICAgICovXG4gICAgbmFub3NlY29uZHMpIHtcbiAgICAgICAgdGhpcy5zZWNvbmRzID0gc2Vjb25kcztcbiAgICAgICAgdGhpcy5uYW5vc2Vjb25kcyA9IG5hbm9zZWNvbmRzO1xuICAgICAgICBpZiAobmFub3NlY29uZHMgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVGltZXN0YW1wIG5hbm9zZWNvbmRzIG91dCBvZiByYW5nZTogJyArIG5hbm9zZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFub3NlY29uZHMgPj0gMWU5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVGltZXN0YW1wIG5hbm9zZWNvbmRzIG91dCBvZiByYW5nZTogJyArIG5hbm9zZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Vjb25kcyA8IE1JTl9TRUNPTkRTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVGltZXN0YW1wIHNlY29uZHMgb3V0IG9mIHJhbmdlOiAnICsgc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyB3aWxsIGJyZWFrIGluIHRoZSB5ZWFyIDEwLDAwMC5cbiAgICAgICAgaWYgKHNlY29uZHMgPj0gMjUzNDAyMzAwODAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVGltZXN0YW1wIHNlY29uZHMgb3V0IG9mIHJhbmdlOiAnICsgc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBgVGltZXN0YW1wYCB0byBhIEphdmFTY3JpcHQgYERhdGVgIG9iamVjdC4gVGhpcyBjb252ZXJzaW9uXG4gICAgICogY2F1c2VzIGEgbG9zcyBvZiBwcmVjaXNpb24gc2luY2UgYERhdGVgIG9iamVjdHMgb25seSBzdXBwb3J0IG1pbGxpc2Vjb25kXG4gICAgICogcHJlY2lzaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgSmF2YVNjcmlwdCBgRGF0ZWAgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2FtZSBwb2ludCBpbiB0aW1lIGFzXG4gICAgICogICAgIHRoaXMgYFRpbWVzdGFtcGAsIHdpdGggbWlsbGlzZWNvbmQgcHJlY2lzaW9uLlxuICAgICAqL1xuICAgIHRvRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudG9NaWxsaXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYFRpbWVzdGFtcGAgdG8gYSBudW1lcmljIHRpbWVzdGFtcCAoaW4gbWlsbGlzZWNvbmRzIHNpbmNlXG4gICAgICogZXBvY2gpLiBUaGlzIG9wZXJhdGlvbiBjYXVzZXMgYSBsb3NzIG9mIHByZWNpc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwb2ludCBpbiB0aW1lIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyB0aW1lc3RhbXAsIHJlcHJlc2VudGVkIGFzXG4gICAgICogICAgIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIFVuaXggZXBvY2ggMTk3MC0wMS0wMVQwMDowMDowMFouXG4gICAgICovXG4gICAgdG9NaWxsaXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlY29uZHMgKiAxMDAwICsgdGhpcy5uYW5vc2Vjb25kcyAvIE1TX1RPX05BTk9TO1xuICAgIH1cbiAgICBfY29tcGFyZVRvKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnNlY29uZHMgPT09IG90aGVyLnNlY29uZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKHRoaXMubmFub3NlY29uZHMsIG90aGVyLm5hbm9zZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcih0aGlzLnNlY29uZHMsIG90aGVyLnNlY29uZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgVGltZXN0YW1wYCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG90aGVyIC0gVGhlIGBUaW1lc3RhbXBgIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYFRpbWVzdGFtcGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKi9cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAob3RoZXIuc2Vjb25kcyA9PT0gdGhpcy5zZWNvbmRzICYmIG90aGVyLm5hbm9zZWNvbmRzID09PSB0aGlzLm5hbm9zZWNvbmRzKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgYFRpbWVzdGFtcGAuICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoJ1RpbWVzdGFtcChzZWNvbmRzPScgK1xuICAgICAgICAgICAgdGhpcy5zZWNvbmRzICtcbiAgICAgICAgICAgICcsIG5hbm9zZWNvbmRzPScgK1xuICAgICAgICAgICAgdGhpcy5uYW5vc2Vjb25kcyArXG4gICAgICAgICAgICAnKScpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgYFRpbWVzdGFtcGAuICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzZWNvbmRzOiB0aGlzLnNlY29uZHMsIG5hbm9zZWNvbmRzOiB0aGlzLm5hbm9zZWNvbmRzIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgb2JqZWN0IHRvIGEgcHJpbWl0aXZlIHN0cmluZywgd2hpY2ggYWxsb3dzIGBUaW1lc3RhbXBgIG9iamVjdHNcbiAgICAgKiB0byBiZSBjb21wYXJlZCB1c2luZyB0aGUgYD5gLCBgPD1gLCBgPj1gIGFuZCBgPmAgb3BlcmF0b3JzLlxuICAgICAqL1xuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIHJldHVybnMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gPHNlY29uZHM+LjxuYW5vc2Vjb25kcz4gd2hlcmVcbiAgICAgICAgLy8gPHNlY29uZHM+IGlzIHRyYW5zbGF0ZWQgdG8gaGF2ZSBhIG5vbi1uZWdhdGl2ZSB2YWx1ZSBhbmQgYm90aCA8c2Vjb25kcz5cbiAgICAgICAgLy8gYW5kIDxuYW5vc2Vjb25kcz4gYXJlIGxlZnQtcGFkZGVkIHdpdGggemVyb2VzIHRvIGJlIGEgY29uc2lzdGVudCBsZW5ndGguXG4gICAgICAgIC8vIFN0cmluZ3Mgd2l0aCB0aGlzIGZvcm1hdCB0aGVuIGhhdmUgYSBsZXhpY29ncmFwaGljYWwgb3JkZXJpbmcgdGhhdCBtYXRjaGVzXG4gICAgICAgIC8vIHRoZSBleHBlY3RlZCBvcmRlcmluZy4gVGhlIDxzZWNvbmRzPiB0cmFuc2xhdGlvbiBpcyBkb25lIHRvIGF2b2lkIGhhdmluZ1xuICAgICAgICAvLyBhIGxlYWRpbmcgbmVnYXRpdmUgc2lnbiAoaS5lLiBhIGxlYWRpbmcgJy0nIGNoYXJhY3RlcikgaW4gaXRzIHN0cmluZ1xuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiwgd2hpY2ggd291bGQgYWZmZWN0IGl0cyBsZXhpY29ncmFwaGljYWwgb3JkZXJpbmcuXG4gICAgICAgIGNvbnN0IGFkanVzdGVkU2Vjb25kcyA9IHRoaXMuc2Vjb25kcyAtIE1JTl9TRUNPTkRTO1xuICAgICAgICAvLyBOb3RlOiBVcCB0byAxMiBkZWNpbWFsIGRpZ2l0cyBhcmUgcmVxdWlyZWQgdG8gcmVwcmVzZW50IGFsbCB2YWxpZFxuICAgICAgICAvLyAnc2Vjb25kcycgdmFsdWVzLlxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRTZWNvbmRzID0gU3RyaW5nKGFkanVzdGVkU2Vjb25kcykucGFkU3RhcnQoMTIsICcwJyk7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZE5hbm9zZWNvbmRzID0gU3RyaW5nKHRoaXMubmFub3NlY29uZHMpLnBhZFN0YXJ0KDksICcwJyk7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRTZWNvbmRzICsgJy4nICsgZm9ybWF0dGVkTmFub3NlY29uZHM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIHZlcnNpb24gb2YgYSBkb2N1bWVudCBpbiBGaXJlc3RvcmUuIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIHZlcnNpb25cbiAqIHRpbWVzdGFtcCwgc3VjaCBhcyB1cGRhdGVfdGltZSBvciByZWFkX3RpbWUuXG4gKi9cbmNsYXNzIFNuYXBzaG90VmVyc2lvbiB7XG4gICAgc3RhdGljIGZyb21UaW1lc3RhbXAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTbmFwc2hvdFZlcnNpb24odmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgbWluKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNuYXBzaG90VmVyc2lvbihuZXcgVGltZXN0YW1wKDAsIDApKTtcbiAgICB9XG4gICAgc3RhdGljIG1heCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTbmFwc2hvdFZlcnNpb24obmV3IFRpbWVzdGFtcCgyNTM0MDIzMDA3OTksIDFlOSAtIDEpKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodGltZXN0YW1wKSB7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgIH1cbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wLl9jb21wYXJlVG8ob3RoZXIudGltZXN0YW1wKTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXAuaXNFcXVhbChvdGhlci50aW1lc3RhbXApO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIG51bWJlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVyc2lvbiBmb3IgdXNlIGluIHNwZWMgdGVzdHMuICovXG4gICAgdG9NaWNyb3NlY29uZHMoKSB7XG4gICAgICAgIC8vIENvbnZlcnQgdG8gbWljcm9zZWNvbmRzLlxuICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXAuc2Vjb25kcyAqIDFlNiArIHRoaXMudGltZXN0YW1wLm5hbm9zZWNvbmRzIC8gMTAwMDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnU25hcHNob3RWZXJzaW9uKCcgKyB0aGlzLnRpbWVzdGFtcC50b1N0cmluZygpICsgJyknO1xuICAgIH1cbiAgICB0b1RpbWVzdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERPQ1VNRU5UX0tFWV9OQU1FID0gJ19fbmFtZV9fJztcbi8qKlxuICogUGF0aCByZXByZXNlbnRzIGFuIG9yZGVyZWQgc2VxdWVuY2Ugb2Ygc3RyaW5nIHNlZ21lbnRzLlxuICovXG5jbGFzcyBCYXNlUGF0aCB7XG4gICAgY29uc3RydWN0b3Ioc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvZmZzZXQgPiBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCAtIG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPiBzZWdtZW50cy5sZW5ndGggLSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlZ21lbnRzID0gc2VnbWVudHM7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmxlbiA9IGxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBCYXNlUGF0aC5jb21wYXJhdG9yKHRoaXMsIG90aGVyKSA9PT0gMDtcbiAgICB9XG4gICAgY2hpbGQobmFtZU9yUGF0aCkge1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHMuc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMubGltaXQoKSk7XG4gICAgICAgIGlmIChuYW1lT3JQYXRoIGluc3RhbmNlb2YgQmFzZVBhdGgpIHtcbiAgICAgICAgICAgIG5hbWVPclBhdGguZm9yRWFjaChzZWdtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5hbWVPclBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdChzZWdtZW50cyk7XG4gICAgfVxuICAgIC8qKiBUaGUgaW5kZXggb2Ygb25lIHBhc3QgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgcGF0aC4gKi9cbiAgICBsaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ICsgdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIHBvcEZpcnN0KHNpemUpIHtcbiAgICAgICAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IDEgOiBzaXplO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3QodGhpcy5zZWdtZW50cywgdGhpcy5vZmZzZXQgKyBzaXplLCB0aGlzLmxlbmd0aCAtIHNpemUpO1xuICAgIH1cbiAgICBwb3BMYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3QodGhpcy5zZWdtZW50cywgdGhpcy5vZmZzZXQsIHRoaXMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGZpcnN0U2VnbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudHNbdGhpcy5vZmZzZXRdO1xuICAgIH1cbiAgICBsYXN0U2VnbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGdldChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWdtZW50c1t0aGlzLm9mZnNldCArIGluZGV4XTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBpc1ByZWZpeE9mKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci5sZW5ndGggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KGkpICE9PSBvdGhlci5nZXQoaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzSW1tZWRpYXRlUGFyZW50T2YocG90ZW50aWFsQ2hpbGQpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICsgMSAhPT0gcG90ZW50aWFsQ2hpbGQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoaSkgIT09IHBvdGVudGlhbENoaWxkLmdldChpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yRWFjaChmbikge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5vZmZzZXQsIGVuZCA9IHRoaXMubGltaXQoKTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBmbih0aGlzLnNlZ21lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWdtZW50cy5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5saW1pdCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSAyIHBhdGhzIHNlZ21lbnQgYnkgc2VnbWVudCwgcHJpb3JpdGl6aW5nIG51bWVyaWMgSURzXG4gICAgICogKGUuZy4sIFwiX19pZDEyM19fXCIpIGluIG51bWVyaWMgYXNjZW5kaW5nIG9yZGVyLCBmb2xsb3dlZCBieSBzdHJpbmdcbiAgICAgKiBzZWdtZW50cyBpbiBsZXhpY29ncmFwaGljYWwgb3JkZXIuXG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmF0b3IocDEsIHAyKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKHAxLmxlbmd0aCwgcDIubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY29tcGFyaXNvbiA9IEJhc2VQYXRoLmNvbXBhcmVTZWdtZW50cyhwMS5nZXQoaSksIHAyLmdldChpKSk7XG4gICAgICAgICAgICBpZiAoY29tcGFyaXNvbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKHAxLmxlbmd0aCwgcDIubGVuZ3RoKTtcbiAgICB9XG4gICAgc3RhdGljIGNvbXBhcmVTZWdtZW50cyhsaHMsIHJocykge1xuICAgICAgICBjb25zdCBpc0xoc051bWVyaWMgPSBCYXNlUGF0aC5pc051bWVyaWNJZChsaHMpO1xuICAgICAgICBjb25zdCBpc1Joc051bWVyaWMgPSBCYXNlUGF0aC5pc051bWVyaWNJZChyaHMpO1xuICAgICAgICBpZiAoaXNMaHNOdW1lcmljICYmICFpc1Joc051bWVyaWMpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgbGhzIGlzIG51bWVyaWNcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNMaHNOdW1lcmljICYmIGlzUmhzTnVtZXJpYykge1xuICAgICAgICAgICAgLy8gT25seSByaHMgaXMgbnVtZXJpY1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNMaHNOdW1lcmljICYmIGlzUmhzTnVtZXJpYykge1xuICAgICAgICAgICAgLy8gYm90aCBudW1lcmljXG4gICAgICAgICAgICByZXR1cm4gQmFzZVBhdGguZXh0cmFjdE51bWVyaWNJZChsaHMpLmNvbXBhcmUoQmFzZVBhdGguZXh0cmFjdE51bWVyaWNJZChyaHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJvdGggbm9uLW51bWVyaWNcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlVXRmOFN0cmluZ3MobGhzLCByaHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrcyBpZiBhIHNlZ21lbnQgaXMgYSBudW1lcmljIElEIChzdGFydHMgd2l0aCBcIl9faWRcIiBhbmQgZW5kcyB3aXRoIFwiX19cIikuXG4gICAgc3RhdGljIGlzTnVtZXJpY0lkKHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnQuc3RhcnRzV2l0aCgnX19pZCcpICYmIHNlZ21lbnQuZW5kc1dpdGgoJ19fJyk7XG4gICAgfVxuICAgIHN0YXRpYyBleHRyYWN0TnVtZXJpY0lkKHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIEludGVnZXIuZnJvbVN0cmluZyhzZWdtZW50LnN1YnN0cmluZyg0LCBzZWdtZW50Lmxlbmd0aCAtIDIpKTtcbiAgICB9XG59XG4vKipcbiAqIEEgc2xhc2gtc2VwYXJhdGVkIHBhdGggZm9yIG5hdmlnYXRpbmcgcmVzb3VyY2VzIChkb2N1bWVudHMgYW5kIGNvbGxlY3Rpb25zKVxuICogd2l0aGluIEZpcmVzdG9yZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgUmVzb3VyY2VQYXRoIGV4dGVuZHMgQmFzZVBhdGgge1xuICAgIGNvbnN0cnVjdChzZWdtZW50cywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBhdGgoc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgY2Fub25pY2FsU3RyaW5nKCkge1xuICAgICAgICAvLyBOT1RFOiBUaGUgY2xpZW50IGlzIGlnbm9yYW50IG9mIGFueSBwYXRoIHNlZ21lbnRzIGNvbnRhaW5pbmcgZXNjYXBlXG4gICAgICAgIC8vIHNlcXVlbmNlcyAoZS5nLiBfX2lkMTIzX18pIGFuZCBqdXN0IHBhc3NlcyB0aGVtIHRocm91Z2ggcmF3ICh0aGV5IGV4aXN0XG4gICAgICAgIC8vIGZvciBsZWdhY3kgcmVhc29ucyBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGZyZXF1ZW50bHkpLlxuICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuam9pbignLycpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwYXRoXG4gICAgICogd2hlcmUgZWFjaCBwYXRoIHNlZ21lbnQgaGFzIGJlZW4gZW5jb2RlZCB3aXRoXG4gICAgICogYGVuY29kZVVSSUNvbXBvbmVudGAuXG4gICAgICovXG4gICAgdG9VcmlFbmNvZGVkU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5KCkubWFwKGVuY29kZVVSSUNvbXBvbmVudCkuam9pbignLycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVzb3VyY2UgcGF0aCBmcm9tIHRoZSBnaXZlbiBzbGFzaC1kZWxpbWl0ZWQgc3RyaW5nLiBJZiBtdWx0aXBsZVxuICAgICAqIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIGFsbCBjb21wb25lbnRzIGFyZSBjb21iaW5lZC4gTGVhZGluZyBhbmQgdHJhaWxpbmdcbiAgICAgKiBzbGFzaGVzIGZyb20gYWxsIGNvbXBvbmVudHMgYXJlIGlnbm9yZWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TdHJpbmcoLi4ucGF0aENvbXBvbmVudHMpIHtcbiAgICAgICAgLy8gTk9URTogVGhlIGNsaWVudCBpcyBpZ25vcmFudCBvZiBhbnkgcGF0aCBzZWdtZW50cyBjb250YWluaW5nIGVzY2FwZVxuICAgICAgICAvLyBzZXF1ZW5jZXMgKGUuZy4gX19pZDEyM19fKSBhbmQganVzdCBwYXNzZXMgdGhlbSB0aHJvdWdoIHJhdyAodGhleSBleGlzdFxuICAgICAgICAvLyBmb3IgbGVnYWN5IHJlYXNvbnMgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBmcmVxdWVudGx5KS5cbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhDb21wb25lbnRzKSB7XG4gICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKCcvLycpID49IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBzZWdtZW50ICgke3BhdGh9KS4gUGF0aHMgbXVzdCBub3QgY29udGFpbiAvLyBpbiB0aGVtLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlZC5cbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goLi4ucGF0aC5zcGxpdCgnLycpLmZpbHRlcihzZWdtZW50ID0+IHNlZ21lbnQubGVuZ3RoID4gMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2VQYXRoKHNlZ21lbnRzKTtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBhdGgoW10pO1xuICAgIH1cbn1cbmNvbnN0IGlkZW50aWZpZXJSZWdFeHAgPSAvXltfYS16QS1aXVtfYS16QS1aMC05XSokLztcbi8qKlxuICogQSBkb3Qtc2VwYXJhdGVkIHBhdGggZm9yIG5hdmlnYXRpbmcgc3ViLW9iamVjdHMgd2l0aGluIGEgZG9jdW1lbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgRmllbGRQYXRoJDEgZXh0ZW5kcyBCYXNlUGF0aCB7XG4gICAgY29uc3RydWN0KHNlZ21lbnRzLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkUGF0aCQxKHNlZ21lbnRzLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIGNvdWxkIGJlIHVzZWQgYXMgYSBzZWdtZW50IGluIGEgZmllbGQgcGF0aFxuICAgICAqIHdpdGhvdXQgZXNjYXBpbmcuXG4gICAgICovXG4gICAgc3RhdGljIGlzVmFsaWRJZGVudGlmaWVyKHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXJSZWdFeHAudGVzdChzZWdtZW50KTtcbiAgICB9XG4gICAgY2Fub25pY2FsU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5KClcbiAgICAgICAgICAgIC5tYXAoc3RyID0+IHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoL2AvZywgJ1xcXFxgJyk7XG4gICAgICAgICAgICBpZiAoIUZpZWxkUGF0aCQxLmlzVmFsaWRJZGVudGlmaWVyKHN0cikpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnYCcgKyBzdHIgKyAnYCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJy4nKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbm9uaWNhbFN0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBmaWVsZCByZWZlcmVuY2VzIHRoZSBrZXkgb2YgYSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBpc0tleUZpZWxkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy5nZXQoMCkgPT09IERPQ1VNRU5UX0tFWV9OQU1FO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmllbGQgZGVzaWduYXRpbmcgdGhlIGtleSBvZiBhIGRvY3VtZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBrZXlGaWVsZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgkMShbRE9DVU1FTlRfS0VZX05BTUVdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgZmllbGQgc3RyaW5nIGZyb20gdGhlIGdpdmVuIHNlcnZlci1mb3JtYXR0ZWQgc3RyaW5nLlxuICAgICAqXG4gICAgICogLSBTcGxpdHRpbmcgdGhlIGVtcHR5IHN0cmluZyBpcyBub3QgYWxsb3dlZCAoZm9yIG5vdyBhdCBsZWFzdCkuXG4gICAgICogLSBFbXB0eSBzZWdtZW50cyB3aXRoaW4gdGhlIHN0cmluZyAoZS5nLiBpZiB0aGVyZSBhcmUgdHdvIGNvbnNlY3V0aXZlXG4gICAgICogICBzZXBhcmF0b3JzKSBhcmUgbm90IGFsbG93ZWQuXG4gICAgICpcbiAgICAgKiBUT0RPKGIvMzcyNDQxNTcpOiB3ZSBzaG91bGQgbWFrZSB0aGlzIG1vcmUgc3RyaWN0LiBSaWdodCBub3csIGl0IGFsbG93c1xuICAgICAqIG5vbi1pZGVudGlmaWVyIHBhdGggY29tcG9uZW50cywgZXZlbiBpZiB0aGV5IGFyZW4ndCBlc2NhcGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2VydmVyRm9ybWF0KHBhdGgpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSAnJztcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBjb25zdCBhZGRDdXJyZW50U2VnbWVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIGZpZWxkIHBhdGggKCR7cGF0aH0pLiBQYXRocyBtdXN0IG5vdCBiZSBlbXB0eSwgYmVnaW4gYCArXG4gICAgICAgICAgICAgICAgICAgIGB3aXRoICcuJywgZW5kIHdpdGggJy4nLCBvciBjb250YWluICcuLidgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICBjdXJyZW50ID0gJyc7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBpbkJhY2t0aWNrcyA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoaSA8IHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gcGF0aFtpXTtcbiAgICAgICAgICAgIGlmIChjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPT09IHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdQYXRoIGhhcyB0cmFpbGluZyBlc2NhcGUgY2hhcmFjdGVyOiAnICsgcGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwYXRoW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoIShuZXh0ID09PSAnXFxcXCcgfHwgbmV4dCA9PT0gJy4nIHx8IG5leHQgPT09ICdgJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1BhdGggaGFzIGludmFsaWQgZXNjYXBlIHNlcXVlbmNlOiAnICsgcGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gbmV4dDtcbiAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnYCcpIHtcbiAgICAgICAgICAgICAgICBpbkJhY2t0aWNrcyA9ICFpbkJhY2t0aWNrcztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnLicgJiYgIWluQmFja3RpY2tzKSB7XG4gICAgICAgICAgICAgICAgYWRkQ3VycmVudFNlZ21lbnQoKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZEN1cnJlbnRTZWdtZW50KCk7XG4gICAgICAgIGlmIChpbkJhY2t0aWNrcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1VudGVybWluYXRlZCBgIGluIHBhdGg6ICcgKyBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZpZWxkUGF0aCQxKHNlZ21lbnRzKTtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgkMShbXSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgRG9jdW1lbnRLZXkge1xuICAgIGNvbnN0cnVjdG9yKHBhdGgpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21QYXRoKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhwYXRoKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRLZXkoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcobmFtZSkucG9wRmlyc3QoNSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRLZXkoUmVzb3VyY2VQYXRoLmVtcHR5UGF0aCgpKTtcbiAgICB9XG4gICAgZ2V0IGNvbGxlY3Rpb25Hcm91cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC5wb3BMYXN0KCkubGFzdFNlZ21lbnQoKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZG9jdW1lbnQgaXMgaW4gdGhlIHNwZWNpZmllZCBjb2xsZWN0aW9uSWQuICovXG4gICAgaGFzQ29sbGVjdGlvbklkKGNvbGxlY3Rpb25JZCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucGF0aC5sZW5ndGggPj0gMiAmJlxuICAgICAgICAgICAgdGhpcy5wYXRoLmdldCh0aGlzLnBhdGgubGVuZ3RoIC0gMikgPT09IGNvbGxlY3Rpb25JZCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIGdyb3VwIChpLmUuIHRoZSBuYW1lIG9mIHRoZSBwYXJlbnQgY29sbGVjdGlvbikgZm9yIHRoaXMga2V5LiAqL1xuICAgIGdldENvbGxlY3Rpb25Hcm91cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC5nZXQodGhpcy5wYXRoLmxlbmd0aCAtIDIpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgZnVsbHkgcXVhbGlmaWVkIHBhdGggdG8gdGhlIHBhcmVudCBjb2xsZWN0aW9uLiAqL1xuICAgIGdldENvbGxlY3Rpb25QYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLnBvcExhc3QoKTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKG90aGVyICE9PSBudWxsICYmIFJlc291cmNlUGF0aC5jb21wYXJhdG9yKHRoaXMucGF0aCwgb3RoZXIucGF0aCkgPT09IDApO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC50b1N0cmluZygpO1xuICAgIH1cbiAgICBzdGF0aWMgY29tcGFyYXRvcihrMSwgazIpIHtcbiAgICAgICAgcmV0dXJuIFJlc291cmNlUGF0aC5jb21wYXJhdG9yKGsxLnBhdGgsIGsyLnBhdGgpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNEb2N1bWVudEtleShwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCAlIDIgPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgZG9jdW1lbnQga2V5IHdpdGggdGhlIGdpdmVuIHNlZ21lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlZ21lbnRzIC0gVGhlIHNlZ21lbnRzIG9mIHRoZSBwYXRoIHRvIHRoZSBkb2N1bWVudFxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluc3RhbmNlIG9mIERvY3VtZW50S2V5XG4gICAgICovXG4gICAgc3RhdGljIGZyb21TZWdtZW50cyhzZWdtZW50cykge1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KG5ldyBSZXNvdXJjZVBhdGgoc2VnbWVudHMuc2xpY2UoKSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhlIGluaXRpYWwgbXV0YXRpb24gYmF0Y2ggaWQgZm9yIGVhY2ggaW5kZXguIEdldHMgdXBkYXRlZCBkdXJpbmcgaW5kZXhcbiAqIGJhY2tmaWxsLlxuICovXG5jb25zdCBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQgPSAtMTtcbi8qKlxuICogVGhlIGluaXRpYWwgc2VxdWVuY2UgbnVtYmVyIGZvciBlYWNoIGluZGV4LiBHZXRzIHVwZGF0ZWQgZHVyaW5nIGluZGV4XG4gKiBiYWNrZmlsbC5cbiAqL1xuY29uc3QgSU5JVElBTF9TRVFVRU5DRV9OVU1CRVIgPSAwO1xuLyoqXG4gKiBBbiBpbmRleCBkZWZpbml0aW9uIGZvciBmaWVsZCBpbmRleGVzIGluIEZpcmVzdG9yZS5cbiAqXG4gKiBFdmVyeSBpbmRleCBpcyBhc3NvY2lhdGVkIHdpdGggYSBjb2xsZWN0aW9uLiBUaGUgZGVmaW5pdGlvbiBjb250YWlucyBhIGxpc3RcbiAqIG9mIGZpZWxkcyBhbmQgdGhlaXIgaW5kZXgga2luZCAod2hpY2ggY2FuIGJlIGBBU0NFTkRJTkdgLCBgREVTQ0VORElOR2Agb3JcbiAqIGBDT05UQUlOU2AgZm9yIEFycmF5Q29udGFpbnMvQXJyYXlDb250YWluc0FueSBxdWVyaWVzKS5cbiAqXG4gKiBVbmxpa2UgdGhlIGJhY2tlbmQsIHRoZSBTREsgZG9lcyBub3QgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGNvbGxlY3Rpb24gb3JcbiAqIGNvbGxlY3Rpb24gZ3JvdXAtc2NvcGVkIGluZGljZXMuIEV2ZXJ5IGluZGV4IGNhbiBiZSB1c2VkIGZvciBib3RoIHNpbmdsZVxuICogY29sbGVjdGlvbiBhbmQgY29sbGVjdGlvbiBncm91cCBxdWVyaWVzLlxuICovXG5jbGFzcyBGaWVsZEluZGV4IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggSUQuIFJldHVybnMgLTEgaWYgdGhlIGluZGV4IElEIGlzIG5vdCBhdmFpbGFibGUgKGUuZy4gdGhlIGluZGV4XG4gICAgICogaGFzIG5vdCB5ZXQgYmVlbiBwZXJzaXN0ZWQpLlxuICAgICAqL1xuICAgIGluZGV4SWQsIFxuICAgIC8qKiBUaGUgY29sbGVjdGlvbiBJRCB0aGlzIGluZGV4IGFwcGxpZXMgdG8uICovXG4gICAgY29sbGVjdGlvbkdyb3VwLCBcbiAgICAvKiogVGhlIGZpZWxkIHNlZ21lbnRzIGZvciB0aGlzIGluZGV4LiAqL1xuICAgIGZpZWxkcywgXG4gICAgLyoqIFNob3dzIGhvdyB1cC10by1kYXRlIHRoZSBpbmRleCBpcyBmb3IgdGhlIGN1cnJlbnQgdXNlci4gKi9cbiAgICBpbmRleFN0YXRlKSB7XG4gICAgICAgIHRoaXMuaW5kZXhJZCA9IGluZGV4SWQ7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbkdyb3VwID0gY29sbGVjdGlvbkdyb3VwO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgdGhpcy5pbmRleFN0YXRlID0gaW5kZXhTdGF0ZTtcbiAgICB9XG59XG4vKiogQW4gSUQgZm9yIGFuIGluZGV4IHRoYXQgaGFzIG5vdCB5ZXQgYmVlbiBhZGRlZCB0byBwZXJzaXN0ZW5jZS4gICovXG5GaWVsZEluZGV4LlVOS05PV05fSUQgPSAtMTtcbi8qKiBSZXR1cm5zIHRoZSBBcnJheUNvbnRhaW5zL0FycmF5Q29udGFpbnNBbnkgc2VnbWVudCBmb3IgdGhpcyBpbmRleC4gKi9cbmZ1bmN0aW9uIGZpZWxkSW5kZXhHZXRBcnJheVNlZ21lbnQoZmllbGRJbmRleCkge1xuICAgIHJldHVybiBmaWVsZEluZGV4LmZpZWxkcy5maW5kKHMgPT4gcy5raW5kID09PSAyIC8qIEluZGV4S2luZC5DT05UQUlOUyAqLyk7XG59XG4vKiogUmV0dXJucyBhbGwgZGlyZWN0aW9uYWwgKGFzY2VuZGluZy9kZXNjZW5kaW5nKSBzZWdtZW50cyBmb3IgdGhpcyBpbmRleC4gKi9cbmZ1bmN0aW9uIGZpZWxkSW5kZXhHZXREaXJlY3Rpb25hbFNlZ21lbnRzKGZpZWxkSW5kZXgpIHtcbiAgICByZXR1cm4gZmllbGRJbmRleC5maWVsZHMuZmlsdGVyKHMgPT4gcy5raW5kICE9PSAyIC8qIEluZGV4S2luZC5DT05UQUlOUyAqLyk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG9yZGVyIG9mIHRoZSBkb2N1bWVudCBrZXkgY29tcG9uZW50IGZvciB0aGUgZ2l2ZW4gaW5kZXguXG4gKlxuICogUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBpbiB0aGUgV2ViIEluZGV4ZWREYiBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmllbGRJbmRleEdldEtleU9yZGVyKGZpZWxkSW5kZXgpIHtcbiAgICBjb25zdCBkaXJlY3Rpb25hbFNlZ21lbnRzID0gZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoZmllbGRJbmRleCk7XG4gICAgcmV0dXJuIGRpcmVjdGlvbmFsU2VnbWVudHMubGVuZ3RoID09PSAwXG4gICAgICAgID8gMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovXG4gICAgICAgIDogZGlyZWN0aW9uYWxTZWdtZW50c1tkaXJlY3Rpb25hbFNlZ21lbnRzLmxlbmd0aCAtIDFdLmtpbmQ7XG59XG4vKipcbiAqIENvbXBhcmVzIGluZGV4ZXMgYnkgY29sbGVjdGlvbiBncm91cCBhbmQgc2VnbWVudHMuIElnbm9yZXMgdXBkYXRlIHRpbWUgYW5kXG4gKiBpbmRleCBJRC5cbiAqL1xuZnVuY3Rpb24gZmllbGRJbmRleFNlbWFudGljQ29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xuICAgIGxldCBjbXAgPSBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQuY29sbGVjdGlvbkdyb3VwLCByaWdodC5jb2xsZWN0aW9uR3JvdXApO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihsZWZ0LmZpZWxkcy5sZW5ndGgsIHJpZ2h0LmZpZWxkcy5sZW5ndGgpOyArK2kpIHtcbiAgICAgICAgY21wID0gaW5kZXhTZWdtZW50Q29tcGFyYXRvcihsZWZ0LmZpZWxkc1tpXSwgcmlnaHQuZmllbGRzW2ldKTtcbiAgICAgICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LmZpZWxkcy5sZW5ndGgsIHJpZ2h0LmZpZWxkcy5sZW5ndGgpO1xufVxuLyoqIFJldHVybnMgYSBkZWJ1ZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZmllbGQgaW5kZXggKi9cbmZ1bmN0aW9uIGZpZWxkSW5kZXhUb1N0cmluZyhmaWVsZEluZGV4KSB7XG4gICAgcmV0dXJuIGBpZD0ke2ZpZWxkSW5kZXguaW5kZXhJZH18Y2c9JHtmaWVsZEluZGV4LmNvbGxlY3Rpb25Hcm91cH18Zj0ke2ZpZWxkSW5kZXguZmllbGRzLm1hcChmID0+IGAke2YuZmllbGRQYXRofToke2Yua2luZH1gKS5qb2luKCcsJyl9YDtcbn1cbi8qKiBBbiBpbmRleCBjb21wb25lbnQgY29uc2lzdGluZyBvZiBmaWVsZCBwYXRoIGFuZCBpbmRleCB0eXBlLiAgKi9cbmNsYXNzIEluZGV4U2VnbWVudCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRoZSBmaWVsZCBwYXRoIG9mIHRoZSBjb21wb25lbnQuICovXG4gICAgZmllbGRQYXRoLCBcbiAgICAvKiogVGhlIGZpZWxkcyBzb3J0aW5nIG9yZGVyLiAqL1xuICAgIGtpbmQpIHtcbiAgICAgICAgdGhpcy5maWVsZFBhdGggPSBmaWVsZFBhdGg7XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5kZXhTZWdtZW50Q29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IGNtcCA9IEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IobGVmdC5maWVsZFBhdGgsIHJpZ2h0LmZpZWxkUGF0aCk7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LmtpbmQsIHJpZ2h0LmtpbmQpO1xufVxuLyoqXG4gKiBTdG9yZXMgdGhlIFwiaGlnaCB3YXRlciBtYXJrXCIgdGhhdCBpbmRpY2F0ZXMgaG93IHVwZGF0ZWQgdGhlIEluZGV4IGlzIGZvciB0aGVcbiAqIGN1cnJlbnQgdXNlci5cbiAqL1xuY2xhc3MgSW5kZXhTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZW4gdGhlIGluZGV4IHdhcyBsYXN0IHVwZGF0ZWQgKHJlbGF0aXZlIHRvIG90aGVyIGluZGV4ZXMpLlxuICAgICAqL1xuICAgIHNlcXVlbmNlTnVtYmVyLCBcbiAgICAvKiogVGhlIHRoZSBsYXRlc3QgaW5kZXhlZCByZWFkIHRpbWUsIGRvY3VtZW50IGFuZCBiYXRjaCBpZC4gKi9cbiAgICBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZU51bWJlciA9IHNlcXVlbmNlTnVtYmVyO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gICAgLyoqIFRoZSBzdGF0ZSBvZiBhbiBpbmRleCB0aGF0IGhhcyBub3QgeWV0IGJlZW4gYmFja2ZpbGxlZC4gKi9cbiAgICBzdGF0aWMgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhTdGF0ZShJTklUSUFMX1NFUVVFTkNFX05VTUJFUiwgSW5kZXhPZmZzZXQubWluKCkpO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBvZmZzZXQgdGhhdCBtYXRjaGVzIGFsbCBkb2N1bWVudHMgd2l0aCBhIHJlYWQgdGltZSBoaWdoZXIgdGhhblxuICogYHJlYWRUaW1lYC5cbiAqL1xuZnVuY3Rpb24gbmV3SW5kZXhPZmZzZXRTdWNjZXNzb3JGcm9tUmVhZFRpbWUocmVhZFRpbWUsIGxhcmdlc3RCYXRjaElkKSB7XG4gICAgLy8gV2Ugd2FudCB0byBjcmVhdGUgYW4gb2Zmc2V0IHRoYXQgbWF0Y2hlcyBhbGwgZG9jdW1lbnRzIHdpdGggYSByZWFkIHRpbWVcbiAgICAvLyBncmVhdGVyIHRoYW4gdGhlIHByb3ZpZGVkIHJlYWQgdGltZS4gVG8gZG8gc28sIHdlIHRlY2huaWNhbGx5IG5lZWQgdG9cbiAgICAvLyBjcmVhdGUgYW4gb2Zmc2V0IGZvciBgKHJlYWRUaW1lLCBNQVhfRE9DVU1FTlRfS0VZKWAuIFdoaWxlIHdlIGNvdWxkIHVzZVxuICAgIC8vIFVuaWNvZGUgY29kZXBvaW50cyB0byBnZW5lcmF0ZSBNQVhfRE9DVU1FTlRfS0VZLCBpdCBpcyBtdWNoIGVhc2llciB0byB1c2VcbiAgICAvLyBgKHJlYWRUaW1lICsgMSwgRG9jdW1lbnRLZXkuZW1wdHkoKSlgIHNpbmNlIGA+IERvY3VtZW50S2V5LmVtcHR5KClgIG1hdGNoZXNcbiAgICAvLyBhbGwgdmFsaWQgZG9jdW1lbnQgSURzLlxuICAgIGNvbnN0IHN1Y2Nlc3NvclNlY29uZHMgPSByZWFkVGltZS50b1RpbWVzdGFtcCgpLnNlY29uZHM7XG4gICAgY29uc3Qgc3VjY2Vzc29yTmFub3MgPSByZWFkVGltZS50b1RpbWVzdGFtcCgpLm5hbm9zZWNvbmRzICsgMTtcbiAgICBjb25zdCBzdWNjZXNzb3IgPSBTbmFwc2hvdFZlcnNpb24uZnJvbVRpbWVzdGFtcChzdWNjZXNzb3JOYW5vcyA9PT0gMWU5XG4gICAgICAgID8gbmV3IFRpbWVzdGFtcChzdWNjZXNzb3JTZWNvbmRzICsgMSwgMClcbiAgICAgICAgOiBuZXcgVGltZXN0YW1wKHN1Y2Nlc3NvclNlY29uZHMsIHN1Y2Nlc3Nvck5hbm9zKSk7XG4gICAgcmV0dXJuIG5ldyBJbmRleE9mZnNldChzdWNjZXNzb3IsIERvY3VtZW50S2V5LmVtcHR5KCksIGxhcmdlc3RCYXRjaElkKTtcbn1cbi8qKiBDcmVhdGVzIGEgbmV3IG9mZnNldCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZG9jdW1lbnQuICovXG5mdW5jdGlvbiBuZXdJbmRleE9mZnNldEZyb21Eb2N1bWVudChkb2N1bWVudCkge1xuICAgIHJldHVybiBuZXcgSW5kZXhPZmZzZXQoZG9jdW1lbnQucmVhZFRpbWUsIGRvY3VtZW50LmtleSwgSU5JVElBTF9MQVJHRVNUX0JBVENIX0lEKTtcbn1cbi8qKlxuICogU3RvcmVzIHRoZSBsYXRlc3QgcmVhZCB0aW1lLCBkb2N1bWVudCBhbmQgYmF0Y2ggSUQgdGhhdCB3ZXJlIHByb2Nlc3NlZCBmb3IgYW5cbiAqIGluZGV4LlxuICovXG5jbGFzcyBJbmRleE9mZnNldCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIGxhdGVzdCByZWFkIHRpbWUgdmVyc2lvbiB0aGF0IGhhcyBiZWVuIGluZGV4ZWQgYnkgRmlyZXN0b3JlIGZvciB0aGlzXG4gICAgICogZmllbGQgaW5kZXguXG4gICAgICovXG4gICAgcmVhZFRpbWUsIFxuICAgIC8qKlxuICAgICAqIFRoZSBrZXkgb2YgdGhlIGxhc3QgZG9jdW1lbnQgdGhhdCB3YXMgaW5kZXhlZCBmb3IgdGhpcyBxdWVyeS4gVXNlXG4gICAgICogYERvY3VtZW50S2V5LmVtcHR5KClgIGlmIG5vIGRvY3VtZW50IGhhcyBiZWVuIGluZGV4ZWQuXG4gICAgICovXG4gICAgZG9jdW1lbnRLZXksIFxuICAgIC8qXG4gICAgICogVGhlIGxhcmdlc3QgbXV0YXRpb24gYmF0Y2ggaWQgdGhhdCdzIGJlZW4gcHJvY2Vzc2VkIGJ5IEZpcmVzdG9yZS5cbiAgICAgKi9cbiAgICBsYXJnZXN0QmF0Y2hJZCkge1xuICAgICAgICB0aGlzLnJlYWRUaW1lID0gcmVhZFRpbWU7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRLZXkgPSBkb2N1bWVudEtleTtcbiAgICAgICAgdGhpcy5sYXJnZXN0QmF0Y2hJZCA9IGxhcmdlc3RCYXRjaElkO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhbiBvZmZzZXQgdGhhdCBzb3J0cyBiZWZvcmUgYWxsIHJlZ3VsYXIgb2Zmc2V0cy4gKi9cbiAgICBzdGF0aWMgbWluKCkge1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4T2Zmc2V0KFNuYXBzaG90VmVyc2lvbi5taW4oKSwgRG9jdW1lbnRLZXkuZW1wdHkoKSwgSU5JVElBTF9MQVJHRVNUX0JBVENIX0lEKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYW4gb2Zmc2V0IHRoYXQgc29ydHMgYWZ0ZXIgYWxsIHJlZ3VsYXIgb2Zmc2V0cy4gKi9cbiAgICBzdGF0aWMgbWF4KCkge1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4T2Zmc2V0KFNuYXBzaG90VmVyc2lvbi5tYXgoKSwgRG9jdW1lbnRLZXkuZW1wdHkoKSwgSU5JVElBTF9MQVJHRVNUX0JBVENIX0lEKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbmRleE9mZnNldENvbXBhcmF0b3IobGVmdCwgcmlnaHQpIHtcbiAgICBsZXQgY21wID0gbGVmdC5yZWFkVGltZS5jb21wYXJlVG8ocmlnaHQucmVhZFRpbWUpO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG4gICAgY21wID0gRG9jdW1lbnRLZXkuY29tcGFyYXRvcihsZWZ0LmRvY3VtZW50S2V5LCByaWdodC5kb2N1bWVudEtleSk7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0Lmxhcmdlc3RCYXRjaElkLCByaWdodC5sYXJnZXN0QmF0Y2hJZCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBQUklNQVJZX0xFQVNFX0xPU1RfRVJST1JfTVNHID0gJ1RoZSBjdXJyZW50IHRhYiBpcyBub3QgaW4gdGhlIHJlcXVpcmVkIHN0YXRlIHRvIHBlcmZvcm0gdGhpcyBvcGVyYXRpb24uICcgK1xuICAgICdJdCBtaWdodCBiZSBuZWNlc3NhcnkgdG8gcmVmcmVzaCB0aGUgYnJvd3NlciB0YWIuJztcbi8qKlxuICogQSBiYXNlIGNsYXNzIHJlcHJlc2VudGluZyBhIHBlcnNpc3RlbmNlIHRyYW5zYWN0aW9uLCBlbmNhcHN1bGF0aW5nIGJvdGggdGhlXG4gKiB0cmFuc2FjdGlvbidzIHNlcXVlbmNlIG51bWJlcnMgYXMgd2VsbCBhcyBhIGxpc3Qgb2Ygb25Db21taXR0ZWQgbGlzdGVuZXJzLlxuICpcbiAqIFdoZW4geW91IGNhbGwgUGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oKSwgaXQgd2lsbCBjcmVhdGUgYSB0cmFuc2FjdGlvbiBhbmRcbiAqIHBhc3MgaXQgdG8geW91ciBjYWxsYmFjay4gWW91IHRoZW4gcGFzcyBpdCB0byBhbnkgbWV0aG9kIHRoYXQgb3BlcmF0ZXNcbiAqIG9uIHBlcnNpc3RlbmNlLlxuICovXG5jbGFzcyBQZXJzaXN0ZW5jZVRyYW5zYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vbkNvbW1pdHRlZExpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICBhZGRPbkNvbW1pdHRlZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMub25Db21taXR0ZWRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJhaXNlT25Db21taXR0ZWRFdmVudCgpIHtcbiAgICAgICAgdGhpcy5vbkNvbW1pdHRlZExpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKCkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVmVyaWZpZXMgdGhlIGVycm9yIHRocm93biBieSBhIExvY2FsU3RvcmUgb3BlcmF0aW9uLiBJZiBhIExvY2FsU3RvcmVcbiAqIG9wZXJhdGlvbiBmYWlscyBiZWNhdXNlIHRoZSBwcmltYXJ5IGxlYXNlIGhhcyBiZWVuIHRha2VuIGJ5IGFub3RoZXIgY2xpZW50LFxuICogd2UgaWdub3JlIHRoZSBlcnJvciAodGhlIHBlcnNpc3RlbmNlIGxheWVyIHdpbGwgaW1tZWRpYXRlbHkgY2FsbFxuICogYGFwcGx5UHJpbWFyeUxlYXNlYCB0byBwcm9wYWdhdGUgdGhlIHByaW1hcnkgc3RhdGUgY2hhbmdlKS4gQWxsIG90aGVyIGVycm9yc1xuICogYXJlIHJlLXRocm93bi5cbiAqXG4gKiBAcGFyYW0gZXJyIC0gQW4gZXJyb3IgcmV0dXJuZWQgYnkgYSBMb2NhbFN0b3JlIG9wZXJhdGlvbi5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHdlIHJlY292ZXJlZCwgb3IgdGhlIG9yaWdpbmFsIGVycm9yLlxuICovXG5hc3luYyBmdW5jdGlvbiBpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlID09PSBDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04gJiZcbiAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFBSSU1BUllfTEVBU0VfTE9TVF9FUlJPUl9NU0cpIHtcbiAgICAgICAgbG9nRGVidWcoJ0xvY2FsU3RvcmUnLCAnVW5leHBlY3RlZGx5IGxvc3QgcHJpbWFyeSBsZWFzZScpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUGVyc2lzdGVuY2VQcm9taXNlIGlzIGVzc2VudGlhbGx5IGEgcmUtaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZSBleGNlcHRcbiAqIGl0IGhhcyBhIC5uZXh0KCkgbWV0aG9kIGluc3RlYWQgb2YgLnRoZW4oKSBhbmQgLm5leHQoKSBhbmQgLmNhdGNoKCkgY2FsbGJhY2tzXG4gKiBhcmUgZXhlY3V0ZWQgc3luY2hyb25vdXNseSB3aGVuIGEgUGVyc2lzdGVuY2VQcm9taXNlIHJlc29sdmVzIHJhdGhlciB0aGFuXG4gKiBhc3luY2hyb25vdXNseSAoUHJvbWlzZSBpbXBsZW1lbnRhdGlvbnMgdXNlIHNldEltbWVkaWF0ZSgpIG9yIHNpbWlsYXIpLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIGludGVyb3BlcmF0ZSB3aXRoIEluZGV4ZWREQiB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHlcbiAqIGNvbW1pdCB0cmFuc2FjdGlvbnMgaWYgY29udHJvbCBpcyByZXR1cm5lZCB0byB0aGUgZXZlbnQgbG9vcCB3aXRob3V0XG4gKiBzeW5jaHJvbm91c2x5IGluaXRpYXRpbmcgYW5vdGhlciBvcGVyYXRpb24gb24gdGhlIHRyYW5zYWN0aW9uLlxuICpcbiAqIE5PVEU6IC50aGVuKCkgYW5kIC5jYXRjaCgpIG9ubHkgYWxsb3cgYSBzaW5nbGUgY29uc3VtZXIsIHVubGlrZSBub3JtYWxcbiAqIFByb21pc2VzLlxuICovXG5jbGFzcyBQZXJzaXN0ZW5jZVByb21pc2Uge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIE5PVEU6IG5leHQvY2F0Y2hDYWxsYmFjayB3aWxsIGFsd2F5cyBwb2ludCB0byBvdXIgb3duIHdyYXBwZXIgZnVuY3Rpb25zLFxuICAgICAgICAvLyBub3QgdGhlIHVzZXIncyByYXcgbmV4dCgpIG9yIGNhdGNoKCkgY2FsbGJhY2tzLlxuICAgICAgICB0aGlzLm5leHRDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuY2F0Y2hDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIC8vIFdoZW4gdGhlIG9wZXJhdGlvbiByZXNvbHZlcywgd2UnbGwgc2V0IHJlc3VsdCBvciBlcnJvciBhbmQgbWFyayBpc0RvbmUuXG4gICAgICAgIHRoaXMucmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmlzRG9uZSA9IGZhbHNlO1xuICAgICAgICAvLyBTZXQgdG8gdHJ1ZSB3aGVuIC50aGVuKCkgb3IgLmNhdGNoKCkgYXJlIGNhbGxlZCBhbmQgcHJldmVudHMgYWRkaXRpb25hbFxuICAgICAgICAvLyBjaGFpbmluZy5cbiAgICAgICAgdGhpcy5jYWxsYmFja0F0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgIGNhbGxiYWNrKHZhbHVlID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSBzaG91bGQgYmUgZGVmaW5lZCB1bmxlc3MgVCBpcyBWb2lkLCBidXQgd2UgY2FuJ3QgZXhwcmVzc1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgaW4gdGhlIHR5cGUgc3lzdGVtLlxuICAgICAgICAgICAgICAgIHRoaXMubmV4dENhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2F0Y2hDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2F0Y2hDYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaChmbikge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0KHVuZGVmaW5lZCwgZm4pO1xuICAgIH1cbiAgICBuZXh0KG5leHRGbiwgY2F0Y2hGbikge1xuICAgICAgICBpZiAodGhpcy5jYWxsYmFja0F0dGFjaGVkKSB7XG4gICAgICAgICAgICBmYWlsKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsYmFja0F0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaXNEb25lKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwU3VjY2VzcyhuZXh0Rm4sIHRoaXMucmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBGYWlsdXJlKGNhdGNoRm4sIHRoaXMuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dENhbGxiYWNrID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JhcFN1Y2Nlc3MobmV4dEZuLCB2YWx1ZSkubmV4dChyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5jYXRjaENhbGxiYWNrID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JhcEZhaWx1cmUoY2F0Y2hGbiwgZXJyb3IpLm5leHQocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9Qcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uZXh0KHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3cmFwVXNlckZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmbigpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFBlcnNpc3RlbmNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JhcFN1Y2Nlc3MobmV4dEZuLCB2YWx1ZSkge1xuICAgICAgICBpZiAobmV4dEZuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwVXNlckZ1bmN0aW9uKCgpID0+IG5leHRGbih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBuZXh0Rm4sIHRoZW4gUiBtdXN0IGJlIHRoZSBzYW1lIGFzIFRcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JhcEZhaWx1cmUoY2F0Y2hGbiwgZXJyb3IpIHtcbiAgICAgICAgaWYgKGNhdGNoRm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBVc2VyRnVuY3Rpb24oKCkgPT4gY2F0Y2hGbihlcnJvcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyByZXNvbHZlKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgcmVqZWN0KGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgd2FpdEZvcihcbiAgICAvLyBBY2NlcHQgYWxsIFByb21pc2UgdHlwZXMgaW4gd2FpdEZvcigpLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCBleHBlY3RlZENvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZENvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICBhbGwuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICArK2V4cGVjdGVkQ291bnQ7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgKytyZXNvbHZlZENvdW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSAmJiByZXNvbHZlZENvdW50ID09PSBleHBlY3RlZENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBlcnIgPT4gcmVqZWN0KGVycikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZENvdW50ID09PSBleHBlY3RlZENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gYXJyYXkgb2YgcHJlZGljYXRlIGZ1bmN0aW9ucyB0aGF0IGFzeW5jaHJvbm91c2x5IGV2YWx1YXRlIHRvIGFcbiAgICAgKiBib29sZWFuLCBpbXBsZW1lbnRzIGEgc2hvcnQtY2lyY3VpdGluZyBgb3JgIGJldHdlZW4gdGhlIHJlc3VsdHMuIFByZWRpY2F0ZXNcbiAgICAgKiB3aWxsIGJlIGV2YWx1YXRlZCB1bnRpbCBvbmUgb2YgdGhlbSByZXR1cm5zIGB0cnVlYCwgdGhlbiBzdG9wLiBUaGUgZmluYWxcbiAgICAgKiByZXN1bHQgd2lsbCBiZSB3aGV0aGVyIGFueSBvZiB0aGVtIHJldHVybmVkIGB0cnVlYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgb3IocHJlZGljYXRlcykge1xuICAgICAgICBsZXQgcCA9IFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgZm9yIChjb25zdCBwcmVkaWNhdGUgb2YgcHJlZGljYXRlcykge1xuICAgICAgICAgICAgcCA9IHAubmV4dChpc1RydWUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc1RydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGlzVHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIHN0YXRpYyBmb3JFYWNoKGNvbGxlY3Rpb24sIGYpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgY29sbGVjdGlvbi5mb3JFYWNoKChyLCBzKSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGYuY2FsbCh0aGlzLCByLCBzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy53YWl0Rm9yKHByb21pc2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uY3VycmVudGx5IG1hcCBhbGwgYXJyYXkgZWxlbWVudHMgdGhyb3VnaCBhc3luY2hyb25vdXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIG1hcEFycmF5KGFycmF5LCBmKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkQ291bnQgPSBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGV4cGVjdGVkQ291bnQpO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHBlY3RlZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gaTtcbiAgICAgICAgICAgICAgICBmKGFycmF5W2N1cnJlbnRdKS5uZXh0KHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbY3VycmVudF0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICsrcmVzb2x2ZWRDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkQ291bnQgPT09IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBlcnIgPT4gcmVqZWN0KGVycikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gcmVjdXJzaXZlIFBlcnNpc3RlbmNlUHJvbWlzZSBjYWxscywgdGhhdCBhdm9pZHNcbiAgICAgKiBwb3RlbnRpYWwgbWVtb3J5IHByb2JsZW1zIGZyb20gdW5ib3VuZGVkIGNoYWlucyBvZiBwcm9taXNlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgYWN0aW9uYCB3aWxsIGJlIGNhbGxlZCByZXBlYXRlZGx5IHdoaWxlIGBjb25kaXRpb25gIGlzIHRydWUuXG4gICAgICovXG4gICAgc3RhdGljIGRvV2hpbGUoY29uZGl0aW9uLCBhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uKCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uKCkubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gUmVmZXJlbmNlcyB0byBgd2luZG93YCBhcmUgZ3VhcmRlZCBieSBTaW1wbGVEYi5pc0F2YWlsYWJsZSgpXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cbmNvbnN0IExPR19UQUckaSA9ICdTaW1wbGVEYic7XG4vKipcbiAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZXRyeSBhdHRlbXB0cyBmb3IgYW4gSW5kZXhlZERiIHRyYW5zYWN0aW9uIHRoYXQgZmFpbHNcbiAqIHdpdGggYSBET01FeGNlcHRpb24uXG4gKi9cbmNvbnN0IFRSQU5TQUNUSU9OX1JFVFJZX0NPVU5UID0gMztcbi8qKlxuICogV3JhcHMgYW4gSURCVHJhbnNhY3Rpb24gYW5kIGV4cG9zZXMgYSBzdG9yZSgpIG1ldGhvZCB0byBnZXQgYSBoYW5kbGUgdG8gYVxuICogc3BlY2lmaWMgb2JqZWN0IHN0b3JlLlxuICovXG5jbGFzcyBTaW1wbGVEYlRyYW5zYWN0aW9uIHtcbiAgICBzdGF0aWMgb3BlbihkYiwgYWN0aW9uLCBtb2RlLCBvYmplY3RTdG9yZU5hbWVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpbXBsZURiVHJhbnNhY3Rpb24oYWN0aW9uLCBkYi50cmFuc2FjdGlvbihvYmplY3RTdG9yZU5hbWVzLCBtb2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGFjdGlvbiwgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3IoYWN0aW9uLCB0cmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBJbmRleGVkRGIgdHJhbnNhY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24ub25hYm9ydCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5lcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbkRlZmVycmVkLnJlamVjdChuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihhY3Rpb24sIHRyYW5zYWN0aW9uLmVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24ub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBjaGVja0ZvckFuZFJlcG9ydGlPU0Vycm9yKGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5yZWplY3QobmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoYWN0aW9uLCBlcnJvcikpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgY29tcGxldGlvblByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbiAgICBhYm9ydChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbkRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ0Fib3J0aW5nIHRyYW5zYWN0aW9uOicsIGVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdDbGllbnQtaW5pdGlhdGVkIGFib3J0Jyk7XG4gICAgICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1heWJlQ29tbWl0KCkge1xuICAgICAgICAvLyBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBWMyBJbmRleGVkREIsIHdlIGludm9rZSBjb21taXQoKSBleHBsaWNpdGx5IHRvXG4gICAgICAgIC8vIHNwZWVkIHVwIGluZGV4IERCIHByb2Nlc3NpbmcgaWYgdGhlIGV2ZW50IGxvb3AgcmVtYWlucyBibG9ja3MuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IG1heWJlVjNJbmRleGVkRGIgPSB0aGlzLnRyYW5zYWN0aW9uO1xuICAgICAgICBpZiAoIXRoaXMuYWJvcnRlZCAmJiB0eXBlb2YgbWF5YmVWM0luZGV4ZWREYi5jb21taXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlVjNJbmRleGVkRGIuY29tbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFNpbXBsZURiU3RvcmU8S2V5VHlwZSwgVmFsdWVUeXBlPiBmb3IgdGhlIHNwZWNpZmllZCBzdG9yZS4gQWxsXG4gICAgICogb3BlcmF0aW9ucyBwZXJmb3JtZWQgb24gdGhlIFNpbXBsZURiU3RvcmUgaGFwcGVuIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGlzXG4gICAgICogdHJhbnNhY3Rpb24gYW5kIGl0IGNhbm5vdCBiZSB1c2VkIGFueW1vcmUgb25jZSB0aGUgdHJhbnNhY3Rpb24gaXNcbiAgICAgKiBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2UgY2FuJ3QgYWN0dWFsbHkgZW5mb3JjZSB0aGF0IHRoZSBLZXlUeXBlIGFuZCBWYWx1ZVR5cGUgYXJlXG4gICAgICogY29ycmVjdCwgYnV0IHRoZXkgYWxsb3cgdHlwZSBzYWZldHkgdGhyb3VnaCB0aGUgcmVzdCBvZiB0aGUgY29uc3VtaW5nIGNvZGUuXG4gICAgICovXG4gICAgc3RvcmUoc3RvcmVOYW1lKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy50cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZURiU3RvcmUoc3RvcmUpO1xuICAgIH1cbn1cbi8qKlxuICogUHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBJbmRleGVkRGIgd2l0aCBhIHNpbXBsaWZpZWQgaW50ZXJmYWNlIHRoYXQgdXNlc1xuICogUHJvbWlzZS1saWtlIHJldHVybiB2YWx1ZXMgdG8gY2hhaW4gb3BlcmF0aW9ucy4gUmVhbCBwcm9taXNlcyBjYW5ub3QgYmUgdXNlZFxuICogc2luY2UgLnRoZW4oKSBjb250aW51YXRpb25zIGFyZSBleGVjdXRlZCBhc3luY2hyb25vdXNseSAoZS5nLiB2aWFcbiAqIC5zZXRJbW1lZGlhdGUpLCB3aGljaCB3b3VsZCBjYXVzZSBJbmRleGVkREIgdG8gZW5kIHRoZSB0cmFuc2FjdGlvbi5cbiAqIFNlZSBQZXJzaXN0ZW5jZVByb21pc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xuY2xhc3MgU2ltcGxlRGIge1xuICAgIC8qKiBEZWxldGVzIHRoZSBzcGVjaWZpZWQgZGF0YWJhc2UuICovXG4gICAgc3RhdGljIGRlbGV0ZShuYW1lKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ1JlbW92aW5nIGRhdGFiYXNlOicsIG5hbWUpO1xuICAgICAgICByZXR1cm4gd3JhcFJlcXVlc3Qod2luZG93LmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShuYW1lKSkudG9Qcm9taXNlKCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgSW5kZXhlZERCIGlzIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gKi9cbiAgICBzdGF0aWMgaXNBdmFpbGFibGUoKSB7XG4gICAgICAgIGlmICghaXNJbmRleGVkREJBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChTaW1wbGVEYi5pc01vY2tQZXJzaXN0ZW5jZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBleHRlbnNpdmVseSB1c2UgaW5kZXhlZCBhcnJheSB2YWx1ZXMgYW5kIGNvbXBvdW5kIGtleXMsXG4gICAgICAgIC8vIHdoaWNoIElFIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0LiBIb3dldmVyLCB0aGV5IHN0aWxsIGhhdmUgaW5kZXhlZERCXG4gICAgICAgIC8vIGRlZmluZWQgb24gdGhlIHdpbmRvdywgc28gd2UgbmVlZCB0byBjaGVjayBmb3IgdGhlbSBoZXJlIGFuZCBtYWtlIHN1cmVcbiAgICAgICAgLy8gdG8gcmV0dXJuIHRoYXQgcGVyc2lzdGVuY2UgaXMgbm90IGVuYWJsZWQgZm9yIHRob3NlIGJyb3dzZXJzLlxuICAgICAgICAvLyBGb3IgdHJhY2tpbmcgc3VwcG9ydCBvZiB0aGlzIGZlYXR1cmUsIHNlZSBoZXJlOlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL3N0YXR1cy9pbmRleGVkZGJhcnJheXNhbmRtdWx0aWVudHJ5c3VwcG9ydC9cbiAgICAgICAgLy8gQ2hlY2sgdGhlIFVBIHN0cmluZyB0byBmaW5kIG91dCB0aGUgYnJvd3Nlci5cbiAgICAgICAgY29uc3QgdWEgPSBnZXRVQSgpO1xuICAgICAgICAvLyBJRSAxMFxuICAgICAgICAvLyB1YSA9ICdNb3ppbGxhLzUuMCAoY29tcGF0aWJsZTsgTVNJRSAxMC4wOyBXaW5kb3dzIE5UIDYuMjsgVHJpZGVudC82LjApJztcbiAgICAgICAgLy8gSUUgMTFcbiAgICAgICAgLy8gdWEgPSAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgNi4zOyBUcmlkZW50LzcuMDsgcnY6MTEuMCkgbGlrZSBHZWNrbyc7XG4gICAgICAgIC8vIEVkZ2VcbiAgICAgICAgLy8gdWEgPSAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV09XNjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsXG4gICAgICAgIC8vIGxpa2UgR2Vja28pIENocm9tZS8zOS4wLjIxNzEuNzEgU2FmYXJpLzUzNy4zNiBFZGdlLzEyLjAnO1xuICAgICAgICAvLyBpT1MgU2FmYXJpOiBEaXNhYmxlIGZvciB1c2VycyBydW5uaW5nIGlPUyB2ZXJzaW9uIDwgMTAuXG4gICAgICAgIGNvbnN0IGlPU1ZlcnNpb24gPSBTaW1wbGVEYi5nZXRJT1NWZXJzaW9uKHVhKTtcbiAgICAgICAgY29uc3QgaXNVbnN1cHBvcnRlZElPUyA9IDAgPCBpT1NWZXJzaW9uICYmIGlPU1ZlcnNpb24gPCAxMDtcbiAgICAgICAgLy8gQW5kcm9pZCBicm93c2VyOiBEaXNhYmxlIGZvciB1c2VycyBydW5uaW5nIHZlcnNpb24gPCA0LjUuXG4gICAgICAgIGNvbnN0IGFuZHJvaWRWZXJzaW9uID0gZ2V0QW5kcm9pZFZlcnNpb24odWEpO1xuICAgICAgICBjb25zdCBpc1Vuc3VwcG9ydGVkQW5kcm9pZCA9IDAgPCBhbmRyb2lkVmVyc2lvbiAmJiBhbmRyb2lkVmVyc2lvbiA8IDQuNTtcbiAgICAgICAgaWYgKHVhLmluZGV4T2YoJ01TSUUgJykgPiAwIHx8XG4gICAgICAgICAgICB1YS5pbmRleE9mKCdUcmlkZW50LycpID4gMCB8fFxuICAgICAgICAgICAgdWEuaW5kZXhPZignRWRnZS8nKSA+IDAgfHxcbiAgICAgICAgICAgIGlzVW5zdXBwb3J0ZWRJT1MgfHxcbiAgICAgICAgICAgIGlzVW5zdXBwb3J0ZWRBbmRyb2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGJhY2tpbmcgSW5kZXhlZERCIHN0b3JlIGlzIHRoZSBOb2RlIEluZGV4ZWREQlNoaW1cbiAgICAgKiAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9heGVtY2xpb24vSW5kZXhlZERCU2hpbSkuXG4gICAgICovXG4gICAgc3RhdGljIGlzTW9ja1BlcnNpc3RlbmNlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAoKF9hID0gcHJvY2Vzcy5lbnYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5VU0VfTU9DS19QRVJTSVNURU5DRSkgPT09ICdZRVMnKTtcbiAgICB9XG4gICAgLyoqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZyb20gYSB0cmFuc2FjdGlvbi4gKi9cbiAgICBzdGF0aWMgZ2V0U3RvcmUodHhuLCBzdG9yZSkge1xuICAgICAgICByZXR1cm4gdHhuLnN0b3JlKHN0b3JlKTtcbiAgICB9XG4gICAgLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xuICAgIC8qKiBQYXJzZSBVc2VyIEFnZW50IHRvIGRldGVybWluZSBpT1MgdmVyc2lvbi4gUmV0dXJucyAtMSBpZiBub3QgZm91bmQuICovXG4gICAgc3RhdGljIGdldElPU1ZlcnNpb24odWEpIHtcbiAgICAgICAgY29uc3QgaU9TVmVyc2lvblJlZ2V4ID0gdWEubWF0Y2goL2koPzpwaG9uZXxwYWR8cG9kKSBvcyAoW1xcZF9dKykvaSk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBpT1NWZXJzaW9uUmVnZXhcbiAgICAgICAgICAgID8gaU9TVmVyc2lvblJlZ2V4WzFdLnNwbGl0KCdfJykuc2xpY2UoMCwgMikuam9pbignLicpXG4gICAgICAgICAgICA6ICctMSc7XG4gICAgICAgIHJldHVybiBOdW1iZXIodmVyc2lvbik7XG4gICAgfVxuICAgIC8qXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTaW1wbGVEYiB3cmFwcGVyIGZvciBJbmRleGVkRGIgZGF0YWJhc2UgYG5hbWVgLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGB2ZXJzaW9uYCBtdXN0IG5vdCBiZSBhIGRvd25ncmFkZS4gSW5kZXhlZERCIGRvZXMgbm90IHN1cHBvcnRcbiAgICAgKiBkb3duZ3JhZGluZyB0aGUgc2NoZW1hIHZlcnNpb24uIFdlIGN1cnJlbnRseSBkbyBub3Qgc3VwcG9ydCBhbnkgd2F5IHRvIGRvXG4gICAgICogdmVyc2lvbmluZyBvdXRzaWRlIG9mIEluZGV4ZWREQidzIHZlcnNpb25pbmcgbWVjaGFuaXNtLCBhcyBvbmx5XG4gICAgICogdmVyc2lvbi11cGdyYWRlIHRyYW5zYWN0aW9ucyBhcmUgYWxsb3dlZCB0byBkbyB0aGluZ3MgbGlrZSBjcmVhdGVcbiAgICAgKiBvYmplY3RzdG9yZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgdmVyc2lvbiwgc2NoZW1hQ29udmVydGVyKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuc2NoZW1hQ29udmVydGVyID0gc2NoZW1hQ29udmVydGVyO1xuICAgICAgICBjb25zdCBpT1NWZXJzaW9uID0gU2ltcGxlRGIuZ2V0SU9TVmVyc2lvbihnZXRVQSgpKTtcbiAgICAgICAgLy8gTk9URTogQWNjb3JkaW5nIHRvIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xOTcwNTAsIHRoZVxuICAgICAgICAvLyBidWcgd2UncmUgY2hlY2tpbmcgZm9yIHNob3VsZCBleGlzdCBpbiBpT1MgPj0gMTIuMiBhbmQgPCAxMywgYnV0IGZvclxuICAgICAgICAvLyB3aGF0ZXZlciByZWFzb24gaXQncyBtdWNoIGhhcmRlciB0byBoaXQgYWZ0ZXIgMTIuMiBzbyB3ZSBvbmx5IHByb2FjdGl2ZWx5XG4gICAgICAgIC8vIGxvZyBvbiAxMi4yLlxuICAgICAgICBpZiAoaU9TVmVyc2lvbiA9PT0gMTIuMikge1xuICAgICAgICAgICAgbG9nRXJyb3IoJ0ZpcmVzdG9yZSBwZXJzaXN0ZW5jZSBzdWZmZXJzIGZyb20gYSBidWcgaW4gaU9TIDEyLjIgJyArXG4gICAgICAgICAgICAgICAgJ1NhZmFyaSB0aGF0IG1heSBjYXVzZSB5b3VyIGFwcCB0byBzdG9wIHdvcmtpbmcuIFNlZSAnICtcbiAgICAgICAgICAgICAgICAnaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzU2NDk2Mjk2LzExMDkxNSBmb3IgZGV0YWlscyAnICtcbiAgICAgICAgICAgICAgICAnYW5kIGEgcG90ZW50aWFsIHdvcmthcm91bmQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIHNwZWNpZmllZCBkYXRhYmFzZSwgY3JlYXRpbmcgb3IgdXBncmFkaW5nIGl0IGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBhc3luYyBlbnN1cmVEYihhY3Rpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLmRiKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdPcGVuaW5nIGRhdGFiYXNlOicsIHRoaXMubmFtZSk7XG4gICAgICAgICAgICB0aGlzLmRiID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8obWlrZWxlaGVuKTogSW52ZXN0aWdhdGUgYnJvd3NlciBjb21wYXRpYmlsaXR5LlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JbmRleGVkREJfQVBJL1VzaW5nX0luZGV4ZWREQlxuICAgICAgICAgICAgICAgIC8vIHN1Z2dlc3RzIElFOSBhbmQgb2xkZXIgV2ViS2l0IGJyb3dzZXJzIGhhbmRsZSB1cGdyYWRlXG4gICAgICAgICAgICAgICAgLy8gZGlmZmVyZW50bHkuIFRoZXkgZXhwZWN0IHNldFZlcnNpb24sIGFzIGRlc2NyaWJlZCBoZXJlOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JREJWZXJzaW9uQ2hhbmdlUmVxdWVzdC9zZXRWZXJzaW9uXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMubmFtZSwgdGhpcy52ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmJsb2NrZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihhY3Rpb24sICdDYW5ub3QgdXBncmFkZSBJbmRleGVkREIgc2NoZW1hIHdoaWxlIGFub3RoZXIgdGFiIGlzIG9wZW4uICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0Nsb3NlIGFsbCB0YWJzIHRoYXQgYWNjZXNzIEZpcmVzdG9yZSBhbmQgcmVsb2FkIHRoaXMgcGFnZSB0byBwcm9jZWVkLicpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGV2ZW50LnRhcmdldC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdWZXJzaW9uRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ0EgbmV3ZXIgdmVyc2lvbiBvZiB0aGUgRmlyZXN0b3JlIFNESyB3YXMgcHJldmlvdXNseSB1c2VkIGFuZCBzbyB0aGUgcGVyc2lzdGVkICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIHZlcnNpb24gb2YgdGhlIFNESyB5b3UgYXJlIG5vdyB1c2luZy4gVGhlIFNESyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnd2lsbCBvcGVyYXRlIHdpdGggcGVyc2lzdGVuY2UgZGlzYWJsZWQuIElmIHlvdSBuZWVkIHBlcnNpc3RlbmNlLCBwbGVhc2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlLXVwZ3JhZGUgdG8gYSBuZXdlciB2ZXJzaW9uIG9mIHRoZSBTREsgb3IgZWxzZSBjbGVhciB0aGUgcGVyc2lzdGVkIEluZGV4ZWREQiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YSBmb3IgeW91ciBhcHAgdG8gc3RhcnQgZnJlc2guJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdJbnZhbGlkU3RhdGVFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnVW5hYmxlIHRvIG9wZW4gYW4gSW5kZXhlZERCIGNvbm5lY3Rpb24uIFRoaXMgY291bGQgYmUgZHVlIHRvIHJ1bm5pbmcgaW4gYSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSBicm93c2luZyBzZXNzaW9uIG9uIGEgYnJvd3NlciB3aG9zZSBwcml2YXRlIGJyb3dzaW5nIHNlc3Npb25zIGRvIG5vdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3VwcG9ydCBJbmRleGVkREI6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoYWN0aW9uLCBlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdEYXRhYmFzZSBcIicgKyB0aGlzLm5hbWUgKyAnXCIgcmVxdWlyZXMgdXBncmFkZSBmcm9tIHZlcnNpb246JywgZXZlbnQub2xkVmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRiID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlbWFDb252ZXJ0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jcmVhdGVPclVwZ3JhZGUoZGIsIHJlcXVlc3QudHJhbnNhY3Rpb24sIGV2ZW50Lm9sZFZlcnNpb24sIHRoaXMudmVyc2lvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ0RhdGFiYXNlIHVwZ3JhZGUgdG8gdmVyc2lvbiAnICsgdGhpcy52ZXJzaW9uICsgJyBjb21wbGV0ZScpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbmNoYW5nZWxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRiLm9udmVyc2lvbmNoYW5nZSA9IGV2ZW50ID0+IHRoaXMudmVyc2lvbmNoYW5nZWxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYjtcbiAgICB9XG4gICAgc2V0VmVyc2lvbkNoYW5nZUxpc3RlbmVyKHZlcnNpb25DaGFuZ2VMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnZlcnNpb25jaGFuZ2VsaXN0ZW5lciA9IHZlcnNpb25DaGFuZ2VMaXN0ZW5lcjtcbiAgICAgICAgaWYgKHRoaXMuZGIpIHtcbiAgICAgICAgICAgIHRoaXMuZGIub252ZXJzaW9uY2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb25DaGFuZ2VMaXN0ZW5lcihldmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJ1blRyYW5zYWN0aW9uKGFjdGlvbiwgbW9kZSwgb2JqZWN0U3RvcmVzLCB0cmFuc2FjdGlvbkZuKSB7XG4gICAgICAgIGNvbnN0IHJlYWRvbmx5ID0gbW9kZSA9PT0gJ3JlYWRvbmx5JztcbiAgICAgICAgbGV0IGF0dGVtcHROdW1iZXIgPSAwO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgKythdHRlbXB0TnVtYmVyO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRiID0gYXdhaXQgdGhpcy5lbnN1cmVEYihhY3Rpb24pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gU2ltcGxlRGJUcmFuc2FjdGlvbi5vcGVuKHRoaXMuZGIsIGFjdGlvbiwgcmVhZG9ubHkgPyAncmVhZG9ubHknIDogJ3JlYWR3cml0ZScsIG9iamVjdFN0b3Jlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25GblJlc3VsdCA9IHRyYW5zYWN0aW9uRm4odHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLm1heWJlQ29tbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWJvcnQgdGhlIHRyYW5zYWN0aW9uIGlmIHRoZXJlIHdhcyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWJvcnQoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW5ub3QgYWN0dWFsbHkgcmVjb3ZlciwgYW5kIGNhbGxpbmcgYGFib3J0KClgIHdpbGwgY2F1c2UgdGhlIHRyYW5zYWN0aW9uJ3NcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcGxldGlvbiBwcm9taXNlIHRvIGJlIHJlamVjdGVkLiBUaGlzIGluIHR1cm4gbWVhbnMgdGhhdCB3ZSB3b24ndCB1c2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYHRyYW5zYWN0aW9uRm5SZXN1bHRgIGJlbG93LiBXZSByZXR1cm4gYSByZWplY3Rpb24gaGVyZSBzbyB0aGF0IHdlIGRvbid0IGFkZCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9zc2liaWxpdHkgb2YgcmV0dXJuaW5nIGB2b2lkYCB0byB0aGUgdHlwZSBvZiBgdHJhbnNhY3Rpb25GblJlc3VsdGAuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudG9Qcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgLy8gQXMgbm90ZWQgYWJvdmUsIGVycm9ycyBhcmUgcHJvcGFnYXRlZCBieSBhYm9ydGluZyB0aGUgdHJhbnNhY3Rpb24uIFNvXG4gICAgICAgICAgICAgICAgLy8gd2Ugc3dhbGxvdyBhbnkgZXJyb3IgaGVyZSB0byBhdm9pZCB0aGUgYnJvd3NlciBsb2dnaW5nIGl0IGFzIHVuaGFuZGxlZC5cbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkZuUmVzdWx0LmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGNvbXBsZXRlIChpLmUuIEluZGV4ZWREYidzIG9uc3VjY2VzcyBldmVudCB0b1xuICAgICAgICAgICAgICAgIC8vIGZpcmUpLCBidXQgc3RpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCB0cmFuc2FjdGlvbkZuUmVzdWx0IGJhY2sgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gY2FsbGVyLlxuICAgICAgICAgICAgICAgIGF3YWl0IHRyYW5zYWN0aW9uLmNvbXBsZXRpb25Qcm9taXNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbkZuUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhzY2htaWR0LXNlYmFzdGlhbik6IFdlIGNvdWxkIHByb2JhYmx5IGJlIHNtYXJ0ZXIgYWJvdXQgdGhpcyBhbmRcbiAgICAgICAgICAgICAgICAvLyBub3QgcmV0cnkgZXhjZXB0aW9ucyB0aGF0IGFyZSBsaWtlbHkgdW5yZWNvdmVyYWJsZSAoc3VjaCBhcyBxdW90YVxuICAgICAgICAgICAgICAgIC8vIGV4Y2VlZGVkIGVycm9ycykuXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogV2UgY2Fubm90IHVzZSBhbiBpbnN0YW5jZW9mIGNoZWNrIGZvciBGaXJlc3RvcmVFeGNlcHRpb24sIHNpbmNlIHRoZVxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBpcyB3cmFwcGVkIGluIGEgZ2VuZXJpYyBlcnJvciBieSBvdXIgYXN5bmMvYXdhaXQgaGFuZGxpbmcuXG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlhYmxlID0gZXJyb3IubmFtZSAhPT0gJ0ZpcmViYXNlRXJyb3InICYmXG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHROdW1iZXIgPCBUUkFOU0FDVElPTl9SRVRSWV9DT1VOVDtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdUcmFuc2FjdGlvbiBmYWlsZWQgd2l0aCBlcnJvcjonLCBlcnJvci5tZXNzYWdlLCAnUmV0cnlpbmc6JywgcmV0cnlhYmxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmRiKSB7XG4gICAgICAgICAgICB0aGlzLmRiLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYiA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKiogUGFyc2UgVXNlciBBZ2VudCB0byBkZXRlcm1pbmUgQW5kcm9pZCB2ZXJzaW9uLiBSZXR1cm5zIC0xIGlmIG5vdCBmb3VuZC4gKi9cbmZ1bmN0aW9uIGdldEFuZHJvaWRWZXJzaW9uKHVhKSB7XG4gICAgY29uc3QgYW5kcm9pZFZlcnNpb25SZWdleCA9IHVhLm1hdGNoKC9BbmRyb2lkIChbXFxkLl0rKS9pKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gYW5kcm9pZFZlcnNpb25SZWdleFxuICAgICAgICA/IGFuZHJvaWRWZXJzaW9uUmVnZXhbMV0uc3BsaXQoJy4nKS5zbGljZSgwLCAyKS5qb2luKCcuJylcbiAgICAgICAgOiAnLTEnO1xuICAgIHJldHVybiBOdW1iZXIodmVyc2lvbik7XG59XG4vKipcbiAqIEEgY29udHJvbGxlciBmb3IgaXRlcmF0aW5nIG92ZXIgYSBrZXkgcmFuZ2Ugb3IgaW5kZXguIEl0IGFsbG93cyBhbiBpdGVyYXRlXG4gKiBjYWxsYmFjayB0byBkZWxldGUgdGhlIGN1cnJlbnRseS1yZWZlcmVuY2VkIG9iamVjdCwgb3IganVtcCB0byBhIG5ldyBrZXlcbiAqIHdpdGhpbiB0aGUga2V5IHJhbmdlIG9yIGluZGV4LlxuICovXG5jbGFzcyBJdGVyYXRpb25Db250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYkN1cnNvcikge1xuICAgICAgICB0aGlzLmRiQ3Vyc29yID0gZGJDdXJzb3I7XG4gICAgICAgIHRoaXMuc2hvdWxkU3RvcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5leHRLZXkgPSBudWxsO1xuICAgIH1cbiAgICBnZXQgaXNEb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG91bGRTdG9wO1xuICAgIH1cbiAgICBnZXQgc2tpcFRvS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0S2V5O1xuICAgIH1cbiAgICBzZXQgY3Vyc29yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGJDdXJzb3IgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIHRvIHN0b3AgaXRlcmF0aW9uIGF0IGFueSBwb2ludC5cbiAgICAgKi9cbiAgICBkb25lKCkge1xuICAgICAgICB0aGlzLnNob3VsZFN0b3AgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgdG8gc2tpcCB0byB0aGF0IG5leHQga2V5LCB3aGljaCBjb3VsZCBiZVxuICAgICAqIGFuIGluZGV4IG9yIGEgcHJpbWFyeSBrZXkuXG4gICAgICovXG4gICAgc2tpcChrZXkpIHtcbiAgICAgICAgdGhpcy5uZXh0S2V5ID0ga2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgdGhlIGN1cnJlbnQgY3Vyc29yIHZhbHVlIGZyb20gdGhlIG9iamVjdCBzdG9yZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFlvdSBDQU5OT1QgZG8gdGhpcyB3aXRoIGEga2V5c09ubHkgcXVlcnkuXG4gICAgICovXG4gICAgZGVsZXRlKCkge1xuICAgICAgICByZXR1cm4gd3JhcFJlcXVlc3QodGhpcy5kYkN1cnNvci5kZWxldGUoKSk7XG4gICAgfVxufVxuLyoqIEFuIGVycm9yIHRoYXQgd3JhcHMgZXhjZXB0aW9ucyB0aGF0IHRocm93biBkdXJpbmcgSW5kZXhlZERCIGV4ZWN1dGlvbi4gKi9cbmNsYXNzIEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IgZXh0ZW5kcyBGaXJlc3RvcmVFcnJvciB7XG4gICAgY29uc3RydWN0b3IoYWN0aW9uTmFtZSwgY2F1c2UpIHtcbiAgICAgICAgc3VwZXIoQ29kZS5VTkFWQUlMQUJMRSwgYEluZGV4ZWREQiB0cmFuc2FjdGlvbiAnJHthY3Rpb25OYW1lfScgZmFpbGVkOiAke2NhdXNlfWApO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcic7XG4gICAgfVxufVxuLyoqIFZlcmlmaWVzIHdoZXRoZXIgYGVgIGlzIGFuIEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IuICovXG5mdW5jdGlvbiBpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkge1xuICAgIC8vIFVzZSBuYW1lIGVxdWFsaXR5LCBhcyBpbnN0YW5jZW9mIGNoZWNrcyBvbiBlcnJvcnMgZG9uJ3Qgd29yayB3aXRoIGVycm9yc1xuICAgIC8vIHRoYXQgd3JhcCBvdGhlciBlcnJvcnMuXG4gICAgcmV0dXJuIGUubmFtZSA9PT0gJ0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3InO1xufVxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIGFuIElEQk9iamVjdFN0b3JlIHByb3ZpZGluZyBhbiBBUEkgdGhhdDpcbiAqXG4gKiAxKSBIYXMgZ2VuZXJpYyBLZXlUeXBlIC8gVmFsdWVUeXBlIHBhcmFtZXRlcnMgdG8gcHJvdmlkZSBzdHJvbmdseS10eXBlZFxuICogbWV0aG9kcyBmb3IgYWN0aW5nIGFnYWluc3QgdGhlIG9iamVjdCBzdG9yZS5cbiAqIDIpIERlYWxzIHdpdGggSW5kZXhlZERCJ3Mgb25zdWNjZXNzIC8gb25lcnJvciBldmVudCBjYWxsYmFja3MsIG1ha2luZyBldmVyeVxuICogbWV0aG9kIHJldHVybiBhIFBlcnNpc3RlbmNlUHJvbWlzZSBpbnN0ZWFkLlxuICogMykgUHJvdmlkZXMgYSBoaWdoZXItbGV2ZWwgQVBJIHRvIGF2b2lkIG5lZWRpbmcgdG8gZG8gZXhjZXNzaXZlIHdyYXBwaW5nIG9mXG4gKiBpbnRlcm1lZGlhdGUgSW5kZXhlZERCIHR5cGVzIChJREJDdXJzb3JXaXRoVmFsdWUsIGV0Yy4pXG4gKi9cbmNsYXNzIFNpbXBsZURiU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKHN0b3JlKSB7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG4gICAgcHV0KGtleU9yVmFsdWUsIHZhbHVlKSB7XG4gICAgICAgIGxldCByZXF1ZXN0O1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnUFVUJywgdGhpcy5zdG9yZS5uYW1lLCBrZXlPclZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXF1ZXN0ID0gdGhpcy5zdG9yZS5wdXQodmFsdWUsIGtleU9yVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnUFVUJywgdGhpcy5zdG9yZS5uYW1lLCAnPGF1dG8ta2V5PicsIGtleU9yVmFsdWUpO1xuICAgICAgICAgICAgcmVxdWVzdCA9IHRoaXMuc3RvcmUucHV0KGtleU9yVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdChyZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyB2YWx1ZSBpbnRvIGFuIE9iamVjdCBTdG9yZSBhbmQgcmV0dXJucyB0aGUgbmV3IGtleS4gU2ltaWxhciB0b1xuICAgICAqIEluZGV4ZWREYidzIGBhZGQoKWAsIHRoaXMgbWV0aG9kIHdpbGwgZmFpbCBvbiBwcmltYXJ5IGtleSBjb2xsaXNpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIG9iamVjdCB0byB3cml0ZS5cbiAgICAgKiBAcmV0dXJucyBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBhZGQuXG4gICAgICovXG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckaSwgJ0FERCcsIHRoaXMuc3RvcmUubmFtZSwgdmFsdWUsIHZhbHVlKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuc3RvcmUuYWRkKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHdyYXBSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBmcm9tIHRoZSBzcGVjaWZpZWQgc3RvcmUsIG9yIG51bGxcbiAgICAgKiBpZiBubyBvYmplY3QgZXhpc3RzIHdpdGggdGhlIHNwZWNpZmllZCBrZXkuXG4gICAgICpcbiAgICAgKiBAa2V5IFRoZSBrZXkgb2YgdGhlIG9iamVjdCB0byBnZXQuXG4gICAgICogQHJldHVybnMgVGhlIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IG9yIG51bGwgaWYgbm8gb2JqZWN0IGV4aXN0cy5cbiAgICAgKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnN0b3JlLmdldChrZXkpO1xuICAgICAgICAvLyBXZSdyZSBkb2luZyBhbiB1bnNhZmUgY2FzdCB0byBWYWx1ZVR5cGUuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdChyZXF1ZXN0KS5uZXh0KHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgbm9uZXhpc3RlbmNlIHRvIG51bGwuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnR0VUJywgdGhpcy5zdG9yZS5uYW1lLCBrZXksIHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdERUxFVEUnLCB0aGlzLnN0b3JlLm5hbWUsIGtleSk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnN0b3JlLmRlbGV0ZShrZXkpO1xuICAgICAgICByZXR1cm4gd3JhcFJlcXVlc3QocmVxdWVzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHdlIGV2ZXIgbmVlZCBtb3JlIG9mIHRoZSBjb3VudCB2YXJpYW50cywgd2UgY2FuIGFkZCBvdmVybG9hZHMuIEZvciBub3csXG4gICAgICogYWxsIHdlIG5lZWQgaXMgdG8gY291bnQgZXZlcnl0aGluZyBpbiBhIHN0b3JlLlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHN0b3JlLlxuICAgICAqL1xuICAgIGNvdW50KCkge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGksICdDT1VOVCcsIHRoaXMuc3RvcmUubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnN0b3JlLmNvdW50KCk7XG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdChyZXF1ZXN0KTtcbiAgICB9XG4gICAgbG9hZEFsbChpbmRleE9yUmFuZ2UsIHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdGVPcHRpb25zID0gdGhpcy5vcHRpb25zKGluZGV4T3JSYW5nZSwgcmFuZ2UpO1xuICAgICAgICAvLyBVc2UgYGdldEFsbCgpYCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBJbmRleGVkREIgdjMsIGFzIGl0IGlzIHJvdWdobHlcbiAgICAgICAgLy8gMjAlIGZhc3Rlci5cbiAgICAgICAgY29uc3Qgc3RvcmUgPSBpdGVyYXRlT3B0aW9ucy5pbmRleFxuICAgICAgICAgICAgPyB0aGlzLnN0b3JlLmluZGV4KGl0ZXJhdGVPcHRpb25zLmluZGV4KVxuICAgICAgICAgICAgOiB0aGlzLnN0b3JlO1xuICAgICAgICBpZiAodHlwZW9mIHN0b3JlLmdldEFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldEFsbChpdGVyYXRlT3B0aW9ucy5yYW5nZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmN1cnNvcihpdGVyYXRlT3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlQ3Vyc29yKGN1cnNvciwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSkubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgZmlyc3QgYGNvdW50YCBlbGVtZW50cyBmcm9tIHRoZSBwcm92aWRlZCBpbmRleCByYW5nZS4gTG9hZHMgYWxsXG4gICAgICogZWxlbWVudHMgaWYgbm8gbGltaXQgaXMgcHJvdmlkZWQuXG4gICAgICovXG4gICAgbG9hZEZpcnN0KHJhbmdlLCBjb3VudCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5zdG9yZS5nZXRBbGwocmFuZ2UsIGNvdW50ID09PSBudWxsID8gdW5kZWZpbmVkIDogY291bnQpO1xuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVsZXRlQWxsKGluZGV4T3JSYW5nZSwgcmFuZ2UpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRpLCAnREVMRVRFIEFMTCcsIHRoaXMuc3RvcmUubmFtZSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMoaW5kZXhPclJhbmdlLCByYW5nZSk7XG4gICAgICAgIG9wdGlvbnMua2V5c09ubHkgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5jdXJzb3Iob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGVDdXJzb3IoY3Vyc29yLCAoa2V5LCB2YWx1ZSwgY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgLy8gTk9URTogQ2FsbGluZyBkZWxldGUoKSBvbiBhIGN1cnNvciBpcyBkb2N1bWVudGVkIGFzIG1vcmUgZWZmaWNpZW50IHRoYW5cbiAgICAgICAgICAgIC8vIGNhbGxpbmcgZGVsZXRlKCkgb24gYW4gb2JqZWN0IHN0b3JlIHdpdGggYSBzaW5nbGUga2V5XG4gICAgICAgICAgICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0lEQk9iamVjdFN0b3JlL2RlbGV0ZSksXG4gICAgICAgICAgICAvLyBob3dldmVyLCB0aGlzIHJlcXVpcmVzIHVzICpub3QqIHRvIHVzZSBhIGtleXNPbmx5IGN1cnNvclxuICAgICAgICAgICAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JREJDdXJzb3IvZGVsZXRlKS4gV2VcbiAgICAgICAgICAgIC8vIG1heSB3YW50IHRvIGNvbXBhcmUgdGhlIHBlcmZvcm1hbmNlIG9mIGVhY2ggbWV0aG9kLlxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2wuZGVsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpdGVyYXRlKG9wdGlvbnNPckNhbGxiYWNrLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgb3B0aW9ucztcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zT3JDYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zT3JDYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmN1cnNvcihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0ZUN1cnNvcihjdXJzb3IsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhIHN0b3JlLCBidXQgd2FpdHMgZm9yIHRoZSBnaXZlbiBjYWxsYmFjayB0byBjb21wbGV0ZSBmb3JcbiAgICAgKiBlYWNoIGVudHJ5IGJlZm9yZSBpdGVyYXRpbmcgdGhlIG5leHQgZW50cnkuIFRoaXMgYWxsb3dzIHRoZSBjYWxsYmFjayB0byBkb1xuICAgICAqIGFzeW5jaHJvbm91cyB3b3JrIHRvIGRldGVybWluZSBpZiB0aGlzIGl0ZXJhdGlvbiBzaG91bGQgY29udGludWUuXG4gICAgICpcbiAgICAgKiBUaGUgcHJvdmlkZWQgY2FsbGJhY2sgc2hvdWxkIHJldHVybiBgdHJ1ZWAgdG8gY29udGludWUgaXRlcmF0aW9uLCBhbmRcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpdGVyYXRlU2VyaWFsKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGN1cnNvclJlcXVlc3QgPSB0aGlzLmN1cnNvcih7fSk7XG4gICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGN1cnNvclJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY2hlY2tGb3JBbmRSZXBvcnRpT1NFcnJvcihldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjdXJzb3IucHJpbWFyeUtleSwgY3Vyc29yLnZhbHVlKS5uZXh0KHNob3VsZENvbnRpbnVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZENvbnRpbnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGl0ZXJhdGVDdXJzb3IoY3Vyc29yUmVxdWVzdCwgZm4pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgSXRlcmF0aW9uQ29udHJvbGxlcihjdXJzb3IpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJSZXN1bHQgPSBmbihjdXJzb3IucHJpbWFyeUtleSwgY3Vyc29yLnZhbHVlLCBjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICBpZiAodXNlclJlc3VsdCBpbnN0YW5jZW9mIFBlcnNpc3RlbmNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyUHJvbWlzZSA9IHVzZXJSZXN1bHQuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh1c2VyUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLmlzRG9uZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRyb2xsZXIuc2tpcFRvS2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKGNvbnRyb2xsZXIuc2tpcFRvS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KS5uZXh0KCgpID0+IFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHJlc3VsdHMpKTtcbiAgICB9XG4gICAgb3B0aW9ucyhpbmRleE9yUmFuZ2UsIHJhbmdlKSB7XG4gICAgICAgIGxldCBpbmRleE5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpbmRleE9yUmFuZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleE9yUmFuZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhOYW1lID0gaW5kZXhPclJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBpbmRleE9yUmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaW5kZXg6IGluZGV4TmFtZSwgcmFuZ2UgfTtcbiAgICB9XG4gICAgY3Vyc29yKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGRpcmVjdGlvbiA9ICduZXh0JztcbiAgICAgICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gJ3ByZXYnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RvcmUuaW5kZXgob3B0aW9ucy5pbmRleCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5rZXlzT25seSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleC5vcGVuS2V5Q3Vyc29yKG9wdGlvbnMucmFuZ2UsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXgub3BlbkN1cnNvcihvcHRpb25zLnJhbmdlLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUub3BlbkN1cnNvcihvcHRpb25zLnJhbmdlLCBkaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBXcmFwcyBhbiBJREJSZXF1ZXN0IGluIGEgUGVyc2lzdGVuY2VQcm9taXNlLCB1c2luZyB0aGUgb25zdWNjZXNzIC8gb25lcnJvclxuICogaGFuZGxlcnMgdG8gcmVzb2x2ZSAvIHJlamVjdCB0aGUgUGVyc2lzdGVuY2VQcm9taXNlIGFzIGFwcHJvcHJpYXRlLlxuICovXG5mdW5jdGlvbiB3cmFwUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGNoZWNrRm9yQW5kUmVwb3J0aU9TRXJyb3IoZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG4vLyBHdWFyZCBzbyB3ZSBvbmx5IHJlcG9ydCB0aGUgZXJyb3Igb25jZS5cbmxldCByZXBvcnRlZElPU0Vycm9yID0gZmFsc2U7XG5mdW5jdGlvbiBjaGVja0ZvckFuZFJlcG9ydGlPU0Vycm9yKGVycm9yKSB7XG4gICAgY29uc3QgaU9TVmVyc2lvbiA9IFNpbXBsZURiLmdldElPU1ZlcnNpb24oZ2V0VUEoKSk7XG4gICAgaWYgKGlPU1ZlcnNpb24gPj0gMTIuMiAmJiBpT1NWZXJzaW9uIDwgMTMpIHtcbiAgICAgICAgY29uc3QgSU9TX0VSUk9SID0gJ0FuIGludGVybmFsIGVycm9yIHdhcyBlbmNvdW50ZXJlZCBpbiB0aGUgSW5kZXhlZCBEYXRhYmFzZSBzZXJ2ZXInO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmRleE9mKElPU19FUlJPUikgPj0gMCkge1xuICAgICAgICAgICAgLy8gV3JhcCBlcnJvciBpbiBhIG1vcmUgZGVzY3JpcHRpdmUgb25lLlxuICAgICAgICAgICAgY29uc3QgbmV3RXJyb3IgPSBuZXcgRmlyZXN0b3JlRXJyb3IoJ2ludGVybmFsJywgYElPU19JTkRFWEVEREJfQlVHMTogSW5kZXhlZERiIGhhcyB0aHJvd24gJyR7SU9TX0VSUk9SfScuIFRoaXMgaXMgbGlrZWx5IGAgK1xuICAgICAgICAgICAgICAgIGBkdWUgdG8gYW4gdW5hdm9pZGFibGUgYnVnIGluIGlPUy4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS81NjQ5NjI5Ni8xMTA5MTUgYCArXG4gICAgICAgICAgICAgICAgYGZvciBkZXRhaWxzIGFuZCBhIHBvdGVudGlhbCB3b3JrYXJvdW5kLmApO1xuICAgICAgICAgICAgaWYgKCFyZXBvcnRlZElPU0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0ZWRJT1NFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgYSBnbG9iYWwgZXhjZXB0aW9uIG91dHNpZGUgb2YgdGhpcyBwcm9taXNlIGNoYWluLCBmb3IgdGhlIHVzZXIgdG9cbiAgICAgICAgICAgICAgICAvLyBwb3RlbnRpYWxseSBjYXRjaC5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3RXJyb3I7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3RXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufVxuXG5jb25zdCBMT0dfVEFHJGggPSAnSW5kZXhCYWNrZmlsbGVyJztcbi8qKiBIb3cgbG9uZyB3ZSB3YWl0IHRvIHRyeSBydW5uaW5nIGluZGV4IGJhY2tmaWxsIGFmdGVyIFNESyBpbml0aWFsaXphdGlvbi4gKi9cbmNvbnN0IElOSVRJQUxfQkFDS0ZJTExfREVMQVlfTVMgPSAxNSAqIDEwMDA7XG4vKiogTWluaW11bSBhbW91bnQgb2YgdGltZSBiZXR3ZWVuIGJhY2tmaWxsIGNoZWNrcywgYWZ0ZXIgdGhlIGZpcnN0IG9uZS4gKi9cbmNvbnN0IFJFR1VMQVJfQkFDS0ZJTExfREVMQVlfTVMgPSA2MCAqIDEwMDA7XG4vKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGRvY3VtZW50cyB0byBwcm9jZXNzIGVhY2ggdGltZSBiYWNrZmlsbCgpIGlzIGNhbGxlZC4gKi9cbmNvbnN0IE1BWF9ET0NVTUVOVFNfVE9fUFJPQ0VTUyA9IDUwO1xuLyoqIFRoaXMgY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIHRoZSBzY2hlZHVsaW5nIG9mIEluZGV4IEJhY2tmaWxsZXIuICovXG5jbGFzcyBJbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIge1xuICAgIGNvbnN0cnVjdG9yKGFzeW5jUXVldWUsIGJhY2tmaWxsZXIpIHtcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcbiAgICAgICAgdGhpcy5iYWNrZmlsbGVyID0gYmFja2ZpbGxlcjtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoSU5JVElBTF9CQUNLRklMTF9ERUxBWV9NUyk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLnRhc2spIHtcbiAgICAgICAgICAgIHRoaXMudGFzay5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHN0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhc2sgIT09IG51bGw7XG4gICAgfVxuICAgIHNjaGVkdWxlKGRlbGF5KSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgYFNjaGVkdWxlZCBpbiAke2RlbGF5fW1zYCk7XG4gICAgICAgIHRoaXMudGFzayA9IHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheShcImluZGV4X2JhY2tmaWxsXCIgLyogVGltZXJJZC5JbmRleEJhY2tmaWxsICovLCBkZWxheSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRzUHJvY2Vzc2VkID0gYXdhaXQgdGhpcy5iYWNrZmlsbGVyLmJhY2tmaWxsKCk7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRoLCBgRG9jdW1lbnRzIHdyaXR0ZW46ICR7ZG9jdW1lbnRzUHJvY2Vzc2VkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgJ0lnbm9yaW5nIEluZGV4ZWREQiBlcnJvciBkdXJpbmcgaW5kZXggYmFja2ZpbGw6ICcsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2NoZWR1bGUoUkVHVUxBUl9CQUNLRklMTF9ERUxBWV9NUyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBJbXBsZW1lbnRzIHRoZSBzdGVwcyBmb3IgYmFja2ZpbGxpbmcgaW5kZXhlcy4gKi9cbmNsYXNzIEluZGV4QmFja2ZpbGxlciB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogTG9jYWxTdG9yZSBwcm92aWRlcyBhY2Nlc3MgdG8gSW5kZXhNYW5hZ2VyIGFuZCBMb2NhbERvY3VtZW50Vmlldy5cbiAgICAgKiBUaGVzZSBwcm9wZXJ0aWVzIHdpbGwgdXBkYXRlIHdoZW4gdGhlIHVzZXIgY2hhbmdlcy4gQ29uc2VxdWVudGx5LFxuICAgICAqIG1ha2luZyBhIGxvY2FsIGNvcHkgb2YgSW5kZXhNYW5hZ2VyIGFuZCBMb2NhbERvY3VtZW50VmlldyB3aWxsIHJlcXVpcmVcbiAgICAgKiB1cGRhdGVzIG92ZXIgdGltZS4gVGhlIHNpbXBsZXIgc29sdXRpb24gaXMgdG8gcmVseSBvbiBMb2NhbFN0b3JlIHRvIGhhdmVcbiAgICAgKiBhbiB1cC10by1kYXRlIHJlZmVyZW5jZXMgdG8gSW5kZXhNYW5hZ2VyIGFuZCBMb2NhbERvY3VtZW50U3RvcmUuXG4gICAgICovXG4gICAgbG9jYWxTdG9yZSwgcGVyc2lzdGVuY2UpIHtcbiAgICAgICAgdGhpcy5sb2NhbFN0b3JlID0gbG9jYWxTdG9yZTtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xuICAgIH1cbiAgICBhc3luYyBiYWNrZmlsbChtYXhEb2N1bWVudHNUb1Byb2Nlc3MgPSBNQVhfRE9DVU1FTlRTX1RPX1BST0NFU1MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0JhY2tmaWxsIEluZGV4ZXMnLCAncmVhZHdyaXRlLXByaW1hcnknLCB0eG4gPT4gdGhpcy53cml0ZUluZGV4RW50cmllcyh0eG4sIG1heERvY3VtZW50c1RvUHJvY2VzcykpO1xuICAgIH1cbiAgICAvKiogV3JpdGVzIGluZGV4IGVudHJpZXMgdW50aWwgdGhlIGNhcCBpcyByZWFjaGVkLiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHByb2Nlc3NlZC4gKi9cbiAgICB3cml0ZUluZGV4RW50cmllcyh0cmFuc2FjdGlvbiwgbWF4RG9jdW1lbnRzVG9Qcm9jZXNzKSB7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZENvbGxlY3Rpb25Hcm91cHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCBkb2N1bWVudHNSZW1haW5pbmcgPSBtYXhEb2N1bWVudHNUb1Byb2Nlc3M7XG4gICAgICAgIGxldCBjb250aW51ZUxvb3AgPSB0cnVlO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmRvV2hpbGUoKCkgPT4gY29udGludWVMb29wID09PSB0cnVlICYmIGRvY3VtZW50c1JlbWFpbmluZyA+IDAsICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RvcmUuaW5kZXhNYW5hZ2VyXG4gICAgICAgICAgICAgICAgLmdldE5leHRDb2xsZWN0aW9uR3JvdXBUb1VwZGF0ZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAubmV4dCgoY29sbGVjdGlvbkdyb3VwKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25Hcm91cCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRDb2xsZWN0aW9uR3JvdXBzLmhhcyhjb2xsZWN0aW9uR3JvdXApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlTG9vcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRoLCBgUHJvY2Vzc2luZyBjb2xsZWN0aW9uOiAke2NvbGxlY3Rpb25Hcm91cH1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVFbnRyaWVzRm9yQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIGRvY3VtZW50c1JlbWFpbmluZykubmV4dChkb2N1bWVudHNQcm9jZXNzZWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRzUmVtYWluaW5nIC09IGRvY3VtZW50c1Byb2Nlc3NlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZENvbGxlY3Rpb25Hcm91cHMuYWRkKGNvbGxlY3Rpb25Hcm91cCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5uZXh0KCgpID0+IG1heERvY3VtZW50c1RvUHJvY2VzcyAtIGRvY3VtZW50c1JlbWFpbmluZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBlbnRyaWVzIGZvciB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbiBncm91cC4gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBwcm9jZXNzZWQuXG4gICAgICovXG4gICAgd3JpdGVFbnRyaWVzRm9yQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIGRvY3VtZW50c1JlbWFpbmluZ1VuZGVyQ2FwKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgZWFybGllc3Qgb2Zmc2V0IG9mIGFsbCBmaWVsZCBpbmRleGVzIHRvIHF1ZXJ5IHRoZSBsb2NhbCBjYWNoZS5cbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yZS5pbmRleE1hbmFnZXJcbiAgICAgICAgICAgIC5nZXRNaW5PZmZzZXRGcm9tQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApXG4gICAgICAgICAgICAubmV4dChleGlzdGluZ09mZnNldCA9PiB0aGlzLmxvY2FsU3RvcmUubG9jYWxEb2N1bWVudHNcbiAgICAgICAgICAgIC5nZXROZXh0RG9jdW1lbnRzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIGV4aXN0aW5nT2Zmc2V0LCBkb2N1bWVudHNSZW1haW5pbmdVbmRlckNhcClcbiAgICAgICAgICAgIC5uZXh0KG5leHRCYXRjaCA9PiB7XG4gICAgICAgICAgICBjb25zdCBkb2NzID0gbmV4dEJhdGNoLmNoYW5nZXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JlLmluZGV4TWFuYWdlclxuICAgICAgICAgICAgICAgIC51cGRhdGVJbmRleEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3MpXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gdGhpcy5nZXROZXdPZmZzZXQoZXhpc3RpbmdPZmZzZXQsIG5leHRCYXRjaCkpXG4gICAgICAgICAgICAgICAgLm5leHQobmV3T2Zmc2V0ID0+IHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGgsIGBVcGRhdGluZyBvZmZzZXQ6ICR7bmV3T2Zmc2V0fWApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RvcmUuaW5kZXhNYW5hZ2VyLnVwZGF0ZUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBuZXdPZmZzZXQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiBkb2NzLnNpemUpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRoZSBuZXh0IG9mZnNldCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZG9jdW1lbnRzLiAqL1xuICAgIGdldE5ld09mZnNldChleGlzdGluZ09mZnNldCwgbG9va3VwUmVzdWx0KSB7XG4gICAgICAgIGxldCBtYXhPZmZzZXQgPSBleGlzdGluZ09mZnNldDtcbiAgICAgICAgbG9va3VwUmVzdWx0LmNoYW5nZXMuZm9yRWFjaCgoa2V5LCBkb2N1bWVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3T2Zmc2V0ID0gbmV3SW5kZXhPZmZzZXRGcm9tRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICAgICAgaWYgKGluZGV4T2Zmc2V0Q29tcGFyYXRvcihuZXdPZmZzZXQsIG1heE9mZnNldCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgbWF4T2Zmc2V0ID0gbmV3T2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE9mZnNldChtYXhPZmZzZXQucmVhZFRpbWUsIG1heE9mZnNldC5kb2N1bWVudEtleSwgTWF0aC5tYXgobG9va3VwUmVzdWx0LmJhdGNoSWQsIGV4aXN0aW5nT2Zmc2V0Lmxhcmdlc3RCYXRjaElkKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBgTGlzdGVuU2VxdWVuY2VgIGlzIGEgbW9ub3RvbmljIHNlcXVlbmNlLiBJdCBpcyBpbml0aWFsaXplZCB3aXRoIGEgbWluaW11bSB2YWx1ZSB0b1xuICogZXhjZWVkLiBBbGwgc3Vic2VxdWVudCBjYWxscyB0byBuZXh0IHdpbGwgcmV0dXJuIGluY3JlYXNpbmcgdmFsdWVzLiBJZiBwcm92aWRlZCB3aXRoIGFcbiAqIGBTZXF1ZW5jZU51bWJlclN5bmNlcmAsIGl0IHdpbGwgYWRkaXRpb25hbGx5IGJ1bXAgaXRzIG5leHQgdmFsdWUgd2hlbiB0b2xkIG9mIGEgbmV3IHZhbHVlLCBhc1xuICogd2VsbCBhcyB3cml0ZSBvdXQgc2VxdWVuY2UgbnVtYmVycyB0aGF0IGl0IHByb2R1Y2VzIHZpYSBgbmV4dCgpYC5cbiAqL1xuY2xhc3MgTGlzdGVuU2VxdWVuY2Uge1xuICAgIGNvbnN0cnVjdG9yKHByZXZpb3VzVmFsdWUsIHNlcXVlbmNlTnVtYmVyU3luY2VyKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzVmFsdWU7XG4gICAgICAgIGlmIChzZXF1ZW5jZU51bWJlclN5bmNlcikge1xuICAgICAgICAgICAgc2VxdWVuY2VOdW1iZXJTeW5jZXIuc2VxdWVuY2VOdW1iZXJIYW5kbGVyID0gc2VxdWVuY2VOdW1iZXIgPT4gdGhpcy5zZXRQcmV2aW91c1ZhbHVlKHNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVOZXdTZXF1ZW5jZU51bWJlciA9IHNlcXVlbmNlTnVtYmVyID0+IHNlcXVlbmNlTnVtYmVyU3luY2VyLndyaXRlU2VxdWVuY2VOdW1iZXIoc2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFByZXZpb3VzVmFsdWUoZXh0ZXJuYWxQcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNWYWx1ZSA9IE1hdGgubWF4KGV4dGVybmFsUHJldmlvdXNWYWx1ZSwgdGhpcy5wcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXNWYWx1ZTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gKyt0aGlzLnByZXZpb3VzVmFsdWU7XG4gICAgICAgIGlmICh0aGlzLndyaXRlTmV3U2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVOZXdTZXF1ZW5jZU51bWJlcihuZXh0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0VmFsdWU7XG4gICAgfVxufVxuTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCA9IC0xO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgZXNjYXBlQ2hhciA9ICdcXHUwMDAxJztcbmNvbnN0IGVuY29kZWRTZXBhcmF0b3JDaGFyID0gJ1xcdTAwMDEnO1xuY29uc3QgZW5jb2RlZE51bCA9ICdcXHUwMDEwJztcbmNvbnN0IGVuY29kZWRFc2NhcGUgPSAnXFx1MDAxMSc7XG4vKipcbiAqIEVuY29kZXMgYSByZXNvdXJjZSBwYXRoIGludG8gYSBJbmRleGVkRGItY29tcGF0aWJsZSBzdHJpbmcgZm9ybS5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlUmVzb3VyY2VQYXRoKHBhdGgpIHtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZW5jb2RlU2VwYXJhdG9yKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gZW5jb2RlU2VnbWVudChwYXRoLmdldChpKSwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZVNlcGFyYXRvcihyZXN1bHQpO1xufVxuLyoqIEVuY29kZXMgYSBzaW5nbGUgc2VnbWVudCBvZiBhIHJlc291cmNlIHBhdGggaW50byB0aGUgZ2l2ZW4gcmVzdWx0ICovXG5mdW5jdGlvbiBlbmNvZGVTZWdtZW50KHNlZ21lbnQsIHJlc3VsdEJ1Zikge1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRCdWY7XG4gICAgY29uc3QgbGVuZ3RoID0gc2VnbWVudC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gc2VnbWVudC5jaGFyQXQoaSk7XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgY2FzZSAnXFwwJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlQ2hhciArIGVuY29kZWROdWw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGVzY2FwZUNoYXI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZUNoYXIgKyBlbmNvZGVkRXNjYXBlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gYztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqIEVuY29kZXMgYSBwYXRoIHNlcGFyYXRvciBpbnRvIHRoZSBnaXZlbiByZXN1bHQgKi9cbmZ1bmN0aW9uIGVuY29kZVNlcGFyYXRvcihyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlQ2hhciArIGVuY29kZWRTZXBhcmF0b3JDaGFyO1xufVxuLyoqXG4gKiBEZWNvZGVzIHRoZSBnaXZlbiBJbmRleGVkRGItY29tcGF0aWJsZSBzdHJpbmcgZm9ybSBvZiBhIHJlc291cmNlIHBhdGggaW50b1xuICogYSBSZXNvdXJjZVBhdGggaW5zdGFuY2UuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBub3Qgc3VpdGFibGUgZm9yIHVzZSB3aXRoXG4gKiBkZWNvZGluZyByZXNvdXJjZSBuYW1lcyBmcm9tIHRoZSBzZXJ2ZXI7IHRob3NlIGFyZSBPbmUgUGxhdGZvcm0gZm9ybWF0XG4gKiBzdHJpbmdzLlxuICovXG5mdW5jdGlvbiBkZWNvZGVSZXNvdXJjZVBhdGgocGF0aCkge1xuICAgIC8vIEV2ZW50IHRoZSBlbXB0eSBwYXRoIG11c3QgZW5jb2RlIGFzIGEgcGF0aCBvZiBhdCBsZWFzdCBsZW5ndGggMi4gQSBwYXRoXG4gICAgLy8gd2l0aCBleGFjdGx5IDIgbXVzdCBiZSB0aGUgZW1wdHkgcGF0aC5cbiAgICBjb25zdCBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICBoYXJkQXNzZXJ0KGxlbmd0aCA+PSAyKTtcbiAgICBpZiAobGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGhhcmRBc3NlcnQocGF0aC5jaGFyQXQoMCkgPT09IGVzY2FwZUNoYXIgJiYgcGF0aC5jaGFyQXQoMSkgPT09IGVuY29kZWRTZXBhcmF0b3JDaGFyKTtcbiAgICAgICAgcmV0dXJuIFJlc291cmNlUGF0aC5lbXB0eVBhdGgoKTtcbiAgICB9XG4gICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgY2Fubm90IGV4aXN0IHBhc3QgdGhlIHNlY29uZC10by1sYXN0IHBvc2l0aW9uIGluIHRoZVxuICAgIC8vIHNvdXJjZSB2YWx1ZS5cbiAgICBjb25zdCBsYXN0UmVhc29uYWJsZUVzY2FwZUluZGV4ID0gbGVuZ3RoIC0gMjtcbiAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICAgIGxldCBzZWdtZW50QnVpbGRlciA9ICcnO1xuICAgIGZvciAobGV0IHN0YXJ0ID0gMDsgc3RhcnQgPCBsZW5ndGg7KSB7XG4gICAgICAgIC8vIFRoZSBsYXN0IHR3byBjaGFyYWN0ZXJzIG9mIGEgdmFsaWQgZW5jb2RlZCBwYXRoIG11c3QgYmUgYSBzZXBhcmF0b3IsIHNvXG4gICAgICAgIC8vIHRoZXJlIG11c3QgYmUgYW4gZW5kIHRvIHRoaXMgc2VnbWVudC5cbiAgICAgICAgY29uc3QgZW5kID0gcGF0aC5pbmRleE9mKGVzY2FwZUNoYXIsIHN0YXJ0KTtcbiAgICAgICAgaWYgKGVuZCA8IDAgfHwgZW5kID4gbGFzdFJlYXNvbmFibGVFc2NhcGVJbmRleCkge1xuICAgICAgICAgICAgZmFpbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHQgPSBwYXRoLmNoYXJBdChlbmQgKyAxKTtcbiAgICAgICAgc3dpdGNoIChuZXh0KSB7XG4gICAgICAgICAgICBjYXNlIGVuY29kZWRTZXBhcmF0b3JDaGFyOlxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQaWVjZSA9IHBhdGguc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIGxldCBzZWdtZW50O1xuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50QnVpbGRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgY29weWluZyBmb3IgdGhlIGNvbW1vbiBjYXNlIG9mIGEgc2VnbWVudCB0aGF0IGV4Y2x1ZGVzIFxcMFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgXFwwMDFcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudCA9IGN1cnJlbnRQaWVjZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRCdWlsZGVyICs9IGN1cnJlbnRQaWVjZTtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudCA9IHNlZ21lbnRCdWlsZGVyO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50QnVpbGRlciA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBlbmNvZGVkTnVsOlxuICAgICAgICAgICAgICAgIHNlZ21lbnRCdWlsZGVyICs9IHBhdGguc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRCdWlsZGVyICs9ICdcXDAnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBlbmNvZGVkRXNjYXBlOlxuICAgICAgICAgICAgICAgIC8vIFRoZSBlc2NhcGUgY2hhcmFjdGVyIGNhbiBiZSB1c2VkIGluIHRoZSBvdXRwdXQgdG8gZW5jb2RlIGl0c2VsZi5cbiAgICAgICAgICAgICAgICBzZWdtZW50QnVpbGRlciArPSBwYXRoLnN1YnN0cmluZyhzdGFydCwgZW5kICsgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IGVuZCArIDI7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVzb3VyY2VQYXRoKHNlZ21lbnRzKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxID0gJ3JlbW90ZURvY3VtZW50cyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBuYW1lICdvd25lcicgaXMgY2hvc2VuIHRvIGVuc3VyZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoXG4gKiBvbGRlciBjbGllbnRzIHRoYXQgb25seSBzdXBwb3J0ZWQgc2luZ2xlIGxvY2tlZCBhY2Nlc3MgdG8gdGhlIHBlcnNpc3RlbmNlXG4gKiBsYXllci5cbiAqL1xuY29uc3QgRGJQcmltYXJ5Q2xpZW50U3RvcmUgPSAnb3duZXInO1xuLyoqXG4gKiBUaGUga2V5IHN0cmluZyB1c2VkIGZvciB0aGUgc2luZ2xlIG9iamVjdCB0aGF0IGV4aXN0cyBpbiB0aGVcbiAqIERiUHJpbWFyeUNsaWVudCBzdG9yZS5cbiAqL1xuY29uc3QgRGJQcmltYXJ5Q2xpZW50S2V5ID0gJ293bmVyJztcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAgKi9cbmNvbnN0IERiTXV0YXRpb25RdWV1ZVN0b3JlID0gJ211dGF0aW9uUXVldWVzJztcbi8qKiBLZXlzIGFyZSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHZpYSB0aGUgdXNlcklkIHByb3BlcnR5LiAqL1xuY29uc3QgRGJNdXRhdGlvblF1ZXVlS2V5UGF0aCA9ICd1c2VySWQnO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICAqL1xuY29uc3QgRGJNdXRhdGlvbkJhdGNoU3RvcmUgPSAnbXV0YXRpb25zJztcbi8qKiBLZXlzIGFyZSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHZpYSB0aGUgdXNlcklkLCBiYXRjaElkIHByb3BlcnRpZXMuICovXG5jb25zdCBEYk11dGF0aW9uQmF0Y2hLZXlQYXRoID0gJ2JhdGNoSWQnO1xuLyoqIFRoZSBpbmRleCBuYW1lIGZvciBsb29rdXAgb2YgbXV0YXRpb25zIGJ5IHVzZXIuICovXG5jb25zdCBEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zSW5kZXggPSAndXNlck11dGF0aW9uc0luZGV4Jztcbi8qKiBUaGUgdXNlciBtdXRhdGlvbnMgaW5kZXggaXMga2V5ZWQgYnkgW3VzZXJJZCwgYmF0Y2hJZF0gcGFpcnMuICovXG5jb25zdCBEYk11dGF0aW9uQmF0Y2hVc2VyTXV0YXRpb25zS2V5UGF0aCA9IFsndXNlcklkJywgJ2JhdGNoSWQnXTtcbi8qKlxuICogQ3JlYXRlcyBhIFt1c2VySWRdIGtleSBmb3IgdXNlIGluIHRoZSBEYkRvY3VtZW50TXV0YXRpb25zIGluZGV4IHRvIGl0ZXJhdGVcbiAqIG92ZXIgYWxsIG9mIGEgdXNlcidzIGRvY3VtZW50IG11dGF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbmV3RGJEb2N1bWVudE11dGF0aW9uUHJlZml4Rm9yVXNlcih1c2VySWQpIHtcbiAgICByZXR1cm4gW3VzZXJJZF07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBbdXNlcklkLCBlbmNvZGVkUGF0aF0ga2V5IGZvciB1c2UgaW4gdGhlIERiRG9jdW1lbnRNdXRhdGlvbnNcbiAqIGluZGV4IHRvIGl0ZXJhdGUgb3ZlciBhbGwgYXQgZG9jdW1lbnQgbXV0YXRpb25zIGZvciBhIGdpdmVuIHBhdGggb3IgbG93ZXIuXG4gKi9cbmZ1bmN0aW9uIG5ld0RiRG9jdW1lbnRNdXRhdGlvblByZWZpeEZvclBhdGgodXNlcklkLCBwYXRoKSB7XG4gICAgcmV0dXJuIFt1c2VySWQsIGVuY29kZVJlc291cmNlUGF0aChwYXRoKV07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBmdWxsIGluZGV4IGtleSBvZiBbdXNlcklkLCBlbmNvZGVkUGF0aCwgYmF0Y2hJZF0gZm9yIGluc2VydGluZ1xuICogYW5kIGRlbGV0aW5nIGludG8gdGhlIERiRG9jdW1lbnRNdXRhdGlvbnMgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIG5ld0RiRG9jdW1lbnRNdXRhdGlvbktleSh1c2VySWQsIHBhdGgsIGJhdGNoSWQpIHtcbiAgICByZXR1cm4gW3VzZXJJZCwgZW5jb2RlUmVzb3VyY2VQYXRoKHBhdGgpLCBiYXRjaElkXTtcbn1cbi8qKlxuICogQmVjYXVzZSB3ZSBzdG9yZSBhbGwgdGhlIHVzZWZ1bCBpbmZvcm1hdGlvbiBmb3IgdGhpcyBzdG9yZSBpbiB0aGUga2V5LFxuICogdGhlcmUgaXMgbm8gdXNlZnVsIGluZm9ybWF0aW9uIHRvIHN0b3JlIGFzIHRoZSB2YWx1ZS4gVGhlIHJhdyAodW5lbmNvZGVkKVxuICogcGF0aCBjYW5ub3QgYmUgc3RvcmVkIGJlY2F1c2UgSW5kZXhlZERiIGRvZXNuJ3Qgc3RvcmUgcHJvdG90eXBlXG4gKiBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgRGJEb2N1bWVudE11dGF0aW9uUGxhY2Vob2xkZXIgPSB7fTtcbmNvbnN0IERiRG9jdW1lbnRNdXRhdGlvblN0b3JlID0gJ2RvY3VtZW50TXV0YXRpb25zJztcbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRTdG9yZSA9ICdyZW1vdGVEb2N1bWVudHNWMTQnO1xuLyoqXG4gKiBUaGUgcHJpbWFyeSBrZXkgb2YgdGhlIHJlbW90ZSBkb2N1bWVudHMgc3RvcmUsIHdoaWNoIGFsbG93cyBmb3IgZWZmaWNpZW50XG4gKiBhY2Nlc3MgYnkgY29sbGVjdGlvbiBwYXRoIGFuZCByZWFkIHRpbWUuXG4gKi9cbmNvbnN0IERiUmVtb3RlRG9jdW1lbnRLZXlQYXRoID0gW1xuICAgICdwcmVmaXhQYXRoJyxcbiAgICAnY29sbGVjdGlvbkdyb3VwJyxcbiAgICAncmVhZFRpbWUnLFxuICAgICdkb2N1bWVudElkJ1xuXTtcbi8qKiBBbiBpbmRleCB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byBkb2N1bWVudHMgYnkga2V5LiAqL1xuY29uc3QgRGJSZW1vdGVEb2N1bWVudERvY3VtZW50S2V5SW5kZXggPSAnZG9jdW1lbnRLZXlJbmRleCc7XG5jb25zdCBEYlJlbW90ZURvY3VtZW50RG9jdW1lbnRLZXlJbmRleFBhdGggPSBbXG4gICAgJ3ByZWZpeFBhdGgnLFxuICAgICdjb2xsZWN0aW9uR3JvdXAnLFxuICAgICdkb2N1bWVudElkJ1xuXTtcbi8qKlxuICogQW4gaW5kZXggdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gZG9jdW1lbnRzIGJ5IGNvbGxlY3Rpb24gZ3JvdXAgYW5kIHJlYWRcbiAqIHRpbWUuXG4gKlxuICogVGhpcyBpbmRleCBpcyB1c2VkIGJ5IHRoZSBpbmRleCBiYWNrZmlsbGVyLlxuICovXG5jb25zdCBEYlJlbW90ZURvY3VtZW50Q29sbGVjdGlvbkdyb3VwSW5kZXggPSAnY29sbGVjdGlvbkdyb3VwSW5kZXgnO1xuY29uc3QgRGJSZW1vdGVEb2N1bWVudENvbGxlY3Rpb25Hcm91cEluZGV4UGF0aCA9IFtcbiAgICAnY29sbGVjdGlvbkdyb3VwJyxcbiAgICAncmVhZFRpbWUnLFxuICAgICdwcmVmaXhQYXRoJyxcbiAgICAnZG9jdW1lbnRJZCdcbl07XG5jb25zdCBEYlJlbW90ZURvY3VtZW50R2xvYmFsU3RvcmUgPSAncmVtb3RlRG9jdW1lbnRHbG9iYWwnO1xuY29uc3QgRGJSZW1vdGVEb2N1bWVudEdsb2JhbEtleSA9ICdyZW1vdGVEb2N1bWVudEdsb2JhbEtleSc7XG5jb25zdCBEYlRhcmdldFN0b3JlID0gJ3RhcmdldHMnO1xuLyoqIEtleXMgYXJlIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdmlhIHRoZSB0YXJnZXRJZCBwcm9wZXJ0eS4gKi9cbmNvbnN0IERiVGFyZ2V0S2V5UGF0aCA9ICd0YXJnZXRJZCc7XG4vKiogVGhlIG5hbWUgb2YgdGhlIHF1ZXJ5VGFyZ2V0cyBpbmRleC4gKi9cbmNvbnN0IERiVGFyZ2V0UXVlcnlUYXJnZXRzSW5kZXhOYW1lID0gJ3F1ZXJ5VGFyZ2V0c0luZGV4Jztcbi8qKlxuICogVGhlIGluZGV4IG9mIGFsbCBjYW5vbmljYWxJZHMgdG8gdGhlIHRhcmdldHMgdGhhdCB0aGV5IG1hdGNoLiBUaGlzIGlzIG5vdFxuICogYSB1bmlxdWUgbWFwcGluZyBiZWNhdXNlIGNhbm9uaWNhbElkIGRvZXMgbm90IHByb21pc2UgYSB1bmlxdWUgbmFtZSBmb3IgYWxsXG4gKiBwb3NzaWJsZSBxdWVyaWVzLCBzbyB3ZSBhcHBlbmQgdGhlIHRhcmdldElkIHRvIG1ha2UgdGhlIG1hcHBpbmcgdW5pcXVlLlxuICovXG5jb25zdCBEYlRhcmdldFF1ZXJ5VGFyZ2V0c0tleVBhdGggPSBbJ2Nhbm9uaWNhbElkJywgJ3RhcmdldElkJ107XG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gICovXG5jb25zdCBEYlRhcmdldERvY3VtZW50U3RvcmUgPSAndGFyZ2V0RG9jdW1lbnRzJztcbi8qKiBLZXlzIGFyZSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHZpYSB0aGUgdGFyZ2V0SWQsIHBhdGggcHJvcGVydGllcy4gKi9cbmNvbnN0IERiVGFyZ2V0RG9jdW1lbnRLZXlQYXRoID0gWyd0YXJnZXRJZCcsICdwYXRoJ107XG4vKiogVGhlIGluZGV4IG5hbWUgZm9yIHRoZSByZXZlcnNlIGluZGV4LiAqL1xuY29uc3QgRGJUYXJnZXREb2N1bWVudERvY3VtZW50VGFyZ2V0c0luZGV4ID0gJ2RvY3VtZW50VGFyZ2V0c0luZGV4Jztcbi8qKiBXZSBhbHNvIG5lZWQgdG8gY3JlYXRlIHRoZSByZXZlcnNlIGluZGV4IGZvciB0aGVzZSBwcm9wZXJ0aWVzLiAqL1xuY29uc3QgRGJUYXJnZXREb2N1bWVudERvY3VtZW50VGFyZ2V0c0tleVBhdGggPSBbJ3BhdGgnLCAndGFyZ2V0SWQnXTtcbi8qKlxuICogVGhlIGtleSBzdHJpbmcgdXNlZCBmb3IgdGhlIHNpbmdsZSBvYmplY3QgdGhhdCBleGlzdHMgaW4gdGhlXG4gKiBEYlRhcmdldEdsb2JhbCBzdG9yZS5cbiAqL1xuY29uc3QgRGJUYXJnZXRHbG9iYWxLZXkgPSAndGFyZ2V0R2xvYmFsS2V5JztcbmNvbnN0IERiVGFyZ2V0R2xvYmFsU3RvcmUgPSAndGFyZ2V0R2xvYmFsJztcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xuY29uc3QgRGJDb2xsZWN0aW9uUGFyZW50U3RvcmUgPSAnY29sbGVjdGlvblBhcmVudHMnO1xuLyoqIEtleXMgYXJlIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdmlhIHRoZSBjb2xsZWN0aW9uSWQsIHBhcmVudCBwcm9wZXJ0aWVzLiAqL1xuY29uc3QgRGJDb2xsZWN0aW9uUGFyZW50S2V5UGF0aCA9IFsnY29sbGVjdGlvbklkJywgJ3BhcmVudCddO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXG5jb25zdCBEYkNsaWVudE1ldGFkYXRhU3RvcmUgPSAnY2xpZW50TWV0YWRhdGEnO1xuLyoqIEtleXMgYXJlIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdmlhIHRoZSBjbGllbnRJZCBwcm9wZXJ0aWVzLiAqL1xuY29uc3QgRGJDbGllbnRNZXRhZGF0YUtleVBhdGggPSAnY2xpZW50SWQnO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXG5jb25zdCBEYkJ1bmRsZVN0b3JlID0gJ2J1bmRsZXMnO1xuY29uc3QgRGJCdW5kbGVLZXlQYXRoID0gJ2J1bmRsZUlkJztcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xuY29uc3QgRGJOYW1lZFF1ZXJ5U3RvcmUgPSAnbmFtZWRRdWVyaWVzJztcbmNvbnN0IERiTmFtZWRRdWVyeUtleVBhdGggPSAnbmFtZSc7XG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gKi9cbmNvbnN0IERiSW5kZXhDb25maWd1cmF0aW9uU3RvcmUgPSAnaW5kZXhDb25maWd1cmF0aW9uJztcbmNvbnN0IERiSW5kZXhDb25maWd1cmF0aW9uS2V5UGF0aCA9ICdpbmRleElkJztcbi8qKlxuICogQW4gaW5kZXggdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGluZGV4IGNvbmZpZ3VyYXRpb25zIGJ5IGNvbGxlY3Rpb25cbiAqIGdyb3VwLlxuICpcbiAqIFBPUlRJTkcgTk9URTogaU9TIGFuZCBBbmRyb2lkIG1haW50YWluIHRoaXMgaW5kZXggaW4tbWVtb3J5LCBidXQgdGhpcyBpc1xuICogbm90IHBvc3NpYmxlIGhlcmUgYXMgdGhlIFdlYiBjbGllbnQgc3VwcG9ydHMgY29uY3VycmVudCBhY2Nlc3MgdG9cbiAqIHBlcnNpc3RlbmNlIHZpYSBtdWx0aS10YWIuXG4gKi9cbmNvbnN0IERiSW5kZXhDb25maWd1cmF0aW9uQ29sbGVjdGlvbkdyb3VwSW5kZXggPSAnY29sbGVjdGlvbkdyb3VwSW5kZXgnO1xuY29uc3QgRGJJbmRleENvbmZpZ3VyYXRpb25Db2xsZWN0aW9uR3JvdXBJbmRleFBhdGggPSAnY29sbGVjdGlvbkdyb3VwJztcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xuY29uc3QgRGJJbmRleFN0YXRlU3RvcmUgPSAnaW5kZXhTdGF0ZSc7XG5jb25zdCBEYkluZGV4U3RhdGVLZXlQYXRoID0gWydpbmRleElkJywgJ3VpZCddO1xuLyoqXG4gKiBBbiBpbmRleCB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byBkb2N1bWVudHMgaW4gYSBjb2xsZWN0aW9uIHNvcnRlZCBieSBsYXN0XG4gKiB1cGRhdGUgdGltZS4gVXNlZCBieSB0aGUgYmFja2ZpbGxlci5cbiAqXG4gKiBQT1JUSU5HIE5PVEU6IGlPUyBhbmQgQW5kcm9pZCBtYWludGFpbiB0aGlzIGluZGV4IGluLW1lbW9yeSwgYnV0IHRoaXMgaXNcbiAqIG5vdCBwb3NzaWJsZSBoZXJlIGFzIHRoZSBXZWIgY2xpZW50IHN1cHBvcnRzIGNvbmN1cnJlbnQgYWNjZXNzIHRvXG4gKiBwZXJzaXN0ZW5jZSB2aWEgbXVsdGktdGFiLlxuICovXG5jb25zdCBEYkluZGV4U3RhdGVTZXF1ZW5jZU51bWJlckluZGV4ID0gJ3NlcXVlbmNlTnVtYmVySW5kZXgnO1xuY29uc3QgRGJJbmRleFN0YXRlU2VxdWVuY2VOdW1iZXJJbmRleFBhdGggPSBbJ3VpZCcsICdzZXF1ZW5jZU51bWJlciddO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXG5jb25zdCBEYkluZGV4RW50cnlTdG9yZSA9ICdpbmRleEVudHJpZXMnO1xuY29uc3QgRGJJbmRleEVudHJ5S2V5UGF0aCA9IFtcbiAgICAnaW5kZXhJZCcsXG4gICAgJ3VpZCcsXG4gICAgJ2FycmF5VmFsdWUnLFxuICAgICdkaXJlY3Rpb25hbFZhbHVlJyxcbiAgICAnb3JkZXJlZERvY3VtZW50S2V5JyxcbiAgICAnZG9jdW1lbnRLZXknXG5dO1xuY29uc3QgRGJJbmRleEVudHJ5RG9jdW1lbnRLZXlJbmRleCA9ICdkb2N1bWVudEtleUluZGV4JztcbmNvbnN0IERiSW5kZXhFbnRyeURvY3VtZW50S2V5SW5kZXhQYXRoID0gW1xuICAgICdpbmRleElkJyxcbiAgICAndWlkJyxcbiAgICAnb3JkZXJlZERvY3VtZW50S2V5J1xuXTtcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xuY29uc3QgRGJEb2N1bWVudE92ZXJsYXlTdG9yZSA9ICdkb2N1bWVudE92ZXJsYXlzJztcbmNvbnN0IERiRG9jdW1lbnRPdmVybGF5S2V5UGF0aCA9IFtcbiAgICAndXNlcklkJyxcbiAgICAnY29sbGVjdGlvblBhdGgnLFxuICAgICdkb2N1bWVudElkJ1xuXTtcbmNvbnN0IERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvblBhdGhPdmVybGF5SW5kZXggPSAnY29sbGVjdGlvblBhdGhPdmVybGF5SW5kZXgnO1xuY29uc3QgRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleFBhdGggPSBbXG4gICAgJ3VzZXJJZCcsXG4gICAgJ2NvbGxlY3Rpb25QYXRoJyxcbiAgICAnbGFyZ2VzdEJhdGNoSWQnXG5dO1xuY29uc3QgRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uR3JvdXBPdmVybGF5SW5kZXggPSAnY29sbGVjdGlvbkdyb3VwT3ZlcmxheUluZGV4JztcbmNvbnN0IERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvbkdyb3VwT3ZlcmxheUluZGV4UGF0aCA9IFtcbiAgICAndXNlcklkJyxcbiAgICAnY29sbGVjdGlvbkdyb3VwJyxcbiAgICAnbGFyZ2VzdEJhdGNoSWQnXG5dO1xuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXG5jb25zdCBEYkdsb2JhbHNTdG9yZSA9ICdnbG9iYWxzJztcbmNvbnN0IERiR2xvYmFsc0tleVBhdGggPSAnbmFtZSc7XG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nXG5jb25zdCBWMV9TVE9SRVMgPSBbXG4gICAgRGJNdXRhdGlvblF1ZXVlU3RvcmUsXG4gICAgRGJNdXRhdGlvbkJhdGNoU3RvcmUsXG4gICAgRGJEb2N1bWVudE11dGF0aW9uU3RvcmUsXG4gICAgRGJSZW1vdGVEb2N1bWVudFN0b3JlJDEsXG4gICAgRGJUYXJnZXRTdG9yZSxcbiAgICBEYlByaW1hcnlDbGllbnRTdG9yZSxcbiAgICBEYlRhcmdldEdsb2JhbFN0b3JlLFxuICAgIERiVGFyZ2V0RG9jdW1lbnRTdG9yZVxuXTtcbi8vIFZpc2libGUgZm9yIHRlc3RpbmdcbmNvbnN0IFYzX1NUT1JFUyA9IFYxX1NUT1JFUztcbi8vIE5vdGU6IERiUmVtb3RlRG9jdW1lbnRDaGFuZ2VzIGlzIG5vIGxvbmdlciB1c2VkIGFuZCBkcm9wcGVkIHdpdGggdjkuXG5jb25zdCBWNF9TVE9SRVMgPSBbLi4uVjNfU1RPUkVTLCBEYkNsaWVudE1ldGFkYXRhU3RvcmVdO1xuY29uc3QgVjZfU1RPUkVTID0gWy4uLlY0X1NUT1JFUywgRGJSZW1vdGVEb2N1bWVudEdsb2JhbFN0b3JlXTtcbmNvbnN0IFY4X1NUT1JFUyA9IFsuLi5WNl9TVE9SRVMsIERiQ29sbGVjdGlvblBhcmVudFN0b3JlXTtcbmNvbnN0IFYxMV9TVE9SRVMgPSBbLi4uVjhfU1RPUkVTLCBEYkJ1bmRsZVN0b3JlLCBEYk5hbWVkUXVlcnlTdG9yZV07XG5jb25zdCBWMTJfU1RPUkVTID0gWy4uLlYxMV9TVE9SRVMsIERiRG9jdW1lbnRPdmVybGF5U3RvcmVdO1xuY29uc3QgVjEzX1NUT1JFUyA9IFtcbiAgICBEYk11dGF0aW9uUXVldWVTdG9yZSxcbiAgICBEYk11dGF0aW9uQmF0Y2hTdG9yZSxcbiAgICBEYkRvY3VtZW50TXV0YXRpb25TdG9yZSxcbiAgICBEYlJlbW90ZURvY3VtZW50U3RvcmUsXG4gICAgRGJUYXJnZXRTdG9yZSxcbiAgICBEYlByaW1hcnlDbGllbnRTdG9yZSxcbiAgICBEYlRhcmdldEdsb2JhbFN0b3JlLFxuICAgIERiVGFyZ2V0RG9jdW1lbnRTdG9yZSxcbiAgICBEYkNsaWVudE1ldGFkYXRhU3RvcmUsXG4gICAgRGJSZW1vdGVEb2N1bWVudEdsb2JhbFN0b3JlLFxuICAgIERiQ29sbGVjdGlvblBhcmVudFN0b3JlLFxuICAgIERiQnVuZGxlU3RvcmUsXG4gICAgRGJOYW1lZFF1ZXJ5U3RvcmUsXG4gICAgRGJEb2N1bWVudE92ZXJsYXlTdG9yZVxuXTtcbmNvbnN0IFYxNF9TVE9SRVMgPSBWMTNfU1RPUkVTO1xuY29uc3QgVjE1X1NUT1JFUyA9IFtcbiAgICAuLi5WMTRfU1RPUkVTLFxuICAgIERiSW5kZXhDb25maWd1cmF0aW9uU3RvcmUsXG4gICAgRGJJbmRleFN0YXRlU3RvcmUsXG4gICAgRGJJbmRleEVudHJ5U3RvcmVcbl07XG5jb25zdCBWMTZfU1RPUkVTID0gVjE1X1NUT1JFUztcbmNvbnN0IFYxN19TVE9SRVMgPSBbLi4uVjE1X1NUT1JFUywgRGJHbG9iYWxzU3RvcmVdO1xuLyoqIFJldHVybnMgdGhlIG9iamVjdCBzdG9yZXMgZm9yIHRoZSBwcm92aWRlZCBzY2hlbWEuICovXG5mdW5jdGlvbiBnZXRPYmplY3RTdG9yZXMoc2NoZW1hVmVyc2lvbikge1xuICAgIGlmIChzY2hlbWFWZXJzaW9uID09PSAxNykge1xuICAgICAgICByZXR1cm4gVjE3X1NUT1JFUztcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hVmVyc2lvbiA9PT0gMTYpIHtcbiAgICAgICAgcmV0dXJuIFYxNl9TVE9SRVM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYVZlcnNpb24gPT09IDE1KSB7XG4gICAgICAgIHJldHVybiBWMTVfU1RPUkVTO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWFWZXJzaW9uID09PSAxNCkge1xuICAgICAgICByZXR1cm4gVjE0X1NUT1JFUztcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hVmVyc2lvbiA9PT0gMTMpIHtcbiAgICAgICAgcmV0dXJuIFYxM19TVE9SRVM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYVZlcnNpb24gPT09IDEyKSB7XG4gICAgICAgIHJldHVybiBWMTJfU1RPUkVTO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWFWZXJzaW9uID09PSAxMSkge1xuICAgICAgICByZXR1cm4gVjExX1NUT1JFUztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZhaWwoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBJbmRleGVkRGJUcmFuc2FjdGlvbiBleHRlbmRzIFBlcnNpc3RlbmNlVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNpbXBsZURiVHJhbnNhY3Rpb24sIGN1cnJlbnRTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNpbXBsZURiVHJhbnNhY3Rpb24gPSBzaW1wbGVEYlRyYW5zYWN0aW9uO1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZU51bWJlciA9IGN1cnJlbnRTZXF1ZW5jZU51bWJlcjtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTdG9yZSh0eG4sIHN0b3JlKSB7XG4gICAgY29uc3QgaW5kZXhlZERiVHJhbnNhY3Rpb24gPSBkZWJ1Z0Nhc3QodHhuKTtcbiAgICByZXR1cm4gU2ltcGxlRGIuZ2V0U3RvcmUoaW5kZXhlZERiVHJhbnNhY3Rpb24uc2ltcGxlRGJUcmFuc2FjdGlvbiwgc3RvcmUpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0U2l6ZShvYmopIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG59XG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIGZuKGtleSwgb2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwVG9BcnJheShvYmosIGZuKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChmbihvYmpba2V5XSwga2V5LCBvYmopKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIEFuIGltbXV0YWJsZSBzb3J0ZWQgbWFwIGltcGxlbWVudGF0aW9uLCBiYXNlZCBvbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2tcbi8vIHRyZWUuXG5jbGFzcyBTb3J0ZWRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3IsIHJvb3QpIHtcbiAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdCA/IHJvb3QgOiBMTFJCTm9kZS5FTVBUWTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hcCwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS92YWx1ZSBhZGRlZCBvciByZXBsYWNlZC5cbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3IsIHRoaXMucm9vdFxuICAgICAgICAgICAgLmluc2VydChrZXksIHZhbHVlLCB0aGlzLmNvbXBhcmF0b3IpXG4gICAgICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCkpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgbWFwLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IHJlbW92ZWQuXG4gICAgcmVtb3ZlKGtleSkge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3IsIHRoaXMucm9vdFxuICAgICAgICAgICAgLnJlbW92ZShrZXksIHRoaXMuY29tcGFyYXRvcilcbiAgICAgICAgICAgIC5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLkJMQUNLLCBudWxsLCBudWxsKSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBub2RlIHdpdGggdGhlIGdpdmVuIGtleSwgb3IgbnVsbC5cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5yb290O1xuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBjb25zdCBjbXAgPSB0aGlzLmNvbXBhcmF0b3Ioa2V5LCBub2RlLmtleSk7XG4gICAgICAgICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhpcyBzb3J0ZWQgbWFwLCBvciAtMSBpZiBpdCBkb2Vzbid0XG4gICAgLy8gZXhpc3QuXG4gICAgaW5kZXhPZihrZXkpIHtcbiAgICAgICAgLy8gTnVtYmVyIG9mIG5vZGVzIHRoYXQgd2VyZSBwcnVuZWQgd2hlbiBkZXNjZW5kaW5nIHJpZ2h0XG4gICAgICAgIGxldCBwcnVuZWROb2RlcyA9IDA7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5yb290O1xuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBjb25zdCBjbXAgPSB0aGlzLmNvbXBhcmF0b3Ioa2V5LCBub2RlLmtleSk7XG4gICAgICAgICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBydW5lZE5vZGVzICsgbm9kZS5sZWZ0LnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENvdW50IGFsbCBub2RlcyBsZWZ0IG9mIHRoZSBub2RlIHBsdXMgdGhlIG5vZGUgaXRzZWxmXG4gICAgICAgICAgICAgICAgcHJ1bmVkTm9kZXMgKz0gbm9kZS5sZWZ0LnNpemUgKyAxO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vZGUgbm90IGZvdW5kXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5pc0VtcHR5KCk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgbWFwLlxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LnNpemU7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG1pbmltdW0ga2V5IGluIHRoZSBtYXAuXG4gICAgbWluS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Lm1pbktleSgpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIGtleSBpbiB0aGUgbWFwLlxuICAgIG1heEtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5tYXhLZXkoKTtcbiAgICB9XG4gICAgLy8gVHJhdmVyc2VzIHRoZSBtYXAgaW4ga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxuICAgIC8vIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cbiAgICAvLyBSZXR1cm5zIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLCBvciB0aGUgbGFzdCBmYWxzZXlcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXG4gICAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbik7XG4gICAgfVxuICAgIGZvckVhY2goZm4pIHtcbiAgICAgICAgdGhpcy5pbm9yZGVyVHJhdmVyc2FsKChrLCB2KSA9PiB7XG4gICAgICAgICAgICBmbihrLCB2KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbm9yZGVyVHJhdmVyc2FsKChrLCB2KSA9PiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbnMucHVzaChgJHtrfToke3Z9YCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYHske2Rlc2NyaXB0aW9ucy5qb2luKCcsICcpfX1gO1xuICAgIH1cbiAgICAvLyBUcmF2ZXJzZXMgdGhlIG1hcCBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb25cbiAgICAvLyBmdW5jdGlvbiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci4gSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzXG4gICAgLy8gYWJvcnRlZC5cbiAgICAvLyBSZXR1cm5zIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLCBvciB0aGUgbGFzdCBmYWxzZXlcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXG4gICAgcmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbik7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB0aGUgU29ydGVkTWFwLlxuICAgIGdldEl0ZXJhdG9yKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdCwgbnVsbCwgdGhpcy5jb21wYXJhdG9yLCBmYWxzZSk7XG4gICAgfVxuICAgIGdldEl0ZXJhdG9yRnJvbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3QsIGtleSwgdGhpcy5jb21wYXJhdG9yLCBmYWxzZSk7XG4gICAgfVxuICAgIGdldFJldmVyc2VJdGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3QsIG51bGwsIHRoaXMuY29tcGFyYXRvciwgdHJ1ZSk7XG4gICAgfVxuICAgIGdldFJldmVyc2VJdGVyYXRvckZyb20oa2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290LCBrZXksIHRoaXMuY29tcGFyYXRvciwgdHJ1ZSk7XG4gICAgfVxufSAvLyBlbmQgU29ydGVkTWFwXG4vLyBBbiBpdGVyYXRvciBvdmVyIGFuIExMUkJOb2RlLlxuY2xhc3MgU29ydGVkTWFwSXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIHN0YXJ0S2V5LCBjb21wYXJhdG9yLCBpc1JldmVyc2UpIHtcbiAgICAgICAgdGhpcy5pc1JldmVyc2UgPSBpc1JldmVyc2U7XG4gICAgICAgIHRoaXMubm9kZVN0YWNrID0gW107XG4gICAgICAgIGxldCBjbXAgPSAxO1xuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBjbXAgPSBzdGFydEtleSA/IGNvbXBhcmF0b3Iobm9kZS5rZXksIHN0YXJ0S2V5KSA6IDE7XG4gICAgICAgICAgICAvLyBmbGlwIHRoZSBjb21wYXJpc29uIGlmIHdlJ3JlIGdvaW5nIGluIHJldmVyc2VcbiAgICAgICAgICAgIGlmIChzdGFydEtleSAmJiBpc1JldmVyc2UpIHtcbiAgICAgICAgICAgICAgICBjbXAgKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBsZXNzIHRoYW4gb3VyIHN0YXJ0IGtleS4gaWdub3JlIGl0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG5vZGUgaXMgZXhhY3RseSBlcXVhbCB0byBvdXIgc3RhcnQga2V5LiBQdXNoIGl0IG9uIHRoZSBzdGFjayxcbiAgICAgICAgICAgICAgICAvLyBidXQgc3RvcCBpdGVyYXRpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBncmVhdGVyIHRoYW4gb3VyIHN0YXJ0IGtleSwgYWRkIGl0IHRvIHRoZSBzdGFjayBhbmQgbW92ZVxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBuZXh0IG9uZVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TmV4dCgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLm5vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBrZXk6IG5vZGUua2V5LCB2YWx1ZTogbm9kZS52YWx1ZSB9O1xuICAgICAgICBpZiAodGhpcy5pc1JldmVyc2UpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoYXNOZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlU3RhY2subGVuZ3RoID4gMDtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZVN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZVN0YWNrW3RoaXMubm9kZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4geyBrZXk6IG5vZGUua2V5LCB2YWx1ZTogbm9kZS52YWx1ZSB9O1xuICAgIH1cbn0gLy8gZW5kIFNvcnRlZE1hcEl0ZXJhdG9yXG4vLyBSZXByZXNlbnRzIGEgbm9kZSBpbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2sgdHJlZS5cbmNsYXNzIExMUkJOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yICE9IG51bGwgPyBjb2xvciA6IExMUkJOb2RlLlJFRDtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdCAhPSBudWxsID8gbGVmdCA6IExMUkJOb2RlLkVNUFRZO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogTExSQk5vZGUuRU1QVFk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMubGVmdC5zaXplICsgMSArIHRoaXMucmlnaHQuc2l6ZTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgbm9kZSwgb3B0aW9uYWxseSByZXBsYWNpbmcgcGllY2VzIG9mIGl0LlxuICAgIGNvcHkoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5ICE9IG51bGwgPyBrZXkgOiB0aGlzLmtleSwgdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogdGhpcy52YWx1ZSwgY29sb3IgIT0gbnVsbCA/IGNvbG9yIDogdGhpcy5jb2xvciwgbGVmdCAhPSBudWxsID8gbGVmdCA6IHRoaXMubGVmdCwgcmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogdGhpcy5yaWdodCk7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVHJhdmVyc2VzIHRoZSB0cmVlIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cbiAgICAvLyBmb3IgZWFjaCBub2RlLiBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cbiAgICAvLyBSZXR1cm5zIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLCBvciB0aGUgbGFzdCBmYWxzZXlcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXG4gICAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxlZnQuaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHx8XG4gICAgICAgICAgICBhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Lmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSk7XG4gICAgfVxuICAgIC8vIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb25cbiAgICAvLyBmdW5jdGlvbiBmb3IgZWFjaCBub2RlLiBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cbiAgICAvLyBSZXR1cm5zIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLCBvciB0aGUgbGFzdCBmYWxzZXlcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXG4gICAgcmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnJpZ2h0LnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB8fFxuICAgICAgICAgICAgYWN0aW9uKHRoaXMua2V5LCB0aGlzLnZhbHVlKSB8fFxuICAgICAgICAgICAgdGhpcy5sZWZ0LnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG1pbmltdW0gbm9kZSBpbiB0aGUgdHJlZS5cbiAgICBtaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmxlZnQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQubWluKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXG4gICAgbWluS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oKS5rZXk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG1heGltdW0ga2V5IGluIHRoZSB0cmVlLlxuICAgIG1heEtleSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5tYXhLZXkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm5zIG5ldyB0cmVlLCB3aXRoIHRoZSBrZXkvdmFsdWUgYWRkZWQuXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgbGV0IG4gPSB0aGlzO1xuICAgICAgICBjb25zdCBjbXAgPSBjb21wYXJhdG9yKGtleSwgbi5rZXkpO1xuICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBuLmxlZnQuaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgdmFsdWUsIG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0Lmluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4uZml4VXAoKTtcbiAgICB9XG4gICAgcmVtb3ZlTWluKCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIExMUkJOb2RlLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuID0gdGhpcztcbiAgICAgICAgaWYgKCFuLmxlZnQuaXNSZWQoKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWQoKSkge1xuICAgICAgICAgICAgbiA9IG4ubW92ZVJlZExlZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmVNaW4oKSwgbnVsbCk7XG4gICAgICAgIHJldHVybiBuLmZpeFVwKCk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgbmV3IHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBpdGVtIHJlbW92ZWQuXG4gICAgcmVtb3ZlKGtleSwgY29tcGFyYXRvcikge1xuICAgICAgICBsZXQgc21hbGxlc3Q7XG4gICAgICAgIGxldCBuID0gdGhpcztcbiAgICAgICAgaWYgKGNvbXBhcmF0b3Ioa2V5LCBuLmtleSkgPCAwKSB7XG4gICAgICAgICAgICBpZiAoIW4ubGVmdC5pc0VtcHR5KCkgJiYgIW4ubGVmdC5pc1JlZCgpICYmICFuLmxlZnQubGVmdC5pc1JlZCgpKSB7XG4gICAgICAgICAgICAgICAgbiA9IG4ubW92ZVJlZExlZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0LnJlbW92ZShrZXksIGNvbXBhcmF0b3IpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuLmxlZnQuaXNSZWQoKSkge1xuICAgICAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW4ucmlnaHQuaXNFbXB0eSgpICYmICFuLnJpZ2h0LmlzUmVkKCkgJiYgIW4ucmlnaHQubGVmdC5pc1JlZCgpKSB7XG4gICAgICAgICAgICAgICAgbiA9IG4ubW92ZVJlZFJpZ2h0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChuLnJpZ2h0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTExSQk5vZGUuRU1QVFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzbWFsbGVzdCA9IG4ucmlnaHQubWluKCk7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBuLmNvcHkoc21hbGxlc3Qua2V5LCBzbWFsbGVzdC52YWx1ZSwgbnVsbCwgbnVsbCwgbi5yaWdodC5yZW1vdmVNaW4oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0LnJlbW92ZShrZXksIGNvbXBhcmF0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbi5maXhVcCgpO1xuICAgIH1cbiAgICBpc1JlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3I7XG4gICAgfVxuICAgIC8vIFJldHVybnMgbmV3IHRyZWUgYWZ0ZXIgcGVyZm9ybWluZyBhbnkgbmVlZGVkIHJvdGF0aW9ucy5cbiAgICBmaXhVcCgpIHtcbiAgICAgICAgbGV0IG4gPSB0aGlzO1xuICAgICAgICBpZiAobi5yaWdodC5pc1JlZCgpICYmICFuLmxlZnQuaXNSZWQoKSkge1xuICAgICAgICAgICAgbiA9IG4ucm90YXRlTGVmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWQoKSAmJiBuLmxlZnQubGVmdC5pc1JlZCgpKSB7XG4gICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWQoKSAmJiBuLnJpZ2h0LmlzUmVkKCkpIHtcbiAgICAgICAgICAgIG4gPSBuLmNvbG9yRmxpcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBtb3ZlUmVkTGVmdCgpIHtcbiAgICAgICAgbGV0IG4gPSB0aGlzLmNvbG9yRmxpcCgpO1xuICAgICAgICBpZiAobi5yaWdodC5sZWZ0LmlzUmVkKCkpIHtcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5yb3RhdGVSaWdodCgpKTtcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZUxlZnQoKTtcbiAgICAgICAgICAgIG4gPSBuLmNvbG9yRmxpcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBtb3ZlUmVkUmlnaHQoKSB7XG4gICAgICAgIGxldCBuID0gdGhpcy5jb2xvckZsaXAoKTtcbiAgICAgICAgaWYgKG4ubGVmdC5sZWZ0LmlzUmVkKCkpIHtcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0KCk7XG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgcm90YXRlTGVmdCgpIHtcbiAgICAgICAgY29uc3QgbmwgPSB0aGlzLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuUkVELCBudWxsLCB0aGlzLnJpZ2h0LmxlZnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG5sLCBudWxsKTtcbiAgICB9XG4gICAgcm90YXRlUmlnaHQoKSB7XG4gICAgICAgIGNvbnN0IG5yID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLlJFRCwgdGhpcy5sZWZ0LnJpZ2h0LCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG51bGwsIG5yKTtcbiAgICB9XG4gICAgY29sb3JGbGlwKCkge1xuICAgICAgICBjb25zdCBsZWZ0ID0gdGhpcy5sZWZ0LmNvcHkobnVsbCwgbnVsbCwgIXRoaXMubGVmdC5jb2xvciwgbnVsbCwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsICF0aGlzLnJpZ2h0LmNvbG9yLCBudWxsLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weShudWxsLCBudWxsLCAhdGhpcy5jb2xvciwgbGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICAvLyBGb3IgdGVzdGluZy5cbiAgICBjaGVja01heERlcHRoKCkge1xuICAgICAgICBjb25zdCBibGFja0RlcHRoID0gdGhpcy5jaGVjaygpO1xuICAgICAgICBpZiAoTWF0aC5wb3coMi4wLCBibGFja0RlcHRoKSA8PSB0aGlzLnNpemUgKyAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJbiBhIGJhbGFuY2VkIFJCIHRyZWUsIHRoZSBibGFjay1kZXB0aCAobnVtYmVyIG9mIGJsYWNrIG5vZGVzKSBmcm9tIHJvb3QgdG9cbiAgICAvLyBsZWF2ZXMgaXMgZXF1YWwgb24gYm90aCBzaWRlcy4gIFRoaXMgZnVuY3Rpb24gdmVyaWZpZXMgdGhhdCBvciBhc3NlcnRzLlxuICAgIGNoZWNrKCkge1xuICAgICAgICBpZiAodGhpcy5pc1JlZCgpICYmIHRoaXMubGVmdC5pc1JlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBmYWlsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNSZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsYWNrRGVwdGggPSB0aGlzLmxlZnQuY2hlY2soKTtcbiAgICAgICAgaWYgKGJsYWNrRGVwdGggIT09IHRoaXMucmlnaHQuY2hlY2soKSkge1xuICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJsYWNrRGVwdGggKyAodGhpcy5pc1JlZCgpID8gMCA6IDEpO1xuICAgICAgICB9XG4gICAgfVxufSAvLyBlbmQgTExSQk5vZGVcbi8vIEVtcHR5IG5vZGUgaXMgc2hhcmVkIGJldHdlZW4gYWxsIExMUkIgdHJlZXMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuTExSQk5vZGUuRU1QVFkgPSBudWxsO1xuTExSQk5vZGUuUkVEID0gdHJ1ZTtcbkxMUkJOb2RlLkJMQUNLID0gZmFsc2U7XG4vLyBSZXByZXNlbnRzIGFuIGVtcHR5IG5vZGUgKGEgbGVhZiBub2RlIGluIHRoZSBSZWQtQmxhY2sgVHJlZSkuXG5jbGFzcyBMTFJCRW1wdHlOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG4gICAgZ2V0IGtleSgpIHtcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHRocm93IGZhaWwoKTtcbiAgICB9XG4gICAgZ2V0IGNvbG9yKCkge1xuICAgICAgICB0aHJvdyBmYWlsKCk7XG4gICAgfVxuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICB0aHJvdyBmYWlsKCk7XG4gICAgfVxuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLlxuICAgIGNvcHkoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS92YWx1ZSBhZGRlZC5cbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IExMUkJOb2RlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxuICAgIHJlbW92ZShrZXksIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbWluS2V5KCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbWF4S2V5KCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaXNSZWQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gRm9yIHRlc3RpbmcuXG4gICAgY2hlY2tNYXhEZXB0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNoZWNrKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59IC8vIGVuZCBMTFJCRW1wdHlOb2RlXG5MTFJCTm9kZS5FTVBUWSA9IG5ldyBMTFJCRW1wdHlOb2RlKCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFNvcnRlZFNldCBpcyBhbiBpbW11dGFibGUgKGNvcHktb24td3JpdGUpIGNvbGxlY3Rpb24gdGhhdCBob2xkcyBlbGVtZW50c1xuICogaW4gb3JkZXIgc3BlY2lmaWVkIGJ5IHRoZSBwcm92aWRlZCBjb21wYXJhdG9yLlxuICpcbiAqIE5PVEU6IGlmIHByb3ZpZGVkIGNvbXBhcmF0b3IgcmV0dXJucyAwIGZvciB0d28gZWxlbWVudHMsIHdlIGNvbnNpZGVyIHRoZW0gdG9cbiAqIGJlIGVxdWFsIVxuICovXG5jbGFzcyBTb3J0ZWRTZXQge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3IpO1xuICAgIH1cbiAgICBoYXMoZWxlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmdldChlbGVtKSAhPT0gbnVsbDtcbiAgICB9XG4gICAgZmlyc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubWluS2V5KCk7XG4gICAgfVxuICAgIGxhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubWF4S2V5KCk7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnNpemU7XG4gICAgfVxuICAgIGluZGV4T2YoZWxlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmluZGV4T2YoZWxlbSk7XG4gICAgfVxuICAgIC8qKiBJdGVyYXRlcyBlbGVtZW50cyBpbiBvcmRlciBkZWZpbmVkIGJ5IFwiY29tcGFyYXRvclwiICovXG4gICAgZm9yRWFjaChjYikge1xuICAgICAgICB0aGlzLmRhdGEuaW5vcmRlclRyYXZlcnNhbCgoaywgdikgPT4ge1xuICAgICAgICAgICAgY2Ioayk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogSXRlcmF0ZXMgb3ZlciBgZWxlbWBzIHN1Y2ggdGhhdDogcmFuZ2VbMF0gJmx0Oz0gZWxlbSAmbHQ7IHJhbmdlWzFdLiAqL1xuICAgIGZvckVhY2hJblJhbmdlKHJhbmdlLCBjYikge1xuICAgICAgICBjb25zdCBpdGVyID0gdGhpcy5kYXRhLmdldEl0ZXJhdG9yRnJvbShyYW5nZVswXSk7XG4gICAgICAgIHdoaWxlIChpdGVyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbSA9IGl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyYXRvcihlbGVtLmtleSwgcmFuZ2VbMV0pID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYihlbGVtLmtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBgZWxlbWBzIHN1Y2ggdGhhdDogc3RhcnQgJmx0Oz0gZWxlbSB1bnRpbCBmYWxzZSBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBmb3JFYWNoV2hpbGUoY2IsIHN0YXJ0KSB7XG4gICAgICAgIGxldCBpdGVyO1xuICAgICAgICBpZiAoc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXRlciA9IHRoaXMuZGF0YS5nZXRJdGVyYXRvckZyb20oc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlciA9IHRoaXMuZGF0YS5nZXRJdGVyYXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpdGVyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbSA9IGl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2IoZWxlbS5rZXkpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEZpbmRzIHRoZSBsZWFzdCBlbGVtZW50IGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgZWxlbWAuICovXG4gICAgZmlyc3RBZnRlck9yRXF1YWwoZWxlbSkge1xuICAgICAgICBjb25zdCBpdGVyID0gdGhpcy5kYXRhLmdldEl0ZXJhdG9yRnJvbShlbGVtKTtcbiAgICAgICAgcmV0dXJuIGl0ZXIuaGFzTmV4dCgpID8gaXRlci5nZXROZXh0KCkua2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0SXRlcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkU2V0SXRlcmF0b3IodGhpcy5kYXRhLmdldEl0ZXJhdG9yKCkpO1xuICAgIH1cbiAgICBnZXRJdGVyYXRvckZyb20oa2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkU2V0SXRlcmF0b3IodGhpcy5kYXRhLmdldEl0ZXJhdG9yRnJvbShrZXkpKTtcbiAgICB9XG4gICAgLyoqIEluc2VydHMgb3IgdXBkYXRlcyBhbiBlbGVtZW50ICovXG4gICAgYWRkKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmRhdGEucmVtb3ZlKGVsZW0pLmluc2VydChlbGVtLCB0cnVlKSk7XG4gICAgfVxuICAgIC8qKiBEZWxldGVzIGFuIGVsZW1lbnQgKi9cbiAgICBkZWxldGUoZWxlbSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzKGVsZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KHRoaXMuZGF0YS5yZW1vdmUoZWxlbSkpO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmlzRW1wdHkoKTtcbiAgICB9XG4gICAgdW5pb25XaXRoKG90aGVyKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzO1xuICAgICAgICAvLyBNYWtlIHN1cmUgYHJlc3VsdGAgYWx3YXlzIHJlZmVycyB0byB0aGUgbGFyZ2VyIG9uZSBvZiB0aGUgdHdvIHNldHMuXG4gICAgICAgIGlmIChyZXN1bHQuc2l6ZSA8IG90aGVyLnNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG90aGVyO1xuICAgICAgICAgICAgb3RoZXIgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyLmZvckVhY2goZWxlbSA9PiB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGVsZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNvcnRlZFNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaXplICE9PSBvdGhlci5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhpc0l0ID0gdGhpcy5kYXRhLmdldEl0ZXJhdG9yKCk7XG4gICAgICAgIGNvbnN0IG90aGVySXQgPSBvdGhlci5kYXRhLmdldEl0ZXJhdG9yKCk7XG4gICAgICAgIHdoaWxlICh0aGlzSXQuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBjb25zdCB0aGlzRWxlbSA9IHRoaXNJdC5nZXROZXh0KCkua2V5O1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJFbGVtID0gb3RoZXJJdC5nZXROZXh0KCkua2V5O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyYXRvcih0aGlzRWxlbSwgb3RoZXJFbGVtKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaCh0YXJnZXRJZCA9PiB7XG4gICAgICAgICAgICByZXMucHVzaCh0YXJnZXRJZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaChlbGVtID0+IHJlc3VsdC5wdXNoKGVsZW0pKTtcbiAgICAgICAgcmV0dXJuICdTb3J0ZWRTZXQoJyArIHJlc3VsdC50b1N0cmluZygpICsgJyknO1xuICAgIH1cbiAgICBjb3B5KGRhdGEpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNvcnRlZFNldCh0aGlzLmNvbXBhcmF0b3IpO1xuICAgICAgICByZXN1bHQuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuY2xhc3MgU29ydGVkU2V0SXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGl0ZXIpIHtcbiAgICAgICAgdGhpcy5pdGVyID0gaXRlcjtcbiAgICB9XG4gICAgZ2V0TmV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlci5nZXROZXh0KCkua2V5O1xuICAgIH1cbiAgICBoYXNOZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyLmhhc05leHQoKTtcbiAgICB9XG59XG4vKipcbiAqIENvbXBhcmVzIHR3byBzb3J0ZWQgc2V0cyBmb3IgZXF1YWxpdHkgdXNpbmcgdGhlaXIgbmF0dXJhbCBvcmRlcmluZy4gVGhlXG4gKiBtZXRob2QgY29tcHV0ZXMgdGhlIGludGVyc2VjdGlvbiBhbmQgaW52b2tlcyBgb25BZGRgIGZvciBldmVyeSBlbGVtZW50IHRoYXRcbiAqIGlzIGluIGBhZnRlcmAgYnV0IG5vdCBgYmVmb3JlYC4gYG9uUmVtb3ZlYCBpcyBpbnZva2VkIGZvciBldmVyeSBlbGVtZW50IGluXG4gKiBgYmVmb3JlYCBidXQgbWlzc2luZyBmcm9tIGBhZnRlcmAuXG4gKlxuICogVGhlIG1ldGhvZCBjcmVhdGVzIGEgY29weSBvZiBib3RoIGBiZWZvcmVgIGFuZCBgYWZ0ZXJgIGFuZCBydW5zIGluIE8obiBsb2dcbiAqIG4pLCB3aGVyZSBuIGlzIHRoZSBzaXplIG9mIHRoZSB0d28gbGlzdHMuXG4gKlxuICogQHBhcmFtIGJlZm9yZSAtIFRoZSBlbGVtZW50cyB0aGF0IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBzZXQuXG4gKiBAcGFyYW0gYWZ0ZXIgLSBUaGUgZWxlbWVudHMgdG8gZGlmZiBhZ2FpbnN0IHRoZSBvcmlnaW5hbCBzZXQuXG4gKiBAcGFyYW0gY29tcGFyYXRvciAtIFRoZSBjb21wYXJhdG9yIGZvciB0aGUgZWxlbWVudHMgaW4gYmVmb3JlIGFuZCBhZnRlci5cbiAqIEBwYXJhbSBvbkFkZCAtIEEgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBldmVyeSBlbGVtZW50IHRoYXQgaXMgcGFydCBvZiBgXG4gKiBhZnRlcmAgYnV0IG5vdCBgYmVmb3JlYC5cbiAqIEBwYXJhbSBvblJlbW92ZSAtIEEgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBldmVyeSBlbGVtZW50IHRoYXQgaXMgcGFydCBvZlxuICogYGJlZm9yZWAgYnV0IG5vdCBgYWZ0ZXJgLlxuICovXG5mdW5jdGlvbiBkaWZmU29ydGVkU2V0cyhiZWZvcmUsIGFmdGVyLCBjb21wYXJhdG9yLCBvbkFkZCwgb25SZW1vdmUpIHtcbiAgICBjb25zdCBiZWZvcmVJdCA9IGJlZm9yZS5nZXRJdGVyYXRvcigpO1xuICAgIGNvbnN0IGFmdGVySXQgPSBhZnRlci5nZXRJdGVyYXRvcigpO1xuICAgIGxldCBiZWZvcmVWYWx1ZSA9IGFkdmFuY2VJdGVyYXRvcihiZWZvcmVJdCk7XG4gICAgbGV0IGFmdGVyVmFsdWUgPSBhZHZhbmNlSXRlcmF0b3IoYWZ0ZXJJdCk7XG4gICAgLy8gV2FsayB0aHJvdWdoIHRoZSB0d28gc2V0cyBhdCB0aGUgc2FtZSB0aW1lLCB1c2luZyB0aGUgb3JkZXJpbmcgZGVmaW5lZCBieVxuICAgIC8vIGBjb21wYXJhdG9yYC5cbiAgICB3aGlsZSAoYmVmb3JlVmFsdWUgfHwgYWZ0ZXJWYWx1ZSkge1xuICAgICAgICBsZXQgYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGJlZm9yZVZhbHVlICYmIGFmdGVyVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmF0b3IoYmVmb3JlVmFsdWUsIGFmdGVyVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZWxlbWVudCB3YXMgcmVtb3ZlZCBpZiB0aGUgbmV4dCBlbGVtZW50IGluIG91ciBvcmRlcmVkXG4gICAgICAgICAgICAgICAgLy8gd2Fsa3Rocm91Z2ggaXMgb25seSBpbiBgYmVmb3JlYC5cbiAgICAgICAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZWxlbWVudCB3YXMgYWRkZWQgaWYgdGhlIG5leHQgZWxlbWVudCBpbiBvdXIgb3JkZXJlZCB3YWxrdGhyb3VnaFxuICAgICAgICAgICAgICAgIC8vIGlzIG9ubHkgaW4gYGFmdGVyYC5cbiAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmVmb3JlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZGVkKSB7XG4gICAgICAgICAgICBvbkFkZChhZnRlclZhbHVlKTtcbiAgICAgICAgICAgIGFmdGVyVmFsdWUgPSBhZHZhbmNlSXRlcmF0b3IoYWZ0ZXJJdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgb25SZW1vdmUoYmVmb3JlVmFsdWUpO1xuICAgICAgICAgICAgYmVmb3JlVmFsdWUgPSBhZHZhbmNlSXRlcmF0b3IoYmVmb3JlSXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmVmb3JlVmFsdWUgPSBhZHZhbmNlSXRlcmF0b3IoYmVmb3JlSXQpO1xuICAgICAgICAgICAgYWZ0ZXJWYWx1ZSA9IGFkdmFuY2VJdGVyYXRvcihhZnRlckl0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbmV4dCBlbGVtZW50IGZyb20gdGhlIGl0ZXJhdG9yIG9yIGB1bmRlZmluZWRgIGlmIG5vbmUgYXZhaWxhYmxlLlxuICovXG5mdW5jdGlvbiBhZHZhbmNlSXRlcmF0b3IoaXQpIHtcbiAgICByZXR1cm4gaXQuaGFzTmV4dCgpID8gaXQuZ2V0TmV4dCgpIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlcyBhIHNldCBvZiBmaWVsZHMgdGhhdCBjYW4gYmUgdXNlZCB0byBwYXJ0aWFsbHkgcGF0Y2ggYSBkb2N1bWVudC5cbiAqIEZpZWxkTWFzayBpcyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggT2JqZWN0VmFsdWUuXG4gKiBFeGFtcGxlczpcbiAqICAgZm9vIC0gT3ZlcndyaXRlcyBmb28gZW50aXJlbHkgd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWUuIElmIGZvbyBpcyBub3RcbiAqICAgICAgICAgcHJlc2VudCBpbiB0aGUgY29tcGFuaW9uIE9iamVjdFZhbHVlLCB0aGUgZmllbGQgaXMgZGVsZXRlZC5cbiAqICAgZm9vLmJhciAtIE92ZXJ3cml0ZXMgb25seSB0aGUgZmllbGQgYmFyIG9mIHRoZSBvYmplY3QgZm9vLlxuICogICAgICAgICAgICAgSWYgZm9vIGlzIG5vdCBhbiBvYmplY3QsIGZvbyBpcyByZXBsYWNlZCB3aXRoIGFuIG9iamVjdFxuICogICAgICAgICAgICAgY29udGFpbmluZyBmb29cbiAqL1xuY2xhc3MgRmllbGRNYXNrIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIC8vIFRPRE8oZGltb25kKTogdmFsaWRhdGlvbiBvZiBGaWVsZE1hc2tcbiAgICAgICAgLy8gU29ydCB0aGUgZmllbGQgbWFzayB0byBzdXBwb3J0IGBGaWVsZE1hc2suaXNFcXVhbCgpYCBhbmQgYXNzZXJ0IGJlbG93LlxuICAgICAgICBmaWVsZHMuc29ydChGaWVsZFBhdGgkMS5jb21wYXJhdG9yKTtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkTWFzayhbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgRmllbGRNYXNrIG9iamVjdCB0aGF0IGlzIHRoZSByZXN1bHQgb2YgYWRkaW5nIGFsbCB0aGUgZ2l2ZW5cbiAgICAgKiBmaWVsZHMgcGF0aHMgdG8gdGhpcyBmaWVsZCBtYXNrLlxuICAgICAqL1xuICAgIHVuaW9uV2l0aChleHRyYUZpZWxkcykge1xuICAgICAgICBsZXQgbWVyZ2VkTWFza1NldCA9IG5ldyBTb3J0ZWRTZXQoRmllbGRQYXRoJDEuY29tcGFyYXRvcik7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRQYXRoIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBtZXJnZWRNYXNrU2V0ID0gbWVyZ2VkTWFza1NldC5hZGQoZmllbGRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkUGF0aCBvZiBleHRyYUZpZWxkcykge1xuICAgICAgICAgICAgbWVyZ2VkTWFza1NldCA9IG1lcmdlZE1hc2tTZXQuYWRkKGZpZWxkUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZE1hc2sobWVyZ2VkTWFza1NldC50b0FycmF5KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGF0IGBmaWVsZFBhdGhgIGlzIGluY2x1ZGVkIGJ5IGF0IGxlYXN0IG9uZSBmaWVsZCBpbiB0aGlzIGZpZWxkXG4gICAgICogbWFzay5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gTyhuKSBvcGVyYXRpb24sIHdoZXJlIGBuYCBpcyB0aGUgc2l6ZSBvZiB0aGUgZmllbGQgbWFzay5cbiAgICAgKi9cbiAgICBjb3ZlcnMoZmllbGRQYXRoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRNYXNrUGF0aCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZpZWxkTWFza1BhdGguaXNQcmVmaXhPZihmaWVsZFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBhcnJheUVxdWFscyh0aGlzLmZpZWxkcywgb3RoZXIuZmllbGRzLCAobCwgcikgPT4gbC5pc0VxdWFsKHIpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogQ29udmVydHMgYSBCYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBiaW5hcnkgc3RyaW5nLiAqL1xuZnVuY3Rpb24gZGVjb2RlQmFzZTY0KGVuY29kZWQpIHtcbiAgICAvLyBOb3RlOiBXZSB1c2VkIHRvIHZhbGlkYXRlIHRoZSBiYXNlNjQgc3RyaW5nIGhlcmUgdmlhIGEgcmVndWxhciBleHByZXNzaW9uLlxuICAgIC8vIFRoaXMgd2FzIHJlbW92ZWQgdG8gaW1wcm92ZSB0aGUgcGVyZm9ybWFuY2Ugb2YgaW5kZXhpbmcuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGVuY29kZWQsICdiYXNlNjQnKS50b1N0cmluZygnYmluYXJ5Jyk7XG59XG4vKiogQ29udmVydHMgYSBiaW5hcnkgc3RyaW5nIHRvIGEgQmFzZTY0IGVuY29kZWQgc3RyaW5nLiAqL1xuZnVuY3Rpb24gZW5jb2RlQmFzZTY0KHJhdykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShyYXcsICdiaW5hcnknKS50b1N0cmluZygnYmFzZTY0Jyk7XG59XG4vKiogVHJ1ZSBpZiBhbmQgb25seSBpZiB0aGUgQmFzZTY0IGNvbnZlcnNpb24gZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUuICovXG5mdW5jdGlvbiBpc0Jhc2U2NEF2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogSW1tdXRhYmxlIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIFwicHJvdG9cIiBieXRlIHN0cmluZy5cbiAqXG4gKiBQcm90byBieXRlIHN0cmluZ3MgY2FuIGVpdGhlciBiZSBCYXNlNjQtZW5jb2RlZCBzdHJpbmdzIG9yIFVpbnQ4QXJyYXlzIHdoZW5cbiAqIHNlbnQgb24gdGhlIHdpcmUuIFRoaXMgY2xhc3MgYWJzdHJhY3RzIGF3YXkgdGhpcyBkaWZmZXJlbnRpYXRpb24gYnkgaG9sZGluZ1xuICogdGhlIHByb3RvIGJ5dGUgc3RyaW5nIGluIGEgY29tbW9uIGNsYXNzIHRoYXQgbXVzdCBiZSBjb252ZXJ0ZWQgaW50byBhIHN0cmluZ1xuICogYmVmb3JlIGJlaW5nIHNlbnQgYXMgYSBwcm90by5cbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBCeXRlU3RyaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihiaW5hcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5iaW5hcnlTdHJpbmcgPSBiaW5hcnlTdHJpbmc7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmFzZTY0U3RyaW5nKGJhc2U2NCkge1xuICAgICAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBkZWNvZGVCYXNlNjQoYmFzZTY0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlU3RyaW5nKGJpbmFyeVN0cmluZyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tVWludDhBcnJheShhcnJheSkge1xuICAgICAgICAvLyBUT0RPKGluZGV4aW5nKTsgUmVtb3ZlIHRoZSBjb3B5IG9mIHRoZSBieXRlIHN0cmluZyBoZXJlIGFzIHRoaXMgbWV0aG9kXG4gICAgICAgIC8vIGlzIGZyZXF1ZW50bHkgY2FsbGVkIGR1cmluZyBpbmRleGluZy5cbiAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYmluYXJ5U3RyaW5nRnJvbVVpbnQ4QXJyYXkoYXJyYXkpO1xuICAgICAgICByZXR1cm4gbmV3IEJ5dGVTdHJpbmcoYmluYXJ5U3RyaW5nKTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IHRoaXMuYmluYXJ5U3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy5iaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKyspLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9CYXNlNjQoKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVCYXNlNjQodGhpcy5iaW5hcnlTdHJpbmcpO1xuICAgIH1cbiAgICB0b1VpbnQ4QXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5RnJvbUJpbmFyeVN0cmluZyh0aGlzLmJpbmFyeVN0cmluZyk7XG4gICAgfVxuICAgIGFwcHJveGltYXRlQnl0ZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmFyeVN0cmluZy5sZW5ndGggKiAyO1xuICAgIH1cbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IodGhpcy5iaW5hcnlTdHJpbmcsIG90aGVyLmJpbmFyeVN0cmluZyk7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5U3RyaW5nID09PSBvdGhlci5iaW5hcnlTdHJpbmc7XG4gICAgfVxufVxuQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORyA9IG5ldyBCeXRlU3RyaW5nKCcnKTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYW4gVWludDhhcnJheSB0byBhIGJpbmFyeSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJpbmFyeVN0cmluZ0Zyb21VaW50OEFycmF5KGFycmF5KSB7XG4gICAgbGV0IGJpbmFyeVN0cmluZyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYmluYXJ5U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYmluYXJ5U3RyaW5nO1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhIGJpbmFyeSBzdHJpbmcgdG8gYW4gVWludDhBcnJheS5cbiAqL1xuZnVuY3Rpb24gdWludDhBcnJheUZyb21CaW5hcnlTdHJpbmcoYmluYXJ5U3RyaW5nKSB7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnVmZmVyW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBBIFJlZ0V4cCBtYXRjaGluZyBJU08gODYwMSBVVEMgdGltZXN0YW1wcyB3aXRoIG9wdGlvbmFsIGZyYWN0aW9uLlxuY29uc3QgSVNPX1RJTUVTVEFNUF9SRUdfRVhQID0gbmV3IFJlZ0V4cCgvXlxcZHs0fS1cXGRcXGQtXFxkXFxkVFxcZFxcZDpcXGRcXGQ6XFxkXFxkKD86XFwuKFxcZCspKT9aJC8pO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcG9zc2libGUgUHJvdG8gdmFsdWVzIGZvciBhIHRpbWVzdGFtcCB2YWx1ZSBpbnRvIGEgXCJzZWNvbmRzIGFuZFxuICogbmFub3NcIiByZXByZXNlbnRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplVGltZXN0YW1wKGRhdGUpIHtcbiAgICBoYXJkQXNzZXJ0KCEhZGF0ZSk7XG4gICAgLy8gVGhlIGpzb24gaW50ZXJmYWNlIChmb3IgdGhlIGJyb3dzZXIpIHdpbGwgcmV0dXJuIGFuIGlzbyB0aW1lc3RhbXAgc3RyaW5nLFxuICAgIC8vIHdoaWxlIHRoZSBwcm90byBqcyBsaWJyYXJ5IChmb3Igbm9kZSkgd2lsbCByZXR1cm4gYVxuICAgIC8vIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgaW5zdGFuY2UuXG4gICAgaWYgKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBUaGUgZGF0ZSBzdHJpbmcgY2FuIGhhdmUgaGlnaGVyIHByZWNpc2lvbiAobmFub3MpIHRoYW4gdGhlIERhdGUgY2xhc3NcbiAgICAgICAgLy8gKG1pbGxpcyksIHNvIHdlIGRvIHNvbWUgY3VzdG9tIHBhcnNpbmcgaGVyZS5cbiAgICAgICAgLy8gUGFyc2UgdGhlIG5hbm9zIHJpZ2h0IG91dCBvZiB0aGUgc3RyaW5nLlxuICAgICAgICBsZXQgbmFub3MgPSAwO1xuICAgICAgICBjb25zdCBmcmFjdGlvbiA9IElTT19USU1FU1RBTVBfUkVHX0VYUC5leGVjKGRhdGUpO1xuICAgICAgICBoYXJkQXNzZXJ0KCEhZnJhY3Rpb24pO1xuICAgICAgICBpZiAoZnJhY3Rpb25bMV0pIHtcbiAgICAgICAgICAgIC8vIFBhZCB0aGUgZnJhY3Rpb24gb3V0IHRvIDkgZGlnaXRzIChuYW5vcykuXG4gICAgICAgICAgICBsZXQgbmFub1N0ciA9IGZyYWN0aW9uWzFdO1xuICAgICAgICAgICAgbmFub1N0ciA9IChuYW5vU3RyICsgJzAwMDAwMDAwMCcpLnN1YnN0cigwLCA5KTtcbiAgICAgICAgICAgIG5hbm9zID0gTnVtYmVyKG5hbm9TdHIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlIHRoZSBkYXRlIHRvIGdldCB0aGUgc2Vjb25kcy5cbiAgICAgICAgY29uc3QgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICBjb25zdCBzZWNvbmRzID0gTWF0aC5mbG9vcihwYXJzZWREYXRlLmdldFRpbWUoKSAvIDEwMDApO1xuICAgICAgICByZXR1cm4geyBzZWNvbmRzLCBuYW5vcyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVE9ETyhiLzM3MjgyMjM3KTogVXNlIHN0cmluZ3MgZm9yIFByb3RvMyB0aW1lc3RhbXBzXG4gICAgICAgIC8vIGFzc2VydCghdGhpcy5vcHRpb25zLnVzZVByb3RvM0pzb24sXG4gICAgICAgIC8vICAgJ1RoZSB0aW1lc3RhbXAgaW5zdGFuY2UgZm9ybWF0IHJlcXVpcmVzIFByb3RvIEpTLicpO1xuICAgICAgICBjb25zdCBzZWNvbmRzID0gbm9ybWFsaXplTnVtYmVyKGRhdGUuc2Vjb25kcyk7XG4gICAgICAgIGNvbnN0IG5hbm9zID0gbm9ybWFsaXplTnVtYmVyKGRhdGUubmFub3MpO1xuICAgICAgICByZXR1cm4geyBzZWNvbmRzLCBuYW5vcyB9O1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgdGhlIHBvc3NpYmxlIFByb3RvIHR5cGVzIGZvciBudW1iZXJzIGludG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAqIFJldHVybnMgMCBpZiB0aGUgdmFsdWUgaXMgbm90IG51bWVyaWMuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZU51bWJlcih2YWx1ZSkge1xuICAgIC8vIFRPRE8oYmpvcm5pY2spOiBIYW5kbGUgaW50NjQgZ3JlYXRlciB0aGFuIDUzIGJpdHMuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuLyoqIENvbnZlcnRzIHRoZSBwb3NzaWJsZSBQcm90byB0eXBlcyBmb3IgQmxvYnMgaW50byBhIEJ5dGVTdHJpbmcuICovXG5mdW5jdGlvbiBub3JtYWxpemVCeXRlU3RyaW5nKGJsb2IpIHtcbiAgICBpZiAodHlwZW9mIGJsb2IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBCeXRlU3RyaW5nLmZyb21CYXNlNjRTdHJpbmcoYmxvYik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gQnl0ZVN0cmluZy5mcm9tVWludDhBcnJheShibG9iKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSBsb2NhbGx5LWFwcGxpZWQgU2VydmVyVGltZXN0YW1wLlxuICpcbiAqIFNlcnZlciBUaW1lc3RhbXBzIGFyZSBiYWNrZWQgYnkgTWFwVmFsdWVzIHRoYXQgY29udGFpbiBhbiBpbnRlcm5hbCBmaWVsZFxuICogYF9fdHlwZV9fYCB3aXRoIGEgdmFsdWUgb2YgYHNlcnZlcl90aW1lc3RhbXBgLiBUaGUgcHJldmlvdXMgdmFsdWUgYW5kIGxvY2FsXG4gKiB3cml0ZSB0aW1lIGFyZSBzdG9yZWQgaW4gaXRzIGBfX3ByZXZpb3VzX3ZhbHVlX19gIGFuZCBgX19sb2NhbF93cml0ZV90aW1lX19gXG4gKiBmaWVsZHMgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIE5vdGVzOlxuICogLSBTZXJ2ZXJUaW1lc3RhbXBWYWx1ZSBpbnN0YW5jZXMgYXJlIGNyZWF0ZWQgYXMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBhXG4gKiAgIHRyYW5zZm9ybS4gVGhleSBjYW4gb25seSBleGlzdCBpbiB0aGUgbG9jYWwgdmlldyBvZiBhIGRvY3VtZW50LiBUaGVyZWZvcmVcbiAqICAgdGhleSBkbyBub3QgbmVlZCB0byBiZSBwYXJzZWQgb3Igc2VyaWFsaXplZC5cbiAqIC0gV2hlbiBldmFsdWF0ZWQgbG9jYWxseSAoZS5nLiBmb3Igc25hcHNob3QuZGF0YSgpKSwgdGhleSBieSBkZWZhdWx0XG4gKiAgIGV2YWx1YXRlIHRvIGBudWxsYC4gVGhpcyBiZWhhdmlvciBjYW4gYmUgY29uZmlndXJlZCBieSBwYXNzaW5nIGN1c3RvbVxuICogICBGaWVsZFZhbHVlT3B0aW9ucyB0byB2YWx1ZSgpLlxuICogLSBXaXRoIHJlc3BlY3QgdG8gb3RoZXIgU2VydmVyVGltZXN0YW1wVmFsdWVzLCB0aGV5IHNvcnQgYnkgdGhlaXJcbiAqICAgbG9jYWxXcml0ZVRpbWUuXG4gKi9cbmNvbnN0IFNFUlZFUl9USU1FU1RBTVBfU0VOVElORUwgPSAnc2VydmVyX3RpbWVzdGFtcCc7XG5jb25zdCBUWVBFX0tFWSQxID0gJ19fdHlwZV9fJztcbmNvbnN0IFBSRVZJT1VTX1ZBTFVFX0tFWSA9ICdfX3ByZXZpb3VzX3ZhbHVlX18nO1xuY29uc3QgTE9DQUxfV1JJVEVfVElNRV9LRVkgPSAnX19sb2NhbF93cml0ZV90aW1lX18nO1xuZnVuY3Rpb24gaXNTZXJ2ZXJUaW1lc3RhbXAodmFsdWUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHR5cGUgPSAoX2IgPSAoKChfYSA9IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5tYXBWYWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpZWxkcykgfHwge30pW1RZUEVfS0VZJDFdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RyaW5nVmFsdWU7XG4gICAgcmV0dXJuIHR5cGUgPT09IFNFUlZFUl9USU1FU1RBTVBfU0VOVElORUw7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU2VydmVyVGltZXN0YW1wIHByb3RvIHZhbHVlICh1c2luZyB0aGUgaW50ZXJuYWwgZm9ybWF0KS5cbiAqL1xuZnVuY3Rpb24gc2VydmVyVGltZXN0YW1wJDEobG9jYWxXcml0ZVRpbWUsIHByZXZpb3VzVmFsdWUpIHtcbiAgICBjb25zdCBtYXBWYWx1ZSA9IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICBbVFlQRV9LRVkkMV06IHtcbiAgICAgICAgICAgICAgICBzdHJpbmdWYWx1ZTogU0VSVkVSX1RJTUVTVEFNUF9TRU5USU5FTFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtMT0NBTF9XUklURV9USU1FX0tFWV06IHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXBWYWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBzZWNvbmRzOiBsb2NhbFdyaXRlVGltZS5zZWNvbmRzLFxuICAgICAgICAgICAgICAgICAgICBuYW5vczogbG9jYWxXcml0ZVRpbWUubmFub3NlY29uZHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFdlIHNob3VsZCBhdm9pZCBzdG9yaW5nIGRlZXBseSBuZXN0ZWQgc2VydmVyIHRpbWVzdGFtcCBtYXAgdmFsdWVzXG4gICAgLy8gYmVjYXVzZSB3ZSBuZXZlciB1c2UgdGhlIGludGVybWVkaWF0ZSBcInByZXZpb3VzIHZhbHVlc1wiLlxuICAgIC8vIEZvciBleGFtcGxlOlxuICAgIC8vIHByZXZpb3VzOiA0MkwsIGFkZDogdDEsIHJlc3VsdDogdDEgLT4gNDJMXG4gICAgLy8gcHJldmlvdXM6IHQxLCAgYWRkOiB0MiwgcmVzdWx0OiB0MiAtPiA0MkwgKE5PVCB0MiAtPiB0MSAtPiA0MkwpXG4gICAgLy8gcHJldmlvdXM6IHQyLCAgYWRkOiB0MywgcmVzdWx0OiB0MyAtPiA0MkwgKE5PVCB0MyAtPiB0MiAtPiB0MSAtPiA0MkwpXG4gICAgLy8gYGdldFByZXZpb3VzVmFsdWVgIHJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBzZXJ2ZXIgdGltZXN0YW1wcyB0byBmaW5kIHRoZVxuICAgIC8vIGxlYXN0IHJlY2VudCBWYWx1ZS5cbiAgICBpZiAocHJldmlvdXNWYWx1ZSAmJiBpc1NlcnZlclRpbWVzdGFtcChwcmV2aW91c1ZhbHVlKSkge1xuICAgICAgICBwcmV2aW91c1ZhbHVlID0gZ2V0UHJldmlvdXNWYWx1ZShwcmV2aW91c1ZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgbWFwVmFsdWUuZmllbGRzW1BSRVZJT1VTX1ZBTFVFX0tFWV0gPSBwcmV2aW91c1ZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4geyBtYXBWYWx1ZSB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmllbGQgYmVmb3JlIHRoaXMgU2VydmVyVGltZXN0YW1wIHdhcyBzZXQuXG4gKlxuICogUHJlc2VydmluZyB0aGUgcHJldmlvdXMgdmFsdWVzIGFsbG93cyB0aGUgdXNlciB0byBkaXNwbGF5IHRoZSBsYXN0IHJlc29sZWRcbiAqIHZhbHVlIHVudGlsIHRoZSBiYWNrZW5kIHJlc3BvbmRzIHdpdGggdGhlIHRpbWVzdGFtcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJldmlvdXNWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB2YWx1ZS5tYXBWYWx1ZS5maWVsZHNbUFJFVklPVVNfVkFMVUVfS0VZXTtcbiAgICBpZiAoaXNTZXJ2ZXJUaW1lc3RhbXAocHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGdldFByZXZpb3VzVmFsdWUocHJldmlvdXNWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsb2NhbCB0aW1lIGF0IHdoaWNoIHRoaXMgdGltZXN0YW1wIHdhcyBmaXJzdCBzZXQuXG4gKi9cbmZ1bmN0aW9uIGdldExvY2FsV3JpdGVUaW1lKHZhbHVlKSB7XG4gICAgY29uc3QgbG9jYWxXcml0ZVRpbWUgPSBub3JtYWxpemVUaW1lc3RhbXAodmFsdWUubWFwVmFsdWUuZmllbGRzW0xPQ0FMX1dSSVRFX1RJTUVfS0VZXS50aW1lc3RhbXBWYWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAobG9jYWxXcml0ZVRpbWUuc2Vjb25kcywgbG9jYWxXcml0ZVRpbWUubmFub3MpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgRGF0YWJhc2VJbmZvIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgRGF0YWJhc2VJbmZvIHVzaW5nIHRoZSBwcm92aWRlZCBob3N0LCBkYXRhYmFzZUlkIGFuZFxuICAgICAqIHBlcnNpc3RlbmNlS2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFiYXNlSWQgLSBUaGUgZGF0YWJhc2UgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBhcHBJZCAtIFRoZSBGaXJlYmFzZSBBcHAgSWQuXG4gICAgICogQHBhcmFtIHBlcnNpc3RlbmNlS2V5IC0gQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBGaXJlc3RvcmUncyBsb2NhbFxuICAgICAqIHN0b3JhZ2UgKHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgZGF0YWJhc2VJZCkuXG4gICAgICogQHBhcmFtIGhvc3QgLSBUaGUgRmlyZXN0b3JlIGJhY2tlbmQgaG9zdCB0byBjb25uZWN0IHRvLlxuICAgICAqIEBwYXJhbSBzc2wgLSBXaGV0aGVyIHRvIHVzZSBTU0wgd2hlbiBjb25uZWN0aW5nLlxuICAgICAqIEBwYXJhbSBmb3JjZUxvbmdQb2xsaW5nIC0gV2hldGhlciB0byB1c2UgdGhlIGZvcmNlTG9uZ1BvbGxpbmcgb3B0aW9uXG4gICAgICogd2hlbiB1c2luZyBXZWJDaGFubmVsIGFzIHRoZSBuZXR3b3JrIHRyYW5zcG9ydC5cbiAgICAgKiBAcGFyYW0gYXV0b0RldGVjdExvbmdQb2xsaW5nIC0gV2hldGhlciB0byB1c2UgdGhlIGRldGVjdEJ1ZmZlcmluZ1Byb3h5XG4gICAgICogb3B0aW9uIHdoZW4gdXNpbmcgV2ViQ2hhbm5lbCBhcyB0aGUgbmV0d29yayB0cmFuc3BvcnQuXG4gICAgICogQHBhcmFtIGxvbmdQb2xsaW5nT3B0aW9ucyBPcHRpb25zIHRoYXQgY29uZmlndXJlIGxvbmctcG9sbGluZy5cbiAgICAgKiBAcGFyYW0gdXNlRmV0Y2hTdHJlYW1zIFdoZXRoZXIgdG8gdXNlIHRoZSBGZXRjaCBBUEkgaW5zdGVhZCBvZlxuICAgICAqIFhNTEhUVFBSZXF1ZXN0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGF0YWJhc2VJZCwgYXBwSWQsIHBlcnNpc3RlbmNlS2V5LCBob3N0LCBzc2wsIGZvcmNlTG9uZ1BvbGxpbmcsIGF1dG9EZXRlY3RMb25nUG9sbGluZywgbG9uZ1BvbGxpbmdPcHRpb25zLCB1c2VGZXRjaFN0cmVhbXMpIHtcbiAgICAgICAgdGhpcy5kYXRhYmFzZUlkID0gZGF0YWJhc2VJZDtcbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkO1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlS2V5ID0gcGVyc2lzdGVuY2VLZXk7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuc3NsID0gc3NsO1xuICAgICAgICB0aGlzLmZvcmNlTG9uZ1BvbGxpbmcgPSBmb3JjZUxvbmdQb2xsaW5nO1xuICAgICAgICB0aGlzLmF1dG9EZXRlY3RMb25nUG9sbGluZyA9IGF1dG9EZXRlY3RMb25nUG9sbGluZztcbiAgICAgICAgdGhpcy5sb25nUG9sbGluZ09wdGlvbnMgPSBsb25nUG9sbGluZ09wdGlvbnM7XG4gICAgICAgIHRoaXMudXNlRmV0Y2hTdHJlYW1zID0gdXNlRmV0Y2hTdHJlYW1zO1xuICAgIH1cbn1cbi8qKiBUaGUgZGVmYXVsdCBkYXRhYmFzZSBuYW1lIGZvciBhIHByb2plY3QuICovXG5jb25zdCBERUZBVUxUX0RBVEFCQVNFX05BTUUgPSAnKGRlZmF1bHQpJztcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZGF0YWJhc2UgSUQgYSBGaXJlc3RvcmUgY2xpZW50IGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBEYXRhYmFzZUlkIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9qZWN0SWQsIGRhdGFiYXNlKSB7XG4gICAgICAgIHRoaXMucHJvamVjdElkID0gcHJvamVjdElkO1xuICAgICAgICB0aGlzLmRhdGFiYXNlID0gZGF0YWJhc2UgPyBkYXRhYmFzZSA6IERFRkFVTFRfREFUQUJBU0VfTkFNRTtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGFiYXNlSWQoJycsICcnKTtcbiAgICB9XG4gICAgZ2V0IGlzRGVmYXVsdERhdGFiYXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhYmFzZSA9PT0gREVGQVVMVF9EQVRBQkFTRV9OQU1FO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBEYXRhYmFzZUlkICYmXG4gICAgICAgICAgICBvdGhlci5wcm9qZWN0SWQgPT09IHRoaXMucHJvamVjdElkICYmXG4gICAgICAgICAgICBvdGhlci5kYXRhYmFzZSA9PT0gdGhpcy5kYXRhYmFzZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGF0YWJhc2VJZEZyb21BcHAoYXBwLCBkYXRhYmFzZSkge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5hcHBseShhcHAub3B0aW9ucywgWydwcm9qZWN0SWQnXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1wicHJvamVjdElkXCIgbm90IHByb3ZpZGVkIGluIGZpcmViYXNlLmluaXRpYWxpemVBcHAuJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0YWJhc2VJZChhcHAub3B0aW9ucy5wcm9qZWN0SWQsIGRhdGFiYXNlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBTZW50aW5lbCB2YWx1ZSB0aGF0IHNvcnRzIGJlZm9yZSBhbnkgTXV0YXRpb24gQmF0Y2ggSUQuICovXG5jb25zdCBCQVRDSElEX1VOS05PV04gPSAtMTtcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgdmFyaWFibGUgaXMgZWl0aGVyIHVuZGVmaW5lZCBvciBudWxsLlxuICovXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuLyoqIFJldHVybnMgd2hldGhlciB0aGUgdmFsdWUgcmVwcmVzZW50cyAtMC4gKi9cbmZ1bmN0aW9uIGlzTmVnYXRpdmVaZXJvKHZhbHVlKSB7XG4gICAgLy8gRGV0ZWN0IGlmIHRoZSB2YWx1ZSBpcyAtMC4wLiBCYXNlZCBvbiBwb2x5ZmlsbCBmcm9tXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAgcmV0dXJuIHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA9PT0gMSAvIC0wO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyIGFuZCBpbiB0aGUgc2FmZSBpbnRlZ2VyIHJhbmdlXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdCBmb3IgYmVpbmcgYW4gaW50ZWdlciBhbmQgaW4gdGhlIHNhZmUgcmFuZ2VcbiAqL1xuZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJlxuICAgICAgICAhaXNOZWdhdGl2ZVplcm8odmFsdWUpICYmXG4gICAgICAgIHZhbHVlIDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmXG4gICAgICAgIHZhbHVlID49IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IFRZUEVfS0VZID0gJ19fdHlwZV9fJztcbmNvbnN0IE1BWF9WQUxVRV9UWVBFID0gJ19fbWF4X18nO1xuY29uc3QgTUFYX1ZBTFVFID0ge1xuICAgIG1hcFZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgJ19fdHlwZV9fJzogeyBzdHJpbmdWYWx1ZTogTUFYX1ZBTFVFX1RZUEUgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IFZFQ1RPUl9WQUxVRV9TRU5USU5FTCA9ICdfX3ZlY3Rvcl9fJztcbmNvbnN0IFZFQ1RPUl9NQVBfVkVDVE9SU19LRVkgPSAndmFsdWUnO1xuY29uc3QgTUlOX1ZBTFVFID0ge1xuICAgIG51bGxWYWx1ZTogJ05VTExfVkFMVUUnXG59O1xuLyoqIEV4dHJhY3RzIHRoZSBiYWNrZW5kJ3MgdHlwZSBvcmRlciBmb3IgdGhlIHByb3ZpZGVkIHZhbHVlLiAqL1xuZnVuY3Rpb24gdHlwZU9yZGVyKHZhbHVlKSB7XG4gICAgaWYgKCdudWxsVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAwIC8qIFR5cGVPcmRlci5OdWxsVmFsdWUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCdib29sZWFuVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFR5cGVPcmRlci5Cb29sZWFuVmFsdWUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIHZhbHVlIHx8ICdkb3VibGVWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDIgLyogVHlwZU9yZGVyLk51bWJlclZhbHVlICovO1xuICAgIH1cbiAgICBlbHNlIGlmICgndGltZXN0YW1wVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAzIC8qIFR5cGVPcmRlci5UaW1lc3RhbXBWYWx1ZSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3N0cmluZ1ZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gNSAvKiBUeXBlT3JkZXIuU3RyaW5nVmFsdWUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCdieXRlc1ZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gNiAvKiBUeXBlT3JkZXIuQmxvYlZhbHVlICovO1xuICAgIH1cbiAgICBlbHNlIGlmICgncmVmZXJlbmNlVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiA3IC8qIFR5cGVPcmRlci5SZWZWYWx1ZSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2dlb1BvaW50VmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiA4IC8qIFR5cGVPcmRlci5HZW9Qb2ludFZhbHVlICovO1xuICAgIH1cbiAgICBlbHNlIGlmICgnYXJyYXlWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDkgLyogVHlwZU9yZGVyLkFycmF5VmFsdWUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCdtYXBWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzU2VydmVyVGltZXN0YW1wKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDQgLyogVHlwZU9yZGVyLlNlcnZlclRpbWVzdGFtcFZhbHVlICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTWF4VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gOTAwNzE5OTI1NDc0MDk5MSAvKiBUeXBlT3JkZXIuTWF4VmFsdWUgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNWZWN0b3JWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAxMCAvKiBUeXBlT3JkZXIuVmVjdG9yVmFsdWUgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDExIC8qIFR5cGVPcmRlci5PYmplY3RWYWx1ZSAqLztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxufVxuLyoqIFRlc3RzIGBsZWZ0YCBhbmQgYHJpZ2h0YCBmb3IgZXF1YWxpdHkgYmFzZWQgb24gdGhlIGJhY2tlbmQgc2VtYW50aWNzLiAqL1xuZnVuY3Rpb24gdmFsdWVFcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdCA9PT0gcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGxlZnRUeXBlID0gdHlwZU9yZGVyKGxlZnQpO1xuICAgIGNvbnN0IHJpZ2h0VHlwZSA9IHR5cGVPcmRlcihyaWdodCk7XG4gICAgaWYgKGxlZnRUeXBlICE9PSByaWdodFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzd2l0Y2ggKGxlZnRUeXBlKSB7XG4gICAgICAgIGNhc2UgMCAvKiBUeXBlT3JkZXIuTnVsbFZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgMSAvKiBUeXBlT3JkZXIuQm9vbGVhblZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQuYm9vbGVhblZhbHVlID09PSByaWdodC5ib29sZWFuVmFsdWU7XG4gICAgICAgIGNhc2UgNCAvKiBUeXBlT3JkZXIuU2VydmVyVGltZXN0YW1wVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gZ2V0TG9jYWxXcml0ZVRpbWUobGVmdCkuaXNFcXVhbChnZXRMb2NhbFdyaXRlVGltZShyaWdodCkpO1xuICAgICAgICBjYXNlIDMgLyogVHlwZU9yZGVyLlRpbWVzdGFtcFZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIHRpbWVzdGFtcEVxdWFscyhsZWZ0LCByaWdodCk7XG4gICAgICAgIGNhc2UgNSAvKiBUeXBlT3JkZXIuU3RyaW5nVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gbGVmdC5zdHJpbmdWYWx1ZSA9PT0gcmlnaHQuc3RyaW5nVmFsdWU7XG4gICAgICAgIGNhc2UgNiAvKiBUeXBlT3JkZXIuQmxvYlZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGJsb2JFcXVhbHMobGVmdCwgcmlnaHQpO1xuICAgICAgICBjYXNlIDcgLyogVHlwZU9yZGVyLlJlZlZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQucmVmZXJlbmNlVmFsdWUgPT09IHJpZ2h0LnJlZmVyZW5jZVZhbHVlO1xuICAgICAgICBjYXNlIDggLyogVHlwZU9yZGVyLkdlb1BvaW50VmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gZ2VvUG9pbnRFcXVhbHMobGVmdCwgcmlnaHQpO1xuICAgICAgICBjYXNlIDIgLyogVHlwZU9yZGVyLk51bWJlclZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIG51bWJlckVxdWFscyhsZWZ0LCByaWdodCk7XG4gICAgICAgIGNhc2UgOSAvKiBUeXBlT3JkZXIuQXJyYXlWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBhcnJheUVxdWFscyhsZWZ0LmFycmF5VmFsdWUudmFsdWVzIHx8IFtdLCByaWdodC5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXSwgdmFsdWVFcXVhbHMpO1xuICAgICAgICBjYXNlIDEwIC8qIFR5cGVPcmRlci5WZWN0b3JWYWx1ZSAqLzpcbiAgICAgICAgY2FzZSAxMSAvKiBUeXBlT3JkZXIuT2JqZWN0VmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0RXF1YWxzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgY2FzZSA5MDA3MTk5MjU0NzQwOTkxIC8qIFR5cGVPcmRlci5NYXhWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0aW1lc3RhbXBFcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAodHlwZW9mIGxlZnQudGltZXN0YW1wVmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIHR5cGVvZiByaWdodC50aW1lc3RhbXBWYWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgbGVmdC50aW1lc3RhbXBWYWx1ZS5sZW5ndGggPT09IHJpZ2h0LnRpbWVzdGFtcFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAvLyBVc2Ugc3RyaW5nIGVxdWFsaXR5IGZvciBJU08gODYwMSB0aW1lc3RhbXBzXG4gICAgICAgIHJldHVybiBsZWZ0LnRpbWVzdGFtcFZhbHVlID09PSByaWdodC50aW1lc3RhbXBWYWx1ZTtcbiAgICB9XG4gICAgY29uc3QgbGVmdFRpbWVzdGFtcCA9IG5vcm1hbGl6ZVRpbWVzdGFtcChsZWZ0LnRpbWVzdGFtcFZhbHVlKTtcbiAgICBjb25zdCByaWdodFRpbWVzdGFtcCA9IG5vcm1hbGl6ZVRpbWVzdGFtcChyaWdodC50aW1lc3RhbXBWYWx1ZSk7XG4gICAgcmV0dXJuIChsZWZ0VGltZXN0YW1wLnNlY29uZHMgPT09IHJpZ2h0VGltZXN0YW1wLnNlY29uZHMgJiZcbiAgICAgICAgbGVmdFRpbWVzdGFtcC5uYW5vcyA9PT0gcmlnaHRUaW1lc3RhbXAubmFub3MpO1xufVxuZnVuY3Rpb24gZ2VvUG9pbnRFcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gKG5vcm1hbGl6ZU51bWJlcihsZWZ0Lmdlb1BvaW50VmFsdWUubGF0aXR1ZGUpID09PVxuICAgICAgICBub3JtYWxpemVOdW1iZXIocmlnaHQuZ2VvUG9pbnRWYWx1ZS5sYXRpdHVkZSkgJiZcbiAgICAgICAgbm9ybWFsaXplTnVtYmVyKGxlZnQuZ2VvUG9pbnRWYWx1ZS5sb25naXR1ZGUpID09PVxuICAgICAgICAgICAgbm9ybWFsaXplTnVtYmVyKHJpZ2h0Lmdlb1BvaW50VmFsdWUubG9uZ2l0dWRlKSk7XG59XG5mdW5jdGlvbiBibG9iRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUJ5dGVTdHJpbmcobGVmdC5ieXRlc1ZhbHVlKS5pc0VxdWFsKG5vcm1hbGl6ZUJ5dGVTdHJpbmcocmlnaHQuYnl0ZXNWYWx1ZSkpO1xufVxuZnVuY3Rpb24gbnVtYmVyRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIGxlZnQgJiYgJ2ludGVnZXJWYWx1ZScgaW4gcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIChub3JtYWxpemVOdW1iZXIobGVmdC5pbnRlZ2VyVmFsdWUpID09PSBub3JtYWxpemVOdW1iZXIocmlnaHQuaW50ZWdlclZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdkb3VibGVWYWx1ZScgaW4gbGVmdCAmJiAnZG91YmxlVmFsdWUnIGluIHJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IG4xID0gbm9ybWFsaXplTnVtYmVyKGxlZnQuZG91YmxlVmFsdWUpO1xuICAgICAgICBjb25zdCBuMiA9IG5vcm1hbGl6ZU51bWJlcihyaWdodC5kb3VibGVWYWx1ZSk7XG4gICAgICAgIGlmIChuMSA9PT0gbjIpIHtcbiAgICAgICAgICAgIHJldHVybiBpc05lZ2F0aXZlWmVybyhuMSkgPT09IGlzTmVnYXRpdmVaZXJvKG4yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc05hTihuMSkgJiYgaXNOYU4objIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9iamVjdEVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IGxlZnRNYXAgPSBsZWZ0Lm1hcFZhbHVlLmZpZWxkcyB8fCB7fTtcbiAgICBjb25zdCByaWdodE1hcCA9IHJpZ2h0Lm1hcFZhbHVlLmZpZWxkcyB8fCB7fTtcbiAgICBpZiAob2JqZWN0U2l6ZShsZWZ0TWFwKSAhPT0gb2JqZWN0U2l6ZShyaWdodE1hcCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBsZWZ0TWFwKSB7XG4gICAgICAgIGlmIChsZWZ0TWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGlmIChyaWdodE1hcFtrZXldID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAhdmFsdWVFcXVhbHMobGVmdE1hcFtrZXldLCByaWdodE1hcFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIEFycmF5VmFsdWUgY29udGFpbnMgdGhlIHNwZWNpZmllZCBlbGVtZW50LiAqL1xuZnVuY3Rpb24gYXJyYXlWYWx1ZUNvbnRhaW5zKGhheXN0YWNrLCBuZWVkbGUpIHtcbiAgICByZXR1cm4gKChoYXlzdGFjay52YWx1ZXMgfHwgW10pLmZpbmQodiA9PiB2YWx1ZUVxdWFscyh2LCBuZWVkbGUpKSAhPT0gdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIHZhbHVlQ29tcGFyZShsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0ID09PSByaWdodCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgbGVmdFR5cGUgPSB0eXBlT3JkZXIobGVmdCk7XG4gICAgY29uc3QgcmlnaHRUeXBlID0gdHlwZU9yZGVyKHJpZ2h0KTtcbiAgICBpZiAobGVmdFR5cGUgIT09IHJpZ2h0VHlwZSkge1xuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0VHlwZSwgcmlnaHRUeXBlKTtcbiAgICB9XG4gICAgc3dpdGNoIChsZWZ0VHlwZSkge1xuICAgICAgICBjYXNlIDAgLyogVHlwZU9yZGVyLk51bGxWYWx1ZSAqLzpcbiAgICAgICAgY2FzZSA5MDA3MTk5MjU0NzQwOTkxIC8qIFR5cGVPcmRlci5NYXhWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlIDEgLyogVHlwZU9yZGVyLkJvb2xlYW5WYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQuYm9vbGVhblZhbHVlLCByaWdodC5ib29sZWFuVmFsdWUpO1xuICAgICAgICBjYXNlIDIgLyogVHlwZU9yZGVyLk51bWJlclZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVOdW1iZXJzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgY2FzZSAzIC8qIFR5cGVPcmRlci5UaW1lc3RhbXBWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlVGltZXN0YW1wcyhsZWZ0LnRpbWVzdGFtcFZhbHVlLCByaWdodC50aW1lc3RhbXBWYWx1ZSk7XG4gICAgICAgIGNhc2UgNCAvKiBUeXBlT3JkZXIuU2VydmVyVGltZXN0YW1wVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVRpbWVzdGFtcHMoZ2V0TG9jYWxXcml0ZVRpbWUobGVmdCksIGdldExvY2FsV3JpdGVUaW1lKHJpZ2h0KSk7XG4gICAgICAgIGNhc2UgNSAvKiBUeXBlT3JkZXIuU3RyaW5nVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVV0ZjhTdHJpbmdzKGxlZnQuc3RyaW5nVmFsdWUsIHJpZ2h0LnN0cmluZ1ZhbHVlKTtcbiAgICAgICAgY2FzZSA2IC8qIFR5cGVPcmRlci5CbG9iVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUJsb2JzKGxlZnQuYnl0ZXNWYWx1ZSwgcmlnaHQuYnl0ZXNWYWx1ZSk7XG4gICAgICAgIGNhc2UgNyAvKiBUeXBlT3JkZXIuUmVmVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVJlZmVyZW5jZXMobGVmdC5yZWZlcmVuY2VWYWx1ZSwgcmlnaHQucmVmZXJlbmNlVmFsdWUpO1xuICAgICAgICBjYXNlIDggLyogVHlwZU9yZGVyLkdlb1BvaW50VmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUdlb1BvaW50cyhsZWZ0Lmdlb1BvaW50VmFsdWUsIHJpZ2h0Lmdlb1BvaW50VmFsdWUpO1xuICAgICAgICBjYXNlIDkgLyogVHlwZU9yZGVyLkFycmF5VmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUFycmF5cyhsZWZ0LmFycmF5VmFsdWUsIHJpZ2h0LmFycmF5VmFsdWUpO1xuICAgICAgICBjYXNlIDEwIC8qIFR5cGVPcmRlci5WZWN0b3JWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlVmVjdG9ycyhsZWZ0Lm1hcFZhbHVlLCByaWdodC5tYXBWYWx1ZSk7XG4gICAgICAgIGNhc2UgMTEgLyogVHlwZU9yZGVyLk9iamVjdFZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVNYXBzKGxlZnQubWFwVmFsdWUsIHJpZ2h0Lm1hcFZhbHVlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IGxlZnROdW1iZXIgPSBub3JtYWxpemVOdW1iZXIobGVmdC5pbnRlZ2VyVmFsdWUgfHwgbGVmdC5kb3VibGVWYWx1ZSk7XG4gICAgY29uc3QgcmlnaHROdW1iZXIgPSBub3JtYWxpemVOdW1iZXIocmlnaHQuaW50ZWdlclZhbHVlIHx8IHJpZ2h0LmRvdWJsZVZhbHVlKTtcbiAgICBpZiAobGVmdE51bWJlciA8IHJpZ2h0TnVtYmVyKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVmdE51bWJlciA+IHJpZ2h0TnVtYmVyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZWZ0TnVtYmVyID09PSByaWdodE51bWJlcikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIG9uZSBvciBib3RoIGFyZSBOYU4uXG4gICAgICAgIGlmIChpc05hTihsZWZ0TnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKHJpZ2h0TnVtYmVyKSA/IDAgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZVRpbWVzdGFtcHMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAodHlwZW9mIGxlZnQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIHR5cGVvZiByaWdodCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgbGVmdC5sZW5ndGggPT09IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGxlZnRUaW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAobGVmdCk7XG4gICAgY29uc3QgcmlnaHRUaW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAocmlnaHQpO1xuICAgIGNvbnN0IGNvbXBhcmlzb24gPSBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRUaW1lc3RhbXAuc2Vjb25kcywgcmlnaHRUaW1lc3RhbXAuc2Vjb25kcyk7XG4gICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmlzb247XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRUaW1lc3RhbXAubmFub3MsIHJpZ2h0VGltZXN0YW1wLm5hbm9zKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVSZWZlcmVuY2VzKGxlZnRQYXRoLCByaWdodFBhdGgpIHtcbiAgICBjb25zdCBsZWZ0U2VnbWVudHMgPSBsZWZ0UGF0aC5zcGxpdCgnLycpO1xuICAgIGNvbnN0IHJpZ2h0U2VnbWVudHMgPSByaWdodFBhdGguc3BsaXQoJy8nKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnRTZWdtZW50cy5sZW5ndGggJiYgaSA8IHJpZ2h0U2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29tcGFyaXNvbiA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFNlZ21lbnRzW2ldLCByaWdodFNlZ21lbnRzW2ldKTtcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRTZWdtZW50cy5sZW5ndGgsIHJpZ2h0U2VnbWVudHMubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVHZW9Qb2ludHMobGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBjb21wYXJpc29uID0gcHJpbWl0aXZlQ29tcGFyYXRvcihub3JtYWxpemVOdW1iZXIobGVmdC5sYXRpdHVkZSksIG5vcm1hbGl6ZU51bWJlcihyaWdodC5sYXRpdHVkZSkpO1xuICAgIGlmIChjb21wYXJpc29uICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJpc29uO1xuICAgIH1cbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihub3JtYWxpemVOdW1iZXIobGVmdC5sb25naXR1ZGUpLCBub3JtYWxpemVOdW1iZXIocmlnaHQubG9uZ2l0dWRlKSk7XG59XG5mdW5jdGlvbiBjb21wYXJlQmxvYnMobGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBsZWZ0Qnl0ZXMgPSBub3JtYWxpemVCeXRlU3RyaW5nKGxlZnQpO1xuICAgIGNvbnN0IHJpZ2h0Qnl0ZXMgPSBub3JtYWxpemVCeXRlU3RyaW5nKHJpZ2h0KTtcbiAgICByZXR1cm4gbGVmdEJ5dGVzLmNvbXBhcmVUbyhyaWdodEJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVBcnJheXMobGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBsZWZ0QXJyYXkgPSBsZWZ0LnZhbHVlcyB8fCBbXTtcbiAgICBjb25zdCByaWdodEFycmF5ID0gcmlnaHQudmFsdWVzIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEFycmF5Lmxlbmd0aCAmJiBpIDwgcmlnaHRBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjb21wYXJlID0gdmFsdWVDb21wYXJlKGxlZnRBcnJheVtpXSwgcmlnaHRBcnJheVtpXSk7XG4gICAgICAgIGlmIChjb21wYXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0QXJyYXkubGVuZ3RoLCByaWdodEFycmF5Lmxlbmd0aCk7XG59XG5mdW5jdGlvbiBjb21wYXJlVmVjdG9ycyhsZWZ0LCByaWdodCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCBsZWZ0TWFwID0gbGVmdC5maWVsZHMgfHwge307XG4gICAgY29uc3QgcmlnaHRNYXAgPSByaWdodC5maWVsZHMgfHwge307XG4gICAgLy8gVGhlIHZlY3RvciBpcyBhIG1hcCwgYnV0IG9ubHkgdmVjdG9yIHZhbHVlIGlzIGNvbXBhcmVkLlxuICAgIGNvbnN0IGxlZnRBcnJheVZhbHVlID0gKF9hID0gbGVmdE1hcFtWRUNUT1JfTUFQX1ZFQ1RPUlNfS0VZXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFycmF5VmFsdWU7XG4gICAgY29uc3QgcmlnaHRBcnJheVZhbHVlID0gKF9iID0gcmlnaHRNYXBbVkVDVE9SX01BUF9WRUNUT1JTX0tFWV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hcnJheVZhbHVlO1xuICAgIGNvbnN0IGxlbmd0aENvbXBhcmUgPSBwcmltaXRpdmVDb21wYXJhdG9yKCgoX2MgPSBsZWZ0QXJyYXlWYWx1ZSA9PT0gbnVsbCB8fCBsZWZ0QXJyYXlWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVmdEFycmF5VmFsdWUudmFsdWVzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVuZ3RoKSB8fCAwLCAoKF9kID0gcmlnaHRBcnJheVZhbHVlID09PSBudWxsIHx8IHJpZ2h0QXJyYXlWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmlnaHRBcnJheVZhbHVlLnZhbHVlcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgfHwgMCk7XG4gICAgaWYgKGxlbmd0aENvbXBhcmUgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aENvbXBhcmU7XG4gICAgfVxuICAgIHJldHVybiBjb21wYXJlQXJyYXlzKGxlZnRBcnJheVZhbHVlLCByaWdodEFycmF5VmFsdWUpO1xufVxuZnVuY3Rpb24gY29tcGFyZU1hcHMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdCA9PT0gTUFYX1ZBTFVFLm1hcFZhbHVlICYmIHJpZ2h0ID09PSBNQVhfVkFMVUUubWFwVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlZnQgPT09IE1BWF9WQUxVRS5tYXBWYWx1ZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmlnaHQgPT09IE1BWF9WQUxVRS5tYXBWYWx1ZSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGNvbnN0IGxlZnRNYXAgPSBsZWZ0LmZpZWxkcyB8fCB7fTtcbiAgICBjb25zdCBsZWZ0S2V5cyA9IE9iamVjdC5rZXlzKGxlZnRNYXApO1xuICAgIGNvbnN0IHJpZ2h0TWFwID0gcmlnaHQuZmllbGRzIHx8IHt9O1xuICAgIGNvbnN0IHJpZ2h0S2V5cyA9IE9iamVjdC5rZXlzKHJpZ2h0TWFwKTtcbiAgICAvLyBFdmVuIHRob3VnaCBNYXBWYWx1ZXMgYXJlIGxpa2VseSBzb3J0ZWQgY29ycmVjdGx5IGJhc2VkIG9uIHRoZWlyIGluc2VydGlvblxuICAgIC8vIG9yZGVyIChlLmcuIHdoZW4gcmVjZWl2ZWQgZnJvbSB0aGUgYmFja2VuZCksIGxvY2FsIG1vZGlmaWNhdGlvbnMgY2FuIGJyaW5nXG4gICAgLy8gZWxlbWVudHMgb3V0IG9mIG9yZGVyLiBXZSBuZWVkIHRvIHJlLXNvcnQgdGhlIGVsZW1lbnRzIHRvIGVuc3VyZSB0aGF0XG4gICAgLy8gY2Fub25pY2FsIElEcyBhcmUgaW5kZXBlbmRlbnQgb2YgaW5zZXJ0aW9uIG9yZGVyLlxuICAgIGxlZnRLZXlzLnNvcnQoKTtcbiAgICByaWdodEtleXMuc29ydCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoICYmIGkgPCByaWdodEtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qga2V5Q29tcGFyZSA9IGNvbXBhcmVVdGY4U3RyaW5ncyhsZWZ0S2V5c1tpXSwgcmlnaHRLZXlzW2ldKTtcbiAgICAgICAgaWYgKGtleUNvbXBhcmUgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlDb21wYXJlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBhcmUgPSB2YWx1ZUNvbXBhcmUobGVmdE1hcFtsZWZ0S2V5c1tpXV0sIHJpZ2h0TWFwW3JpZ2h0S2V5c1tpXV0pO1xuICAgICAgICBpZiAoY29tcGFyZSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdEtleXMubGVuZ3RoLCByaWdodEtleXMubGVuZ3RoKTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBjYW5vbmljYWwgSUQgZm9yIHRoZSBwcm92aWRlZCBmaWVsZCB2YWx1ZSAoYXMgdXNlZCBpbiBUYXJnZXRcbiAqIHNlcmlhbGl6YXRpb24pLlxuICovXG5mdW5jdGlvbiBjYW5vbmljYWxJZCh2YWx1ZSkge1xuICAgIHJldHVybiBjYW5vbmlmeVZhbHVlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5VmFsdWUodmFsdWUpIHtcbiAgICBpZiAoJ251bGxWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2Jvb2xlYW5WYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdmFsdWUuYm9vbGVhblZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgnaW50ZWdlclZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gJycgKyB2YWx1ZS5pbnRlZ2VyVmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdkb3VibGVWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdmFsdWUuZG91YmxlVmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCd0aW1lc3RhbXBWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbm9uaWZ5VGltZXN0YW1wKHZhbHVlLnRpbWVzdGFtcFZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3N0cmluZ1ZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuc3RyaW5nVmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdieXRlc1ZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2Fub25pZnlCeXRlU3RyaW5nKHZhbHVlLmJ5dGVzVmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICgncmVmZXJlbmNlVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYW5vbmlmeVJlZmVyZW5jZSh2YWx1ZS5yZWZlcmVuY2VWYWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdnZW9Qb2ludFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2Fub25pZnlHZW9Qb2ludCh2YWx1ZS5nZW9Qb2ludFZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2FycmF5VmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYW5vbmlmeUFycmF5KHZhbHVlLmFycmF5VmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnbWFwVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYW5vbmlmeU1hcCh2YWx1ZS5tYXBWYWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5Qnl0ZVN0cmluZyhieXRlU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUJ5dGVTdHJpbmcoYnl0ZVN0cmluZykudG9CYXNlNjQoKTtcbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5VGltZXN0YW1wKHRpbWVzdGFtcCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRUaW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAodGltZXN0YW1wKTtcbiAgICByZXR1cm4gYHRpbWUoJHtub3JtYWxpemVkVGltZXN0YW1wLnNlY29uZHN9LCR7bm9ybWFsaXplZFRpbWVzdGFtcC5uYW5vc30pYDtcbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5R2VvUG9pbnQoZ2VvUG9pbnQpIHtcbiAgICByZXR1cm4gYGdlbygke2dlb1BvaW50LmxhdGl0dWRlfSwke2dlb1BvaW50LmxvbmdpdHVkZX0pYDtcbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5UmVmZXJlbmNlKHJlZmVyZW5jZVZhbHVlKSB7XG4gICAgcmV0dXJuIERvY3VtZW50S2V5LmZyb21OYW1lKHJlZmVyZW5jZVZhbHVlKS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gY2Fub25pZnlNYXAobWFwVmFsdWUpIHtcbiAgICAvLyBJdGVyYXRpb24gb3JkZXIgaW4gSmF2YVNjcmlwdCBpcyBub3QgZ3VhcmFudGVlZC4gVG8gZW5zdXJlIHRoYXQgd2UgZ2VuZXJhdGVcbiAgICAvLyBtYXRjaGluZyBjYW5vbmljYWwgSURzIGZvciBpZGVudGljYWwgbWFwcywgd2UgbmVlZCB0byBzb3J0IHRoZSBrZXlzLlxuICAgIGNvbnN0IHNvcnRlZEtleXMgPSBPYmplY3Qua2V5cyhtYXBWYWx1ZS5maWVsZHMgfHwge30pLnNvcnQoKTtcbiAgICBsZXQgcmVzdWx0ID0gJ3snO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc29ydGVkS2V5cykge1xuICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gYCR7a2V5fToke2Nhbm9uaWZ5VmFsdWUobWFwVmFsdWUuZmllbGRzW2tleV0pfWA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgKyAnfSc7XG59XG5mdW5jdGlvbiBjYW5vbmlmeUFycmF5KGFycmF5VmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gJ1snO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBhcnJheVZhbHVlLnZhbHVlcyB8fCBbXSkge1xuICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gY2Fub25pZnlWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgKyAnXSc7XG59XG4vKipcbiAqIFJldHVybnMgYW4gYXBwcm94aW1hdGUgKGFuZCB3aWxkbHkgaW5hY2N1cmF0ZSkgaW4tbWVtb3J5IHNpemUgZm9yIHRoZSBmaWVsZFxuICogdmFsdWUuXG4gKlxuICogVGhlIG1lbW9yeSBzaXplIHRha2VzIGludG8gYWNjb3VudCBvbmx5IHRoZSBhY3R1YWwgdXNlciBkYXRhIGFzIGl0IHJlc2lkZXNcbiAqIGluIG1lbW9yeSBhbmQgaWdub3JlcyBvYmplY3Qgb3ZlcmhlYWQuXG4gKi9cbmZ1bmN0aW9uIGVzdGltYXRlQnl0ZVNpemUodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVPcmRlcih2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSAwIC8qIFR5cGVPcmRlci5OdWxsVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgY2FzZSAxIC8qIFR5cGVPcmRlci5Cb29sZWFuVmFsdWUgKi86XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgY2FzZSAyIC8qIFR5cGVPcmRlci5OdW1iZXJWYWx1ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICBjYXNlIDMgLyogVHlwZU9yZGVyLlRpbWVzdGFtcFZhbHVlICovOlxuICAgICAgICAgICAgLy8gVGltZXN0YW1wcyBhcmUgbWFkZSB1cCBvZiB0d28gZGlzdGluY3QgbnVtYmVycyAoc2Vjb25kcyArIG5hbm9zZWNvbmRzKVxuICAgICAgICAgICAgcmV0dXJuIDE2O1xuICAgICAgICBjYXNlIDQgLyogVHlwZU9yZGVyLlNlcnZlclRpbWVzdGFtcFZhbHVlICovOlxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IGdldFByZXZpb3VzVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWUgPyAxNiArIGVzdGltYXRlQnl0ZVNpemUocHJldmlvdXNWYWx1ZSkgOiAxNjtcbiAgICAgICAgY2FzZSA1IC8qIFR5cGVPcmRlci5TdHJpbmdWYWx1ZSAqLzpcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0RhdGFfc3RydWN0dXJlczpcbiAgICAgICAgICAgIC8vIFwiSmF2YVNjcmlwdCdzIFN0cmluZyB0eXBlIGlzIFsuLi5dIGEgc2V0IG9mIGVsZW1lbnRzIG9mIDE2LWJpdCB1bnNpZ25lZFxuICAgICAgICAgICAgLy8gaW50ZWdlciB2YWx1ZXNcIlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN0cmluZ1ZhbHVlLmxlbmd0aCAqIDI7XG4gICAgICAgIGNhc2UgNiAvKiBUeXBlT3JkZXIuQmxvYlZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZUJ5dGVTdHJpbmcodmFsdWUuYnl0ZXNWYWx1ZSkuYXBwcm94aW1hdGVCeXRlU2l6ZSgpO1xuICAgICAgICBjYXNlIDcgLyogVHlwZU9yZGVyLlJlZlZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnJlZmVyZW5jZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgY2FzZSA4IC8qIFR5cGVPcmRlci5HZW9Qb2ludFZhbHVlICovOlxuICAgICAgICAgICAgLy8gR2VvUG9pbnRzIGFyZSBtYWRlIHVwIG9mIHR3byBkaXN0aW5jdCBudW1iZXJzIChsYXRpdHVkZSArIGxvbmdpdHVkZSlcbiAgICAgICAgICAgIHJldHVybiAxNjtcbiAgICAgICAgY2FzZSA5IC8qIFR5cGVPcmRlci5BcnJheVZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGVzdGltYXRlQXJyYXlCeXRlU2l6ZSh2YWx1ZS5hcnJheVZhbHVlKTtcbiAgICAgICAgY2FzZSAxMCAvKiBUeXBlT3JkZXIuVmVjdG9yVmFsdWUgKi86XG4gICAgICAgIGNhc2UgMTEgLyogVHlwZU9yZGVyLk9iamVjdFZhbHVlICovOlxuICAgICAgICAgICAgcmV0dXJuIGVzdGltYXRlTWFwQnl0ZVNpemUodmFsdWUubWFwVmFsdWUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVzdGltYXRlTWFwQnl0ZVNpemUobWFwVmFsdWUpIHtcbiAgICBsZXQgc2l6ZSA9IDA7XG4gICAgZm9yRWFjaChtYXBWYWx1ZS5maWVsZHMsIChrZXksIHZhbCkgPT4ge1xuICAgICAgICBzaXplICs9IGtleS5sZW5ndGggKyBlc3RpbWF0ZUJ5dGVTaXplKHZhbCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpemU7XG59XG5mdW5jdGlvbiBlc3RpbWF0ZUFycmF5Qnl0ZVNpemUoYXJyYXlWYWx1ZSkge1xuICAgIHJldHVybiAoYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pLnJlZHVjZSgocHJldmlvdXNTaXplLCB2YWx1ZSkgPT4gcHJldmlvdXNTaXplICsgZXN0aW1hdGVCeXRlU2l6ZSh2YWx1ZSksIDApO1xufVxuLyoqIFJldHVybnMgYSByZWZlcmVuY2UgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBkYXRhYmFzZSBhbmQga2V5LiAqL1xuZnVuY3Rpb24gcmVmVmFsdWUoZGF0YWJhc2VJZCwga2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVmZXJlbmNlVmFsdWU6IGBwcm9qZWN0cy8ke2RhdGFiYXNlSWQucHJvamVjdElkfS9kYXRhYmFzZXMvJHtkYXRhYmFzZUlkLmRhdGFiYXNlfS9kb2N1bWVudHMvJHtrZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKX1gXG4gICAgfTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBJbnRlZ2VyVmFsdWUgLiAqL1xuZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgJ2ludGVnZXJWYWx1ZScgaW4gdmFsdWU7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBEb3VibGVWYWx1ZS4gKi9cbmZ1bmN0aW9uIGlzRG91YmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgJ2RvdWJsZVZhbHVlJyBpbiB2YWx1ZTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBlaXRoZXIgYW4gSW50ZWdlclZhbHVlIG9yIGEgRG91YmxlVmFsdWUuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBpc0ludGVnZXIodmFsdWUpIHx8IGlzRG91YmxlKHZhbHVlKTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBBcnJheVZhbHVlLiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICdhcnJheVZhbHVlJyBpbiB2YWx1ZTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhIE51bGxWYWx1ZS4gKi9cbmZ1bmN0aW9uIGlzTnVsbFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgJ251bGxWYWx1ZScgaW4gdmFsdWU7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgTmFOLiAqL1xuZnVuY3Rpb24gaXNOYW5WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICdkb3VibGVWYWx1ZScgaW4gdmFsdWUgJiYgaXNOYU4oTnVtYmVyKHZhbHVlLmRvdWJsZVZhbHVlKSk7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBNYXBWYWx1ZS4gKi9cbmZ1bmN0aW9uIGlzTWFwVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAnbWFwVmFsdWUnIGluIHZhbHVlO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgVmV0b3JWYWx1ZS4gKi9cbmZ1bmN0aW9uIGlzVmVjdG9yVmFsdWUodmFsdWUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHR5cGUgPSAoX2IgPSAoKChfYSA9IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5tYXBWYWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpZWxkcykgfHwge30pW1RZUEVfS0VZXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0cmluZ1ZhbHVlO1xuICAgIHJldHVybiB0eXBlID09PSBWRUNUT1JfVkFMVUVfU0VOVElORUw7XG59XG4vKiogQ3JlYXRlcyBhIGRlZXAgY29weSBvZiBgc291cmNlYC4gKi9cbmZ1bmN0aW9uIGRlZXBDbG9uZShzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmdlb1BvaW50VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZ2VvUG9pbnRWYWx1ZTogT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLmdlb1BvaW50VmFsdWUpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHNvdXJjZS50aW1lc3RhbXBWYWx1ZSAmJlxuICAgICAgICB0eXBlb2Ygc291cmNlLnRpbWVzdGFtcFZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4geyB0aW1lc3RhbXBWYWx1ZTogT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLnRpbWVzdGFtcFZhbHVlKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChzb3VyY2UubWFwVmFsdWUpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0geyBtYXBWYWx1ZTogeyBmaWVsZHM6IHt9IH0gfTtcbiAgICAgICAgZm9yRWFjaChzb3VyY2UubWFwVmFsdWUuZmllbGRzLCAoa2V5LCB2YWwpID0+ICh0YXJnZXQubWFwVmFsdWUuZmllbGRzW2tleV0gPSBkZWVwQ2xvbmUodmFsKSkpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBlbHNlIGlmIChzb3VyY2UuYXJyYXlWYWx1ZSkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB7IGFycmF5VmFsdWU6IHsgdmFsdWVzOiBbXSB9IH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKHNvdXJjZS5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXSkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRhcmdldC5hcnJheVZhbHVlLnZhbHVlc1tpXSA9IGRlZXBDbG9uZShzb3VyY2UuYXJyYXlWYWx1ZS52YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlKTtcbiAgICB9XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBWYWx1ZSByZXByZXNlbnRzIHRoZSBjYW5vbmljYWwge0BsaW5rICNNQVhfVkFMVUV9IC4gKi9cbmZ1bmN0aW9uIGlzTWF4VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gKCgoKHZhbHVlLm1hcFZhbHVlIHx8IHt9KS5maWVsZHMgfHwge30pWydfX3R5cGVfXyddIHx8IHt9KS5zdHJpbmdWYWx1ZSA9PT1cbiAgICAgICAgTUFYX1ZBTFVFX1RZUEUpO1xufVxuY29uc3QgTUlOX1ZFQ1RPUl9WQUxVRSA9IHtcbiAgICBtYXBWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIFtUWVBFX0tFWV06IHsgc3RyaW5nVmFsdWU6IFZFQ1RPUl9WQUxVRV9TRU5USU5FTCB9LFxuICAgICAgICAgICAgW1ZFQ1RPUl9NQVBfVkVDVE9SU19LRVldOiB7XG4gICAgICAgICAgICAgICAgYXJyYXlWYWx1ZToge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG4vKiogUmV0dXJucyB0aGUgbG93ZXN0IHZhbHVlIGZvciB0aGUgZ2l2ZW4gdmFsdWUgdHlwZSAoaW5jbHVzaXZlKS4gKi9cbmZ1bmN0aW9uIHZhbHVlc0dldExvd2VyQm91bmQodmFsdWUpIHtcbiAgICBpZiAoJ251bGxWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2Jvb2xlYW5WYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgYm9vbGVhblZhbHVlOiBmYWxzZSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnaW50ZWdlclZhbHVlJyBpbiB2YWx1ZSB8fCAnZG91YmxlVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiBOYU4gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3RpbWVzdGFtcFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyB0aW1lc3RhbXBWYWx1ZTogeyBzZWNvbmRzOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB9IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKCdzdHJpbmdWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RyaW5nVmFsdWU6ICcnIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKCdieXRlc1ZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBieXRlc1ZhbHVlOiAnJyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgncmVmZXJlbmNlVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiByZWZWYWx1ZShEYXRhYmFzZUlkLmVtcHR5KCksIERvY3VtZW50S2V5LmVtcHR5KCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnZ2VvUG9pbnRWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZ2VvUG9pbnRWYWx1ZTogeyBsYXRpdHVkZTogLTkwLCBsb25naXR1ZGU6IC0xODAgfSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnYXJyYXlWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgYXJyYXlWYWx1ZToge30gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ21hcFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNWZWN0b3JWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBNSU5fVkVDVE9SX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1hcFZhbHVlOiB7fSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG4vKiogUmV0dXJucyB0aGUgbGFyZ2VzdCB2YWx1ZSBmb3IgdGhlIGdpdmVuIHZhbHVlIHR5cGUgKGV4Y2x1c2l2ZSkuICovXG5mdW5jdGlvbiB2YWx1ZXNHZXRVcHBlckJvdW5kKHZhbHVlKSB7XG4gICAgaWYgKCdudWxsVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGJvb2xlYW5WYWx1ZTogZmFsc2UgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2Jvb2xlYW5WYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6IE5hTiB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnaW50ZWdlclZhbHVlJyBpbiB2YWx1ZSB8fCAnZG91YmxlVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IHRpbWVzdGFtcFZhbHVlOiB7IHNlY29uZHM6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIH0gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3RpbWVzdGFtcFZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBzdHJpbmdWYWx1ZTogJycgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3N0cmluZ1ZhbHVlJyBpbiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBieXRlc1ZhbHVlOiAnJyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnYnl0ZXNWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHJlZlZhbHVlKERhdGFiYXNlSWQuZW1wdHkoKSwgRG9jdW1lbnRLZXkuZW1wdHkoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdyZWZlcmVuY2VWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZ2VvUG9pbnRWYWx1ZTogeyBsYXRpdHVkZTogLTkwLCBsb25naXR1ZGU6IC0xODAgfSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgnZ2VvUG9pbnRWYWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgYXJyYXlWYWx1ZToge30gfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2FycmF5VmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNSU5fVkVDVE9SX1ZBTFVFO1xuICAgIH1cbiAgICBlbHNlIGlmICgnbWFwVmFsdWUnIGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc1ZlY3RvclZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWFwVmFsdWU6IHt9IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1BWF9WQUxVRTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbG93ZXJCb3VuZENvbXBhcmUobGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBjbXAgPSB2YWx1ZUNvbXBhcmUobGVmdC52YWx1ZSwgcmlnaHQudmFsdWUpO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG4gICAgaWYgKGxlZnQuaW5jbHVzaXZlICYmICFyaWdodC5pbmNsdXNpdmUpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmICghbGVmdC5pbmNsdXNpdmUgJiYgcmlnaHQuaW5jbHVzaXZlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHVwcGVyQm91bmRDb21wYXJlKGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgY21wID0gdmFsdWVDb21wYXJlKGxlZnQudmFsdWUsIHJpZ2h0LnZhbHVlKTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIGlmIChsZWZ0LmluY2x1c2l2ZSAmJiAhcmlnaHQuaW5jbHVzaXZlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIGlmICghbGVmdC5pbmNsdXNpdmUgJiYgcmlnaHQuaW5jbHVzaXZlKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIE9iamVjdFZhbHVlIHJlcHJlc2VudHMgYSBNYXBWYWx1ZSBpbiB0aGUgRmlyZXN0b3JlIFByb3RvIGFuZCBvZmZlcnMgdGhlXG4gKiBhYmlsaXR5IHRvIGFkZCBhbmQgcmVtb3ZlIGZpZWxkcyAodmlhIHRoZSBPYmplY3RWYWx1ZUJ1aWxkZXIpLlxuICovXG5jbGFzcyBPYmplY3RWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0VmFsdWUoeyBtYXBWYWx1ZToge30gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBwYXRoIG9yIG51bGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIHRoZSBwYXRoIHRvIHNlYXJjaFxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBhdCB0aGUgcGF0aCBvciBudWxsIGlmIHRoZSBwYXRoIGlzIG5vdCBzZXQuXG4gICAgICovXG4gICAgZmllbGQocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRMZXZlbCA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudExldmVsID0gKGN1cnJlbnRMZXZlbC5tYXBWYWx1ZS5maWVsZHMgfHwge30pW3BhdGguZ2V0KGkpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTWFwVmFsdWUoY3VycmVudExldmVsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSAoY3VycmVudExldmVsLm1hcFZhbHVlLmZpZWxkcyB8fCB7fSlbcGF0aC5sYXN0U2VnbWVudCgpXTtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWwgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmaWVsZCB0byB0aGUgcHJvdmlkZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBmaWVsZCBwYXRoIHRvIHNldC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldChwYXRoLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBmaWVsZHNNYXAgPSB0aGlzLmdldEZpZWxkc01hcChwYXRoLnBvcExhc3QoKSk7XG4gICAgICAgIGZpZWxkc01hcFtwYXRoLmxhc3RTZWdtZW50KCldID0gZGVlcENsb25lKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcHJvdmlkZWQgZmllbGRzIHRvIHRoZSBwcm92aWRlZCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSAtIEEgbWFwIG9mIGZpZWxkcyB0byB2YWx1ZXMgKG9yIG51bGwgZm9yIGRlbGV0ZXMpLlxuICAgICAqL1xuICAgIHNldEFsbChkYXRhKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBGaWVsZFBhdGgkMS5lbXB0eVBhdGgoKTtcbiAgICAgICAgbGV0IHVwc2VydHMgPSB7fTtcbiAgICAgICAgbGV0IGRlbGV0ZXMgPSBbXTtcbiAgICAgICAgZGF0YS5mb3JFYWNoKCh2YWx1ZSwgcGF0aCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQuaXNJbW1lZGlhdGVQYXJlbnRPZihwYXRoKSkge1xuICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgYWNjdW11bGF0ZWQgY2hhbmdlcyBhdCB0aGlzIHBhcmVudCBsb2NhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkc01hcCA9IHRoaXMuZ2V0RmllbGRzTWFwKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUNoYW5nZXMoZmllbGRzTWFwLCB1cHNlcnRzLCBkZWxldGVzKTtcbiAgICAgICAgICAgICAgICB1cHNlcnRzID0ge307XG4gICAgICAgICAgICAgICAgZGVsZXRlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGgucG9wTGFzdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdXBzZXJ0c1twYXRoLmxhc3RTZWdtZW50KCldID0gZGVlcENsb25lKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZXMucHVzaChwYXRoLmxhc3RTZWdtZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmllbGRzTWFwID0gdGhpcy5nZXRGaWVsZHNNYXAocGFyZW50KTtcbiAgICAgICAgdGhpcy5hcHBseUNoYW5nZXMoZmllbGRzTWFwLCB1cHNlcnRzLCBkZWxldGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZmllbGQgYXQgdGhlIHNwZWNpZmllZCBwYXRoLiBJZiB0aGVyZSBpcyBubyBmaWVsZCBhdCB0aGVcbiAgICAgKiBzcGVjaWZpZWQgcGF0aCwgbm90aGluZyBpcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgZmllbGQgcGF0aCB0byByZW1vdmUuXG4gICAgICovXG4gICAgZGVsZXRlKHBhdGgpIHtcbiAgICAgICAgY29uc3QgbmVzdGVkVmFsdWUgPSB0aGlzLmZpZWxkKHBhdGgucG9wTGFzdCgpKTtcbiAgICAgICAgaWYgKGlzTWFwVmFsdWUobmVzdGVkVmFsdWUpICYmIG5lc3RlZFZhbHVlLm1hcFZhbHVlLmZpZWxkcykge1xuICAgICAgICAgICAgZGVsZXRlIG5lc3RlZFZhbHVlLm1hcFZhbHVlLmZpZWxkc1twYXRoLmxhc3RTZWdtZW50KCldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlRXF1YWxzKHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWFwIHRoYXQgY29udGFpbnMgdGhlIGxlYWYgZWxlbWVudCBvZiBgcGF0aGAuIElmIHRoZSBwYXJlbnRcbiAgICAgKiBlbnRyeSBkb2VzIG5vdCB5ZXQgZXhpc3QsIG9yIGlmIGl0IGlzIG5vdCBhIG1hcCwgYSBuZXcgbWFwIHdpbGwgYmUgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBnZXRGaWVsZHNNYXAocGF0aCkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMudmFsdWU7XG4gICAgICAgIGlmICghY3VycmVudC5tYXBWYWx1ZS5maWVsZHMpIHtcbiAgICAgICAgICAgIGN1cnJlbnQubWFwVmFsdWUgPSB7IGZpZWxkczoge30gfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gY3VycmVudC5tYXBWYWx1ZS5maWVsZHNbcGF0aC5nZXQoaSldO1xuICAgICAgICAgICAgaWYgKCFpc01hcFZhbHVlKG5leHQpIHx8ICFuZXh0Lm1hcFZhbHVlLmZpZWxkcykge1xuICAgICAgICAgICAgICAgIG5leHQgPSB7IG1hcFZhbHVlOiB7IGZpZWxkczoge30gfSB9O1xuICAgICAgICAgICAgICAgIGN1cnJlbnQubWFwVmFsdWUuZmllbGRzW3BhdGguZ2V0KGkpXSA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudC5tYXBWYWx1ZS5maWVsZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIGBmaWVsZHNNYXBgIGJ5IGFkZGluZywgcmVwbGFjaW5nIG9yIGRlbGV0aW5nIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBlbnRyaWVzLlxuICAgICAqL1xuICAgIGFwcGx5Q2hhbmdlcyhmaWVsZHNNYXAsIGluc2VydHMsIGRlbGV0ZXMpIHtcbiAgICAgICAgZm9yRWFjaChpbnNlcnRzLCAoa2V5LCB2YWwpID0+IChmaWVsZHNNYXBba2V5XSA9IHZhbCkpO1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGRlbGV0ZXMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHNNYXBbZmllbGRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IE9iamVjdFZhbHVlKGRlZXBDbG9uZSh0aGlzLnZhbHVlKSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGEgRmllbGRNYXNrIGJ1aWx0IGZyb20gYWxsIGZpZWxkcyBpbiBhIE1hcFZhbHVlLlxuICovXG5mdW5jdGlvbiBleHRyYWN0RmllbGRNYXNrKHZhbHVlKSB7XG4gICAgY29uc3QgZmllbGRzID0gW107XG4gICAgZm9yRWFjaCh2YWx1ZS5maWVsZHMsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gbmV3IEZpZWxkUGF0aCQxKFtrZXldKTtcbiAgICAgICAgaWYgKGlzTWFwVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXN0ZWRNYXNrID0gZXh0cmFjdEZpZWxkTWFzayh2YWx1ZS5tYXBWYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBuZXN0ZWRGaWVsZHMgPSBuZXN0ZWRNYXNrLmZpZWxkcztcbiAgICAgICAgICAgIGlmIChuZXN0ZWRGaWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJlc2VydmUgdGhlIGVtcHR5IG1hcCBieSBhZGRpbmcgaXQgdG8gdGhlIEZpZWxkTWFzay5cbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChjdXJyZW50UGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgbmVzdGVkIGFuZCBub24tZW1wdHkgT2JqZWN0VmFsdWVzLCBhZGQgdGhlIEZpZWxkUGF0aCBvZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBsZWFmIG5vZGVzLlxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmVzdGVkUGF0aCBvZiBuZXN0ZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLnB1c2goY3VycmVudFBhdGguY2hpbGQobmVzdGVkUGF0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBuZXN0ZWQgYW5kIG5vbi1lbXB0eSBPYmplY3RWYWx1ZXMsIGFkZCB0aGUgRmllbGRQYXRoIG9mIHRoZSBsZWFmXG4gICAgICAgICAgICAvLyBub2Rlcy5cbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKGN1cnJlbnRQYXRoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgRmllbGRNYXNrKGZpZWxkcyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSBkb2N1bWVudCBpbiBGaXJlc3RvcmUgd2l0aCBhIGtleSwgdmVyc2lvbiwgZGF0YSBhbmQgd2hldGhlciBpdFxuICogaGFzIGxvY2FsIG11dGF0aW9ucyBhcHBsaWVkIHRvIGl0LlxuICpcbiAqIERvY3VtZW50cyBjYW4gdHJhbnNpdGlvbiBiZXR3ZWVuIHN0YXRlcyB2aWEgYGNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQoKWAsXG4gKiBgY29udmVydFRvTm9Eb2N1bWVudCgpYCBhbmQgYGNvbnZlcnRUb1Vua25vd25Eb2N1bWVudCgpYC4gSWYgYSBkb2N1bWVudCBkb2VzXG4gKiBub3QgdHJhbnNpdGlvbiB0byBvbmUgb2YgdGhlc2Ugc3RhdGVzIGV2ZW4gYWZ0ZXIgYWxsIG11dGF0aW9ucyBoYXZlIGJlZW5cbiAqIGFwcGxpZWQsIGBpc1ZhbGlkRG9jdW1lbnQoKWAgcmV0dXJucyBmYWxzZSBhbmQgdGhlIGRvY3VtZW50IHNob3VsZCBiZSByZW1vdmVkXG4gKiBmcm9tIGFsbCB2aWV3cy5cbiAqL1xuY2xhc3MgTXV0YWJsZURvY3VtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIGRvY3VtZW50VHlwZSwgdmVyc2lvbiwgcmVhZFRpbWUsIGNyZWF0ZVRpbWUsIGRhdGEsIGRvY3VtZW50U3RhdGUpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID0gZG9jdW1lbnRUeXBlO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLnJlYWRUaW1lID0gcmVhZFRpbWU7XG4gICAgICAgIHRoaXMuY3JlYXRlVGltZSA9IGNyZWF0ZVRpbWU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9IGRvY3VtZW50U3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkb2N1bWVudCB3aXRoIG5vIGtub3duIHZlcnNpb24gb3IgZGF0YSwgYnV0IHdoaWNoIGNhbiBzZXJ2ZSBhc1xuICAgICAqIGJhc2UgZG9jdW1lbnQgZm9yIG11dGF0aW9ucy5cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3SW52YWxpZERvY3VtZW50KGRvY3VtZW50S2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZURvY3VtZW50KGRvY3VtZW50S2V5LCAwIC8qIERvY3VtZW50VHlwZS5JTlZBTElEICovLCBcbiAgICAgICAgLyogdmVyc2lvbiAqLyBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxuICAgICAgICAvKiByZWFkVGltZSAqLyBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxuICAgICAgICAvKiBjcmVhdGVUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgT2JqZWN0VmFsdWUuZW1wdHkoKSwgMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgZG9jdW1lbnQgdGhhdCBpcyBrbm93biB0byBleGlzdCB3aXRoIHRoZSBnaXZlbiBkYXRhIGF0IHRoZVxuICAgICAqIGdpdmVuIHZlcnNpb24uXG4gICAgICovXG4gICAgc3RhdGljIG5ld0ZvdW5kRG9jdW1lbnQoZG9jdW1lbnRLZXksIHZlcnNpb24sIGNyZWF0ZVRpbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZURvY3VtZW50KGRvY3VtZW50S2V5LCAxIC8qIERvY3VtZW50VHlwZS5GT1VORF9ET0NVTUVOVCAqLywgXG4gICAgICAgIC8qIHZlcnNpb24gKi8gdmVyc2lvbiwgXG4gICAgICAgIC8qIHJlYWRUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXG4gICAgICAgIC8qIGNyZWF0ZVRpbWUgKi8gY3JlYXRlVGltZSwgdmFsdWUsIDAgLyogRG9jdW1lbnRTdGF0ZS5TWU5DRUQgKi8pO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBkb2N1bWVudCB0aGF0IGlzIGtub3duIHRvIG5vdCBleGlzdCBhdCB0aGUgZ2l2ZW4gdmVyc2lvbi4gKi9cbiAgICBzdGF0aWMgbmV3Tm9Eb2N1bWVudChkb2N1bWVudEtleSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IE11dGFibGVEb2N1bWVudChkb2N1bWVudEtleSwgMiAvKiBEb2N1bWVudFR5cGUuTk9fRE9DVU1FTlQgKi8sIFxuICAgICAgICAvKiB2ZXJzaW9uICovIHZlcnNpb24sIFxuICAgICAgICAvKiByZWFkVGltZSAqLyBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxuICAgICAgICAvKiBjcmVhdGVUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgT2JqZWN0VmFsdWUuZW1wdHkoKSwgMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgZG9jdW1lbnQgdGhhdCBpcyBrbm93biB0byBleGlzdCBhdCB0aGUgZ2l2ZW4gdmVyc2lvbiBidXRcbiAgICAgKiB3aG9zZSBkYXRhIGlzIG5vdCBrbm93biAoZS5nLiBhIGRvY3VtZW50IHRoYXQgd2FzIHVwZGF0ZWQgd2l0aG91dCBhIGtub3duXG4gICAgICogYmFzZSBkb2N1bWVudCkuXG4gICAgICovXG4gICAgc3RhdGljIG5ld1Vua25vd25Eb2N1bWVudChkb2N1bWVudEtleSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IE11dGFibGVEb2N1bWVudChkb2N1bWVudEtleSwgMyAvKiBEb2N1bWVudFR5cGUuVU5LTk9XTl9ET0NVTUVOVCAqLywgXG4gICAgICAgIC8qIHZlcnNpb24gKi8gdmVyc2lvbiwgXG4gICAgICAgIC8qIHJlYWRUaW1lICovIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXG4gICAgICAgIC8qIGNyZWF0ZVRpbWUgKi8gU25hcHNob3RWZXJzaW9uLm1pbigpLCBPYmplY3RWYWx1ZS5lbXB0eSgpLCAyIC8qIERvY3VtZW50U3RhdGUuSEFTX0NPTU1JVFRFRF9NVVRBVElPTlMgKi8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBkb2N1bWVudCB0eXBlIHRvIGluZGljYXRlIHRoYXQgaXQgZXhpc3RzIGFuZCB0aGF0IGl0cyB2ZXJzaW9uXG4gICAgICogYW5kIGRhdGEgYXJlIGtub3duLlxuICAgICAqL1xuICAgIGNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQodmVyc2lvbiwgdmFsdWUpIHtcbiAgICAgICAgLy8gSWYgYSBkb2N1bWVudCBpcyBzd2l0Y2hpbmcgc3RhdGUgZnJvbSBiZWluZyBhbiBpbnZhbGlkIG9yIGRlbGV0ZWRcbiAgICAgICAgLy8gZG9jdW1lbnQgdG8gYSB2YWxpZCAoRk9VTkRfRE9DVU1FTlQpIGRvY3VtZW50LCBlaXRoZXIgZHVlIHRvIHJlY2VpdmluZyBhblxuICAgICAgICAvLyB1cGRhdGUgZnJvbSBXYXRjaCBvciBkdWUgdG8gYXBwbHlpbmcgYSBsb2NhbCBzZXQgbXV0YXRpb24gb24gdG9wXG4gICAgICAgIC8vIG9mIGEgZGVsZXRlZCBkb2N1bWVudCwgb3VyIGJlc3QgZ3Vlc3MgYWJvdXQgaXRzIGNyZWF0ZVRpbWUgd291bGQgYmUgdGhlXG4gICAgICAgIC8vIHZlcnNpb24gYXQgd2hpY2ggdGhlIGRvY3VtZW50IHRyYW5zaXRpb25lZCB0byBhIEZPVU5EX0RPQ1VNRU5ULlxuICAgICAgICBpZiAodGhpcy5jcmVhdGVUaW1lLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKSAmJlxuICAgICAgICAgICAgKHRoaXMuZG9jdW1lbnRUeXBlID09PSAyIC8qIERvY3VtZW50VHlwZS5OT19ET0NVTUVOVCAqLyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID09PSAwIC8qIERvY3VtZW50VHlwZS5JTlZBTElEICovKSkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVUaW1lID0gdmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLmRvY3VtZW50VHlwZSA9IDEgLyogRG9jdW1lbnRUeXBlLkZPVU5EX0RPQ1VNRU5UICovO1xuICAgICAgICB0aGlzLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID0gMCAvKiBEb2N1bWVudFN0YXRlLlNZTkNFRCAqLztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGRvY3VtZW50IHR5cGUgdG8gaW5kaWNhdGUgdGhhdCBpdCBkb2Vzbid0IGV4aXN0IGF0IHRoZSBnaXZlblxuICAgICAqIHZlcnNpb24uXG4gICAgICovXG4gICAgY29udmVydFRvTm9Eb2N1bWVudCh2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID0gMiAvKiBEb2N1bWVudFR5cGUuTk9fRE9DVU1FTlQgKi87XG4gICAgICAgIHRoaXMuZGF0YSA9IE9iamVjdFZhbHVlLmVtcHR5KCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9IDAgLyogRG9jdW1lbnRTdGF0ZS5TWU5DRUQgKi87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBkb2N1bWVudCB0eXBlIHRvIGluZGljYXRlIHRoYXQgaXQgZXhpc3RzIGF0IGEgZ2l2ZW4gdmVyc2lvbiBidXRcbiAgICAgKiB0aGF0IGl0cyBkYXRhIGlzIG5vdCBrbm93biAoZS5nLiBhIGRvY3VtZW50IHRoYXQgd2FzIHVwZGF0ZWQgd2l0aG91dCBhIGtub3duXG4gICAgICogYmFzZSBkb2N1bWVudCkuXG4gICAgICovXG4gICAgY29udmVydFRvVW5rbm93bkRvY3VtZW50KHZlcnNpb24pIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5kb2N1bWVudFR5cGUgPSAzIC8qIERvY3VtZW50VHlwZS5VTktOT1dOX0RPQ1VNRU5UICovO1xuICAgICAgICB0aGlzLmRhdGEgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSAyIC8qIERvY3VtZW50U3RhdGUuSEFTX0NPTU1JVFRFRF9NVVRBVElPTlMgKi87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZSA9IDIgLyogRG9jdW1lbnRTdGF0ZS5IQVNfQ09NTUlUVEVEX01VVEFUSU9OUyAqLztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldEhhc0xvY2FsTXV0YXRpb25zKCkge1xuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSAxIC8qIERvY3VtZW50U3RhdGUuSEFTX0xPQ0FMX01VVEFUSU9OUyAqLztcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0UmVhZFRpbWUocmVhZFRpbWUpIHtcbiAgICAgICAgdGhpcy5yZWFkVGltZSA9IHJlYWRUaW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IGhhc0xvY2FsTXV0YXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFN0YXRlID09PSAxIC8qIERvY3VtZW50U3RhdGUuSEFTX0xPQ0FMX01VVEFUSU9OUyAqLztcbiAgICB9XG4gICAgZ2V0IGhhc0NvbW1pdHRlZE11dGF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRTdGF0ZSA9PT0gMiAvKiBEb2N1bWVudFN0YXRlLkhBU19DT01NSVRURURfTVVUQVRJT05TICovO1xuICAgIH1cbiAgICBnZXQgaGFzUGVuZGluZ1dyaXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzTG9jYWxNdXRhdGlvbnMgfHwgdGhpcy5oYXNDb21taXR0ZWRNdXRhdGlvbnM7XG4gICAgfVxuICAgIGlzVmFsaWREb2N1bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUeXBlICE9PSAwIC8qIERvY3VtZW50VHlwZS5JTlZBTElEICovO1xuICAgIH1cbiAgICBpc0ZvdW5kRG9jdW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50VHlwZSA9PT0gMSAvKiBEb2N1bWVudFR5cGUuRk9VTkRfRE9DVU1FTlQgKi87XG4gICAgfVxuICAgIGlzTm9Eb2N1bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUeXBlID09PSAyIC8qIERvY3VtZW50VHlwZS5OT19ET0NVTUVOVCAqLztcbiAgICB9XG4gICAgaXNVbmtub3duRG9jdW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50VHlwZSA9PT0gMyAvKiBEb2N1bWVudFR5cGUuVU5LTk9XTl9ET0NVTUVOVCAqLztcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKG90aGVyIGluc3RhbmNlb2YgTXV0YWJsZURvY3VtZW50ICYmXG4gICAgICAgICAgICB0aGlzLmtleS5pc0VxdWFsKG90aGVyLmtleSkgJiZcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbi5pc0VxdWFsKG90aGVyLnZlcnNpb24pICYmXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50VHlwZSA9PT0gb3RoZXIuZG9jdW1lbnRUeXBlICYmXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPT09IG90aGVyLmRvY3VtZW50U3RhdGUgJiZcbiAgICAgICAgICAgIHRoaXMuZGF0YS5pc0VxdWFsKG90aGVyLmRhdGEpKTtcbiAgICB9XG4gICAgbXV0YWJsZUNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZURvY3VtZW50KHRoaXMua2V5LCB0aGlzLmRvY3VtZW50VHlwZSwgdGhpcy52ZXJzaW9uLCB0aGlzLnJlYWRUaW1lLCB0aGlzLmNyZWF0ZVRpbWUsIHRoaXMuZGF0YS5jbG9uZSgpLCB0aGlzLmRvY3VtZW50U3RhdGUpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChgRG9jdW1lbnQoJHt0aGlzLmtleX0sICR7dGhpcy52ZXJzaW9ufSwgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEudmFsdWUpfSwgYCArXG4gICAgICAgICAgICBge2NyZWF0ZVRpbWU6ICR7dGhpcy5jcmVhdGVUaW1lfX0pLCBgICtcbiAgICAgICAgICAgIGB7ZG9jdW1lbnRUeXBlOiAke3RoaXMuZG9jdW1lbnRUeXBlfX0pLCBgICtcbiAgICAgICAgICAgIGB7ZG9jdW1lbnRTdGF0ZTogJHt0aGlzLmRvY3VtZW50U3RhdGV9fSlgKTtcbiAgICB9XG59XG4vKipcbiAqIENvbXBhcmVzIHRoZSB2YWx1ZSBmb3IgZmllbGQgYGZpZWxkYCBpbiB0aGUgcHJvdmlkZWQgZG9jdW1lbnRzLiBUaHJvd3MgaWZcbiAqIHRoZSBmaWVsZCBkb2VzIG5vdCBleGlzdCBpbiBib3RoIGRvY3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZURvY3VtZW50c0J5RmllbGQoZmllbGQsIGQxLCBkMikge1xuICAgIGNvbnN0IHYxID0gZDEuZGF0YS5maWVsZChmaWVsZCk7XG4gICAgY29uc3QgdjIgPSBkMi5kYXRhLmZpZWxkKGZpZWxkKTtcbiAgICBpZiAodjEgIT09IG51bGwgJiYgdjIgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlQ29tcGFyZSh2MSwgdjIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSBib3VuZCBvZiBhIHF1ZXJ5LlxuICpcbiAqIFRoZSBib3VuZCBpcyBzcGVjaWZpZWQgd2l0aCB0aGUgZ2l2ZW4gY29tcG9uZW50cyByZXByZXNlbnRpbmcgYSBwb3NpdGlvbiBhbmRcbiAqIHdoZXRoZXIgaXQncyBqdXN0IGJlZm9yZSBvciBqdXN0IGFmdGVyIHRoZSBwb3NpdGlvbiAocmVsYXRpdmUgdG8gd2hhdGV2ZXIgdGhlXG4gKiBxdWVyeSBvcmRlciBpcykuXG4gKlxuICogVGhlIHBvc2l0aW9uIHJlcHJlc2VudHMgYSBsb2dpY2FsIGluZGV4IHBvc2l0aW9uIGZvciBhIHF1ZXJ5LiBJdCdzIGEgcHJlZml4XG4gKiBvZiB2YWx1ZXMgZm9yIHRoZSAocG90ZW50aWFsbHkgaW1wbGljaXQpIG9yZGVyIGJ5IGNsYXVzZXMgb2YgYSBxdWVyeS5cbiAqXG4gKiBCb3VuZCBwcm92aWRlcyBhIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGV0aGVyIGEgZG9jdW1lbnQgY29tZXMgYmVmb3JlIG9yXG4gKiBhZnRlciBhIGJvdW5kLiBUaGlzIGlzIGluZmx1ZW5jZWQgYnkgd2hldGhlciB0aGUgcG9zaXRpb24gaXMganVzdCBiZWZvcmUgb3JcbiAqIGp1c3QgYWZ0ZXIgdGhlIHByb3ZpZGVkIHZhbHVlcy5cbiAqL1xuY2xhc3MgQm91bmQge1xuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9uLCBpbmNsdXNpdmUpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLmluY2x1c2l2ZSA9IGluY2x1c2l2ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBib3VuZENvbXBhcmVUb0RvY3VtZW50KGJvdW5kLCBvcmRlckJ5LCBkb2MpIHtcbiAgICBsZXQgY29tcGFyaXNvbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZC5wb3NpdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvcmRlckJ5Q29tcG9uZW50ID0gb3JkZXJCeVtpXTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gYm91bmQucG9zaXRpb25baV07XG4gICAgICAgIGlmIChvcmRlckJ5Q29tcG9uZW50LmZpZWxkLmlzS2V5RmllbGQoKSkge1xuICAgICAgICAgICAgY29tcGFyaXNvbiA9IERvY3VtZW50S2V5LmNvbXBhcmF0b3IoRG9jdW1lbnRLZXkuZnJvbU5hbWUoY29tcG9uZW50LnJlZmVyZW5jZVZhbHVlKSwgZG9jLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkb2NWYWx1ZSA9IGRvYy5kYXRhLmZpZWxkKG9yZGVyQnlDb21wb25lbnQuZmllbGQpO1xuICAgICAgICAgICAgY29tcGFyaXNvbiA9IHZhbHVlQ29tcGFyZShjb21wb25lbnQsIGRvY1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkZXJCeUNvbXBvbmVudC5kaXIgPT09IFwiZGVzY1wiIC8qIERpcmVjdGlvbi5ERVNDRU5ESU5HICovKSB7XG4gICAgICAgICAgICBjb21wYXJpc29uID0gY29tcGFyaXNvbiAqIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJpc29uICE9PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29tcGFyaXNvbjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgZG9jdW1lbnQgc29ydHMgYWZ0ZXIgYSBib3VuZCB1c2luZyB0aGUgcHJvdmlkZWQgc29ydFxuICogb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIGJvdW5kU29ydHNBZnRlckRvY3VtZW50KGJvdW5kLCBvcmRlckJ5LCBkb2MpIHtcbiAgICBjb25zdCBjb21wYXJpc29uID0gYm91bmRDb21wYXJlVG9Eb2N1bWVudChib3VuZCwgb3JkZXJCeSwgZG9jKTtcbiAgICByZXR1cm4gYm91bmQuaW5jbHVzaXZlID8gY29tcGFyaXNvbiA+PSAwIDogY29tcGFyaXNvbiA+IDA7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGRvY3VtZW50IHNvcnRzIGJlZm9yZSBhIGJvdW5kIHVzaW5nIHRoZSBwcm92aWRlZCBzb3J0XG4gKiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gYm91bmRTb3J0c0JlZm9yZURvY3VtZW50KGJvdW5kLCBvcmRlckJ5LCBkb2MpIHtcbiAgICBjb25zdCBjb21wYXJpc29uID0gYm91bmRDb21wYXJlVG9Eb2N1bWVudChib3VuZCwgb3JkZXJCeSwgZG9jKTtcbiAgICByZXR1cm4gYm91bmQuaW5jbHVzaXZlID8gY29tcGFyaXNvbiA8PSAwIDogY29tcGFyaXNvbiA8IDA7XG59XG5mdW5jdGlvbiBib3VuZEVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByaWdodCA9PT0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAocmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGVmdC5pbmNsdXNpdmUgIT09IHJpZ2h0LmluY2x1c2l2ZSB8fFxuICAgICAgICBsZWZ0LnBvc2l0aW9uLmxlbmd0aCAhPT0gcmlnaHQucG9zaXRpb24ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0LnBvc2l0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxlZnRQb3NpdGlvbiA9IGxlZnQucG9zaXRpb25baV07XG4gICAgICAgIGNvbnN0IHJpZ2h0UG9zaXRpb24gPSByaWdodC5wb3NpdGlvbltpXTtcbiAgICAgICAgaWYgKCF2YWx1ZUVxdWFscyhsZWZ0UG9zaXRpb24sIHJpZ2h0UG9zaXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIG9yZGVyaW5nIG9uIGEgZmllbGQsIGluIHNvbWUgRGlyZWN0aW9uLiBEaXJlY3Rpb24gZGVmYXVsdHMgdG8gQVNDRU5ESU5HLlxuICovXG5jbGFzcyBPcmRlckJ5IHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgZGlyID0gXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgfVxufVxuZnVuY3Rpb24gY2Fub25pZnlPcmRlckJ5KG9yZGVyQnkpIHtcbiAgICAvLyBUT0RPKGIvMjkxODMxNjUpOiBNYWtlIHRoaXMgY29sbGlzaW9uIHJvYnVzdC5cbiAgICByZXR1cm4gb3JkZXJCeS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKSArIG9yZGVyQnkuZGlyO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5T3JkZXJCeShvcmRlckJ5KSB7XG4gICAgcmV0dXJuIGAke29yZGVyQnkuZmllbGQuY2Fub25pY2FsU3RyaW5nKCl9ICgke29yZGVyQnkuZGlyfSlgO1xufVxuZnVuY3Rpb24gb3JkZXJCeUVxdWFscyhsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0LmRpciA9PT0gcmlnaHQuZGlyICYmIGxlZnQuZmllbGQuaXNFcXVhbChyaWdodC5maWVsZCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBGaWx0ZXIge1xufVxuY2xhc3MgRmllbGRGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBvcCwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZpbHRlciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZmllbGQsIG9wLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZmllbGQuaXNLZXlGaWVsZCgpKSB7XG4gICAgICAgICAgICBpZiAob3AgPT09IFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLyB8fCBvcCA9PT0gXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVLZXlGaWVsZEluRmlsdGVyKGZpZWxkLCBvcCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBLZXlGaWVsZEZpbHRlcihmaWVsZCwgb3AsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcCA9PT0gXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5Q29udGFpbnNGaWx0ZXIoZmllbGQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEluRmlsdGVyKGZpZWxkLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vdEluRmlsdGVyKGZpZWxkLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3AgPT09IFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5Q29udGFpbnNBbnlGaWx0ZXIoZmllbGQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmllbGRGaWx0ZXIoZmllbGQsIG9wLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUtleUZpZWxkSW5GaWx0ZXIoZmllbGQsIG9wLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gb3AgPT09IFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqL1xuICAgICAgICAgICAgPyBuZXcgS2V5RmllbGRJbkZpbHRlcihmaWVsZCwgdmFsdWUpXG4gICAgICAgICAgICA6IG5ldyBLZXlGaWVsZE5vdEluRmlsdGVyKGZpZWxkLCB2YWx1ZSk7XG4gICAgfVxuICAgIG1hdGNoZXMoZG9jKSB7XG4gICAgICAgIGNvbnN0IG90aGVyID0gZG9jLmRhdGEuZmllbGQodGhpcy5maWVsZCk7XG4gICAgICAgIC8vIFR5cGVzIGRvIG5vdCBoYXZlIHRvIG1hdGNoIGluIE5PVF9FUVVBTCBmaWx0ZXJzLlxuICAgICAgICBpZiAodGhpcy5vcCA9PT0gXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIChvdGhlciAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlc0NvbXBhcmlzb24odmFsdWVDb21wYXJlKG90aGVyLCB0aGlzLnZhbHVlKSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgY29tcGFyZSB0eXBlcyB3aXRoIG1hdGNoaW5nIGJhY2tlbmQgb3JkZXIgKHN1Y2ggYXMgZG91YmxlIGFuZCBpbnQpLlxuICAgICAgICByZXR1cm4gKG90aGVyICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlT3JkZXIodGhpcy52YWx1ZSkgPT09IHR5cGVPcmRlcihvdGhlcikgJiZcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlc0NvbXBhcmlzb24odmFsdWVDb21wYXJlKG90aGVyLCB0aGlzLnZhbHVlKSkpO1xuICAgIH1cbiAgICBtYXRjaGVzQ29tcGFyaXNvbihjb21wYXJpc29uKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5vcCkge1xuICAgICAgICAgICAgY2FzZSBcIjxcIiAvKiBPcGVyYXRvci5MRVNTX1RIQU4gKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPCAwO1xuICAgICAgICAgICAgY2FzZSBcIjw9XCIgLyogT3BlcmF0b3IuTEVTU19USEFOX09SX0VRVUFMICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uIDw9IDA7XG4gICAgICAgICAgICBjYXNlIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA9PT0gMDtcbiAgICAgICAgICAgIGNhc2UgXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiAhPT0gMDtcbiAgICAgICAgICAgIGNhc2UgXCI+XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uID4gMDtcbiAgICAgICAgICAgIGNhc2UgXCI+PVwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTl9PUl9FUVVBTCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA+PSAwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzSW5lcXVhbGl0eSgpIHtcbiAgICAgICAgcmV0dXJuIChbXG4gICAgICAgICAgICBcIjxcIiAvKiBPcGVyYXRvci5MRVNTX1RIQU4gKi8sXG4gICAgICAgICAgICBcIjw9XCIgLyogT3BlcmF0b3IuTEVTU19USEFOX09SX0VRVUFMICovLFxuICAgICAgICAgICAgXCI+XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOICovLFxuICAgICAgICAgICAgXCI+PVwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTl9PUl9FUVVBTCAqLyxcbiAgICAgICAgICAgIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi8sXG4gICAgICAgICAgICBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqL1xuICAgICAgICBdLmluZGV4T2YodGhpcy5vcCkgPj0gMCk7XG4gICAgfVxuICAgIGdldEZsYXR0ZW5lZEZpbHRlcnMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpc107XG4gICAgfVxuICAgIGdldEZpbHRlcnMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpc107XG4gICAgfVxufVxuY2xhc3MgQ29tcG9zaXRlRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJzLCBvcCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRGbGF0dGVuZWRGaWx0ZXJzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZpbHRlciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZmlsdGVycywgb3ApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NpdGVGaWx0ZXIoZmlsdGVycywgb3ApO1xuICAgIH1cbiAgICBtYXRjaGVzKGRvYykge1xuICAgICAgICBpZiAoY29tcG9zaXRlRmlsdGVySXNDb25qdW5jdGlvbih0aGlzKSkge1xuICAgICAgICAgICAgLy8gRm9yIGNvbmp1bmN0aW9ucywgYWxsIGZpbHRlcnMgbXVzdCBtYXRjaCwgc28gcmV0dXJuIGZhbHNlIGlmIGFueSBmaWx0ZXIgZG9lc24ndCBtYXRjaC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcnMuZmluZChmaWx0ZXIgPT4gIWZpbHRlci5tYXRjaGVzKGRvYykpID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgZGlzanVuY3Rpb25zLCBhdCBsZWFzdCBvbmUgZmlsdGVyIHNob3VsZCBtYXRjaC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcnMuZmluZChmaWx0ZXIgPT4gZmlsdGVyLm1hdGNoZXMoZG9jKSkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRGbGF0dGVuZWRGaWx0ZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5tZW1vaXplZEZsYXR0ZW5lZEZpbHRlcnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbW9pemVkRmxhdHRlbmVkRmlsdGVycztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lbW9pemVkRmxhdHRlbmVkRmlsdGVycyA9IHRoaXMuZmlsdGVycy5yZWR1Y2UoKHJlc3VsdCwgc3ViZmlsdGVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChzdWJmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpKTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gdGhpcy5tZW1vaXplZEZsYXR0ZW5lZEZpbHRlcnM7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBtdXRhYmxlIGNvcHkgb2YgYHRoaXMuZmlsdGVyc2BcbiAgICBnZXRGaWx0ZXJzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihbXSwgdGhpcy5maWx0ZXJzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKGNvbXBvc2l0ZUZpbHRlcikge1xuICAgIHJldHVybiBjb21wb3NpdGVGaWx0ZXIub3AgPT09IFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovO1xufVxuZnVuY3Rpb24gY29tcG9zaXRlRmlsdGVySXNEaXNqdW5jdGlvbihjb21wb3NpdGVGaWx0ZXIpIHtcbiAgICByZXR1cm4gY29tcG9zaXRlRmlsdGVyLm9wID09PSBcIm9yXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuT1IgKi87XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGZpbHRlciBpcyBhIGNvbmp1bmN0aW9uIG9mIGZpZWxkIGZpbHRlcnMgb25seS4gUmV0dXJucyBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2l0ZUZpbHRlcklzRmxhdENvbmp1bmN0aW9uKGNvbXBvc2l0ZUZpbHRlcikge1xuICAgIHJldHVybiAoY29tcG9zaXRlRmlsdGVySXNGbGF0KGNvbXBvc2l0ZUZpbHRlcikgJiZcbiAgICAgICAgY29tcG9zaXRlRmlsdGVySXNDb25qdW5jdGlvbihjb21wb3NpdGVGaWx0ZXIpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZmlsdGVyIGRvZXMgbm90IGNvbnRhaW4gYW55IGNvbXBvc2l0ZSBmaWx0ZXJzLiBSZXR1cm5zIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gY29tcG9zaXRlRmlsdGVySXNGbGF0KGNvbXBvc2l0ZUZpbHRlcikge1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGNvbXBvc2l0ZUZpbHRlci5maWx0ZXJzKSB7XG4gICAgICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNhbm9uaWZ5RmlsdGVyKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcikge1xuICAgICAgICAvLyBUT0RPKGIvMjkxODMxNjUpOiBUZWNobmljYWxseSwgdGhpcyB3b24ndCBiZSB1bmlxdWUgaWYgdHdvIHZhbHVlcyBoYXZlXG4gICAgICAgIC8vIHRoZSBzYW1lIGRlc2NyaXB0aW9uLCBzdWNoIGFzIHRoZSBpbnQgMyBhbmQgdGhlIHN0cmluZyBcIjNcIi4gU28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIGFkZCB0aGUgdHlwZXMgaW4gaGVyZSBzb21laG93LCB0b28uXG4gICAgICAgIHJldHVybiAoZmlsdGVyLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpICtcbiAgICAgICAgICAgIGZpbHRlci5vcC50b1N0cmluZygpICtcbiAgICAgICAgICAgIGNhbm9uaWNhbElkKGZpbHRlci52YWx1ZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb21wb3NpdGVGaWx0ZXJJc0ZsYXRDb25qdW5jdGlvbihmaWx0ZXIpKSB7XG4gICAgICAgIC8vIE9sZGVyIFNESyB2ZXJzaW9ucyB1c2UgYW4gaW1wbGljaXQgQU5EIG9wZXJhdGlvbiBiZXR3ZWVuIHRoZWlyIGZpbHRlcnMuXG4gICAgICAgIC8vIEluIHRoZSBuZXcgU0RLIHZlcnNpb25zLCB0aGUgZGV2ZWxvcGVyIG1heSB1c2UgYW4gZXhwbGljaXQgQU5EIGZpbHRlci5cbiAgICAgICAgLy8gVG8gc3RheSBjb25zaXN0ZW50IHdpdGggdGhlIG9sZCB1c2FnZXMsIHdlIGFkZCBhIHNwZWNpYWwgY2FzZSB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhlIGNhbm9uaWNhbCBJRCBmb3IgdGhlc2UgdHdvIGFyZSB0aGUgc2FtZS4gRm9yIGV4YW1wbGU6XG4gICAgICAgIC8vIGBjb2wud2hlcmVFcXVhbHMoXCJhXCIsIDEpLndoZXJlRXF1YWxzKFwiYlwiLCAyKWAgc2hvdWxkIGhhdmUgdGhlIHNhbWVcbiAgICAgICAgLy8gY2Fub25pY2FsIElEIGFzIGBjb2wud2hlcmUoYW5kKGVxdWFscyhcImFcIiwxKSwgZXF1YWxzKFwiYlwiLDIpKSlgLlxuICAgICAgICByZXR1cm4gZmlsdGVyLmZpbHRlcnMubWFwKGZpbHRlciA9PiBjYW5vbmlmeUZpbHRlcihmaWx0ZXIpKS5qb2luKCcsJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXJcbiAgICAgICAgY29uc3QgY2Fub25pY2FsSWRzU3RyaW5nID0gZmlsdGVyLmZpbHRlcnNcbiAgICAgICAgICAgIC5tYXAoZmlsdGVyID0+IGNhbm9uaWZ5RmlsdGVyKGZpbHRlcikpXG4gICAgICAgICAgICAuam9pbignLCcpO1xuICAgICAgICByZXR1cm4gYCR7ZmlsdGVyLm9wfSgke2Nhbm9uaWNhbElkc1N0cmluZ30pYDtcbiAgICB9XG59XG5mdW5jdGlvbiBmaWx0ZXJFcXVhbHMoZjEsIGYyKSB7XG4gICAgaWYgKGYxIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkRmlsdGVyRXF1YWxzKGYxLCBmMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGYxIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGVGaWx0ZXJFcXVhbHMoZjEsIGYyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaWVsZEZpbHRlckVxdWFscyhmMSwgZjIpIHtcbiAgICByZXR1cm4gKGYyIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgJiZcbiAgICAgICAgZjEub3AgPT09IGYyLm9wICYmXG4gICAgICAgIGYxLmZpZWxkLmlzRXF1YWwoZjIuZmllbGQpICYmXG4gICAgICAgIHZhbHVlRXF1YWxzKGYxLnZhbHVlLCBmMi52YWx1ZSkpO1xufVxuZnVuY3Rpb24gY29tcG9zaXRlRmlsdGVyRXF1YWxzKGYxLCBmMikge1xuICAgIGlmIChmMiBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlciAmJlxuICAgICAgICBmMS5vcCA9PT0gZjIub3AgJiZcbiAgICAgICAgZjEuZmlsdGVycy5sZW5ndGggPT09IGYyLmZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHN1YkZpbHRlcnNNYXRjaCA9IGYxLmZpbHRlcnMucmVkdWNlKChyZXN1bHQsIGYxRmlsdGVyLCBpbmRleCkgPT4gcmVzdWx0ICYmIGZpbHRlckVxdWFscyhmMUZpbHRlciwgZjIuZmlsdGVyc1tpbmRleF0pLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHN1YkZpbHRlcnNNYXRjaDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGNvbXBvc2l0ZSBmaWx0ZXIgdGhhdCBjb250YWlucyBhbGwgZmlsdGVyIGZyb21cbiAqIGBjb21wb3NpdGVGaWx0ZXJgIHBsdXMgYWxsIHRoZSBnaXZlbiBmaWx0ZXJzIGluIGBvdGhlckZpbHRlcnNgLlxuICovXG5mdW5jdGlvbiBjb21wb3NpdGVGaWx0ZXJXaXRoQWRkZWRGaWx0ZXJzKGNvbXBvc2l0ZUZpbHRlciwgb3RoZXJGaWx0ZXJzKSB7XG4gICAgY29uc3QgbWVyZ2VkRmlsdGVycyA9IGNvbXBvc2l0ZUZpbHRlci5maWx0ZXJzLmNvbmNhdChvdGhlckZpbHRlcnMpO1xuICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKG1lcmdlZEZpbHRlcnMsIGNvbXBvc2l0ZUZpbHRlci5vcCk7XG59XG4vKiogUmV0dXJucyBhIGRlYnVnIGRlc2NyaXB0aW9uIGZvciBgZmlsdGVyYC4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeUZpbHRlcihmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUZpZWxkRmlsdGVyKGZpbHRlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbHRlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcikge1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5Q29tcG9zaXRlRmlsdGVyKGZpbHRlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJ0ZpbHRlcic7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyaW5naWZ5Q29tcG9zaXRlRmlsdGVyKGZpbHRlcikge1xuICAgIHJldHVybiAoZmlsdGVyLm9wLnRvU3RyaW5nKCkgK1xuICAgICAgICBgIHtgICtcbiAgICAgICAgZmlsdGVyLmdldEZpbHRlcnMoKS5tYXAoc3RyaW5naWZ5RmlsdGVyKS5qb2luKCcgLCcpICtcbiAgICAgICAgJ30nKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUZpZWxkRmlsdGVyKGZpbHRlcikge1xuICAgIHJldHVybiBgJHtmaWx0ZXIuZmllbGQuY2Fub25pY2FsU3RyaW5nKCl9ICR7ZmlsdGVyLm9wfSAke2Nhbm9uaWNhbElkKGZpbHRlci52YWx1ZSl9YDtcbn1cbi8qKiBGaWx0ZXIgdGhhdCBtYXRjaGVzIG9uIGtleSBmaWVsZHMgKGkuZS4gJ19fbmFtZV9fJykuICovXG5jbGFzcyBLZXlGaWVsZEZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgb3AsIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkLCBvcCwgdmFsdWUpO1xuICAgICAgICB0aGlzLmtleSA9IERvY3VtZW50S2V5LmZyb21OYW1lKHZhbHVlLnJlZmVyZW5jZVZhbHVlKTtcbiAgICB9XG4gICAgbWF0Y2hlcyhkb2MpIHtcbiAgICAgICAgY29uc3QgY29tcGFyaXNvbiA9IERvY3VtZW50S2V5LmNvbXBhcmF0b3IoZG9jLmtleSwgdGhpcy5rZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaGVzQ29tcGFyaXNvbihjb21wYXJpc29uKTtcbiAgICB9XG59XG4vKiogRmlsdGVyIHRoYXQgbWF0Y2hlcyBvbiBrZXkgZmllbGRzIHdpdGhpbiBhbiBhcnJheS4gKi9cbmNsYXNzIEtleUZpZWxkSW5GaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkLCBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8sIHZhbHVlKTtcbiAgICAgICAgdGhpcy5rZXlzID0gZXh0cmFjdERvY3VtZW50S2V5c0Zyb21BcnJheVZhbHVlKFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBtYXRjaGVzKGRvYykge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlzLnNvbWUoa2V5ID0+IGtleS5pc0VxdWFsKGRvYy5rZXkpKTtcbiAgICB9XG59XG4vKiogRmlsdGVyIHRoYXQgbWF0Y2hlcyBvbiBrZXkgZmllbGRzIG5vdCBwcmVzZW50IHdpdGhpbiBhbiBhcnJheS4gKi9cbmNsYXNzIEtleUZpZWxkTm90SW5GaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkLCBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLywgdmFsdWUpO1xuICAgICAgICB0aGlzLmtleXMgPSBleHRyYWN0RG9jdW1lbnRLZXlzRnJvbUFycmF5VmFsdWUoXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgbWF0Y2hlcyhkb2MpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmtleXMuc29tZShrZXkgPT4ga2V5LmlzRXF1YWwoZG9jLmtleSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV4dHJhY3REb2N1bWVudEtleXNGcm9tQXJyYXlWYWx1ZShvcCwgdmFsdWUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoKF9hID0gdmFsdWUuYXJyYXlWYWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlcykgfHwgW10pLm1hcCh2ID0+IHtcbiAgICAgICAgcmV0dXJuIERvY3VtZW50S2V5LmZyb21OYW1lKHYucmVmZXJlbmNlVmFsdWUpO1xuICAgIH0pO1xufVxuLyoqIEEgRmlsdGVyIHRoYXQgaW1wbGVtZW50cyB0aGUgYXJyYXktY29udGFpbnMgb3BlcmF0b3IuICovXG5jbGFzcyBBcnJheUNvbnRhaW5zRmlsdGVyIGV4dGVuZHMgRmllbGRGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgICBzdXBlcihmaWVsZCwgXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIG1hdGNoZXMoZG9jKSB7XG4gICAgICAgIGNvbnN0IG90aGVyID0gZG9jLmRhdGEuZmllbGQodGhpcy5maWVsZCk7XG4gICAgICAgIHJldHVybiBpc0FycmF5KG90aGVyKSAmJiBhcnJheVZhbHVlQ29udGFpbnMob3RoZXIuYXJyYXlWYWx1ZSwgdGhpcy52YWx1ZSk7XG4gICAgfVxufVxuLyoqIEEgRmlsdGVyIHRoYXQgaW1wbGVtZW50cyB0aGUgSU4gb3BlcmF0b3IuICovXG5jbGFzcyBJbkZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoZmllbGQsIFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBtYXRjaGVzKGRvYykge1xuICAgICAgICBjb25zdCBvdGhlciA9IGRvYy5kYXRhLmZpZWxkKHRoaXMuZmllbGQpO1xuICAgICAgICByZXR1cm4gb3RoZXIgIT09IG51bGwgJiYgYXJyYXlWYWx1ZUNvbnRhaW5zKHRoaXMudmFsdWUuYXJyYXlWYWx1ZSwgb3RoZXIpO1xuICAgIH1cbn1cbi8qKiBBIEZpbHRlciB0aGF0IGltcGxlbWVudHMgdGhlIG5vdC1pbiBvcGVyYXRvci4gKi9cbmNsYXNzIE5vdEluRmlsdGVyIGV4dGVuZHMgRmllbGRGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgICBzdXBlcihmaWVsZCwgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgbWF0Y2hlcyhkb2MpIHtcbiAgICAgICAgaWYgKGFycmF5VmFsdWVDb250YWlucyh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIHsgbnVsbFZhbHVlOiAnTlVMTF9WQUxVRScgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdGhlciA9IGRvYy5kYXRhLmZpZWxkKHRoaXMuZmllbGQpO1xuICAgICAgICByZXR1cm4gb3RoZXIgIT09IG51bGwgJiYgIWFycmF5VmFsdWVDb250YWlucyh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIG90aGVyKTtcbiAgICB9XG59XG4vKiogQSBGaWx0ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBhcnJheS1jb250YWlucy1hbnkgb3BlcmF0b3IuICovXG5jbGFzcyBBcnJheUNvbnRhaW5zQW55RmlsdGVyIGV4dGVuZHMgRmllbGRGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgICBzdXBlcihmaWVsZCwgXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgbWF0Y2hlcyhkb2MpIHtcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcbiAgICAgICAgaWYgKCFpc0FycmF5KG90aGVyKSB8fCAhb3RoZXIuYXJyYXlWYWx1ZS52YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3RoZXIuYXJyYXlWYWx1ZS52YWx1ZXMuc29tZSh2YWwgPT4gYXJyYXlWYWx1ZUNvbnRhaW5zKHRoaXMudmFsdWUuYXJyYXlWYWx1ZSwgdmFsKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gVmlzaWJsZSBmb3IgdGVzdGluZ1xuY2xhc3MgVGFyZ2V0SW1wbCB7XG4gICAgY29uc3RydWN0b3IocGF0aCwgY29sbGVjdGlvbkdyb3VwID0gbnVsbCwgb3JkZXJCeSA9IFtdLCBmaWx0ZXJzID0gW10sIGxpbWl0ID0gbnVsbCwgc3RhcnRBdCA9IG51bGwsIGVuZEF0ID0gbnVsbCkge1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25Hcm91cCA9IGNvbGxlY3Rpb25Hcm91cDtcbiAgICAgICAgdGhpcy5vcmRlckJ5ID0gb3JkZXJCeTtcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgICAgICAgdGhpcy5saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLnN0YXJ0QXQgPSBzdGFydEF0O1xuICAgICAgICB0aGlzLmVuZEF0ID0gZW5kQXQ7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRDYW5vbmljYWxJZCA9IG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIFRhcmdldCB3aXRoIGEgcGF0aCBhbmQgb3B0aW9uYWwgYWRkaXRpb25hbCBxdWVyeSBjb25zdHJhaW50cy5cbiAqIFBhdGggbXVzdCBjdXJyZW50bHkgYmUgZW1wdHkgaWYgdGhpcyBpcyBhIGNvbGxlY3Rpb24gZ3JvdXAgcXVlcnkuXG4gKlxuICogTk9URTogeW91IHNob3VsZCBhbHdheXMgY29uc3RydWN0IGBUYXJnZXRgIGZyb20gYFF1ZXJ5LnRvVGFyZ2V0YCBpbnN0ZWFkIG9mXG4gKiB1c2luZyB0aGlzIGZhY3RvcnkgbWV0aG9kLCBiZWNhdXNlIGBRdWVyeWAgcHJvdmlkZXMgYW4gaW1wbGljaXQgYG9yZGVyQnlgXG4gKiBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gbmV3VGFyZ2V0KHBhdGgsIGNvbGxlY3Rpb25Hcm91cCA9IG51bGwsIG9yZGVyQnkgPSBbXSwgZmlsdGVycyA9IFtdLCBsaW1pdCA9IG51bGwsIHN0YXJ0QXQgPSBudWxsLCBlbmRBdCA9IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IFRhcmdldEltcGwocGF0aCwgY29sbGVjdGlvbkdyb3VwLCBvcmRlckJ5LCBmaWx0ZXJzLCBsaW1pdCwgc3RhcnRBdCwgZW5kQXQpO1xufVxuZnVuY3Rpb24gY2Fub25pZnlUYXJnZXQodGFyZ2V0KSB7XG4gICAgY29uc3QgdGFyZ2V0SW1wbCA9IGRlYnVnQ2FzdCh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXRJbXBsLm1lbW9pemVkQ2Fub25pY2FsSWQgPT09IG51bGwpIHtcbiAgICAgICAgbGV0IHN0ciA9IHRhcmdldEltcGwucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICAgICAgaWYgKHRhcmdldEltcGwuY29sbGVjdGlvbkdyb3VwICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgKz0gJ3xjZzonICsgdGFyZ2V0SW1wbC5jb2xsZWN0aW9uR3JvdXA7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9ICd8ZjonO1xuICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5maWx0ZXJzLm1hcChmID0+IGNhbm9uaWZ5RmlsdGVyKGYpKS5qb2luKCcsJyk7XG4gICAgICAgIHN0ciArPSAnfG9iOic7XG4gICAgICAgIHN0ciArPSB0YXJnZXRJbXBsLm9yZGVyQnkubWFwKG8gPT4gY2Fub25pZnlPcmRlckJ5KG8pKS5qb2luKCcsJyk7XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQodGFyZ2V0SW1wbC5saW1pdCkpIHtcbiAgICAgICAgICAgIHN0ciArPSAnfGw6JztcbiAgICAgICAgICAgIHN0ciArPSB0YXJnZXRJbXBsLmxpbWl0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXRJbXBsLnN0YXJ0QXQpIHtcbiAgICAgICAgICAgIHN0ciArPSAnfGxiOic7XG4gICAgICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5zdGFydEF0LmluY2x1c2l2ZSA/ICdiOicgOiAnYTonO1xuICAgICAgICAgICAgc3RyICs9IHRhcmdldEltcGwuc3RhcnRBdC5wb3NpdGlvbi5tYXAocCA9PiBjYW5vbmljYWxJZChwKSkuam9pbignLCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXRJbXBsLmVuZEF0KSB7XG4gICAgICAgICAgICBzdHIgKz0gJ3x1YjonO1xuICAgICAgICAgICAgc3RyICs9IHRhcmdldEltcGwuZW5kQXQuaW5jbHVzaXZlID8gJ2E6JyA6ICdiOic7XG4gICAgICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5lbmRBdC5wb3NpdGlvbi5tYXAocCA9PiBjYW5vbmljYWxJZChwKSkuam9pbignLCcpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldEltcGwubWVtb2l6ZWRDYW5vbmljYWxJZCA9IHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldEltcGwubWVtb2l6ZWRDYW5vbmljYWxJZDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVRhcmdldCh0YXJnZXQpIHtcbiAgICBsZXQgc3RyID0gdGFyZ2V0LnBhdGguY2Fub25pY2FsU3RyaW5nKCk7XG4gICAgaWYgKHRhcmdldC5jb2xsZWN0aW9uR3JvdXAgIT09IG51bGwpIHtcbiAgICAgICAgc3RyICs9ICcgY29sbGVjdGlvbkdyb3VwPScgKyB0YXJnZXQuY29sbGVjdGlvbkdyb3VwO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LmZpbHRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBzdHIgKz0gYCwgZmlsdGVyczogWyR7dGFyZ2V0LmZpbHRlcnNcbiAgICAgICAgICAgIC5tYXAoZiA9PiBzdHJpbmdpZnlGaWx0ZXIoZikpXG4gICAgICAgICAgICAuam9pbignLCAnKX1dYDtcbiAgICB9XG4gICAgaWYgKCFpc051bGxPclVuZGVmaW5lZCh0YXJnZXQubGltaXQpKSB7XG4gICAgICAgIHN0ciArPSAnLCBsaW1pdDogJyArIHRhcmdldC5saW1pdDtcbiAgICB9XG4gICAgaWYgKHRhcmdldC5vcmRlckJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RyICs9IGAsIG9yZGVyQnk6IFske3RhcmdldC5vcmRlckJ5XG4gICAgICAgICAgICAubWFwKG8gPT4gc3RyaW5naWZ5T3JkZXJCeShvKSlcbiAgICAgICAgICAgIC5qb2luKCcsICcpfV1gO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LnN0YXJ0QXQpIHtcbiAgICAgICAgc3RyICs9ICcsIHN0YXJ0QXQ6ICc7XG4gICAgICAgIHN0ciArPSB0YXJnZXQuc3RhcnRBdC5pbmNsdXNpdmUgPyAnYjonIDogJ2E6JztcbiAgICAgICAgc3RyICs9IHRhcmdldC5zdGFydEF0LnBvc2l0aW9uLm1hcChwID0+IGNhbm9uaWNhbElkKHApKS5qb2luKCcsJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXQuZW5kQXQpIHtcbiAgICAgICAgc3RyICs9ICcsIGVuZEF0OiAnO1xuICAgICAgICBzdHIgKz0gdGFyZ2V0LmVuZEF0LmluY2x1c2l2ZSA/ICdhOicgOiAnYjonO1xuICAgICAgICBzdHIgKz0gdGFyZ2V0LmVuZEF0LnBvc2l0aW9uLm1hcChwID0+IGNhbm9uaWNhbElkKHApKS5qb2luKCcsJyk7XG4gICAgfVxuICAgIHJldHVybiBgVGFyZ2V0KCR7c3RyfSlgO1xufVxuZnVuY3Rpb24gdGFyZ2V0RXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQubGltaXQgIT09IHJpZ2h0LmxpbWl0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxlZnQub3JkZXJCeS5sZW5ndGggIT09IHJpZ2h0Lm9yZGVyQnkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0Lm9yZGVyQnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFvcmRlckJ5RXF1YWxzKGxlZnQub3JkZXJCeVtpXSwgcmlnaHQub3JkZXJCeVtpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVmdC5maWx0ZXJzLmxlbmd0aCAhPT0gcmlnaHQuZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnQuZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWZpbHRlckVxdWFscyhsZWZ0LmZpbHRlcnNbaV0sIHJpZ2h0LmZpbHRlcnNbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlZnQuY29sbGVjdGlvbkdyb3VwICE9PSByaWdodC5jb2xsZWN0aW9uR3JvdXApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWxlZnQucGF0aC5pc0VxdWFsKHJpZ2h0LnBhdGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFib3VuZEVxdWFscyhsZWZ0LnN0YXJ0QXQsIHJpZ2h0LnN0YXJ0QXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kRXF1YWxzKGxlZnQuZW5kQXQsIHJpZ2h0LmVuZEF0KTtcbn1cbmZ1bmN0aW9uIHRhcmdldElzRG9jdW1lbnRUYXJnZXQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIChEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHRhcmdldC5wYXRoKSAmJlxuICAgICAgICB0YXJnZXQuY29sbGVjdGlvbkdyb3VwID09PSBudWxsICYmXG4gICAgICAgIHRhcmdldC5maWx0ZXJzLmxlbmd0aCA9PT0gMCk7XG59XG4vKiogUmV0dXJucyB0aGUgZmllbGQgZmlsdGVycyB0aGF0IHRhcmdldCB0aGUgZ2l2ZW4gZmllbGQgcGF0aC4gKi9cbmZ1bmN0aW9uIHRhcmdldEdldEZpZWxkRmlsdGVyc0ZvclBhdGgodGFyZ2V0LCBwYXRoKSB7XG4gICAgcmV0dXJuIHRhcmdldC5maWx0ZXJzLmZpbHRlcihmID0+IGYgaW5zdGFuY2VvZiBGaWVsZEZpbHRlciAmJiBmLmZpZWxkLmlzRXF1YWwocGF0aCkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZXMgdGhhdCBhcmUgdXNlZCBpbiBBUlJBWV9DT05UQUlOUyBvciBBUlJBWV9DT05UQUlOU19BTllcbiAqIGZpbHRlcnMuIFJldHVybnMgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBzdWNoIGZpbHRlcnMuXG4gKi9cbmZ1bmN0aW9uIHRhcmdldEdldEFycmF5VmFsdWVzKHRhcmdldCwgZmllbGRJbmRleCkge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBmaWVsZEluZGV4R2V0QXJyYXlTZWdtZW50KGZpZWxkSW5kZXgpO1xuICAgIGlmIChzZWdtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmllbGRGaWx0ZXIgb2YgdGFyZ2V0R2V0RmllbGRGaWx0ZXJzRm9yUGF0aCh0YXJnZXQsIHNlZ21lbnQuZmllbGRQYXRoKSkge1xuICAgICAgICBzd2l0Y2ggKGZpZWxkRmlsdGVyLm9wKSB7XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZEZpbHRlci52YWx1ZS5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXTtcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBbZmllbGRGaWx0ZXIudmFsdWVdO1xuICAgICAgICAgICAgLy8gUmVtYWluaW5nIGZpbHRlcnMgYXJlIG5vdCBhcnJheSBmaWx0ZXJzLlxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHZhbHVlcyB0aGF0IGFyZSB1c2VkIGluICE9IG9yIE5PVF9JTiBmaWx0ZXJzLiBSZXR1cm5zXG4gKiBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIHN1Y2ggZmlsdGVycy5cbiAqL1xuZnVuY3Rpb24gdGFyZ2V0R2V0Tm90SW5WYWx1ZXModGFyZ2V0LCBmaWVsZEluZGV4KSB7XG4gICAgY29uc3QgdmFsdWVzID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KSkge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkRmlsdGVyIG9mIHRhcmdldEdldEZpZWxkRmlsdGVyc0ZvclBhdGgodGFyZ2V0LCBzZWdtZW50LmZpZWxkUGF0aCkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRGaWx0ZXIub3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlIGVxdWFsaXR5IHByZWZpeCwgd2hpY2ggaXMgZW5jb2RlZCBpbiB0aGUgaW5kZXggdmFsdWUgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBpbmVxdWFsaXR5IChlLmcuIGBhID09ICdhJyAmJiBiICE9ICdiJ2AgaXMgZW5jb2RlZCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBgdmFsdWUgIT0gJ2FiJ2ApLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuc2V0KHNlZ21lbnQuZmllbGRQYXRoLmNhbm9uaWNhbFN0cmluZygpLCBmaWVsZEZpbHRlci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi86XG4gICAgICAgICAgICAgICAgY2FzZSBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovOlxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RJbi9Ob3RFcXVhbCBpcyBhbHdheXMgYSBzdWZmaXguIFRoZXJlIGNhbm5vdCBiZSBhbnkgcmVtYWluaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlZ21lbnRzIGFuZCBoZW5jZSB3ZSBjYW4gcmV0dXJuIGVhcmx5IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5zZXQoc2VnbWVudC5maWVsZFBhdGguY2Fub25pY2FsU3RyaW5nKCksIGZpZWxkRmlsdGVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWVzLnZhbHVlcygpKTtcbiAgICAgICAgICAgICAgICAvLyBSZW1haW5pbmcgZmlsdGVycyBjYW5ub3QgYmUgdXNlZCBhcyBub3RJbiBib3VuZHMuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFJldHVybnMgYSBsb3dlciBib3VuZCBvZiBmaWVsZCB2YWx1ZXMgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHN0YXJ0aW5nIHBvaW50IHRvXG4gKiBzY2FuIHRoZSBpbmRleCBkZWZpbmVkIGJ5IGBmaWVsZEluZGV4YC4gUmV0dXJucyBgTUlOX1ZBTFVFYCBpZiBubyBsb3dlciBib3VuZFxuICogZXhpc3RzLlxuICovXG5mdW5jdGlvbiB0YXJnZXRHZXRMb3dlckJvdW5kKHRhcmdldCwgZmllbGRJbmRleCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBpbmNsdXNpdmUgPSB0cnVlO1xuICAgIC8vIEZvciBlYWNoIHNlZ21lbnQsIHJldHJpZXZlIGEgbG93ZXIgYm91bmQgaWYgdGhlcmUgaXMgYSBzdWl0YWJsZSBmaWx0ZXIgb3JcbiAgICAvLyBzdGFydEF0LlxuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBmaWVsZEluZGV4R2V0RGlyZWN0aW9uYWxTZWdtZW50cyhmaWVsZEluZGV4KSkge1xuICAgICAgICBjb25zdCBzZWdtZW50Qm91bmQgPSBzZWdtZW50LmtpbmQgPT09IDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqL1xuICAgICAgICAgICAgPyB0YXJnZXRHZXRBc2NlbmRpbmdCb3VuZCh0YXJnZXQsIHNlZ21lbnQuZmllbGRQYXRoLCB0YXJnZXQuc3RhcnRBdClcbiAgICAgICAgICAgIDogdGFyZ2V0R2V0RGVzY2VuZGluZ0JvdW5kKHRhcmdldCwgc2VnbWVudC5maWVsZFBhdGgsIHRhcmdldC5zdGFydEF0KTtcbiAgICAgICAgdmFsdWVzLnB1c2goc2VnbWVudEJvdW5kLnZhbHVlKTtcbiAgICAgICAgaW5jbHVzaXZlICYmIChpbmNsdXNpdmUgPSBzZWdtZW50Qm91bmQuaW5jbHVzaXZlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCb3VuZCh2YWx1ZXMsIGluY2x1c2l2ZSk7XG59XG4vKipcbiAqIFJldHVybnMgYW4gdXBwZXIgYm91bmQgb2YgZmllbGQgdmFsdWVzIHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gZW5kaW5nIHBvaW50XG4gKiB3aGVuIHNjYW5uaW5nIHRoZSBpbmRleCBkZWZpbmVkIGJ5IGBmaWVsZEluZGV4YC4gUmV0dXJucyBgTUFYX1ZBTFVFYCBpZiBub1xuICogdXBwZXIgYm91bmQgZXhpc3RzLlxuICovXG5mdW5jdGlvbiB0YXJnZXRHZXRVcHBlckJvdW5kKHRhcmdldCwgZmllbGRJbmRleCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBpbmNsdXNpdmUgPSB0cnVlO1xuICAgIC8vIEZvciBlYWNoIHNlZ21lbnQsIHJldHJpZXZlIGFuIHVwcGVyIGJvdW5kIGlmIHRoZXJlIGlzIGEgc3VpdGFibGUgZmlsdGVyIG9yXG4gICAgLy8gZW5kQXQuXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIGZpZWxkSW5kZXhHZXREaXJlY3Rpb25hbFNlZ21lbnRzKGZpZWxkSW5kZXgpKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRCb3VuZCA9IHNlZ21lbnQua2luZCA9PT0gMCAvKiBJbmRleEtpbmQuQVNDRU5ESU5HICovXG4gICAgICAgICAgICA/IHRhcmdldEdldERlc2NlbmRpbmdCb3VuZCh0YXJnZXQsIHNlZ21lbnQuZmllbGRQYXRoLCB0YXJnZXQuZW5kQXQpXG4gICAgICAgICAgICA6IHRhcmdldEdldEFzY2VuZGluZ0JvdW5kKHRhcmdldCwgc2VnbWVudC5maWVsZFBhdGgsIHRhcmdldC5lbmRBdCk7XG4gICAgICAgIHZhbHVlcy5wdXNoKHNlZ21lbnRCb3VuZC52YWx1ZSk7XG4gICAgICAgIGluY2x1c2l2ZSAmJiAoaW5jbHVzaXZlID0gc2VnbWVudEJvdW5kLmluY2x1c2l2ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQm91bmQodmFsdWVzLCBpbmNsdXNpdmUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSB0byB1c2UgYXMgdGhlIGxvd2VyIGJvdW5kIGZvciBhc2NlbmRpbmcgaW5kZXggc2VnbWVudCBhdFxuICogdGhlIHByb3ZpZGVkIGBmaWVsZFBhdGhgIChvciB0aGUgdXBwZXIgYm91bmQgZm9yIGFuIGRlc2NlbmRpbmcgc2VnbWVudCkuXG4gKi9cbmZ1bmN0aW9uIHRhcmdldEdldEFzY2VuZGluZ0JvdW5kKHRhcmdldCwgZmllbGRQYXRoLCBib3VuZCkge1xuICAgIGxldCB2YWx1ZSA9IE1JTl9WQUxVRTtcbiAgICBsZXQgaW5jbHVzaXZlID0gdHJ1ZTtcbiAgICAvLyBQcm9jZXNzIGFsbCBmaWx0ZXJzIHRvIGZpbmQgYSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgZmllbGQgc2VnbWVudFxuICAgIGZvciAoY29uc3QgZmllbGRGaWx0ZXIgb2YgdGFyZ2V0R2V0RmllbGRGaWx0ZXJzRm9yUGF0aCh0YXJnZXQsIGZpZWxkUGF0aCkpIHtcbiAgICAgICAgbGV0IGZpbHRlclZhbHVlID0gTUlOX1ZBTFVFO1xuICAgICAgICBsZXQgZmlsdGVySW5jbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZEZpbHRlci5vcCkge1xuICAgICAgICAgICAgY2FzZSBcIjxcIiAvKiBPcGVyYXRvci5MRVNTX1RIQU4gKi86XG4gICAgICAgICAgICBjYXNlIFwiPD1cIiAvKiBPcGVyYXRvci5MRVNTX1RIQU5fT1JfRVFVQUwgKi86XG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSB2YWx1ZXNHZXRMb3dlckJvdW5kKGZpZWxkRmlsdGVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovOlxuICAgICAgICAgICAgY2FzZSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi86XG4gICAgICAgICAgICBjYXNlIFwiPj1cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU5fT1JfRVFVQUwgKi86XG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSBmaWVsZEZpbHRlci52YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI+XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOICovOlxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gZmllbGRGaWx0ZXIudmFsdWU7XG4gICAgICAgICAgICAgICAgZmlsdGVySW5jbHVzaXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi86XG4gICAgICAgICAgICBjYXNlIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovOlxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gTUlOX1ZBTFVFO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gUmVtYWluaW5nIGZpbHRlcnMgY2Fubm90IGJlIHVzZWQgYXMgbG93ZXIgYm91bmRzLlxuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dlckJvdW5kQ29tcGFyZSh7IHZhbHVlLCBpbmNsdXNpdmUgfSwgeyB2YWx1ZTogZmlsdGVyVmFsdWUsIGluY2x1c2l2ZTogZmlsdGVySW5jbHVzaXZlIH0pIDwgMCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmaWx0ZXJWYWx1ZTtcbiAgICAgICAgICAgIGluY2x1c2l2ZSA9IGZpbHRlckluY2x1c2l2ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBhZGRpdGlvbmFsIGJvdW5kLCBjb21wYXJlIHRoZSB2YWx1ZXMgYWdhaW5zdCB0aGUgZXhpc3RpbmdcbiAgICAvLyByYW5nZSB0byBzZWUgaWYgd2UgY2FuIG5hcnJvdyB0aGUgc2NvcGUuXG4gICAgaWYgKGJvdW5kICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0Lm9yZGVyQnkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yZGVyQnkgPSB0YXJnZXQub3JkZXJCeVtpXTtcbiAgICAgICAgICAgIGlmIChvcmRlckJ5LmZpZWxkLmlzRXF1YWwoZmllbGRQYXRoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvclZhbHVlID0gYm91bmQucG9zaXRpb25baV07XG4gICAgICAgICAgICAgICAgaWYgKGxvd2VyQm91bmRDb21wYXJlKHsgdmFsdWUsIGluY2x1c2l2ZSB9LCB7IHZhbHVlOiBjdXJzb3JWYWx1ZSwgaW5jbHVzaXZlOiBib3VuZC5pbmNsdXNpdmUgfSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY3Vyc29yVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSA9IGJvdW5kLmluY2x1c2l2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsdWUsIGluY2x1c2l2ZSB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSB0byB1c2UgYXMgdGhlIHVwcGVyIGJvdW5kIGZvciBhc2NlbmRpbmcgaW5kZXggc2VnbWVudCBhdFxuICogdGhlIHByb3ZpZGVkIGBmaWVsZFBhdGhgIChvciB0aGUgbG93ZXIgYm91bmQgZm9yIGEgZGVzY2VuZGluZyBzZWdtZW50KS5cbiAqL1xuZnVuY3Rpb24gdGFyZ2V0R2V0RGVzY2VuZGluZ0JvdW5kKHRhcmdldCwgZmllbGRQYXRoLCBib3VuZCkge1xuICAgIGxldCB2YWx1ZSA9IE1BWF9WQUxVRTtcbiAgICBsZXQgaW5jbHVzaXZlID0gdHJ1ZTtcbiAgICAvLyBQcm9jZXNzIGFsbCBmaWx0ZXJzIHRvIGZpbmQgYSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgZmllbGQgc2VnbWVudFxuICAgIGZvciAoY29uc3QgZmllbGRGaWx0ZXIgb2YgdGFyZ2V0R2V0RmllbGRGaWx0ZXJzRm9yUGF0aCh0YXJnZXQsIGZpZWxkUGF0aCkpIHtcbiAgICAgICAgbGV0IGZpbHRlclZhbHVlID0gTUFYX1ZBTFVFO1xuICAgICAgICBsZXQgZmlsdGVySW5jbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZEZpbHRlci5vcCkge1xuICAgICAgICAgICAgY2FzZSBcIj49XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOX09SX0VRVUFMICovOlxuICAgICAgICAgICAgY2FzZSBcIj5cIiAvKiBPcGVyYXRvci5HUkVBVEVSX1RIQU4gKi86XG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSB2YWx1ZXNHZXRVcHBlckJvdW5kKGZpZWxkRmlsdGVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJJbmNsdXNpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovOlxuICAgICAgICAgICAgY2FzZSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi86XG4gICAgICAgICAgICBjYXNlIFwiPD1cIiAvKiBPcGVyYXRvci5MRVNTX1RIQU5fT1JfRVFVQUwgKi86XG4gICAgICAgICAgICAgICAgZmlsdGVyVmFsdWUgPSBmaWVsZEZpbHRlci52YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI8XCIgLyogT3BlcmF0b3IuTEVTU19USEFOICovOlxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gZmllbGRGaWx0ZXIudmFsdWU7XG4gICAgICAgICAgICAgICAgZmlsdGVySW5jbHVzaXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi86XG4gICAgICAgICAgICBjYXNlIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovOlxuICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gUmVtYWluaW5nIGZpbHRlcnMgY2Fubm90IGJlIHVzZWQgYXMgdXBwZXIgYm91bmRzLlxuICAgICAgICB9XG4gICAgICAgIGlmICh1cHBlckJvdW5kQ29tcGFyZSh7IHZhbHVlLCBpbmNsdXNpdmUgfSwgeyB2YWx1ZTogZmlsdGVyVmFsdWUsIGluY2x1c2l2ZTogZmlsdGVySW5jbHVzaXZlIH0pID4gMCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmaWx0ZXJWYWx1ZTtcbiAgICAgICAgICAgIGluY2x1c2l2ZSA9IGZpbHRlckluY2x1c2l2ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBhZGRpdGlvbmFsIGJvdW5kLCBjb21wYXJlIHRoZSB2YWx1ZXMgYWdhaW5zdCB0aGUgZXhpc3RpbmdcbiAgICAvLyByYW5nZSB0byBzZWUgaWYgd2UgY2FuIG5hcnJvdyB0aGUgc2NvcGUuXG4gICAgaWYgKGJvdW5kICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0Lm9yZGVyQnkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yZGVyQnkgPSB0YXJnZXQub3JkZXJCeVtpXTtcbiAgICAgICAgICAgIGlmIChvcmRlckJ5LmZpZWxkLmlzRXF1YWwoZmllbGRQYXRoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvclZhbHVlID0gYm91bmQucG9zaXRpb25baV07XG4gICAgICAgICAgICAgICAgaWYgKHVwcGVyQm91bmRDb21wYXJlKHsgdmFsdWUsIGluY2x1c2l2ZSB9LCB7IHZhbHVlOiBjdXJzb3JWYWx1ZSwgaW5jbHVzaXZlOiBib3VuZC5pbmNsdXNpdmUgfSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY3Vyc29yVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSA9IGJvdW5kLmluY2x1c2l2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsdWUsIGluY2x1c2l2ZSB9O1xufVxuLyoqIFJldHVybnMgdGhlIG51bWJlciBvZiBzZWdtZW50cyBvZiBhIHBlcmZlY3QgaW5kZXggZm9yIHRoaXMgdGFyZ2V0LiAqL1xuZnVuY3Rpb24gdGFyZ2V0R2V0U2VnbWVudENvdW50KHRhcmdldCkge1xuICAgIGxldCBmaWVsZHMgPSBuZXcgU29ydGVkU2V0KEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IpO1xuICAgIGxldCBoYXNBcnJheVNlZ21lbnQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiB0YXJnZXQuZmlsdGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YkZpbHRlciBvZiBmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpKSB7XG4gICAgICAgICAgICAvLyBfX25hbWVfXyBpcyBub3QgYW4gZXhwbGljaXQgc2VnbWVudCBvZiBhbnkgaW5kZXgsIHNvIHdlIGRvbid0IG5lZWQgdG9cbiAgICAgICAgICAgIC8vIGNvdW50IGl0LlxuICAgICAgICAgICAgaWYgKHN1YkZpbHRlci5maWVsZC5pc0tleUZpZWxkKCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFSUkFZX0NPTlRBSU5TIG9yIEFSUkFZX0NPTlRBSU5TX0FOWSBmaWx0ZXJzIG11c3QgYmUgY291bnRlZCBzZXBhcmF0ZWx5LlxuICAgICAgICAgICAgLy8gRm9yIGluc3RhbmNlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIGFuIGluZGV4IGZvciBcImEgQVJSQVkgYSBBU0NcIi4gRXZlblxuICAgICAgICAgICAgLy8gdGhvdWdoIHRoZXNlIGFyZSBvbiB0aGUgc2FtZSBmaWVsZCwgdGhleSBzaG91bGQgYmUgY291bnRlZCBhcyB0d29cbiAgICAgICAgICAgIC8vIHNlcGFyYXRlIHNlZ21lbnRzIGluIGFuIGluZGV4LlxuICAgICAgICAgICAgaWYgKHN1YkZpbHRlci5vcCA9PT0gXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovIHx8XG4gICAgICAgICAgICAgICAgc3ViRmlsdGVyLm9wID09PSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLykge1xuICAgICAgICAgICAgICAgIGhhc0FycmF5U2VnbWVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMgPSBmaWVsZHMuYWRkKHN1YkZpbHRlci5maWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHRhcmdldC5vcmRlckJ5KSB7XG4gICAgICAgIC8vIF9fbmFtZV9fIGlzIG5vdCBhbiBleHBsaWNpdCBzZWdtZW50IG9mIGFueSBpbmRleCwgc28gd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAvLyBjb3VudCBpdC5cbiAgICAgICAgaWYgKCFvcmRlckJ5LmZpZWxkLmlzS2V5RmllbGQoKSkge1xuICAgICAgICAgICAgZmllbGRzID0gZmllbGRzLmFkZChvcmRlckJ5LmZpZWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRzLnNpemUgKyAoaGFzQXJyYXlTZWdtZW50ID8gMSA6IDApO1xufVxuZnVuY3Rpb24gdGFyZ2V0SGFzTGltaXQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5saW1pdCAhPT0gbnVsbDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUXVlcnkgZW5jYXBzdWxhdGVzIGFsbCB0aGUgcXVlcnkgYXR0cmlidXRlcyB3ZSBzdXBwb3J0IGluIHRoZSBTREsuIEl0IGNhblxuICogYmUgcnVuIGFnYWluc3QgdGhlIExvY2FsU3RvcmUsIGFzIHdlbGwgYXMgYmUgY29udmVydGVkIHRvIGEgYFRhcmdldGAgdG9cbiAqIHF1ZXJ5IHRoZSBSZW1vdGVTdG9yZSByZXN1bHRzLlxuICpcbiAqIFZpc2libGUgZm9yIHRlc3RpbmcuXG4gKi9cbmNsYXNzIFF1ZXJ5SW1wbCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBRdWVyeSB3aXRoIGEgcGF0aCBhbmQgb3B0aW9uYWwgYWRkaXRpb25hbCBxdWVyeSBjb25zdHJhaW50cy5cbiAgICAgKiBQYXRoIG11c3QgY3VycmVudGx5IGJlIGVtcHR5IGlmIHRoaXMgaXMgYSBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJ5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGNvbGxlY3Rpb25Hcm91cCA9IG51bGwsIGV4cGxpY2l0T3JkZXJCeSA9IFtdLCBmaWx0ZXJzID0gW10sIGxpbWl0ID0gbnVsbCwgbGltaXRUeXBlID0gXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovLCBzdGFydEF0ID0gbnVsbCwgZW5kQXQgPSBudWxsKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbkdyb3VwID0gY29sbGVjdGlvbkdyb3VwO1xuICAgICAgICB0aGlzLmV4cGxpY2l0T3JkZXJCeSA9IGV4cGxpY2l0T3JkZXJCeTtcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgICAgICAgdGhpcy5saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLmxpbWl0VHlwZSA9IGxpbWl0VHlwZTtcbiAgICAgICAgdGhpcy5zdGFydEF0ID0gc3RhcnRBdDtcbiAgICAgICAgdGhpcy5lbmRBdCA9IGVuZEF0O1xuICAgICAgICB0aGlzLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnkgPSBudWxsO1xuICAgICAgICAvLyBUaGUgY29ycmVzcG9uZGluZyBgVGFyZ2V0YCBvZiB0aGlzIGBRdWVyeWAgaW5zdGFuY2UsIGZvciB1c2Ugd2l0aFxuICAgICAgICAvLyBub24tYWdncmVnYXRlIHF1ZXJpZXMuXG4gICAgICAgIHRoaXMubWVtb2l6ZWRUYXJnZXQgPSBudWxsO1xuICAgICAgICAvLyBUaGUgY29ycmVzcG9uZGluZyBgVGFyZ2V0YCBvZiB0aGlzIGBRdWVyeWAgaW5zdGFuY2UsIGZvciB1c2Ugd2l0aFxuICAgICAgICAvLyBhZ2dyZWdhdGUgcXVlcmllcy4gVW5saWtlIHRhcmdldHMgZm9yIG5vbi1hZ2dyZWdhdGUgcXVlcmllcyxcbiAgICAgICAgLy8gYWdncmVnYXRlIHF1ZXJ5IHRhcmdldHMgZG8gbm90IGNvbnRhaW4gbm9ybWFsaXplZCBvcmRlci1ieXMsIHRoZXkgb25seVxuICAgICAgICAvLyBjb250YWluIGV4cGxpY2l0IG9yZGVyLWJ5cy5cbiAgICAgICAgdGhpcy5tZW1vaXplZEFnZ3JlZ2F0ZVRhcmdldCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0QXQpIDtcbiAgICAgICAgaWYgKHRoaXMuZW5kQXQpIDtcbiAgICB9XG59XG4vKiogQ3JlYXRlcyBhIG5ldyBRdWVyeSBpbnN0YW5jZSB3aXRoIHRoZSBvcHRpb25zIHByb3ZpZGVkLiAqL1xuZnVuY3Rpb24gbmV3UXVlcnkocGF0aCwgY29sbGVjdGlvbkdyb3VwLCBleHBsaWNpdE9yZGVyQnksIGZpbHRlcnMsIGxpbWl0LCBsaW1pdFR5cGUsIHN0YXJ0QXQsIGVuZEF0KSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocGF0aCwgY29sbGVjdGlvbkdyb3VwLCBleHBsaWNpdE9yZGVyQnksIGZpbHRlcnMsIGxpbWl0LCBsaW1pdFR5cGUsIHN0YXJ0QXQsIGVuZEF0KTtcbn1cbi8qKiBDcmVhdGVzIGEgbmV3IFF1ZXJ5IGZvciBhIHF1ZXJ5IHRoYXQgbWF0Y2hlcyBhbGwgZG9jdW1lbnRzIGF0IGBwYXRoYCAqL1xuZnVuY3Rpb24gbmV3UXVlcnlGb3JQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChwYXRoKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGNvbnZlcnQgYSBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJ5IGludG8gYSBjb2xsZWN0aW9uIHF1ZXJ5IGF0IGFcbiAqIHNwZWNpZmljIHBhdGguIFRoaXMgaXMgdXNlZCB3aGVuIGV4ZWN1dGluZyBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJpZXMsIHNpbmNlXG4gKiB3ZSBoYXZlIHRvIHNwbGl0IHRoZSBxdWVyeSBpbnRvIGEgc2V0IG9mIGNvbGxlY3Rpb24gcXVlcmllcyBhdCBtdWx0aXBsZVxuICogcGF0aHMuXG4gKi9cbmZ1bmN0aW9uIGFzQ29sbGVjdGlvblF1ZXJ5QXRQYXRoKHF1ZXJ5LCBwYXRoKSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocGF0aCwgXG4gICAgLypjb2xsZWN0aW9uR3JvdXA9Ki8gbnVsbCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5LnNsaWNlKCksIHF1ZXJ5LmZpbHRlcnMuc2xpY2UoKSwgcXVlcnkubGltaXQsIHF1ZXJ5LmxpbWl0VHlwZSwgcXVlcnkuc3RhcnRBdCwgcXVlcnkuZW5kQXQpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBxdWVyeSBkb2VzIG5vdCBzcGVjaWZ5IGFueSBxdWVyeSBjb25zdHJhaW50cyB0aGF0XG4gKiBjb3VsZCByZW1vdmUgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gcXVlcnlNYXRjaGVzQWxsRG9jdW1lbnRzKHF1ZXJ5KSB7XG4gICAgcmV0dXJuIChxdWVyeS5maWx0ZXJzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICBxdWVyeS5saW1pdCA9PT0gbnVsbCAmJlxuICAgICAgICBxdWVyeS5zdGFydEF0ID09IG51bGwgJiZcbiAgICAgICAgcXVlcnkuZW5kQXQgPT0gbnVsbCAmJlxuICAgICAgICAocXVlcnkuZXhwbGljaXRPcmRlckJ5Lmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgKHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICBxdWVyeS5leHBsaWNpdE9yZGVyQnlbMF0uZmllbGQuaXNLZXlGaWVsZCgpKSkpO1xufVxuLy8gUmV0dXJucyB0aGUgc29ydGVkIHNldCBvZiBpbmVxdWFsaXR5IGZpbHRlciBmaWVsZHMgdXNlZCBpbiB0aGlzIHF1ZXJ5LlxuZnVuY3Rpb24gZ2V0SW5lcXVhbGl0eUZpbHRlckZpZWxkcyhxdWVyeSkge1xuICAgIGxldCByZXN1bHQgPSBuZXcgU29ydGVkU2V0KEZpZWxkUGF0aCQxLmNvbXBhcmF0b3IpO1xuICAgIHF1ZXJ5LmZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YkZpbHRlcnMgPSBmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpO1xuICAgICAgICBzdWJGaWx0ZXJzLmZvckVhY2goKGZpbHRlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGZpbHRlci5pc0luZXF1YWxpdHkoKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZmlsdGVyLmZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBRdWVyeSBmb3IgYSBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJ5IHRoYXQgbWF0Y2hlcyBhbGwgZG9jdW1lbnRzXG4gKiB3aXRoaW4gdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb24gZ3JvdXAuXG4gKi9cbmZ1bmN0aW9uIG5ld1F1ZXJ5Rm9yQ29sbGVjdGlvbkdyb3VwKGNvbGxlY3Rpb25JZCkge1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKFJlc291cmNlUGF0aC5lbXB0eVBhdGgoKSwgY29sbGVjdGlvbklkKTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBxdWVyeSBtYXRjaGVzIGEgc2luZ2xlIGRvY3VtZW50IGJ5IHBhdGggKHJhdGhlciB0aGFuIGFcbiAqIGNvbGxlY3Rpb24pLlxuICovXG5mdW5jdGlvbiBpc0RvY3VtZW50UXVlcnkkMShxdWVyeSkge1xuICAgIHJldHVybiAoRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShxdWVyeS5wYXRoKSAmJlxuICAgICAgICBxdWVyeS5jb2xsZWN0aW9uR3JvdXAgPT09IG51bGwgJiZcbiAgICAgICAgcXVlcnkuZmlsdGVycy5sZW5ndGggPT09IDApO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHF1ZXJ5IG1hdGNoZXMgYSBjb2xsZWN0aW9uIGdyb3VwIHJhdGhlciB0aGFuIGEgc3BlY2lmaWNcbiAqIGNvbGxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGlzQ29sbGVjdGlvbkdyb3VwUXVlcnkocXVlcnkpIHtcbiAgICByZXR1cm4gcXVlcnkuY29sbGVjdGlvbkdyb3VwICE9PSBudWxsO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBub3JtYWxpemVkIG9yZGVyLWJ5IGNvbnN0cmFpbnQgdGhhdCBpcyB1c2VkIHRvIGV4ZWN1dGUgdGhlIFF1ZXJ5LFxuICogd2hpY2ggY2FuIGJlIGRpZmZlcmVudCBmcm9tIHRoZSBvcmRlci1ieSBjb25zdHJhaW50cyB0aGUgdXNlciBwcm92aWRlZCAoZS5nLlxuICogdGhlIFNESyBhbmQgYmFja2VuZCBhbHdheXMgb3JkZXJzIGJ5IGBfX25hbWVfX2ApLiBUaGUgbm9ybWFsaXplZCBvcmRlci1ieVxuICogaW5jbHVkZXMgaW1wbGljaXQgb3JkZXItYnlzIGluIGFkZGl0aW9uIHRvIHRoZSBleHBsaWNpdCB1c2VyIHByb3ZpZGVkXG4gKiBvcmRlci1ieXMuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpIHtcbiAgICBjb25zdCBxdWVyeUltcGwgPSBkZWJ1Z0Nhc3QocXVlcnkpO1xuICAgIGlmIChxdWVyeUltcGwubWVtb2l6ZWROb3JtYWxpemVkT3JkZXJCeSA9PT0gbnVsbCkge1xuICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWROb3JtYWxpemVkT3JkZXJCeSA9IFtdO1xuICAgICAgICBjb25zdCBmaWVsZHNOb3JtYWxpemVkID0gbmV3IFNldCgpO1xuICAgICAgICAvLyBBbnkgZXhwbGljaXQgb3JkZXIgYnkgZmllbGRzIHNob3VsZCBiZSBhZGRlZCBhcyBpcy5cbiAgICAgICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHF1ZXJ5SW1wbC5leHBsaWNpdE9yZGVyQnkpIHtcbiAgICAgICAgICAgIHF1ZXJ5SW1wbC5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5LnB1c2gob3JkZXJCeSk7XG4gICAgICAgICAgICBmaWVsZHNOb3JtYWxpemVkLmFkZChvcmRlckJ5LmZpZWxkLmNhbm9uaWNhbFN0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgb3JkZXIgb2YgdGhlIGltcGxpY2l0IG9yZGVyaW5nIGFsd2F5cyBtYXRjaGVzIHRoZSBsYXN0IGV4cGxpY2l0IG9yZGVyIGJ5LlxuICAgICAgICBjb25zdCBsYXN0RGlyZWN0aW9uID0gcXVlcnlJbXBsLmV4cGxpY2l0T3JkZXJCeS5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IHF1ZXJ5SW1wbC5leHBsaWNpdE9yZGVyQnlbcXVlcnlJbXBsLmV4cGxpY2l0T3JkZXJCeS5sZW5ndGggLSAxXS5kaXJcbiAgICAgICAgICAgIDogXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovO1xuICAgICAgICAvLyBBbnkgaW5lcXVhbGl0eSBmaWVsZHMgbm90IGV4cGxpY2l0bHkgb3JkZXJlZCBzaG91bGQgYmUgaW1wbGljaXRseSBvcmRlcmVkIGluIGEgbGV4aWNvZ3JhcGhpY2FsXG4gICAgICAgIC8vIG9yZGVyLiBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBpbmVxdWFsaXR5IGZpbHRlcnMgb24gdGhlIHNhbWUgZmllbGQsIHRoZSBmaWVsZCBzaG91bGQgYmUgYWRkZWRcbiAgICAgICAgLy8gb25seSBvbmNlLlxuICAgICAgICAvLyBOb3RlOiBgU29ydGVkU2V0PEZpZWxkUGF0aD5gIHNvcnRzIHRoZSBrZXkgZmllbGQgYmVmb3JlIG90aGVyIGZpZWxkcy4gSG93ZXZlciwgd2Ugd2FudCB0aGUga2V5XG4gICAgICAgIC8vIGZpZWxkIHRvIGJlIHNvcnRlZCBsYXN0LlxuICAgICAgICBjb25zdCBpbmVxdWFsaXR5RmllbGRzID0gZ2V0SW5lcXVhbGl0eUZpbHRlckZpZWxkcyhxdWVyeUltcGwpO1xuICAgICAgICBpbmVxdWFsaXR5RmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgaWYgKCFmaWVsZHNOb3JtYWxpemVkLmhhcyhmaWVsZC5jYW5vbmljYWxTdHJpbmcoKSkgJiZcbiAgICAgICAgICAgICAgICAhZmllbGQuaXNLZXlGaWVsZCgpKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlJbXBsLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnkucHVzaChuZXcgT3JkZXJCeShmaWVsZCwgbGFzdERpcmVjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWRkIHRoZSBkb2N1bWVudCBrZXkgZmllbGQgdG8gdGhlIGxhc3QgaWYgaXQgaXMgbm90IGV4cGxpY2l0bHkgb3JkZXJlZC5cbiAgICAgICAgaWYgKCFmaWVsZHNOb3JtYWxpemVkLmhhcyhGaWVsZFBhdGgkMS5rZXlGaWVsZCgpLmNhbm9uaWNhbFN0cmluZygpKSkge1xuICAgICAgICAgICAgcXVlcnlJbXBsLm1lbW9pemVkTm9ybWFsaXplZE9yZGVyQnkucHVzaChuZXcgT3JkZXJCeShGaWVsZFBhdGgkMS5rZXlGaWVsZCgpLCBsYXN0RGlyZWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5SW1wbC5tZW1vaXplZE5vcm1hbGl6ZWRPcmRlckJ5O1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGBRdWVyeWAgaW5zdGFuY2UgdG8gaXRzIGNvcnJlc3BvbmRpbmcgYFRhcmdldGAgcmVwcmVzZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5VG9UYXJnZXQocXVlcnkpIHtcbiAgICBjb25zdCBxdWVyeUltcGwgPSBkZWJ1Z0Nhc3QocXVlcnkpO1xuICAgIGlmICghcXVlcnlJbXBsLm1lbW9pemVkVGFyZ2V0KSB7XG4gICAgICAgIHF1ZXJ5SW1wbC5tZW1vaXplZFRhcmdldCA9IF9xdWVyeVRvVGFyZ2V0KHF1ZXJ5SW1wbCwgcXVlcnlOb3JtYWxpemVkT3JkZXJCeShxdWVyeSkpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnlJbXBsLm1lbW9pemVkVGFyZ2V0O1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGBRdWVyeWAgaW5zdGFuY2UgdG8gaXRzIGNvcnJlc3BvbmRpbmcgYFRhcmdldGAgcmVwcmVzZW50YXRpb24sXG4gKiBmb3IgdXNlIHdpdGhpbiBhbiBhZ2dyZWdhdGUgcXVlcnkuIFVubGlrZSB0YXJnZXRzIGZvciBub24tYWdncmVnYXRlIHF1ZXJpZXMsXG4gKiBhZ2dyZWdhdGUgcXVlcnkgdGFyZ2V0cyBkbyBub3QgY29udGFpbiBub3JtYWxpemVkIG9yZGVyLWJ5cywgdGhleSBvbmx5XG4gKiBjb250YWluIGV4cGxpY2l0IG9yZGVyLWJ5cy5cbiAqL1xuZnVuY3Rpb24gcXVlcnlUb0FnZ3JlZ2F0ZVRhcmdldChxdWVyeSkge1xuICAgIGNvbnN0IHF1ZXJ5SW1wbCA9IGRlYnVnQ2FzdChxdWVyeSk7XG4gICAgaWYgKCFxdWVyeUltcGwubWVtb2l6ZWRBZ2dyZWdhdGVUYXJnZXQpIHtcbiAgICAgICAgLy8gRG8gbm90IGluY2x1ZGUgaW1wbGljaXQgb3JkZXItYnlzIGZvciBhZ2dyZWdhdGUgcXVlcmllcy5cbiAgICAgICAgcXVlcnlJbXBsLm1lbW9pemVkQWdncmVnYXRlVGFyZ2V0ID0gX3F1ZXJ5VG9UYXJnZXQocXVlcnlJbXBsLCBxdWVyeS5leHBsaWNpdE9yZGVyQnkpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnlJbXBsLm1lbW9pemVkQWdncmVnYXRlVGFyZ2V0O1xufVxuZnVuY3Rpb24gX3F1ZXJ5VG9UYXJnZXQocXVlcnlJbXBsLCBvcmRlckJ5cykge1xuICAgIGlmIChxdWVyeUltcGwubGltaXRUeXBlID09PSBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8pIHtcbiAgICAgICAgcmV0dXJuIG5ld1RhcmdldChxdWVyeUltcGwucGF0aCwgcXVlcnlJbXBsLmNvbGxlY3Rpb25Hcm91cCwgb3JkZXJCeXMsIHF1ZXJ5SW1wbC5maWx0ZXJzLCBxdWVyeUltcGwubGltaXQsIHF1ZXJ5SW1wbC5zdGFydEF0LCBxdWVyeUltcGwuZW5kQXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gRmxpcCB0aGUgb3JkZXJCeSBkaXJlY3Rpb25zIHNpbmNlIHdlIHdhbnQgdGhlIGxhc3QgcmVzdWx0c1xuICAgICAgICBvcmRlckJ5cyA9IG9yZGVyQnlzLm1hcChvcmRlckJ5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IG9yZGVyQnkuZGlyID09PSBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqL1xuICAgICAgICAgICAgICAgID8gXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovXG4gICAgICAgICAgICAgICAgOiBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqLztcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3JkZXJCeShvcmRlckJ5LmZpZWxkLCBkaXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBzd2FwIHRoZSBjdXJzb3JzIHRvIG1hdGNoIHRoZSBub3ctZmxpcHBlZCBxdWVyeSBvcmRlcmluZy5cbiAgICAgICAgY29uc3Qgc3RhcnRBdCA9IHF1ZXJ5SW1wbC5lbmRBdFxuICAgICAgICAgICAgPyBuZXcgQm91bmQocXVlcnlJbXBsLmVuZEF0LnBvc2l0aW9uLCBxdWVyeUltcGwuZW5kQXQuaW5jbHVzaXZlKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjb25zdCBlbmRBdCA9IHF1ZXJ5SW1wbC5zdGFydEF0XG4gICAgICAgICAgICA/IG5ldyBCb3VuZChxdWVyeUltcGwuc3RhcnRBdC5wb3NpdGlvbiwgcXVlcnlJbXBsLnN0YXJ0QXQuaW5jbHVzaXZlKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAvLyBOb3cgcmV0dXJuIGFzIGEgTGltaXRUeXBlLkZpcnN0IHF1ZXJ5LlxuICAgICAgICByZXR1cm4gbmV3VGFyZ2V0KHF1ZXJ5SW1wbC5wYXRoLCBxdWVyeUltcGwuY29sbGVjdGlvbkdyb3VwLCBvcmRlckJ5cywgcXVlcnlJbXBsLmZpbHRlcnMsIHF1ZXJ5SW1wbC5saW1pdCwgc3RhcnRBdCwgZW5kQXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHF1ZXJ5V2l0aEFkZGVkRmlsdGVyKHF1ZXJ5LCBmaWx0ZXIpIHtcbiAgICBjb25zdCBuZXdGaWx0ZXJzID0gcXVlcnkuZmlsdGVycy5jb25jYXQoW2ZpbHRlcl0pO1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5LnBhdGgsIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5LnNsaWNlKCksIG5ld0ZpbHRlcnMsIHF1ZXJ5LmxpbWl0LCBxdWVyeS5saW1pdFR5cGUsIHF1ZXJ5LnN0YXJ0QXQsIHF1ZXJ5LmVuZEF0KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5V2l0aEFkZGVkT3JkZXJCeShxdWVyeSwgb3JkZXJCeSkge1xuICAgIC8vIFRPRE8oZGltb25kKTogdmFsaWRhdGUgdGhhdCBvcmRlckJ5IGRvZXMgbm90IGxpc3QgdGhlIHNhbWUga2V5IHR3aWNlLlxuICAgIGNvbnN0IG5ld09yZGVyQnkgPSBxdWVyeS5leHBsaWNpdE9yZGVyQnkuY29uY2F0KFtvcmRlckJ5XSk7XG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkucGF0aCwgcXVlcnkuY29sbGVjdGlvbkdyb3VwLCBuZXdPcmRlckJ5LCBxdWVyeS5maWx0ZXJzLnNsaWNlKCksIHF1ZXJ5LmxpbWl0LCBxdWVyeS5saW1pdFR5cGUsIHF1ZXJ5LnN0YXJ0QXQsIHF1ZXJ5LmVuZEF0KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5V2l0aExpbWl0KHF1ZXJ5LCBsaW1pdCwgbGltaXRUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkucGF0aCwgcXVlcnkuY29sbGVjdGlvbkdyb3VwLCBxdWVyeS5leHBsaWNpdE9yZGVyQnkuc2xpY2UoKSwgcXVlcnkuZmlsdGVycy5zbGljZSgpLCBsaW1pdCwgbGltaXRUeXBlLCBxdWVyeS5zdGFydEF0LCBxdWVyeS5lbmRBdCk7XG59XG5mdW5jdGlvbiBxdWVyeVdpdGhTdGFydEF0KHF1ZXJ5LCBib3VuZCkge1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5LnBhdGgsIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5LnNsaWNlKCksIHF1ZXJ5LmZpbHRlcnMuc2xpY2UoKSwgcXVlcnkubGltaXQsIHF1ZXJ5LmxpbWl0VHlwZSwgYm91bmQsIHF1ZXJ5LmVuZEF0KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5V2l0aEVuZEF0KHF1ZXJ5LCBib3VuZCkge1xuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5LnBhdGgsIHF1ZXJ5LmNvbGxlY3Rpb25Hcm91cCwgcXVlcnkuZXhwbGljaXRPcmRlckJ5LnNsaWNlKCksIHF1ZXJ5LmZpbHRlcnMuc2xpY2UoKSwgcXVlcnkubGltaXQsIHF1ZXJ5LmxpbWl0VHlwZSwgcXVlcnkuc3RhcnRBdCwgYm91bmQpO1xufVxuZnVuY3Rpb24gcXVlcnlFcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gKHRhcmdldEVxdWFscyhxdWVyeVRvVGFyZ2V0KGxlZnQpLCBxdWVyeVRvVGFyZ2V0KHJpZ2h0KSkgJiZcbiAgICAgICAgbGVmdC5saW1pdFR5cGUgPT09IHJpZ2h0LmxpbWl0VHlwZSk7XG59XG4vLyBUT0RPKGIvMjkxODMxNjUpOiBUaGlzIGlzIHVzZWQgdG8gZ2V0IGEgdW5pcXVlIHN0cmluZyBmcm9tIGEgcXVlcnkgdG8sIGZvclxuLy8gZXhhbXBsZSwgdXNlIGFzIGEgZGljdGlvbmFyeSBrZXksIGJ1dCB0aGUgaW1wbGVtZW50YXRpb24gaXMgc3ViamVjdCB0b1xuLy8gY29sbGlzaW9ucy4gTWFrZSBpdCBjb2xsaXNpb24tZnJlZS5cbmZ1bmN0aW9uIGNhbm9uaWZ5UXVlcnkocXVlcnkpIHtcbiAgICByZXR1cm4gYCR7Y2Fub25pZnlUYXJnZXQocXVlcnlUb1RhcmdldChxdWVyeSkpfXxsdDoke3F1ZXJ5LmxpbWl0VHlwZX1gO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5UXVlcnkocXVlcnkpIHtcbiAgICByZXR1cm4gYFF1ZXJ5KHRhcmdldD0ke3N0cmluZ2lmeVRhcmdldChxdWVyeVRvVGFyZ2V0KHF1ZXJ5KSl9OyBsaW1pdFR5cGU9JHtxdWVyeS5saW1pdFR5cGV9KWA7XG59XG4vKiogUmV0dXJucyB3aGV0aGVyIGBkb2NgIG1hdGNoZXMgdGhlIGNvbnN0cmFpbnRzIG9mIGBxdWVyeWAuICovXG5mdW5jdGlvbiBxdWVyeU1hdGNoZXMocXVlcnksIGRvYykge1xuICAgIHJldHVybiAoZG9jLmlzRm91bmREb2N1bWVudCgpICYmXG4gICAgICAgIHF1ZXJ5TWF0Y2hlc1BhdGhBbmRDb2xsZWN0aW9uR3JvdXAocXVlcnksIGRvYykgJiZcbiAgICAgICAgcXVlcnlNYXRjaGVzT3JkZXJCeShxdWVyeSwgZG9jKSAmJlxuICAgICAgICBxdWVyeU1hdGNoZXNGaWx0ZXJzKHF1ZXJ5LCBkb2MpICYmXG4gICAgICAgIHF1ZXJ5TWF0Y2hlc0JvdW5kcyhxdWVyeSwgZG9jKSk7XG59XG5mdW5jdGlvbiBxdWVyeU1hdGNoZXNQYXRoQW5kQ29sbGVjdGlvbkdyb3VwKHF1ZXJ5LCBkb2MpIHtcbiAgICBjb25zdCBkb2NQYXRoID0gZG9jLmtleS5wYXRoO1xuICAgIGlmIChxdWVyeS5jb2xsZWN0aW9uR3JvdXAgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTk9URTogdGhpcy5wYXRoIGlzIGN1cnJlbnRseSBhbHdheXMgZW1wdHkgc2luY2Ugd2UgZG9uJ3QgZXhwb3NlIENvbGxlY3Rpb25cbiAgICAgICAgLy8gR3JvdXAgcXVlcmllcyByb290ZWQgYXQgYSBkb2N1bWVudCBwYXRoIHlldC5cbiAgICAgICAgcmV0dXJuIChkb2Mua2V5Lmhhc0NvbGxlY3Rpb25JZChxdWVyeS5jb2xsZWN0aW9uR3JvdXApICYmXG4gICAgICAgICAgICBxdWVyeS5wYXRoLmlzUHJlZml4T2YoZG9jUGF0aCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHF1ZXJ5LnBhdGgpKSB7XG4gICAgICAgIC8vIGV4YWN0IG1hdGNoIGZvciBkb2N1bWVudCBxdWVyaWVzXG4gICAgICAgIHJldHVybiBxdWVyeS5wYXRoLmlzRXF1YWwoZG9jUGF0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBzaGFsbG93IGFuY2VzdG9yIHF1ZXJpZXMgYnkgZGVmYXVsdFxuICAgICAgICByZXR1cm4gcXVlcnkucGF0aC5pc0ltbWVkaWF0ZVBhcmVudE9mKGRvY1BhdGgpO1xuICAgIH1cbn1cbi8qKlxuICogQSBkb2N1bWVudCBtdXN0IGhhdmUgYSB2YWx1ZSBmb3IgZXZlcnkgb3JkZXJpbmcgY2xhdXNlIGluIG9yZGVyIHRvIHNob3cgdXBcbiAqIGluIHRoZSByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBxdWVyeU1hdGNoZXNPcmRlckJ5KHF1ZXJ5LCBkb2MpIHtcbiAgICAvLyBXZSBtdXN0IHVzZSBgcXVlcnlOb3JtYWxpemVkT3JkZXJCeSgpYCB0byBnZXQgdGhlIGxpc3Qgb2YgYWxsIG9yZGVyQnlzIChib3RoIGltcGxpY2l0IGFuZCBleHBsaWNpdCkuXG4gICAgLy8gTm90ZSB0aGF0IGZvciBPUiBxdWVyaWVzLCBvcmRlckJ5IGFwcGxpZXMgdG8gYWxsIGRpc2p1bmN0aW9uIHRlcm1zIGFuZCBpbXBsaWNpdCBvcmRlckJ5cyBtdXN0XG4gICAgLy8gYmUgdGFrZW4gaW50byBhY2NvdW50LiBGb3IgZXhhbXBsZSwgdGhlIHF1ZXJ5IFwiYSA+IDEgfHwgYj09MVwiIGhhcyBhbiBpbXBsaWNpdCBcIm9yZGVyQnkgYVwiIGR1ZVxuICAgIC8vIHRvIHRoZSBpbmVxdWFsaXR5LCBhbmQgaXMgZXZhbHVhdGVkIGFzIFwiYSA+IDEgb3JkZXJCeSBhIHx8IGI9PTEgb3JkZXJCeSBhXCIuXG4gICAgLy8gQSBkb2N1bWVudCB3aXRoIGNvbnRlbnQgb2Yge2I6MX0gbWF0Y2hlcyB0aGUgZmlsdGVycywgYnV0IGRvZXMgbm90IG1hdGNoIHRoZSBvcmRlckJ5IGJlY2F1c2VcbiAgICAvLyBpdCdzIG1pc3NpbmcgdGhlIGZpZWxkICdhJy5cbiAgICBmb3IgKGNvbnN0IG9yZGVyQnkgb2YgcXVlcnlOb3JtYWxpemVkT3JkZXJCeShxdWVyeSkpIHtcbiAgICAgICAgLy8gb3JkZXItYnkga2V5IGFsd2F5cyBtYXRjaGVzXG4gICAgICAgIGlmICghb3JkZXJCeS5maWVsZC5pc0tleUZpZWxkKCkgJiYgZG9jLmRhdGEuZmllbGQob3JkZXJCeS5maWVsZCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5TWF0Y2hlc0ZpbHRlcnMocXVlcnksIGRvYykge1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHF1ZXJ5LmZpbHRlcnMpIHtcbiAgICAgICAgaWYgKCFmaWx0ZXIubWF0Y2hlcyhkb2MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKiogTWFrZXMgc3VyZSBhIGRvY3VtZW50IGlzIHdpdGhpbiB0aGUgYm91bmRzLCBpZiBwcm92aWRlZC4gKi9cbmZ1bmN0aW9uIHF1ZXJ5TWF0Y2hlc0JvdW5kcyhxdWVyeSwgZG9jKSB7XG4gICAgaWYgKHF1ZXJ5LnN0YXJ0QXQgJiZcbiAgICAgICAgIWJvdW5kU29ydHNCZWZvcmVEb2N1bWVudChxdWVyeS5zdGFydEF0LCBxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5KHF1ZXJ5KSwgZG9jKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChxdWVyeS5lbmRBdCAmJlxuICAgICAgICAhYm91bmRTb3J0c0FmdGVyRG9jdW1lbnQocXVlcnkuZW5kQXQsIHF1ZXJ5Tm9ybWFsaXplZE9yZGVyQnkocXVlcnkpLCBkb2MpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGNvbGxlY3Rpb24gZ3JvdXAgdGhhdCB0aGlzIHF1ZXJ5IHRhcmdldHMuXG4gKlxuICogUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBpbiB0aGUgV2ViIFNESyB0byBmYWNpbGl0YXRlIG11bHRpLXRhYlxuICogc3luY2hyb25pemF0aW9uIGZvciBxdWVyeSByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBxdWVyeUNvbGxlY3Rpb25Hcm91cChxdWVyeSkge1xuICAgIHJldHVybiAocXVlcnkuY29sbGVjdGlvbkdyb3VwIHx8XG4gICAgICAgIChxdWVyeS5wYXRoLmxlbmd0aCAlIDIgPT09IDFcbiAgICAgICAgICAgID8gcXVlcnkucGF0aC5sYXN0U2VnbWVudCgpXG4gICAgICAgICAgICA6IHF1ZXJ5LnBhdGguZ2V0KHF1ZXJ5LnBhdGgubGVuZ3RoIC0gMikpKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIG5ldyBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29tcGFyZSB0d28gZG9jdW1lbnRzXG4gKiBiYXNlZCBvbiB0aGUgUXVlcnkncyBvcmRlcmluZyBjb25zdHJhaW50LlxuICovXG5mdW5jdGlvbiBuZXdRdWVyeUNvbXBhcmF0b3IocXVlcnkpIHtcbiAgICByZXR1cm4gKGQxLCBkMikgPT4ge1xuICAgICAgICBsZXQgY29tcGFyZWRPbktleUZpZWxkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3Qgb3JkZXJCeSBvZiBxdWVyeU5vcm1hbGl6ZWRPcmRlckJ5KHF1ZXJ5KSkge1xuICAgICAgICAgICAgY29uc3QgY29tcCA9IGNvbXBhcmVEb2NzKG9yZGVyQnksIGQxLCBkMik7XG4gICAgICAgICAgICBpZiAoY29tcCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcGFyZWRPbktleUZpZWxkID0gY29tcGFyZWRPbktleUZpZWxkIHx8IG9yZGVyQnkuZmllbGQuaXNLZXlGaWVsZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG59XG5mdW5jdGlvbiBjb21wYXJlRG9jcyhvcmRlckJ5LCBkMSwgZDIpIHtcbiAgICBjb25zdCBjb21wYXJpc29uID0gb3JkZXJCeS5maWVsZC5pc0tleUZpZWxkKClcbiAgICAgICAgPyBEb2N1bWVudEtleS5jb21wYXJhdG9yKGQxLmtleSwgZDIua2V5KVxuICAgICAgICA6IGNvbXBhcmVEb2N1bWVudHNCeUZpZWxkKG9yZGVyQnkuZmllbGQsIGQxLCBkMik7XG4gICAgc3dpdGNoIChvcmRlckJ5LmRpcikge1xuICAgICAgICBjYXNlIFwiYXNjXCIgLyogRGlyZWN0aW9uLkFTQ0VORElORyAqLzpcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uO1xuICAgICAgICBjYXNlIFwiZGVzY1wiIC8qIERpcmVjdGlvbi5ERVNDRU5ESU5HICovOlxuICAgICAgICAgICAgcmV0dXJuIC0xICogY29tcGFyaXNvbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIG1hcCBpbXBsZW1lbnRhdGlvbiB0aGF0IHVzZXMgb2JqZWN0cyBhcyBrZXlzLiBPYmplY3RzIG11c3QgaGF2ZSBhblxuICogYXNzb2NpYXRlZCBlcXVhbHMgZnVuY3Rpb24gYW5kIG11c3QgYmUgaW1tdXRhYmxlLiBFbnRyaWVzIGluIHRoZSBtYXAgYXJlXG4gKiBzdG9yZWQgdG9nZXRoZXIgd2l0aCB0aGUga2V5IGJlaW5nIHByb2R1Y2VkIGZyb20gdGhlIG1hcEtleUZuLiBUaGlzIG1hcFxuICogYXV0b21hdGljYWxseSBoYW5kbGVzIGNvbGxpc2lvbnMgb2Yga2V5cy5cbiAqL1xuY2xhc3MgT2JqZWN0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihtYXBLZXlGbiwgZXF1YWxzRm4pIHtcbiAgICAgICAgdGhpcy5tYXBLZXlGbiA9IG1hcEtleUZuO1xuICAgICAgICB0aGlzLmVxdWFsc0ZuID0gZXF1YWxzRm47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5uZXIgbWFwIGZvciBhIGtleS92YWx1ZSBwYWlyLiBEdWUgdG8gdGhlIHBvc3NpYmlsaXR5IG9mIGNvbGxpc2lvbnMgd2VcbiAgICAgICAgICoga2VlcCBhIGxpc3Qgb2YgZW50cmllcyB0aGF0IHdlIGRvIGEgbGluZWFyIHNlYXJjaCB0aHJvdWdoIHRvIGZpbmQgYW4gYWN0dWFsXG4gICAgICAgICAqIG1hdGNoLiBOb3RlIHRoYXQgY29sbGlzaW9ucyBzaG91bGQgYmUgcmFyZSwgc28gd2Ugc3RpbGwgZXhwZWN0IG5lYXJcbiAgICAgICAgICogY29uc3RhbnQgdGltZSBsb29rdXBzIGluIHByYWN0aWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbm5lciA9IHt9O1xuICAgICAgICAvKiogVGhlIG51bWJlciBvZiBlbnRyaWVzIHN0b3JlZCBpbiB0aGUgbWFwICovXG4gICAgICAgIHRoaXMuaW5uZXJTaXplID0gMDtcbiAgICB9XG4gICAgLyoqIEdldCBhIHZhbHVlIGZvciB0aGlzIGtleSwgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXMgbm90IGV4aXN0LiAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLm1hcEtleUZuKGtleSk7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLmlubmVyW2lkXTtcbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtvdGhlcktleSwgdmFsdWVdIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0ZuKG90aGVyS2V5LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSkgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqIFB1dCB0aGlzIGtleSBhbmQgdmFsdWUgaW4gdGhlIG1hcC4gKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMubWFwS2V5Rm4oa2V5KTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuaW5uZXJbaWRdO1xuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyW2lkXSA9IFtba2V5LCB2YWx1ZV1dO1xuICAgICAgICAgICAgdGhpcy5pbm5lclNpemUrKztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0ZuKG1hdGNoZXNbaV1bMF0sIGtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHVwZGF0aW5nIGFuIGV4aXN0aW5nIGVudHJ5IGFuZCBkb2VzIG5vdCBpbmNyZWFzZSBgaW5uZXJTaXplYC5cbiAgICAgICAgICAgICAgICBtYXRjaGVzW2ldID0gW2tleSwgdmFsdWVdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXRjaGVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgdGhpcy5pbm5lclNpemUrKztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoaXMga2V5IGZyb20gdGhlIG1hcC4gUmV0dXJucyBhIGJvb2xlYW4gaWYgYW55dGhpbmcgd2FzIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMubWFwS2V5Rm4oa2V5KTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuaW5uZXJbaWRdO1xuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHNGbihtYXRjaGVzW2ldWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmlubmVyW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyU2l6ZS0tO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yRWFjaChmbikge1xuICAgICAgICBmb3JFYWNoKHRoaXMuaW5uZXIsIChfLCBlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgZm4oaywgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gaXNFbXB0eSh0aGlzLmlubmVyKTtcbiAgICB9XG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXJTaXplO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IEVNUFRZX01VVEFCTEVfRE9DVU1FTlRfTUFQID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbmZ1bmN0aW9uIG11dGFibGVEb2N1bWVudE1hcCgpIHtcbiAgICByZXR1cm4gRU1QVFlfTVVUQUJMRV9ET0NVTUVOVF9NQVA7XG59XG5jb25zdCBFTVBUWV9ET0NVTUVOVF9NQVAgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xuZnVuY3Rpb24gZG9jdW1lbnRNYXAoLi4uZG9jcykge1xuICAgIGxldCBtYXAgPSBFTVBUWV9ET0NVTUVOVF9NQVA7XG4gICAgZm9yIChjb25zdCBkb2Mgb2YgZG9jcykge1xuICAgICAgICBtYXAgPSBtYXAuaW5zZXJ0KGRvYy5rZXksIGRvYyk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG5mdW5jdGlvbiBuZXdPdmVybGF5ZWREb2N1bWVudE1hcCgpIHtcbiAgICByZXR1cm4gbmV3RG9jdW1lbnRLZXlNYXAoKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRPdmVybGF5ZWREb2N1bWVudE1hcFRvRG9jdW1lbnRNYXAoY29sbGVjdGlvbikge1xuICAgIGxldCBkb2N1bWVudHMgPSBFTVBUWV9ET0NVTUVOVF9NQVA7XG4gICAgY29sbGVjdGlvbi5mb3JFYWNoKChrLCB2KSA9PiAoZG9jdW1lbnRzID0gZG9jdW1lbnRzLmluc2VydChrLCB2Lm92ZXJsYXllZERvY3VtZW50KSkpO1xuICAgIHJldHVybiBkb2N1bWVudHM7XG59XG5mdW5jdGlvbiBuZXdPdmVybGF5TWFwKCkge1xuICAgIHJldHVybiBuZXdEb2N1bWVudEtleU1hcCgpO1xufVxuZnVuY3Rpb24gbmV3TXV0YXRpb25NYXAoKSB7XG4gICAgcmV0dXJuIG5ld0RvY3VtZW50S2V5TWFwKCk7XG59XG5mdW5jdGlvbiBuZXdEb2N1bWVudEtleU1hcCgpIHtcbiAgICByZXR1cm4gbmV3IE9iamVjdE1hcChrZXkgPT4ga2V5LnRvU3RyaW5nKCksIChsLCByKSA9PiBsLmlzRXF1YWwocikpO1xufVxuY29uc3QgRU1QVFlfRE9DVU1FTlRfVkVSU0lPTl9NQVAgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xuZnVuY3Rpb24gZG9jdW1lbnRWZXJzaW9uTWFwKCkge1xuICAgIHJldHVybiBFTVBUWV9ET0NVTUVOVF9WRVJTSU9OX01BUDtcbn1cbmNvbnN0IEVNUFRZX0RPQ1VNRU5UX0tFWV9TRVQgPSBuZXcgU29ydGVkU2V0KERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xuZnVuY3Rpb24gZG9jdW1lbnRLZXlTZXQoLi4ua2V5cykge1xuICAgIGxldCBzZXQgPSBFTVBUWV9ET0NVTUVOVF9LRVlfU0VUO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgc2V0ID0gc2V0LmFkZChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0O1xufVxuY29uc3QgRU1QVFlfVEFSR0VUX0lEX1NFVCA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XG5mdW5jdGlvbiB0YXJnZXRJZFNldCgpIHtcbiAgICByZXR1cm4gRU1QVFlfVEFSR0VUX0lEX1NFVDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyBhbiBEb3VibGVWYWx1ZSBmb3IgYHZhbHVlYCB0aGF0IGlzIGVuY29kZWQgYmFzZWQgdGhlIHNlcmlhbGl6ZXInc1xuICogYHVzZVByb3RvM0pzb25gIHNldHRpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvRG91YmxlKHNlcmlhbGl6ZXIsIHZhbHVlKSB7XG4gICAgaWYgKHNlcmlhbGl6ZXIudXNlUHJvdG8zSnNvbikge1xuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb3VibGVWYWx1ZTogJ05hTicgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiAnSW5maW5pdHknIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6ICctSW5maW5pdHknIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6IGlzTmVnYXRpdmVaZXJvKHZhbHVlKSA/ICctMCcgOiB2YWx1ZSB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIEludGVnZXJWYWx1ZSBmb3IgYHZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHsgaW50ZWdlclZhbHVlOiAnJyArIHZhbHVlIH07XG59XG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSBmb3IgYSBudW1iZXIgdGhhdCdzIGFwcHJvcHJpYXRlIHRvIHB1dCBpbnRvIGEgcHJvdG8uXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIEludGVnZXJWYWx1ZSBpZiBpdCBjYW4gc2FmZWx5IHJlcHJlc2VudCB0aGUgdmFsdWUsXG4gKiBvdGhlcndpc2UgYSBEb3VibGVWYWx1ZSBpcyByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIoc2VyaWFsaXplciwgdmFsdWUpIHtcbiAgICByZXR1cm4gaXNTYWZlSW50ZWdlcih2YWx1ZSkgPyB0b0ludGVnZXIodmFsdWUpIDogdG9Eb3VibGUoc2VyaWFsaXplciwgdmFsdWUpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIFVzZWQgdG8gcmVwcmVzZW50IGEgZmllbGQgdHJhbnNmb3JtIG9uIGEgbXV0YXRpb24uICovXG5jbGFzcyBUcmFuc2Zvcm1PcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgc3RydWN0dXJhbCB0eXBlIG9mIGBUcmFuc2Zvcm1PcGVyYXRpb25gIGlzIHVuaXF1ZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNTQ1MVxuICAgICAgICB0aGlzLl8gPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgbG9jYWwgdHJhbnNmb3JtIHJlc3VsdCBhZ2FpbnN0IHRoZSBwcm92aWRlZCBgcHJldmlvdXNWYWx1ZWAsXG4gKiBvcHRpb25hbGx5IHVzaW5nIHRoZSBwcm92aWRlZCBsb2NhbFdyaXRlVGltZS5cbiAqL1xuZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm1PcGVyYXRpb25Ub0xvY2FsVmlldyh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUsIGxvY2FsV3JpdGVUaW1lKSB7XG4gICAgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gc2VydmVyVGltZXN0YW1wJDEobG9jYWxXcml0ZVRpbWUsIHByZXZpb3VzVmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBhcHBseUFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5QXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhcHBseU51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb25Ub0xvY2FsVmlldyh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogQ29tcHV0ZXMgYSBmaW5hbCB0cmFuc2Zvcm0gcmVzdWx0IGFmdGVyIHRoZSB0cmFuc2Zvcm0gaGFzIGJlZW4gYWNrbm93bGVkZ2VkXG4gKiBieSB0aGUgc2VydmVyLCBwb3RlbnRpYWxseSB1c2luZyB0aGUgc2VydmVyLXByb3ZpZGVkIHRyYW5zZm9ybVJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm1PcGVyYXRpb25Ub1JlbW90ZURvY3VtZW50KHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSwgdHJhbnNmb3JtUmVzdWx0KSB7XG4gICAgLy8gVGhlIHNlcnZlciBqdXN0IHNlbmRzIG51bGwgYXMgdGhlIHRyYW5zZm9ybSByZXN1bHQgZm9yIGFycmF5IG9wZXJhdGlvbnMsXG4gICAgLy8gc28gd2UgaGF2ZSB0byBjYWxjdWxhdGUgYSByZXN1bHQgdGhlIHNhbWUgYXMgd2UgZG8gZm9yIGxvY2FsXG4gICAgLy8gYXBwbGljYXRpb25zLlxuICAgIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBhcHBseUFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5QXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybVJlc3VsdDtcbn1cbi8qKlxuICogSWYgdGhpcyB0cmFuc2Zvcm0gb3BlcmF0aW9uIGlzIG5vdCBpZGVtcG90ZW50LCByZXR1cm5zIHRoZSBiYXNlIHZhbHVlIHRvXG4gKiBwZXJzaXN0IGZvciB0aGlzIHRyYW5zZm9ybS4gSWYgYSBiYXNlIHZhbHVlIGlzIHJldHVybmVkLCB0aGUgdHJhbnNmb3JtXG4gKiBvcGVyYXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgdG8gdGhpcyBiYXNlIHZhbHVlLCBldmVuIGlmIGRvY3VtZW50IGhhc1xuICogYWxyZWFkeSBiZWVuIHVwZGF0ZWQuXG4gKlxuICogQmFzZSB2YWx1ZXMgcHJvdmlkZSBjb25zaXN0ZW50IGJlaGF2aW9yIGZvciBub24taWRlbXBvdGVudCB0cmFuc2Zvcm1zIGFuZFxuICogYWxsb3cgdXMgdG8gcmV0dXJuIHRoZSBzYW1lIGxhdGVuY3ktY29tcGVuc2F0ZWQgdmFsdWUgZXZlbiBpZiB0aGUgYmFja2VuZFxuICogaGFzIGFscmVhZHkgYXBwbGllZCB0aGUgdHJhbnNmb3JtIG9wZXJhdGlvbi4gVGhlIGJhc2UgdmFsdWUgaXMgbnVsbCBmb3JcbiAqIGlkZW1wb3RlbnQgdHJhbnNmb3JtcywgYXMgdGhleSBjYW4gYmUgcmUtcGxheWVkIGV2ZW4gaWYgdGhlIGJhY2tlbmQgaGFzXG4gKiBhbHJlYWR5IGFwcGxpZWQgdGhlbS5cbiAqXG4gKiBAcmV0dXJucyBhIGJhc2UgdmFsdWUgdG8gc3RvcmUgYWxvbmcgd2l0aCB0aGUgbXV0YXRpb24sIG9yIG51bGwgZm9yXG4gKiBpZGVtcG90ZW50IHRyYW5zZm9ybXMuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVUcmFuc2Zvcm1PcGVyYXRpb25CYXNlVmFsdWUodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKSB7XG4gICAgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIE51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGlzTnVtYmVyKHByZXZpb3VzVmFsdWUpID8gcHJldmlvdXNWYWx1ZSA6IHsgaW50ZWdlclZhbHVlOiAwIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtT3BlcmF0aW9uRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uICYmXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gYXJyYXlFcXVhbHMobGVmdC5lbGVtZW50cywgcmlnaHQuZWxlbWVudHMsIHZhbHVlRXF1YWxzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVmdCBpbnN0YW5jZW9mIEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uICYmXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKGxlZnQuZWxlbWVudHMsIHJpZ2h0LmVsZW1lbnRzLCB2YWx1ZUVxdWFscyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlZnQgaW5zdGFuY2VvZiBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uICYmXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gdmFsdWVFcXVhbHMobGVmdC5vcGVyYW5kLCByaWdodC5vcGVyYW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIChsZWZ0IGluc3RhbmNlb2YgU2VydmVyVGltZXN0YW1wVHJhbnNmb3JtICYmXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgU2VydmVyVGltZXN0YW1wVHJhbnNmb3JtKTtcbn1cbi8qKiBUcmFuc2Zvcm1zIGEgdmFsdWUgaW50byBhIHNlcnZlci1nZW5lcmF0ZWQgdGltZXN0YW1wLiAqL1xuY2xhc3MgU2VydmVyVGltZXN0YW1wVHJhbnNmb3JtIGV4dGVuZHMgVHJhbnNmb3JtT3BlcmF0aW9uIHtcbn1cbi8qKiBUcmFuc2Zvcm1zIGFuIGFycmF5IHZhbHVlIHZpYSBhIHVuaW9uIG9wZXJhdGlvbi4gKi9cbmNsYXNzIEFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24gZXh0ZW5kcyBUcmFuc2Zvcm1PcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseUFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWVzID0gY29lcmNlZEZpZWxkVmFsdWVzQXJyYXkocHJldmlvdXNWYWx1ZSk7XG4gICAgZm9yIChjb25zdCB0b1VuaW9uIG9mIHRyYW5zZm9ybS5lbGVtZW50cykge1xuICAgICAgICBpZiAoIXZhbHVlcy5zb21lKGVsZW1lbnQgPT4gdmFsdWVFcXVhbHMoZWxlbWVudCwgdG9VbmlvbikpKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0b1VuaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBhcnJheVZhbHVlOiB7IHZhbHVlcyB9IH07XG59XG4vKiogVHJhbnNmb3JtcyBhbiBhcnJheSB2YWx1ZSB2aWEgYSByZW1vdmUgb3BlcmF0aW9uLiAqL1xuY2xhc3MgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24gZXh0ZW5kcyBUcmFuc2Zvcm1PcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseUFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSkge1xuICAgIGxldCB2YWx1ZXMgPSBjb2VyY2VkRmllbGRWYWx1ZXNBcnJheShwcmV2aW91c1ZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IHRvUmVtb3ZlIG9mIHRyYW5zZm9ybS5lbGVtZW50cykge1xuICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKGVsZW1lbnQgPT4gIXZhbHVlRXF1YWxzKGVsZW1lbnQsIHRvUmVtb3ZlKSk7XG4gICAgfVxuICAgIHJldHVybiB7IGFycmF5VmFsdWU6IHsgdmFsdWVzIH0gfTtcbn1cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgYmFja2VuZCBzZW1hbnRpY3MgZm9yIGxvY2FsbHkgY29tcHV0ZWQgTlVNRVJJQ19BREQgKGluY3JlbWVudClcbiAqIHRyYW5zZm9ybXMuIENvbnZlcnRzIGFsbCBmaWVsZCB2YWx1ZXMgdG8gaW50ZWdlcnMgb3IgZG91YmxlcywgYnV0IHVubGlrZSB0aGVcbiAqIGJhY2tlbmQgZG9lcyBub3QgY2FwIGludGVnZXIgdmFsdWVzIGF0IDJeNjMuIEluc3RlYWQsIEphdmFTY3JpcHQgbnVtYmVyXG4gKiBhcml0aG1ldGljIGlzIHVzZWQgYW5kIHByZWNpc2lvbiBsb3NzIGNhbiBvY2N1ciBmb3IgdmFsdWVzIGdyZWF0ZXIgdGhhbiAyXjUzLlxuICovXG5jbGFzcyBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uIGV4dGVuZHMgVHJhbnNmb3JtT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyLCBvcGVyYW5kKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgICAgIHRoaXMub3BlcmFuZCA9IG9wZXJhbmQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uVG9Mb2NhbFZpZXcodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKSB7XG4gICAgLy8gUE9SVElORyBOT1RFOiBTaW5jZSBKYXZhU2NyaXB0J3MgaW50ZWdlciBhcml0aG1ldGljIGlzIGxpbWl0ZWQgdG8gNTMgYml0XG4gICAgLy8gcHJlY2lzaW9uIGFuZCByZXNvbHZlcyBvdmVyZmxvd3MgYnkgcmVkdWNpbmcgcHJlY2lzaW9uLCB3ZSBkbyBub3RcbiAgICAvLyBtYW51YWxseSBjYXAgb3ZlcmZsb3dzIGF0IDJeNjMuXG4gICAgY29uc3QgYmFzZVZhbHVlID0gY29tcHV0ZVRyYW5zZm9ybU9wZXJhdGlvbkJhc2VWYWx1ZSh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpO1xuICAgIGNvbnN0IHN1bSA9IGFzTnVtYmVyKGJhc2VWYWx1ZSkgKyBhc051bWJlcih0cmFuc2Zvcm0ub3BlcmFuZCk7XG4gICAgaWYgKGlzSW50ZWdlcihiYXNlVmFsdWUpICYmIGlzSW50ZWdlcih0cmFuc2Zvcm0ub3BlcmFuZCkpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50ZWdlcihzdW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRvRG91YmxlKHRyYW5zZm9ybS5zZXJpYWxpemVyLCBzdW0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5pbnRlZ2VyVmFsdWUgfHwgdmFsdWUuZG91YmxlVmFsdWUpO1xufVxuZnVuY3Rpb24gY29lcmNlZEZpZWxkVmFsdWVzQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuYXJyYXlWYWx1ZS52YWx1ZXNcbiAgICAgICAgPyB2YWx1ZS5hcnJheVZhbHVlLnZhbHVlcy5zbGljZSgpXG4gICAgICAgIDogW107XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogQSBmaWVsZCBwYXRoIGFuZCB0aGUgVHJhbnNmb3JtT3BlcmF0aW9uIHRvIHBlcmZvcm0gdXBvbiBpdC4gKi9cbmNsYXNzIEZpZWxkVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgfVxufVxuZnVuY3Rpb24gZmllbGRUcmFuc2Zvcm1FcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gKGxlZnQuZmllbGQuaXNFcXVhbChyaWdodC5maWVsZCkgJiZcbiAgICAgICAgdHJhbnNmb3JtT3BlcmF0aW9uRXF1YWxzKGxlZnQudHJhbnNmb3JtLCByaWdodC50cmFuc2Zvcm0pKTtcbn1cbmZ1bmN0aW9uIGZpZWxkVHJhbnNmb3Jtc0FyZUVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPT09IHVuZGVmaW5lZCAmJiByaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobGVmdCAmJiByaWdodCkge1xuICAgICAgICByZXR1cm4gYXJyYXlFcXVhbHMobGVmdCwgcmlnaHQsIChsLCByKSA9PiBmaWVsZFRyYW5zZm9ybUVxdWFscyhsLCByKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKiBUaGUgcmVzdWx0IG9mIHN1Y2Nlc3NmdWxseSBhcHBseWluZyBhIG11dGF0aW9uIHRvIHRoZSBiYWNrZW5kLiAqL1xuY2xhc3MgTXV0YXRpb25SZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJzaW9uIGF0IHdoaWNoIHRoZSBtdXRhdGlvbiB3YXMgY29tbWl0dGVkOlxuICAgICAqXG4gICAgICogLSBGb3IgbW9zdCBvcGVyYXRpb25zLCB0aGlzIGlzIHRoZSB1cGRhdGVUaW1lIGluIHRoZSBXcml0ZVJlc3VsdC5cbiAgICAgKiAtIEZvciBkZWxldGVzLCB0aGUgY29tbWl0VGltZSBvZiB0aGUgV3JpdGVSZXNwb25zZSAoYmVjYXVzZSBkZWxldGVzIGFyZVxuICAgICAqICAgbm90IHN0b3JlZCBhbmQgaGF2ZSBubyB1cGRhdGVUaW1lKS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGVzZSB2ZXJzaW9ucyBjYW4gYmUgZGlmZmVyZW50OiBOby1vcCB3cml0ZXMgd2lsbCBub3QgY2hhbmdlXG4gICAgICogdGhlIHVwZGF0ZVRpbWUgZXZlbiB0aG91Z2ggdGhlIGNvbW1pdFRpbWUgYWR2YW5jZXMuXG4gICAgICovXG4gICAgdmVyc2lvbiwgXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdGluZyBmaWVsZHMgcmV0dXJuZWQgZnJvbSB0aGUgYmFja2VuZCBhZnRlciBhIG11dGF0aW9uXG4gICAgICogY29udGFpbmluZyBmaWVsZCB0cmFuc2Zvcm1zIGhhcyBiZWVuIGNvbW1pdHRlZC4gQ29udGFpbnMgb25lIEZpZWxkVmFsdWVcbiAgICAgKiBmb3IgZWFjaCBGaWVsZFRyYW5zZm9ybSB0aGF0IHdhcyBpbiB0aGUgbXV0YXRpb24uXG4gICAgICpcbiAgICAgKiBXaWxsIGJlIGVtcHR5IGlmIHRoZSBtdXRhdGlvbiBkaWQgbm90IGNvbnRhaW4gYW55IGZpZWxkIHRyYW5zZm9ybXMuXG4gICAgICovXG4gICAgdHJhbnNmb3JtUmVzdWx0cykge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVJlc3VsdHMgPSB0cmFuc2Zvcm1SZXN1bHRzO1xuICAgIH1cbn1cbi8qKlxuICogRW5jb2RlcyBhIHByZWNvbmRpdGlvbiBmb3IgYSBtdXRhdGlvbi4gVGhpcyBmb2xsb3dzIHRoZSBtb2RlbCB0aGF0IHRoZVxuICogYmFja2VuZCBhY2NlcHRzIHdpdGggdGhlIHNwZWNpYWwgY2FzZSBvZiBhbiBleHBsaWNpdCBcImVtcHR5XCIgcHJlY29uZGl0aW9uXG4gKiAobWVhbmluZyBubyBwcmVjb25kaXRpb24pLlxuICovXG5jbGFzcyBQcmVjb25kaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHVwZGF0ZVRpbWUsIGV4aXN0cykge1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWUgPSB1cGRhdGVUaW1lO1xuICAgICAgICB0aGlzLmV4aXN0cyA9IGV4aXN0cztcbiAgICB9XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgZW1wdHkgUHJlY29uZGl0aW9uLiAqL1xuICAgIHN0YXRpYyBub25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByZWNvbmRpdGlvbigpO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBQcmVjb25kaXRpb24gd2l0aCBhbiBleGlzdHMgZmxhZy4gKi9cbiAgICBzdGF0aWMgZXhpc3RzKGV4aXN0cykge1xuICAgICAgICByZXR1cm4gbmV3IFByZWNvbmRpdGlvbih1bmRlZmluZWQsIGV4aXN0cyk7XG4gICAgfVxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IFByZWNvbmRpdGlvbiBiYXNlZCBvbiBhIHZlcnNpb24gYSBkb2N1bWVudCBleGlzdHMgYXQuICovXG4gICAgc3RhdGljIHVwZGF0ZVRpbWUodmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IFByZWNvbmRpdGlvbih2ZXJzaW9uKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgd2hldGhlciB0aGlzIFByZWNvbmRpdGlvbiBpcyBlbXB0eS4gKi9cbiAgICBnZXQgaXNOb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVUaW1lID09PSB1bmRlZmluZWQgJiYgdGhpcy5leGlzdHMgPT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKHRoaXMuZXhpc3RzID09PSBvdGhlci5leGlzdHMgJiZcbiAgICAgICAgICAgICh0aGlzLnVwZGF0ZVRpbWVcbiAgICAgICAgICAgICAgICA/ICEhb3RoZXIudXBkYXRlVGltZSAmJiB0aGlzLnVwZGF0ZVRpbWUuaXNFcXVhbChvdGhlci51cGRhdGVUaW1lKVxuICAgICAgICAgICAgICAgIDogIW90aGVyLnVwZGF0ZVRpbWUpKTtcbiAgICB9XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBwcmVjb25kaXRpb25zIGlzIHZhbGlkIGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQuICovXG5mdW5jdGlvbiBwcmVjb25kaXRpb25Jc1ZhbGlkRm9yRG9jdW1lbnQocHJlY29uZGl0aW9uLCBkb2N1bWVudCkge1xuICAgIGlmIChwcmVjb25kaXRpb24udXBkYXRlVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAoZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkgJiZcbiAgICAgICAgICAgIGRvY3VtZW50LnZlcnNpb24uaXNFcXVhbChwcmVjb25kaXRpb24udXBkYXRlVGltZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcmVjb25kaXRpb24uZXhpc3RzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHByZWNvbmRpdGlvbi5leGlzdHMgPT09IGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLyoqXG4gKiBBIG11dGF0aW9uIGRlc2NyaWJlcyBhIHNlbGYtY29udGFpbmVkIGNoYW5nZSB0byBhIGRvY3VtZW50LiBNdXRhdGlvbnMgY2FuXG4gKiBjcmVhdGUsIHJlcGxhY2UsIGRlbGV0ZSwgYW5kIHVwZGF0ZSBzdWJzZXRzIG9mIGRvY3VtZW50cy5cbiAqXG4gKiBNdXRhdGlvbnMgbm90IG9ubHkgYWN0IG9uIHRoZSB2YWx1ZSBvZiB0aGUgZG9jdW1lbnQgYnV0IGFsc28gaXRzIHZlcnNpb24uXG4gKlxuICogRm9yIGxvY2FsIG11dGF0aW9ucyAobXV0YXRpb25zIHRoYXQgaGF2ZW4ndCBiZWVuIGNvbW1pdHRlZCB5ZXQpLCB3ZSBwcmVzZXJ2ZVxuICogdGhlIGV4aXN0aW5nIHZlcnNpb24gZm9yIFNldCBhbmQgUGF0Y2ggbXV0YXRpb25zLiBGb3IgRGVsZXRlIG11dGF0aW9ucywgd2VcbiAqIHJlc2V0IHRoZSB2ZXJzaW9uIHRvIDAuXG4gKlxuICogSGVyZSdzIHRoZSBleHBlY3RlZCB0cmFuc2l0aW9uIHRhYmxlLlxuICpcbiAqIE1VVEFUSU9OICAgICAgICAgICBBUFBMSUVEIFRPICAgICAgICAgICAgUkVTVUxUUyBJTlxuICpcbiAqIFNldE11dGF0aW9uICAgICAgICBEb2N1bWVudCh2MykgICAgICAgICAgRG9jdW1lbnQodjMpXG4gKiBTZXRNdXRhdGlvbiAgICAgICAgTm9Eb2N1bWVudCh2MykgICAgICAgIERvY3VtZW50KHYwKVxuICogU2V0TXV0YXRpb24gICAgICAgIEludmFsaWREb2N1bWVudCh2MCkgICBEb2N1bWVudCh2MClcbiAqIFBhdGNoTXV0YXRpb24gICAgICBEb2N1bWVudCh2MykgICAgICAgICAgRG9jdW1lbnQodjMpXG4gKiBQYXRjaE11dGF0aW9uICAgICAgTm9Eb2N1bWVudCh2MykgICAgICAgIE5vRG9jdW1lbnQodjMpXG4gKiBQYXRjaE11dGF0aW9uICAgICAgSW52YWxpZERvY3VtZW50KHYwKSAgIFVua25vd25Eb2N1bWVudCh2MylcbiAqIERlbGV0ZU11dGF0aW9uICAgICBEb2N1bWVudCh2MykgICAgICAgICAgTm9Eb2N1bWVudCh2MClcbiAqIERlbGV0ZU11dGF0aW9uICAgICBOb0RvY3VtZW50KHYzKSAgICAgICAgTm9Eb2N1bWVudCh2MClcbiAqIERlbGV0ZU11dGF0aW9uICAgICBJbnZhbGlkRG9jdW1lbnQodjApICAgTm9Eb2N1bWVudCh2MClcbiAqXG4gKiBGb3IgYWNrbm93bGVkZ2VkIG11dGF0aW9ucywgd2UgdXNlIHRoZSB1cGRhdGVUaW1lIG9mIHRoZSBXcml0ZVJlc3BvbnNlIGFzXG4gKiB0aGUgcmVzdWx0aW5nIHZlcnNpb24gZm9yIFNldCBhbmQgUGF0Y2ggbXV0YXRpb25zLiBBcyBkZWxldGVzIGhhdmUgbm9cbiAqIGV4cGxpY2l0IHVwZGF0ZSB0aW1lLCB3ZSB1c2UgdGhlIGNvbW1pdFRpbWUgb2YgdGhlIFdyaXRlUmVzcG9uc2UgZm9yXG4gKiBEZWxldGUgbXV0YXRpb25zLlxuICpcbiAqIElmIGEgbXV0YXRpb24gaXMgYWNrbm93bGVkZ2VkIGJ5IHRoZSBiYWNrZW5kIGJ1dCBmYWlscyB0aGUgcHJlY29uZGl0aW9uIGNoZWNrXG4gKiBsb2NhbGx5LCB3ZSB0cmFuc2l0aW9uIHRvIGFuIGBVbmtub3duRG9jdW1lbnRgIGFuZCByZWx5IG9uIFdhdGNoIHRvIHNlbmQgdXNcbiAqIHRoZSB1cGRhdGVkIHZlcnNpb24uXG4gKlxuICogRmllbGQgdHJhbnNmb3JtcyBhcmUgdXNlZCBvbmx5IHdpdGggUGF0Y2ggYW5kIFNldCBNdXRhdGlvbnMuIFdlIHVzZSB0aGVcbiAqIGB1cGRhdGVUcmFuc2Zvcm1zYCBtZXNzYWdlIHRvIHN0b3JlIHRyYW5zZm9ybXMsIHJhdGhlciB0aGFuIHRoZSBgdHJhbnNmb3Jtc2BzXG4gKiBtZXNzYWdlcy5cbiAqXG4gKiAjIyBTdWJjbGFzc2luZyBOb3Rlc1xuICpcbiAqIEV2ZXJ5IHR5cGUgb2YgbXV0YXRpb24gbmVlZHMgdG8gaW1wbGVtZW50IGl0cyBvd24gYXBwbHlUb1JlbW90ZURvY3VtZW50KCkgYW5kXG4gKiBhcHBseVRvTG9jYWxWaWV3KCkgdG8gaW1wbGVtZW50IHRoZSBhY3R1YWwgYmVoYXZpb3Igb2YgYXBwbHlpbmcgdGhlIG11dGF0aW9uXG4gKiB0byBzb21lIHNvdXJjZSBkb2N1bWVudCAoc2VlIGBzZXRNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudCgpYCBmb3IgYW5cbiAqIGV4YW1wbGUpLlxuICovXG5jbGFzcyBNdXRhdGlvbiB7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBtZXRob2QgdG8gY2FsY3VsYXRlIGEgYE11dGF0aW9uYCByZXByZXNlbnRpbmcgdGhlIG92ZXJsYXkgZnJvbSB0aGVcbiAqIGZpbmFsIHN0YXRlIG9mIHRoZSBkb2N1bWVudCwgYW5kIGEgYEZpZWxkTWFza2AgcmVwcmVzZW50aW5nIHRoZSBmaWVsZHMgdGhhdFxuICogYXJlIG11dGF0ZWQgYnkgdGhlIGxvY2FsIG11dGF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlT3ZlcmxheU11dGF0aW9uKGRvYywgbWFzaykge1xuICAgIGlmICghZG9jLmhhc0xvY2FsTXV0YXRpb25zIHx8IChtYXNrICYmIG1hc2suZmllbGRzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIG1hc2sgaXMgbnVsbCB3aGVuIHNldHMgb3IgZGVsZXRlcyBhcmUgYXBwbGllZCB0byB0aGUgY3VycmVudCBkb2N1bWVudC5cbiAgICBpZiAobWFzayA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoZG9jLmlzTm9Eb2N1bWVudCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbGV0ZU11dGF0aW9uKGRvYy5rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXRNdXRhdGlvbihkb2Mua2V5LCBkb2MuZGF0YSwgUHJlY29uZGl0aW9uLm5vbmUoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGRvY1ZhbHVlID0gZG9jLmRhdGE7XG4gICAgICAgIGNvbnN0IHBhdGNoVmFsdWUgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xuICAgICAgICBsZXQgbWFza1NldCA9IG5ldyBTb3J0ZWRTZXQoRmllbGRQYXRoJDEuY29tcGFyYXRvcik7XG4gICAgICAgIGZvciAobGV0IHBhdGggb2YgbWFzay5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmICghbWFza1NldC5oYXMocGF0aCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBkb2NWYWx1ZS5maWVsZChwYXRoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZGVsZXRpbmcgYSBuZXN0ZWQgZmllbGQsIHdlIHRha2UgdGhlIGltbWVkaWF0ZSBwYXJlbnQgYXNcbiAgICAgICAgICAgICAgICAvLyB0aGUgbWFzayB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcmVzdWx0aW5nIG11dGF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIEp1c3RpZmljYXRpb246IE5lc3RlZCBmaWVsZHMgY2FuIGNyZWF0ZSBwYXJlbnQgZmllbGRzIGltcGxpY2l0bHkuIElmXG4gICAgICAgICAgICAgICAgLy8gb25seSBhIGxlYWYgZW50cnkgaXMgZGVsZXRlZCBpbiBsYXRlciBtdXRhdGlvbnMsIHRoZSBwYXJlbnQgZmllbGRcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgc3RpbGwgcmVtYWluLCBidXQgd2UgbWF5IGhhdmUgbG9zdCB0aGlzIGluZm9ybWF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIG11dGF0aW9uIChmb28uYmFyIDEpLCB0aGVuIG11dGF0aW9uIChmb28uYmFyIGRlbGV0ZSgpKS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGxlYXZlcyB0aGUgZmluYWwgcmVzdWx0IChmb28sIHt9KS4gRGVzcGl0ZSB0aGUgZmFjdCB0aGF0IGBkb2NgXG4gICAgICAgICAgICAgICAgLy8gaGFzIHRoZSBjb3JyZWN0IHJlc3VsdCwgYGZvb2AgaXMgbm90IGluIGBtYXNrYCwgYW5kIHRoZSByZXN1bHRpbmdcbiAgICAgICAgICAgICAgICAvLyBtdXRhdGlvbiB3b3VsZCBtaXNzIGBmb29gLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHBhdGgucG9wTGFzdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRvY1ZhbHVlLmZpZWxkKHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hWYWx1ZS5kZWxldGUocGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaFZhbHVlLnNldChwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hc2tTZXQgPSBtYXNrU2V0LmFkZChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhdGNoTXV0YXRpb24oZG9jLmtleSwgcGF0Y2hWYWx1ZSwgbmV3IEZpZWxkTWFzayhtYXNrU2V0LnRvQXJyYXkoKSksIFByZWNvbmRpdGlvbi5ub25lKCkpO1xuICAgIH1cbn1cbi8qKlxuICogQXBwbGllcyB0aGlzIG11dGF0aW9uIHRvIHRoZSBnaXZlbiBkb2N1bWVudCBmb3IgdGhlIHB1cnBvc2VzIG9mIGNvbXB1dGluZyBhXG4gKiBuZXcgcmVtb3RlIGRvY3VtZW50LiBJZiB0aGUgaW5wdXQgZG9jdW1lbnQgZG9lc24ndCBtYXRjaCB0aGUgZXhwZWN0ZWQgc3RhdGVcbiAqIChlLmcuIGl0IGlzIGludmFsaWQgb3Igb3V0ZGF0ZWQpLCB0aGUgZG9jdW1lbnQgdHlwZSBtYXkgdHJhbnNpdGlvbiB0b1xuICogdW5rbm93bi5cbiAqXG4gKiBAcGFyYW0gbXV0YXRpb24gLSBUaGUgbXV0YXRpb24gdG8gYXBwbHkuXG4gKiBAcGFyYW0gZG9jdW1lbnQgLSBUaGUgZG9jdW1lbnQgdG8gbXV0YXRlLiBUaGUgaW5wdXQgZG9jdW1lbnQgY2FuIGJlIGFuXG4gKiAgICAgaW52YWxpZCBkb2N1bWVudCBpZiB0aGUgY2xpZW50IGhhcyBubyBrbm93bGVkZ2Ugb2YgdGhlIHByZS1tdXRhdGlvbiBzdGF0ZVxuICogICAgIG9mIHRoZSBkb2N1bWVudC5cbiAqIEBwYXJhbSBtdXRhdGlvblJlc3VsdCAtIFRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIG11dGF0aW9uIGZyb20gdGhlIGJhY2tlbmQuXG4gKi9cbmZ1bmN0aW9uIG11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQpIHtcbiAgICBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBTZXRNdXRhdGlvbikge1xuICAgICAgICBzZXRNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBQYXRjaE11dGF0aW9uKSB7XG4gICAgICAgIHBhdGNoTXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWxldGVNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KTtcbiAgICB9XG59XG4vKipcbiAqIEFwcGxpZXMgdGhpcyBtdXRhdGlvbiB0byB0aGUgZ2l2ZW4gZG9jdW1lbnQgZm9yIHRoZSBwdXJwb3NlcyBvZiBjb21wdXRpbmdcbiAqIHRoZSBuZXcgbG9jYWwgdmlldyBvZiBhIGRvY3VtZW50LiBJZiB0aGUgaW5wdXQgZG9jdW1lbnQgZG9lc24ndCBtYXRjaCB0aGVcbiAqIGV4cGVjdGVkIHN0YXRlLCB0aGUgZG9jdW1lbnQgaXMgbm90IG1vZGlmaWVkLlxuICpcbiAqIEBwYXJhbSBtdXRhdGlvbiAtIFRoZSBtdXRhdGlvbiB0byBhcHBseS5cbiAqIEBwYXJhbSBkb2N1bWVudCAtIFRoZSBkb2N1bWVudCB0byBtdXRhdGUuIFRoZSBpbnB1dCBkb2N1bWVudCBjYW4gYmUgYW5cbiAqICAgICBpbnZhbGlkIGRvY3VtZW50IGlmIHRoZSBjbGllbnQgaGFzIG5vIGtub3dsZWRnZSBvZiB0aGUgcHJlLW11dGF0aW9uIHN0YXRlXG4gKiAgICAgb2YgdGhlIGRvY3VtZW50LlxuICogQHBhcmFtIHByZXZpb3VzTWFzayAtIFRoZSBmaWVsZHMgdGhhdCBoYXZlIGJlZW4gdXBkYXRlZCBiZWZvcmUgYXBwbHlpbmcgdGhpcyBtdXRhdGlvbi5cbiAqIEBwYXJhbSBsb2NhbFdyaXRlVGltZSAtIEEgdGltZXN0YW1wIGluZGljYXRpbmcgdGhlIGxvY2FsIHdyaXRlIHRpbWUgb2YgdGhlXG4gKiAgICAgYmF0Y2ggdGhpcyBtdXRhdGlvbiBpcyBhIHBhcnQgb2YuXG4gKiBAcmV0dXJucyBBIGBGaWVsZE1hc2tgIHJlcHJlc2VudGluZyB0aGUgZmllbGRzIHRoYXQgYXJlIGNoYW5nZWQgYnkgYXBwbHlpbmcgdGhpcyBtdXRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgcHJldmlvdXNNYXNrLCBsb2NhbFdyaXRlVGltZSkge1xuICAgIGlmIChtdXRhdGlvbiBpbnN0YW5jZW9mIFNldE11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBzZXRNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBwcmV2aW91c01hc2ssIGxvY2FsV3JpdGVUaW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBQYXRjaE11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBwYXRjaE11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIHByZXZpb3VzTWFzaywgbG9jYWxXcml0ZVRpbWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZU11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIHByZXZpb3VzTWFzayk7XG4gICAgfVxufVxuLyoqXG4gKiBJZiB0aGlzIG11dGF0aW9uIGlzIG5vdCBpZGVtcG90ZW50LCByZXR1cm5zIHRoZSBiYXNlIHZhbHVlIHRvIHBlcnNpc3Qgd2l0aFxuICogdGhpcyBtdXRhdGlvbi4gSWYgYSBiYXNlIHZhbHVlIGlzIHJldHVybmVkLCB0aGUgbXV0YXRpb24gaXMgYWx3YXlzIGFwcGxpZWRcbiAqIHRvIHRoaXMgYmFzZSB2YWx1ZSwgZXZlbiBpZiBkb2N1bWVudCBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWQuXG4gKlxuICogVGhlIGJhc2UgdmFsdWUgaXMgYSBzcGFyc2Ugb2JqZWN0IHRoYXQgY29uc2lzdHMgb2Ygb25seSB0aGUgZG9jdW1lbnRcbiAqIGZpZWxkcyBmb3Igd2hpY2ggdGhpcyBtdXRhdGlvbiBjb250YWlucyBhIG5vbi1pZGVtcG90ZW50IHRyYW5zZm9ybWF0aW9uXG4gKiAoZS5nLiBhIG51bWVyaWMgaW5jcmVtZW50KS4gVGhlIHByb3ZpZGVkIHZhbHVlIGd1YXJhbnRlZXMgY29uc2lzdGVudFxuICogYmVoYXZpb3IgZm9yIG5vbi1pZGVtcG90ZW50IHRyYW5zZm9ybXMgYW5kIGFsbG93IHVzIHRvIHJldHVybiB0aGUgc2FtZVxuICogbGF0ZW5jeS1jb21wZW5zYXRlZCB2YWx1ZSBldmVuIGlmIHRoZSBiYWNrZW5kIGhhcyBhbHJlYWR5IGFwcGxpZWQgdGhlXG4gKiBtdXRhdGlvbi4gVGhlIGJhc2UgdmFsdWUgaXMgbnVsbCBmb3IgaWRlbXBvdGVudCBtdXRhdGlvbnMsIGFzIHRoZXkgY2FuIGJlXG4gKiByZS1wbGF5ZWQgZXZlbiBpZiB0aGUgYmFja2VuZCBoYXMgYWxyZWFkeSBhcHBsaWVkIHRoZW0uXG4gKlxuICogQHJldHVybnMgYSBiYXNlIHZhbHVlIHRvIHN0b3JlIGFsb25nIHdpdGggdGhlIG11dGF0aW9uLCBvciBudWxsIGZvclxuICogaWRlbXBvdGVudCBtdXRhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG11dGF0aW9uRXh0cmFjdEJhc2VWYWx1ZShtdXRhdGlvbiwgZG9jdW1lbnQpIHtcbiAgICBsZXQgYmFzZU9iamVjdCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBmaWVsZFRyYW5zZm9ybSBvZiBtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZSA9IGRvY3VtZW50LmRhdGEuZmllbGQoZmllbGRUcmFuc2Zvcm0uZmllbGQpO1xuICAgICAgICBjb25zdCBjb2VyY2VkVmFsdWUgPSBjb21wdXRlVHJhbnNmb3JtT3BlcmF0aW9uQmFzZVZhbHVlKGZpZWxkVHJhbnNmb3JtLnRyYW5zZm9ybSwgZXhpc3RpbmdWYWx1ZSB8fCBudWxsKTtcbiAgICAgICAgaWYgKGNvZXJjZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoYmFzZU9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJhc2VPYmplY3QgPSBPYmplY3RWYWx1ZS5lbXB0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFzZU9iamVjdC5zZXQoZmllbGRUcmFuc2Zvcm0uZmllbGQsIGNvZXJjZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2VPYmplY3QgPyBiYXNlT2JqZWN0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIG11dGF0aW9uRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSAhPT0gcmlnaHQudHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghbGVmdC5rZXkuaXNFcXVhbChyaWdodC5rZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFsZWZ0LnByZWNvbmRpdGlvbi5pc0VxdWFsKHJpZ2h0LnByZWNvbmRpdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWZpZWxkVHJhbnNmb3Jtc0FyZUVxdWFsKGxlZnQuZmllbGRUcmFuc2Zvcm1zLCByaWdodC5maWVsZFRyYW5zZm9ybXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gMCAvKiBNdXRhdGlvblR5cGUuU2V0ICovKSB7XG4gICAgICAgIHJldHVybiBsZWZ0LnZhbHVlLmlzRXF1YWwocmlnaHQudmFsdWUpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSAxIC8qIE11dGF0aW9uVHlwZS5QYXRjaCAqLykge1xuICAgICAgICByZXR1cm4gKGxlZnQuZGF0YS5pc0VxdWFsKHJpZ2h0LmRhdGEpICYmXG4gICAgICAgICAgICBsZWZ0LmZpZWxkTWFzay5pc0VxdWFsKHJpZ2h0LmZpZWxkTWFzaykpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQSBtdXRhdGlvbiB0aGF0IGNyZWF0ZXMgb3IgcmVwbGFjZXMgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBrZXkgd2l0aCB0aGVcbiAqIG9iamVjdCB2YWx1ZSBjb250ZW50cy5cbiAqL1xuY2xhc3MgU2V0TXV0YXRpb24gZXh0ZW5kcyBNdXRhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSwgcHJlY29uZGl0aW9uLCBmaWVsZFRyYW5zZm9ybXMgPSBbXSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnByZWNvbmRpdGlvbiA9IHByZWNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXM7XG4gICAgICAgIHRoaXMudHlwZSA9IDAgLyogTXV0YXRpb25UeXBlLlNldCAqLztcbiAgICB9XG4gICAgZ2V0RmllbGRNYXNrKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KSB7XG4gICAgLy8gVW5saWtlIHNldE11dGF0aW9uQXBwbHlUb0xvY2FsVmlldywgaWYgd2UncmUgYXBwbHlpbmcgYSBtdXRhdGlvbiB0byBhXG4gICAgLy8gcmVtb3RlIGRvY3VtZW50IHRoZSBzZXJ2ZXIgaGFzIGFjY2VwdGVkIHRoZSBtdXRhdGlvbiBzbyB0aGUgcHJlY29uZGl0aW9uXG4gICAgLy8gbXVzdCBoYXZlIGhlbGQuXG4gICAgY29uc3QgbmV3RGF0YSA9IG11dGF0aW9uLnZhbHVlLmNsb25lKCk7XG4gICAgY29uc3QgdHJhbnNmb3JtUmVzdWx0cyA9IHNlcnZlclRyYW5zZm9ybVJlc3VsdHMobXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQudHJhbnNmb3JtUmVzdWx0cyk7XG4gICAgbmV3RGF0YS5zZXRBbGwodHJhbnNmb3JtUmVzdWx0cyk7XG4gICAgZG9jdW1lbnRcbiAgICAgICAgLmNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQobXV0YXRpb25SZXN1bHQudmVyc2lvbiwgbmV3RGF0YSlcbiAgICAgICAgLnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpO1xufVxuZnVuY3Rpb24gc2V0TXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgcHJldmlvdXNNYXNrLCBsb2NhbFdyaXRlVGltZSkge1xuICAgIGlmICghcHJlY29uZGl0aW9uSXNWYWxpZEZvckRvY3VtZW50KG11dGF0aW9uLnByZWNvbmRpdGlvbiwgZG9jdW1lbnQpKSB7XG4gICAgICAgIC8vIFRoZSBtdXRhdGlvbiBmYWlsZWQgdG8gYXBwbHkgKGUuZy4gYSBkb2N1bWVudCBJRCBjcmVhdGVkIHdpdGggYWRkKClcbiAgICAgICAgLy8gY2F1c2VkIGEgbmFtZSBjb2xsaXNpb24pLlxuICAgICAgICByZXR1cm4gcHJldmlvdXNNYXNrO1xuICAgIH1cbiAgICBjb25zdCBuZXdEYXRhID0gbXV0YXRpb24udmFsdWUuY2xvbmUoKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHRzID0gbG9jYWxUcmFuc2Zvcm1SZXN1bHRzKG11dGF0aW9uLmZpZWxkVHJhbnNmb3JtcywgbG9jYWxXcml0ZVRpbWUsIGRvY3VtZW50KTtcbiAgICBuZXdEYXRhLnNldEFsbCh0cmFuc2Zvcm1SZXN1bHRzKTtcbiAgICBkb2N1bWVudFxuICAgICAgICAuY29udmVydFRvRm91bmREb2N1bWVudChkb2N1bWVudC52ZXJzaW9uLCBuZXdEYXRhKVxuICAgICAgICAuc2V0SGFzTG9jYWxNdXRhdGlvbnMoKTtcbiAgICByZXR1cm4gbnVsbDsgLy8gU2V0TXV0YXRpb24gb3ZlcndyaXRlcyBhbGwgZmllbGRzLlxufVxuLyoqXG4gKiBBIG11dGF0aW9uIHRoYXQgbW9kaWZpZXMgZmllbGRzIG9mIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4ga2V5IHdpdGggdGhlXG4gKiBnaXZlbiB2YWx1ZXMuIFRoZSB2YWx1ZXMgYXJlIGFwcGxpZWQgdGhyb3VnaCBhIGZpZWxkIG1hc2s6XG4gKlxuICogICogV2hlbiBhIGZpZWxkIGlzIGluIGJvdGggdGhlIG1hc2sgYW5kIHRoZSB2YWx1ZXMsIHRoZSBjb3JyZXNwb25kaW5nIGZpZWxkXG4gKiAgICBpcyB1cGRhdGVkLlxuICogICogV2hlbiBhIGZpZWxkIGlzIGluIG5laXRoZXIgdGhlIG1hc2sgbm9yIHRoZSB2YWx1ZXMsIHRoZSBjb3JyZXNwb25kaW5nXG4gKiAgICBmaWVsZCBpcyB1bm1vZGlmaWVkLlxuICogICogV2hlbiBhIGZpZWxkIGlzIGluIHRoZSBtYXNrIGJ1dCBub3QgaW4gdGhlIHZhbHVlcywgdGhlIGNvcnJlc3BvbmRpbmcgZmllbGRcbiAqICAgIGlzIGRlbGV0ZWQuXG4gKiAgKiBXaGVuIGEgZmllbGQgaXMgbm90IGluIHRoZSBtYXNrIGJ1dCBpcyBpbiB0aGUgdmFsdWVzLCB0aGUgdmFsdWVzIG1hcCBpc1xuICogICAgaWdub3JlZC5cbiAqL1xuY2xhc3MgUGF0Y2hNdXRhdGlvbiBleHRlbmRzIE11dGF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIGRhdGEsIGZpZWxkTWFzaywgcHJlY29uZGl0aW9uLCBmaWVsZFRyYW5zZm9ybXMgPSBbXSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5maWVsZE1hc2sgPSBmaWVsZE1hc2s7XG4gICAgICAgIHRoaXMucHJlY29uZGl0aW9uID0gcHJlY29uZGl0aW9uO1xuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IGZpZWxkVHJhbnNmb3JtcztcbiAgICAgICAgdGhpcy50eXBlID0gMSAvKiBNdXRhdGlvblR5cGUuUGF0Y2ggKi87XG4gICAgfVxuICAgIGdldEZpZWxkTWFzaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRNYXNrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCkge1xuICAgIGlmICghcHJlY29uZGl0aW9uSXNWYWxpZEZvckRvY3VtZW50KG11dGF0aW9uLnByZWNvbmRpdGlvbiwgZG9jdW1lbnQpKSB7XG4gICAgICAgIC8vIFNpbmNlIHRoZSBtdXRhdGlvbiB3YXMgbm90IHJlamVjdGVkLCB3ZSBrbm93IHRoYXQgdGhlIHByZWNvbmRpdGlvblxuICAgICAgICAvLyBtYXRjaGVkIG9uIHRoZSBiYWNrZW5kLiBXZSB0aGVyZWZvcmUgbXVzdCBub3QgaGF2ZSB0aGUgZXhwZWN0ZWQgdmVyc2lvblxuICAgICAgICAvLyBvZiB0aGUgZG9jdW1lbnQgaW4gb3VyIGNhY2hlIGFuZCBjb252ZXJ0IHRvIGFuIFVua25vd25Eb2N1bWVudCB3aXRoIGFcbiAgICAgICAgLy8ga25vd24gdXBkYXRlVGltZS5cbiAgICAgICAgZG9jdW1lbnQuY29udmVydFRvVW5rbm93bkRvY3VtZW50KG11dGF0aW9uUmVzdWx0LnZlcnNpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdHMgPSBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzKG11dGF0aW9uLmZpZWxkVHJhbnNmb3JtcywgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0LnRyYW5zZm9ybVJlc3VsdHMpO1xuICAgIGNvbnN0IG5ld0RhdGEgPSBkb2N1bWVudC5kYXRhO1xuICAgIG5ld0RhdGEuc2V0QWxsKGdldFBhdGNoKG11dGF0aW9uKSk7XG4gICAgbmV3RGF0YS5zZXRBbGwodHJhbnNmb3JtUmVzdWx0cyk7XG4gICAgZG9jdW1lbnRcbiAgICAgICAgLmNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQobXV0YXRpb25SZXN1bHQudmVyc2lvbiwgbmV3RGF0YSlcbiAgICAgICAgLnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpO1xufVxuZnVuY3Rpb24gcGF0Y2hNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBwcmV2aW91c01hc2ssIGxvY2FsV3JpdGVUaW1lKSB7XG4gICAgaWYgKCFwcmVjb25kaXRpb25Jc1ZhbGlkRm9yRG9jdW1lbnQobXV0YXRpb24ucHJlY29uZGl0aW9uLCBkb2N1bWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzTWFzaztcbiAgICB9XG4gICAgY29uc3QgdHJhbnNmb3JtUmVzdWx0cyA9IGxvY2FsVHJhbnNmb3JtUmVzdWx0cyhtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMsIGxvY2FsV3JpdGVUaW1lLCBkb2N1bWVudCk7XG4gICAgY29uc3QgbmV3RGF0YSA9IGRvY3VtZW50LmRhdGE7XG4gICAgbmV3RGF0YS5zZXRBbGwoZ2V0UGF0Y2gobXV0YXRpb24pKTtcbiAgICBuZXdEYXRhLnNldEFsbCh0cmFuc2Zvcm1SZXN1bHRzKTtcbiAgICBkb2N1bWVudFxuICAgICAgICAuY29udmVydFRvRm91bmREb2N1bWVudChkb2N1bWVudC52ZXJzaW9uLCBuZXdEYXRhKVxuICAgICAgICAuc2V0SGFzTG9jYWxNdXRhdGlvbnMoKTtcbiAgICBpZiAocHJldmlvdXNNYXNrID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcHJldmlvdXNNYXNrXG4gICAgICAgIC51bmlvbldpdGgobXV0YXRpb24uZmllbGRNYXNrLmZpZWxkcylcbiAgICAgICAgLnVuaW9uV2l0aChtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMubWFwKHRyYW5zZm9ybSA9PiB0cmFuc2Zvcm0uZmllbGQpKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIEZpZWxkUGF0aC9WYWx1ZSBtYXAgd2l0aCB0aGUgY29udGVudCBvZiB0aGUgUGF0Y2hNdXRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UGF0Y2gobXV0YXRpb24pIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgbXV0YXRpb24uZmllbGRNYXNrLmZpZWxkcy5mb3JFYWNoKGZpZWxkUGF0aCA9PiB7XG4gICAgICAgIGlmICghZmllbGRQYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBtdXRhdGlvbi5kYXRhLmZpZWxkKGZpZWxkUGF0aCk7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGZpZWxkUGF0aCwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGxpc3Qgb2YgXCJ0cmFuc2Zvcm0gcmVzdWx0c1wiIChhIHRyYW5zZm9ybSByZXN1bHQgaXMgYSBmaWVsZCB2YWx1ZVxuICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYSB0cmFuc2Zvcm0pIGZvciB1c2UgYWZ0ZXIgYSBtdXRhdGlvblxuICogY29udGFpbmluZyB0cmFuc2Zvcm1zIGhhcyBiZWVuIGFja25vd2xlZGdlZCBieSB0aGUgc2VydmVyLlxuICpcbiAqIEBwYXJhbSBmaWVsZFRyYW5zZm9ybXMgLSBUaGUgZmllbGQgdHJhbnNmb3JtcyB0byBhcHBseSB0aGUgcmVzdWx0IHRvLlxuICogQHBhcmFtIG11dGFibGVEb2N1bWVudCAtIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBkb2N1bWVudCBhZnRlciBhcHBseWluZyBhbGxcbiAqIHByZXZpb3VzIG11dGF0aW9ucy5cbiAqIEBwYXJhbSBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzIC0gVGhlIHRyYW5zZm9ybSByZXN1bHRzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIuXG4gKiBAcmV0dXJucyBUaGUgdHJhbnNmb3JtIHJlc3VsdHMgbGlzdC5cbiAqL1xuZnVuY3Rpb24gc2VydmVyVHJhbnNmb3JtUmVzdWx0cyhmaWVsZFRyYW5zZm9ybXMsIG11dGFibGVEb2N1bWVudCwgc2VydmVyVHJhbnNmb3JtUmVzdWx0cykge1xuICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdHMgPSBuZXcgTWFwKCk7XG4gICAgaGFyZEFzc2VydChmaWVsZFRyYW5zZm9ybXMubGVuZ3RoID09PSBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkVHJhbnNmb3JtID0gZmllbGRUcmFuc2Zvcm1zW2ldO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBmaWVsZFRyYW5zZm9ybS50cmFuc2Zvcm07XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBtdXRhYmxlRG9jdW1lbnQuZGF0YS5maWVsZChmaWVsZFRyYW5zZm9ybS5maWVsZCk7XG4gICAgICAgIHRyYW5zZm9ybVJlc3VsdHMuc2V0KGZpZWxkVHJhbnNmb3JtLmZpZWxkLCBhcHBseVRyYW5zZm9ybU9wZXJhdGlvblRvUmVtb3RlRG9jdW1lbnQodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlLCBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1SZXN1bHRzO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbGlzdCBvZiBcInRyYW5zZm9ybSByZXN1bHRzXCIgKGEgdHJhbnNmb3JtIHJlc3VsdCBpcyBhIGZpZWxkIHZhbHVlXG4gKiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBhIHRyYW5zZm9ybSkgZm9yIHVzZSB3aGVuIGFwcGx5aW5nIGFcbiAqIHRyYW5zZm9ybSBsb2NhbGx5LlxuICpcbiAqIEBwYXJhbSBmaWVsZFRyYW5zZm9ybXMgLSBUaGUgZmllbGQgdHJhbnNmb3JtcyB0byBhcHBseSB0aGUgcmVzdWx0IHRvLlxuICogQHBhcmFtIGxvY2FsV3JpdGVUaW1lIC0gVGhlIGxvY2FsIHRpbWUgb2YgdGhlIG11dGF0aW9uICh1c2VkIHRvXG4gKiAgICAgZ2VuZXJhdGUgU2VydmVyVGltZXN0YW1wVmFsdWVzKS5cbiAqIEBwYXJhbSBtdXRhYmxlRG9jdW1lbnQgLSBUaGUgZG9jdW1lbnQgdG8gYXBwbHkgdHJhbnNmb3JtcyBvbi5cbiAqIEByZXR1cm5zIFRoZSB0cmFuc2Zvcm0gcmVzdWx0cyBsaXN0LlxuICovXG5mdW5jdGlvbiBsb2NhbFRyYW5zZm9ybVJlc3VsdHMoZmllbGRUcmFuc2Zvcm1zLCBsb2NhbFdyaXRlVGltZSwgbXV0YWJsZURvY3VtZW50KSB7XG4gICAgY29uc3QgdHJhbnNmb3JtUmVzdWx0cyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkVHJhbnNmb3JtIG9mIGZpZWxkVHJhbnNmb3Jtcykge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBmaWVsZFRyYW5zZm9ybS50cmFuc2Zvcm07XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBtdXRhYmxlRG9jdW1lbnQuZGF0YS5maWVsZChmaWVsZFRyYW5zZm9ybS5maWVsZCk7XG4gICAgICAgIHRyYW5zZm9ybVJlc3VsdHMuc2V0KGZpZWxkVHJhbnNmb3JtLmZpZWxkLCBhcHBseVRyYW5zZm9ybU9wZXJhdGlvblRvTG9jYWxWaWV3KHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSwgbG9jYWxXcml0ZVRpbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybVJlc3VsdHM7XG59XG4vKiogQSBtdXRhdGlvbiB0aGF0IGRlbGV0ZXMgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBrZXkuICovXG5jbGFzcyBEZWxldGVNdXRhdGlvbiBleHRlbmRzIE11dGF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHByZWNvbmRpdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5wcmVjb25kaXRpb24gPSBwcmVjb25kaXRpb247XG4gICAgICAgIHRoaXMudHlwZSA9IDIgLyogTXV0YXRpb25UeXBlLkRlbGV0ZSAqLztcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBbXTtcbiAgICB9XG4gICAgZ2V0RmllbGRNYXNrKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWxldGVNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KSB7XG4gICAgLy8gVW5saWtlIGFwcGx5VG9Mb2NhbFZpZXcsIGlmIHdlJ3JlIGFwcGx5aW5nIGEgbXV0YXRpb24gdG8gYSByZW1vdGVcbiAgICAvLyBkb2N1bWVudCB0aGUgc2VydmVyIGhhcyBhY2NlcHRlZCB0aGUgbXV0YXRpb24gc28gdGhlIHByZWNvbmRpdGlvbiBtdXN0XG4gICAgLy8gaGF2ZSBoZWxkLlxuICAgIGRvY3VtZW50XG4gICAgICAgIC5jb252ZXJ0VG9Ob0RvY3VtZW50KG11dGF0aW9uUmVzdWx0LnZlcnNpb24pXG4gICAgICAgIC5zZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZU11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIHByZXZpb3VzTWFzaykge1xuICAgIGlmIChwcmVjb25kaXRpb25Jc1ZhbGlkRm9yRG9jdW1lbnQobXV0YXRpb24ucHJlY29uZGl0aW9uLCBkb2N1bWVudCkpIHtcbiAgICAgICAgZG9jdW1lbnQuY29udmVydFRvTm9Eb2N1bWVudChkb2N1bWVudC52ZXJzaW9uKS5zZXRIYXNMb2NhbE11dGF0aW9ucygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZpb3VzTWFzaztcbn1cbi8qKlxuICogQSBtdXRhdGlvbiB0aGF0IHZlcmlmaWVzIHRoZSBleGlzdGVuY2Ugb2YgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBrZXkgd2l0aFxuICogdGhlIHByb3ZpZGVkIHByZWNvbmRpdGlvbi5cbiAqXG4gKiBUaGUgYHZlcmlmeWAgb3BlcmF0aW9uIGlzIG9ubHkgdXNlZCBpbiBUcmFuc2FjdGlvbnMsIGFuZCB0aGlzIGNsYXNzIHNlcnZlc1xuICogcHJpbWFyaWx5IHRvIGZhY2lsaXRhdGUgc2VyaWFsaXphdGlvbiBpbnRvIHByb3Rvcy5cbiAqL1xuY2xhc3MgVmVyaWZ5TXV0YXRpb24gZXh0ZW5kcyBNdXRhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBwcmVjb25kaXRpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucHJlY29uZGl0aW9uID0gcHJlY29uZGl0aW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSAzIC8qIE11dGF0aW9uVHlwZS5WZXJpZnkgKi87XG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gW107XG4gICAgfVxuICAgIGdldEZpZWxkTWFzaygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGJhdGNoIG9mIG11dGF0aW9ucyB0aGF0IHdpbGwgYmUgc2VudCBhcyBvbmUgdW5pdCB0byB0aGUgYmFja2VuZC5cbiAqL1xuY2xhc3MgTXV0YXRpb25CYXRjaCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGJhdGNoSWQgLSBUaGUgdW5pcXVlIElEIG9mIHRoaXMgbXV0YXRpb24gYmF0Y2guXG4gICAgICogQHBhcmFtIGxvY2FsV3JpdGVUaW1lIC0gVGhlIG9yaWdpbmFsIHdyaXRlIHRpbWUgb2YgdGhpcyBtdXRhdGlvbi5cbiAgICAgKiBAcGFyYW0gYmFzZU11dGF0aW9ucyAtIE11dGF0aW9ucyB0aGF0IGFyZSB1c2VkIHRvIHBvcHVsYXRlIHRoZSBiYXNlXG4gICAgICogdmFsdWVzIHdoZW4gdGhpcyBtdXRhdGlvbiBpcyBhcHBsaWVkIGxvY2FsbHkuIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9jYWxseVxuICAgICAqIG92ZXJ3cml0ZSB2YWx1ZXMgdGhhdCBhcmUgcGVyc2lzdGVkIGluIHRoZSByZW1vdGUgZG9jdW1lbnQgY2FjaGUuIEJhc2VcbiAgICAgKiBtdXRhdGlvbnMgYXJlIG5ldmVyIHNlbnQgdG8gdGhlIGJhY2tlbmQuXG4gICAgICogQHBhcmFtIG11dGF0aW9ucyAtIFRoZSB1c2VyLXByb3ZpZGVkIG11dGF0aW9ucyBpbiB0aGlzIG11dGF0aW9uIGJhdGNoLlxuICAgICAqIFVzZXItcHJvdmlkZWQgbXV0YXRpb25zIGFyZSBhcHBsaWVkIGJvdGggbG9jYWxseSBhbmQgcmVtb3RlbHkgb24gdGhlXG4gICAgICogYmFja2VuZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihiYXRjaElkLCBsb2NhbFdyaXRlVGltZSwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKSB7XG4gICAgICAgIHRoaXMuYmF0Y2hJZCA9IGJhdGNoSWQ7XG4gICAgICAgIHRoaXMubG9jYWxXcml0ZVRpbWUgPSBsb2NhbFdyaXRlVGltZTtcbiAgICAgICAgdGhpcy5iYXNlTXV0YXRpb25zID0gYmFzZU11dGF0aW9ucztcbiAgICAgICAgdGhpcy5tdXRhdGlvbnMgPSBtdXRhdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYWxsIHRoZSBtdXRhdGlvbnMgaW4gdGhpcyBNdXRhdGlvbkJhdGNoIHRvIHRoZSBzcGVjaWZpZWQgZG9jdW1lbnRcbiAgICAgKiB0byBjb21wdXRlIHRoZSBzdGF0ZSBvZiB0aGUgcmVtb3RlIGRvY3VtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgLSBUaGUgZG9jdW1lbnQgdG8gYXBwbHkgbXV0YXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSBiYXRjaFJlc3VsdCAtIFRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIE11dGF0aW9uQmF0Y2ggdG8gdGhlXG4gICAgICogYmFja2VuZC5cbiAgICAgKi9cbiAgICBhcHBseVRvUmVtb3RlRG9jdW1lbnQoZG9jdW1lbnQsIGJhdGNoUmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uUmVzdWx0cyA9IGJhdGNoUmVzdWx0Lm11dGF0aW9uUmVzdWx0cztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbXV0YXRpb24gPSB0aGlzLm11dGF0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi5rZXkuaXNFcXVhbChkb2N1bWVudC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXV0YXRpb25SZXN1bHQgPSBtdXRhdGlvblJlc3VsdHNbaV07XG4gICAgICAgICAgICAgICAgbXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGxvY2FsIHZpZXcgb2YgYSBkb2N1bWVudCBnaXZlbiBhbGwgdGhlIG11dGF0aW9ucyBpbiB0aGlzXG4gICAgICogYmF0Y2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgLSBUaGUgZG9jdW1lbnQgdG8gYXBwbHkgbXV0YXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSBtdXRhdGVkRmllbGRzIC0gRmllbGRzIHRoYXQgaGF2ZSBiZWVuIHVwZGF0ZWQgYmVmb3JlIGFwcGx5aW5nIHRoaXMgbXV0YXRpb24gYmF0Y2guXG4gICAgICogQHJldHVybnMgQSBgRmllbGRNYXNrYCByZXByZXNlbnRpbmcgYWxsIHRoZSBmaWVsZHMgdGhhdCBhcmUgbXV0YXRlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvTG9jYWxWaWV3KGRvY3VtZW50LCBtdXRhdGVkRmllbGRzKSB7XG4gICAgICAgIC8vIEZpcnN0LCBhcHBseSB0aGUgYmFzZSBzdGF0ZS4gVGhpcyBhbGxvd3MgdXMgdG8gYXBwbHkgbm9uLWlkZW1wb3RlbnRcbiAgICAgICAgLy8gdHJhbnNmb3JtIGFnYWluc3QgYSBjb25zaXN0ZW50IHNldCBvZiB2YWx1ZXMuXG4gICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgdGhpcy5iYXNlTXV0YXRpb25zKSB7XG4gICAgICAgICAgICBpZiAobXV0YXRpb24ua2V5LmlzRXF1YWwoZG9jdW1lbnQua2V5KSkge1xuICAgICAgICAgICAgICAgIG11dGF0ZWRGaWVsZHMgPSBtdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGVkRmllbGRzLCB0aGlzLmxvY2FsV3JpdGVUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZWNvbmQsIGFwcGx5IGFsbCB1c2VyLXByb3ZpZGVkIG11dGF0aW9ucy5cbiAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiB0aGlzLm11dGF0aW9ucykge1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLmtleS5pc0VxdWFsKGRvY3VtZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICBtdXRhdGVkRmllbGRzID0gbXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRlZEZpZWxkcywgdGhpcy5sb2NhbFdyaXRlVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG11dGF0ZWRGaWVsZHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBsb2NhbCB2aWV3IGZvciBhbGwgcHJvdmlkZWQgZG9jdW1lbnRzIGdpdmVuIHRoZSBtdXRhdGlvbnMgaW5cbiAgICAgKiB0aGlzIGJhdGNoLiBSZXR1cm5zIGEgYERvY3VtZW50S2V5YCB0byBgTXV0YXRpb25gIG1hcCB3aGljaCBjYW4gYmUgdXNlZCB0b1xuICAgICAqIHJlcGxhY2UgYWxsIHRoZSBtdXRhdGlvbiBhcHBsaWNhdGlvbnMuXG4gICAgICovXG4gICAgYXBwbHlUb0xvY2FsRG9jdW1lbnRTZXQoZG9jdW1lbnRNYXAsIGRvY3VtZW50c1dpdGhvdXRSZW1vdGVWZXJzaW9uKSB7XG4gICAgICAgIC8vIFRPRE8obXJzY2htaWR0KTogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBPKG5eMikuIElmIHdlIGFwcGx5IHRoZSBtdXRhdGlvbnNcbiAgICAgICAgLy8gZGlyZWN0bHkgKGFzIGRvbmUgaW4gYGFwcGx5VG9Mb2NhbFZpZXcoKWApLCB3ZSBjYW4gcmVkdWNlIHRoZSBjb21wbGV4aXR5XG4gICAgICAgIC8vIHRvIE8obikuXG4gICAgICAgIGNvbnN0IG92ZXJsYXlzID0gbmV3TXV0YXRpb25NYXAoKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbnMuZm9yRWFjaChtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXllZERvY3VtZW50ID0gZG9jdW1lbnRNYXAuZ2V0KG0ua2V5KTtcbiAgICAgICAgICAgIC8vIFRPRE8obXV0YWJsZWRvY3VtZW50cyk6IFRoaXMgbWV0aG9kIHNob3VsZCB0YWtlIGEgTXV0YWJsZURvY3VtZW50TWFwXG4gICAgICAgICAgICAvLyBhbmQgd2Ugc2hvdWxkIHJlbW92ZSB0aGlzIGNhc3QuXG4gICAgICAgICAgICBjb25zdCBtdXRhYmxlRG9jdW1lbnQgPSBvdmVybGF5ZWREb2N1bWVudC5vdmVybGF5ZWREb2N1bWVudDtcbiAgICAgICAgICAgIGxldCBtdXRhdGVkRmllbGRzID0gdGhpcy5hcHBseVRvTG9jYWxWaWV3KG11dGFibGVEb2N1bWVudCwgb3ZlcmxheWVkRG9jdW1lbnQubXV0YXRlZEZpZWxkcyk7XG4gICAgICAgICAgICAvLyBTZXQgbXV0YXRlZEZpZWxkcyB0byBudWxsIGlmIHRoZSBkb2N1bWVudCBpcyBvbmx5IGZyb20gbG9jYWwgbXV0YXRpb25zLlxuICAgICAgICAgICAgLy8gVGhpcyBjcmVhdGVzIGEgU2V0IG9yIERlbGV0ZSBtdXRhdGlvbiwgaW5zdGVhZCBvZiB0cnlpbmcgdG8gY3JlYXRlIGFcbiAgICAgICAgICAgIC8vIHBhdGNoIG11dGF0aW9uIGFzIHRoZSBvdmVybGF5LlxuICAgICAgICAgICAgbXV0YXRlZEZpZWxkcyA9IGRvY3VtZW50c1dpdGhvdXRSZW1vdGVWZXJzaW9uLmhhcyhtLmtleSlcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IG11dGF0ZWRGaWVsZHM7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gY2FsY3VsYXRlT3ZlcmxheU11dGF0aW9uKG11dGFibGVEb2N1bWVudCwgbXV0YXRlZEZpZWxkcyk7XG4gICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG92ZXJsYXlzLnNldChtLmtleSwgb3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW11dGFibGVEb2N1bWVudC5pc1ZhbGlkRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIG11dGFibGVEb2N1bWVudC5jb252ZXJ0VG9Ob0RvY3VtZW50KFNuYXBzaG90VmVyc2lvbi5taW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3ZlcmxheXM7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11dGF0aW9ucy5yZWR1Y2UoKGtleXMsIG0pID0+IGtleXMuYWRkKG0ua2V5KSwgZG9jdW1lbnRLZXlTZXQoKSk7XG4gICAgfVxuICAgIGlzRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhdGNoSWQgPT09IG90aGVyLmJhdGNoSWQgJiZcbiAgICAgICAgICAgIGFycmF5RXF1YWxzKHRoaXMubXV0YXRpb25zLCBvdGhlci5tdXRhdGlvbnMsIChsLCByKSA9PiBtdXRhdGlvbkVxdWFscyhsLCByKSkgJiZcbiAgICAgICAgICAgIGFycmF5RXF1YWxzKHRoaXMuYmFzZU11dGF0aW9ucywgb3RoZXIuYmFzZU11dGF0aW9ucywgKGwsIHIpID0+IG11dGF0aW9uRXF1YWxzKGwsIHIpKSk7XG4gICAgfVxufVxuLyoqIFRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYSBtdXRhdGlvbiBiYXRjaCB0byB0aGUgYmFja2VuZC4gKi9cbmNsYXNzIE11dGF0aW9uQmF0Y2hSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKGJhdGNoLCBjb21taXRWZXJzaW9uLCBtdXRhdGlvblJlc3VsdHMsIFxuICAgIC8qKlxuICAgICAqIEEgcHJlLWNvbXB1dGVkIG1hcHBpbmcgZnJvbSBlYWNoIG11dGF0ZWQgZG9jdW1lbnQgdG8gdGhlIHJlc3VsdGluZ1xuICAgICAqIHZlcnNpb24uXG4gICAgICovXG4gICAgZG9jVmVyc2lvbnMpIHtcbiAgICAgICAgdGhpcy5iYXRjaCA9IGJhdGNoO1xuICAgICAgICB0aGlzLmNvbW1pdFZlcnNpb24gPSBjb21taXRWZXJzaW9uO1xuICAgICAgICB0aGlzLm11dGF0aW9uUmVzdWx0cyA9IG11dGF0aW9uUmVzdWx0cztcbiAgICAgICAgdGhpcy5kb2NWZXJzaW9ucyA9IGRvY1ZlcnNpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE11dGF0aW9uQmF0Y2hSZXN1bHQgZm9yIHRoZSBnaXZlbiBiYXRjaCBhbmQgcmVzdWx0cy4gVGhlcmVcbiAgICAgKiBtdXN0IGJlIG9uZSByZXN1bHQgZm9yIGVhY2ggbXV0YXRpb24gaW4gdGhlIGJhdGNoLiBUaGlzIHN0YXRpYyBmYWN0b3J5XG4gICAgICogY2FjaGVzIGEgZG9jdW1lbnQ9Jmd0O3ZlcnNpb24gbWFwcGluZyAoZG9jVmVyc2lvbnMpLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKGJhdGNoLCBjb21taXRWZXJzaW9uLCByZXN1bHRzKSB7XG4gICAgICAgIGhhcmRBc3NlcnQoYmF0Y2gubXV0YXRpb25zLmxlbmd0aCA9PT0gcmVzdWx0cy5sZW5ndGgpO1xuICAgICAgICBsZXQgdmVyc2lvbk1hcCA9IGRvY3VtZW50VmVyc2lvbk1hcCgpO1xuICAgICAgICBjb25zdCBtdXRhdGlvbnMgPSBiYXRjaC5tdXRhdGlvbnM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJzaW9uTWFwID0gdmVyc2lvbk1hcC5pbnNlcnQobXV0YXRpb25zW2ldLmtleSwgcmVzdWx0c1tpXS52ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE11dGF0aW9uQmF0Y2hSZXN1bHQoYmF0Y2gsIGNvbW1pdFZlcnNpb24sIHJlc3VsdHMsIHZlcnNpb25NYXApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYW4gb3ZlcmxheSBjb21wdXRlZCBieSBGaXJlc3RvcmUuXG4gKlxuICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgYSBtdXRhdGlvbiBhbmQgdGhlIGxhcmdlc3QgYmF0Y2ggaWQgaW4gRmlyZXN0b3JlIHdoZW5cbiAqIHRoZSBtdXRhdGlvbiB3YXMgY3JlYXRlZC5cbiAqL1xuY2xhc3MgT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IobGFyZ2VzdEJhdGNoSWQsIG11dGF0aW9uKSB7XG4gICAgICAgIHRoaXMubGFyZ2VzdEJhdGNoSWQgPSBsYXJnZXN0QmF0Y2hJZDtcbiAgICAgICAgdGhpcy5tdXRhdGlvbiA9IG11dGF0aW9uO1xuICAgIH1cbiAgICBnZXRLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11dGF0aW9uLmtleTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgIT09IG51bGwgJiYgdGhpcy5tdXRhdGlvbiA9PT0gb3RoZXIubXV0YXRpb247XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYE92ZXJsYXl7XG4gICAgICBsYXJnZXN0QmF0Y2hJZDogJHt0aGlzLmxhcmdlc3RCYXRjaElkfSxcbiAgICAgIG11dGF0aW9uOiAke3RoaXMubXV0YXRpb24udG9TdHJpbmcoKX1cbiAgICB9YDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBFeGlzdGVuY2VGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvdW50LCB1bmNoYW5nZWROYW1lcykge1xuICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICAgIHRoaXMudW5jaGFuZ2VkTmFtZXMgPSB1bmNoYW5nZWROYW1lcztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEVycm9yIENvZGVzIGRlc2NyaWJpbmcgdGhlIGRpZmZlcmVudCB3YXlzIEdSUEMgY2FuIGZhaWwuIFRoZXNlIGFyZSBjb3BpZWRcbiAqIGRpcmVjdGx5IGZyb20gR1JQQydzIHNvdXJjZXMgaGVyZTpcbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvYmNlZWM5NGVhNGZjNWYwMDg1ZDgxMjM1ZDhlMWMwNjc5OGRjMzQxYS9pbmNsdWRlL2dycGMlMkIlMkIvaW1wbC9jb2RlZ2VuL3N0YXR1c19jb2RlX2VudW0uaFxuICpcbiAqIEltcG9ydGFudCEgVGhlIG5hbWVzIG9mIHRoZXNlIGlkZW50aWZpZXJzIG1hdHRlciBiZWNhdXNlIHRoZSBzdHJpbmcgZm9ybXNcbiAqIGFyZSB1c2VkIGZvciByZXZlcnNlIGxvb2t1cHMgZnJvbSB0aGUgd2ViY2hhbm5lbCBzdHJlYW0uIERvIE5PVCBjaGFuZ2UgdGhlXG4gKiBuYW1lcyBvZiB0aGVzZSBpZGVudGlmaWVycyBvciBjaGFuZ2UgdGhpcyBpbnRvIGEgY29uc3QgZW51bS5cbiAqL1xudmFyIFJwY0NvZGU7XG4oZnVuY3Rpb24gKFJwY0NvZGUpIHtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIkNBTkNFTExFRFwiXSA9IDFdID0gXCJDQU5DRUxMRURcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJVTktOT1dOXCJdID0gMl0gPSBcIlVOS05PV05cIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gM10gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJERUFETElORV9FWENFRURFRFwiXSA9IDRdID0gXCJERUFETElORV9FWENFRURFRFwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIk5PVF9GT1VORFwiXSA9IDVdID0gXCJOT1RfRk9VTkRcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJBTFJFQURZX0VYSVNUU1wiXSA9IDZdID0gXCJBTFJFQURZX0VYSVNUU1wiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIlBFUk1JU1NJT05fREVOSUVEXCJdID0gN10gPSBcIlBFUk1JU1NJT05fREVOSUVEXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiVU5BVVRIRU5USUNBVEVEXCJdID0gMTZdID0gXCJVTkFVVEhFTlRJQ0FURURcIjtcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJSRVNPVVJDRV9FWEhBVVNURURcIl0gPSA4XSA9IFwiUkVTT1VSQ0VfRVhIQVVTVEVEXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiRkFJTEVEX1BSRUNPTkRJVElPTlwiXSA9IDldID0gXCJGQUlMRURfUFJFQ09ORElUSU9OXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiQUJPUlRFRFwiXSA9IDEwXSA9IFwiQUJPUlRFRFwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIk9VVF9PRl9SQU5HRVwiXSA9IDExXSA9IFwiT1VUX09GX1JBTkdFXCI7XG4gICAgUnBjQ29kZVtScGNDb2RlW1wiVU5JTVBMRU1FTlRFRFwiXSA9IDEyXSA9IFwiVU5JTVBMRU1FTlRFRFwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIklOVEVSTkFMXCJdID0gMTNdID0gXCJJTlRFUk5BTFwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIlVOQVZBSUxBQkxFXCJdID0gMTRdID0gXCJVTkFWQUlMQUJMRVwiO1xuICAgIFJwY0NvZGVbUnBjQ29kZVtcIkRBVEFfTE9TU1wiXSA9IDE1XSA9IFwiREFUQV9MT1NTXCI7XG59KShScGNDb2RlIHx8IChScGNDb2RlID0ge30pKTtcbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGVycm9yIGNvZGUgcmVwcmVzZW50cyBhIHBlcm1hbmVudCBlcnJvciB3aGVuIHJlY2VpdmVkXG4gKiBpbiByZXNwb25zZSB0byBhIG5vbi13cml0ZSBvcGVyYXRpb24uXG4gKlxuICogU2VlIGlzUGVybWFuZW50V3JpdGVFcnJvciBmb3IgY2xhc3NpZnlpbmcgd3JpdGUgZXJyb3JzLlxuICovXG5mdW5jdGlvbiBpc1Blcm1hbmVudEVycm9yKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSBDb2RlLk9LOlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICAgICAgY2FzZSBDb2RlLkNBTkNFTExFRDpcbiAgICAgICAgY2FzZSBDb2RlLlVOS05PV046XG4gICAgICAgIGNhc2UgQ29kZS5ERUFETElORV9FWENFRURFRDpcbiAgICAgICAgY2FzZSBDb2RlLlJFU09VUkNFX0VYSEFVU1RFRDpcbiAgICAgICAgY2FzZSBDb2RlLklOVEVSTkFMOlxuICAgICAgICBjYXNlIENvZGUuVU5BVkFJTEFCTEU6XG4gICAgICAgIC8vIFVuYXV0aGVudGljYXRlZCBtZWFucyBzb21ldGhpbmcgd2VudCB3cm9uZyB3aXRoIG91ciB0b2tlbiBhbmQgd2UgbmVlZFxuICAgICAgICAvLyB0byByZXRyeSB3aXRoIG5ldyBjcmVkZW50aWFscyB3aGljaCB3aWxsIGhhcHBlbiBhdXRvbWF0aWNhbGx5LlxuICAgICAgICBjYXNlIENvZGUuVU5BVVRIRU5USUNBVEVEOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlIENvZGUuSU5WQUxJRF9BUkdVTUVOVDpcbiAgICAgICAgY2FzZSBDb2RlLk5PVF9GT1VORDpcbiAgICAgICAgY2FzZSBDb2RlLkFMUkVBRFlfRVhJU1RTOlxuICAgICAgICBjYXNlIENvZGUuUEVSTUlTU0lPTl9ERU5JRUQ6XG4gICAgICAgIGNhc2UgQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OOlxuICAgICAgICAvLyBBYm9ydGVkIG1pZ2h0IGJlIHJldHJpZWQgaW4gc29tZSBzY2VuYXJpb3MsIGJ1dCB0aGF0IGlzIGRlcGVuZGVudCBvblxuICAgICAgICAvLyB0aGUgY29udGV4dCBhbmQgc2hvdWxkIGhhbmRsZWQgaW5kaXZpZHVhbGx5IGJ5IHRoZSBjYWxsaW5nIGNvZGUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYXBpcy9kZXNpZ24vZXJyb3JzLlxuICAgICAgICBjYXNlIENvZGUuQUJPUlRFRDpcbiAgICAgICAgY2FzZSBDb2RlLk9VVF9PRl9SQU5HRTpcbiAgICAgICAgY2FzZSBDb2RlLlVOSU1QTEVNRU5URUQ6XG4gICAgICAgIGNhc2UgQ29kZS5EQVRBX0xPU1M6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gZXJyb3IgY29kZSByZXByZXNlbnRzIGEgcGVybWFuZW50IGVycm9yIHdoZW4gcmVjZWl2ZWRcbiAqIGluIHJlc3BvbnNlIHRvIGEgd3JpdGUgb3BlcmF0aW9uLlxuICpcbiAqIFdyaXRlIG9wZXJhdGlvbnMgbXVzdCBiZSBoYW5kbGVkIHNwZWNpYWxseSBiZWNhdXNlIGFzIG9mIGIvMTE5NDM3NzY0LCBBQk9SVEVEXG4gKiBlcnJvcnMgb24gdGhlIHdyaXRlIHN0cmVhbSBzaG91bGQgYmUgcmV0cmllZCB0b28gKGV2ZW4gdGhvdWdoIEFCT1JURUQgZXJyb3JzXG4gKiBhcmUgbm90IGdlbmVyYWxseSByZXRyeWFibGUpLlxuICpcbiAqIE5vdGUgdGhhdCBkdXJpbmcgdGhlIGluaXRpYWwgaGFuZHNoYWtlIG9uIHRoZSB3cml0ZSBzdHJlYW0gYW4gQUJPUlRFRCBlcnJvclxuICogc2lnbmFscyB0aGF0IHdlIHNob3VsZCBkaXNjYXJkIG91ciBzdHJlYW0gdG9rZW4gKGkuZS4gaXQgaXMgcGVybWFuZW50KS4gVGhpc1xuICogbWVhbnMgYSBoYW5kc2hha2UgZXJyb3Igc2hvdWxkIGJlIGNsYXNzaWZpZWQgd2l0aCBpc1Blcm1hbmVudEVycm9yLCBhYm92ZS5cbiAqL1xuZnVuY3Rpb24gaXNQZXJtYW5lbnRXcml0ZUVycm9yKGNvZGUpIHtcbiAgICByZXR1cm4gaXNQZXJtYW5lbnRFcnJvcihjb2RlKSAmJiBjb2RlICE9PSBDb2RlLkFCT1JURUQ7XG59XG4vKipcbiAqIE1hcHMgYW4gZXJyb3IgQ29kZSBmcm9tIEdSUEMgc3RhdHVzIGNvZGUgbnVtYmVyLCBsaWtlIDAsIDEsIG9yIDE0LiBUaGVzZVxuICogYXJlIG5vdCB0aGUgc2FtZSBhcyBIVFRQIHN0YXR1cyBjb2Rlcy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgQ29kZSBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiBHUlBDIHN0YXR1cyBjb2RlLiBGYWlscyBpZiB0aGVyZVxuICogICAgIGlzIG5vIG1hdGNoLlxuICovXG5mdW5jdGlvbiBtYXBDb2RlRnJvbVJwY0NvZGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3Qgbm9ybWFsbHkgaGFwcGVuLCBidXQgaW4gY2VydGFpbiBlcnJvciBjYXNlcyAobGlrZSB0cnlpbmdcbiAgICAgICAgLy8gdG8gc2VuZCBpbnZhbGlkIHByb3RvIG1lc3NhZ2VzKSB3ZSBtYXkgZ2V0IGFuIGVycm9yIHdpdGggbm8gR1JQQyBjb2RlLlxuICAgICAgICBsb2dFcnJvcignR1JQQyBlcnJvciBoYXMgbm8gLmNvZGUnKTtcbiAgICAgICAgcmV0dXJuIENvZGUuVU5LTk9XTjtcbiAgICB9XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5PSzpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLk9LO1xuICAgICAgICBjYXNlIFJwY0NvZGUuQ0FOQ0VMTEVEOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuQ0FOQ0VMTEVEO1xuICAgICAgICBjYXNlIFJwY0NvZGUuVU5LTk9XTjpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlVOS05PV047XG4gICAgICAgIGNhc2UgUnBjQ29kZS5ERUFETElORV9FWENFRURFRDpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkRFQURMSU5FX0VYQ0VFREVEO1xuICAgICAgICBjYXNlIFJwY0NvZGUuUkVTT1VSQ0VfRVhIQVVTVEVEOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuUkVTT1VSQ0VfRVhIQVVTVEVEO1xuICAgICAgICBjYXNlIFJwY0NvZGUuSU5URVJOQUw6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5JTlRFUk5BTDtcbiAgICAgICAgY2FzZSBScGNDb2RlLlVOQVZBSUxBQkxFOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVU5BVkFJTEFCTEU7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5VTkFVVEhFTlRJQ0FURUQ6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5VTkFVVEhFTlRJQ0FURUQ7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5JTlZBTElEX0FSR1VNRU5UOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuSU5WQUxJRF9BUkdVTUVOVDtcbiAgICAgICAgY2FzZSBScGNDb2RlLk5PVF9GT1VORDpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLk5PVF9GT1VORDtcbiAgICAgICAgY2FzZSBScGNDb2RlLkFMUkVBRFlfRVhJU1RTOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuQUxSRUFEWV9FWElTVFM7XG4gICAgICAgIGNhc2UgUnBjQ29kZS5QRVJNSVNTSU9OX0RFTklFRDpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlBFUk1JU1NJT05fREVOSUVEO1xuICAgICAgICBjYXNlIFJwY0NvZGUuRkFJTEVEX1BSRUNPTkRJVElPTjpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkZBSUxFRF9QUkVDT05ESVRJT047XG4gICAgICAgIGNhc2UgUnBjQ29kZS5BQk9SVEVEOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuQUJPUlRFRDtcbiAgICAgICAgY2FzZSBScGNDb2RlLk9VVF9PRl9SQU5HRTpcbiAgICAgICAgICAgIHJldHVybiBDb2RlLk9VVF9PRl9SQU5HRTtcbiAgICAgICAgY2FzZSBScGNDb2RlLlVOSU1QTEVNRU5URUQ6XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5VTklNUExFTUVOVEVEO1xuICAgICAgICBjYXNlIFJwY0NvZGUuREFUQV9MT1NTOlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuREFUQV9MT1NTO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGVycm9yIGVuY291bnRlcmVkIHdoaWxlIGRlY29kaW5nIGJhc2U2NCBzdHJpbmcuXG4gKi9cbmNsYXNzIEJhc2U2NERlY29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQmFzZTY0RGVjb2RlRXJyb3InO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhlIGdsb2JhbCwgc2luZ2xldG9uIGluc3RhbmNlIG9mIFRlc3RpbmdIb29rc1NwaS5cbiAqXG4gKiBUaGlzIHZhcmlhYmxlIHdpbGwgYmUgYG51bGxgIGluIGFsbCBjYXNlcyBfZXhjZXB0XyB3aGVuIHJ1bm5pbmcgZnJvbVxuICogaW50ZWdyYXRpb24gdGVzdHMgdGhhdCBoYXZlIHJlZ2lzdGVyZWQgY2FsbGJhY2tzIHRvIGJlIG5vdGlmaWVkIG9mIGV2ZW50c1xuICogdGhhdCBoYXBwZW4gZHVyaW5nIHRoZSB0ZXN0IGV4ZWN1dGlvbi5cbiAqL1xubGV0IHRlc3RpbmdIb29rc1NwaSA9IG51bGw7XG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBgdGVzdGluZ0hvb2tzU3BpYCBvYmplY3QuXG4gKiBAcGFyYW0gaW5zdGFuY2UgdGhlIGluc3RhbmNlIHRvIHNldC5cbiAqL1xuZnVuY3Rpb24gc2V0VGVzdGluZ0hvb2tzU3BpKGluc3RhbmNlKSB7XG4gICAgaWYgKHRlc3RpbmdIb29rc1NwaSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2EgVGVzdGluZ0hvb2tzU3BpIGluc3RhbmNlIGlzIGFscmVhZHkgc2V0Jyk7XG4gICAgfVxuICAgIHRlc3RpbmdIb29rc1NwaSA9IGluc3RhbmNlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTUFYXzY0X0JJVF9VTlNJR05FRF9JTlRFR0VSID0gbmV3IEludGVnZXIoWzB4ZmZmZmZmZmYsIDB4ZmZmZmZmZmZdLCAwKTtcbi8vIEhhc2ggYSBzdHJpbmcgdXNpbmcgbWQ1IGhhc2hpbmcgYWxnb3JpdGhtLlxuZnVuY3Rpb24gZ2V0TWQ1SGFzaFZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgZW5jb2RlZFZhbHVlID0gbmV3VGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpO1xuICAgIGNvbnN0IG1kNSA9IG5ldyBNZDUoKTtcbiAgICBtZDUudXBkYXRlKGVuY29kZWRWYWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG1kNS5kaWdlc3QoKSk7XG59XG4vLyBJbnRlcnByZXQgdGhlIDE2IGJ5dGVzIGFycmF5IGFzIHR3byA2NC1iaXQgdW5zaWduZWQgaW50ZWdlcnMsIGVuY29kZWQgdXNpbmdcbi8vIDLigJlzIGNvbXBsZW1lbnQgdXNpbmcgbGl0dGxlIGVuZGlhbi5cbmZ1bmN0aW9uIGdldDY0Qml0VWludHMoQnl0ZXMpIHtcbiAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhCeXRlcy5idWZmZXIpO1xuICAgIGNvbnN0IGNodW5rMSA9IGRhdGFWaWV3LmdldFVpbnQzMigwLCAvKiBsaXR0bGVFbmRpYW49ICovIHRydWUpO1xuICAgIGNvbnN0IGNodW5rMiA9IGRhdGFWaWV3LmdldFVpbnQzMig0LCAvKiBsaXR0bGVFbmRpYW49ICovIHRydWUpO1xuICAgIGNvbnN0IGNodW5rMyA9IGRhdGFWaWV3LmdldFVpbnQzMig4LCAvKiBsaXR0bGVFbmRpYW49ICovIHRydWUpO1xuICAgIGNvbnN0IGNodW5rNCA9IGRhdGFWaWV3LmdldFVpbnQzMigxMiwgLyogbGl0dGxlRW5kaWFuPSAqLyB0cnVlKTtcbiAgICBjb25zdCBpbnRlZ2VyMSA9IG5ldyBJbnRlZ2VyKFtjaHVuazEsIGNodW5rMl0sIDApO1xuICAgIGNvbnN0IGludGVnZXIyID0gbmV3IEludGVnZXIoW2NodW5rMywgY2h1bms0XSwgMCk7XG4gICAgcmV0dXJuIFtpbnRlZ2VyMSwgaW50ZWdlcjJdO1xufVxuY2xhc3MgQmxvb21GaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGJpdG1hcCwgcGFkZGluZywgaGFzaENvdW50KSB7XG4gICAgICAgIHRoaXMuYml0bWFwID0gYml0bWFwO1xuICAgICAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICB0aGlzLmhhc2hDb3VudCA9IGhhc2hDb3VudDtcbiAgICAgICAgaWYgKHBhZGRpbmcgPCAwIHx8IHBhZGRpbmcgPj0gOCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJsb29tRmlsdGVyRXJyb3IoYEludmFsaWQgcGFkZGluZzogJHtwYWRkaW5nfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNoQ291bnQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQmxvb21GaWx0ZXJFcnJvcihgSW52YWxpZCBoYXNoIGNvdW50OiAke2hhc2hDb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYml0bWFwLmxlbmd0aCA+IDAgJiYgdGhpcy5oYXNoQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIC8vIE9ubHkgZW1wdHkgYmxvb20gZmlsdGVyIGNhbiBoYXZlIDAgaGFzaCBjb3VudC5cbiAgICAgICAgICAgIHRocm93IG5ldyBCbG9vbUZpbHRlckVycm9yKGBJbnZhbGlkIGhhc2ggY291bnQ6ICR7aGFzaENvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaXRtYXAubGVuZ3RoID09PSAwICYmIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgICAgIC8vIEVtcHR5IGJsb29tIGZpbHRlciBzaG91bGQgaGF2ZSAwIHBhZGRpbmcuXG4gICAgICAgICAgICB0aHJvdyBuZXcgQmxvb21GaWx0ZXJFcnJvcihgSW52YWxpZCBwYWRkaW5nIHdoZW4gYml0bWFwIGxlbmd0aCBpcyAwOiAke3BhZGRpbmd9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaXRDb3VudCA9IGJpdG1hcC5sZW5ndGggKiA4IC0gcGFkZGluZztcbiAgICAgICAgLy8gU2V0IHRoZSBiaXQgY291bnQgaW4gSW50ZWdlciB0byBhdm9pZCByZXBldGl0aW9uIGluIG1pZ2h0Q29udGFpbigpLlxuICAgICAgICB0aGlzLmJpdENvdW50SW5JbnRlZ2VyID0gSW50ZWdlci5mcm9tTnVtYmVyKHRoaXMuYml0Q291bnQpO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGl0aCBoYXNoIHZhbHVlIGJhc2VkIG9uIHRoZSBoYXNoZWQgNjRiaXQgaW50ZWdlcnMsXG4gICAgLy8gYW5kIGNhbGN1bGF0ZSBpdHMgY29ycmVzcG9uZGluZyBiaXQgaW5kZXggaW4gdGhlIGJpdG1hcCB0byBiZSBjaGVja2VkLlxuICAgIGdldEJpdEluZGV4KG51bTEsIG51bTIsIGhhc2hJbmRleCkge1xuICAgICAgICAvLyBDYWxjdWxhdGUgaGFzaGVkIHZhbHVlIGgoaSkgPSBoMSArIChpICogaDIpLlxuICAgICAgICBsZXQgaGFzaFZhbHVlID0gbnVtMS5hZGQobnVtMi5tdWx0aXBseShJbnRlZ2VyLmZyb21OdW1iZXIoaGFzaEluZGV4KSkpO1xuICAgICAgICAvLyBXcmFwIGlmIGhhc2ggdmFsdWUgb3ZlcmZsb3cgNjRiaXQuXG4gICAgICAgIGlmIChoYXNoVmFsdWUuY29tcGFyZShNQVhfNjRfQklUX1VOU0lHTkVEX0lOVEVHRVIpID09PSAxKSB7XG4gICAgICAgICAgICBoYXNoVmFsdWUgPSBuZXcgSW50ZWdlcihbaGFzaFZhbHVlLmdldEJpdHMoMCksIGhhc2hWYWx1ZS5nZXRCaXRzKDEpXSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc2hWYWx1ZS5tb2R1bG8odGhpcy5iaXRDb3VudEluSW50ZWdlcikudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHdoZXRoZXIgdGhlIGJpdCBvbiB0aGUgZ2l2ZW4gaW5kZXggaW4gdGhlIGJpdG1hcCBpcyBzZXQgdG8gMS5cbiAgICBpc0JpdFNldChpbmRleCkge1xuICAgICAgICAvLyBUbyByZXRyaWV2ZSBiaXQgbiwgY2FsY3VsYXRlOiAoYml0bWFwW24gLyA4XSAmICgweDAxIDw8IChuICUgOCkpKS5cbiAgICAgICAgY29uc3QgYnl0ZSA9IHRoaXMuYml0bWFwW01hdGguZmxvb3IoaW5kZXggLyA4KV07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGluZGV4ICUgODtcbiAgICAgICAgcmV0dXJuIChieXRlICYgKDB4MDEgPDwgb2Zmc2V0KSkgIT09IDA7XG4gICAgfVxuICAgIG1pZ2h0Q29udGFpbih2YWx1ZSkge1xuICAgICAgICAvLyBFbXB0eSBiaXRtYXAgc2hvdWxkIGFsd2F5cyByZXR1cm4gZmFsc2Ugb24gbWVtYmVyc2hpcCBjaGVjay5cbiAgICAgICAgaWYgKHRoaXMuYml0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZDVIYXNoZWRWYWx1ZSA9IGdldE1kNUhhc2hWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IFtoYXNoMSwgaGFzaDJdID0gZ2V0NjRCaXRVaW50cyhtZDVIYXNoZWRWYWx1ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5oYXNoQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEJpdEluZGV4KGhhc2gxLCBoYXNoMiwgaSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNCaXRTZXQoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIGJsb29tIGZpbHRlciBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LiAqL1xuICAgIHN0YXRpYyBjcmVhdGUoYml0Q291bnQsIGhhc2hDb3VudCwgY29udGFpbnMpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IGJpdENvdW50ICUgOCA9PT0gMCA/IDAgOiA4IC0gKGJpdENvdW50ICUgOCk7XG4gICAgICAgIGNvbnN0IGJpdG1hcCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChiaXRDb3VudCAvIDgpKTtcbiAgICAgICAgY29uc3QgYmxvb21GaWx0ZXIgPSBuZXcgQmxvb21GaWx0ZXIoYml0bWFwLCBwYWRkaW5nLCBoYXNoQ291bnQpO1xuICAgICAgICBjb250YWlucy5mb3JFYWNoKGl0ZW0gPT4gYmxvb21GaWx0ZXIuaW5zZXJ0KGl0ZW0pKTtcbiAgICAgICAgcmV0dXJuIGJsb29tRmlsdGVyO1xuICAgIH1cbiAgICBpbnNlcnQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYml0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZDVIYXNoZWRWYWx1ZSA9IGdldE1kNUhhc2hWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IFtoYXNoMSwgaGFzaDJdID0gZ2V0NjRCaXRVaW50cyhtZDVIYXNoZWRWYWx1ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5oYXNoQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEJpdEluZGV4KGhhc2gxLCBoYXNoMiwgaSk7XG4gICAgICAgICAgICB0aGlzLnNldEJpdChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Qml0KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZGV4T2ZCeXRlID0gTWF0aC5mbG9vcihpbmRleCAvIDgpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAlIDg7XG4gICAgICAgIHRoaXMuYml0bWFwW2luZGV4T2ZCeXRlXSB8PSAweDAxIDw8IG9mZnNldDtcbiAgICB9XG59XG5jbGFzcyBCbG9vbUZpbHRlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQmxvb21GaWx0ZXJFcnJvcic7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBldmVudCBmcm9tIHRoZSBSZW1vdGVTdG9yZS4gSXQgaXMgc3BsaXQgaW50byB0YXJnZXRDaGFuZ2VzIChjaGFuZ2VzIHRvIHRoZVxuICogc3RhdGUgb3IgdGhlIHNldCBvZiBkb2N1bWVudHMgaW4gb3VyIHdhdGNoZWQgdGFyZ2V0cykgYW5kIGRvY3VtZW50VXBkYXRlc1xuICogKGNoYW5nZXMgdG8gdGhlIGFjdHVhbCBkb2N1bWVudHMpLlxuICovXG5jbGFzcyBSZW1vdGVFdmVudCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIHNuYXBzaG90IHZlcnNpb24gdGhpcyBldmVudCBicmluZ3MgdXMgdXAgdG8sIG9yIE1JTiBpZiBub3Qgc2V0LlxuICAgICAqL1xuICAgIHNuYXBzaG90VmVyc2lvbiwgXG4gICAgLyoqXG4gICAgICogQSBtYXAgZnJvbSB0YXJnZXQgdG8gY2hhbmdlcyB0byB0aGUgdGFyZ2V0LiBTZWUgVGFyZ2V0Q2hhbmdlLlxuICAgICAqL1xuICAgIHRhcmdldENoYW5nZXMsIFxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIHRhcmdldHMgdGhhdCBpcyBrbm93biB0byBiZSBpbmNvbnNpc3RlbnQsIGFuZCB0aGUgcHVycG9zZSBmb3JcbiAgICAgKiByZS1saXN0ZW5pbmcuIExpc3RlbnMgZm9yIHRoZXNlIHRhcmdldHMgc2hvdWxkIGJlIHJlLWVzdGFibGlzaGVkIHdpdGhvdXRcbiAgICAgKiByZXN1bWUgdG9rZW5zLlxuICAgICAqL1xuICAgIHRhcmdldE1pc21hdGNoZXMsIFxuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHdoaWNoIGRvY3VtZW50cyBoYXZlIGNoYW5nZWQgb3IgYmVlbiBkZWxldGVkLCBhbG9uZyB3aXRoIHRoZVxuICAgICAqIGRvYydzIG5ldyB2YWx1ZXMgKGlmIG5vdCBkZWxldGVkKS5cbiAgICAgKi9cbiAgICBkb2N1bWVudFVwZGF0ZXMsIFxuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHdoaWNoIGRvY3VtZW50IHVwZGF0ZXMgYXJlIGR1ZSBvbmx5IHRvIGxpbWJvIHJlc29sdXRpb24gdGFyZ2V0cy5cbiAgICAgKi9cbiAgICByZXNvbHZlZExpbWJvRG9jdW1lbnRzKSB7XG4gICAgICAgIHRoaXMuc25hcHNob3RWZXJzaW9uID0gc25hcHNob3RWZXJzaW9uO1xuICAgICAgICB0aGlzLnRhcmdldENoYW5nZXMgPSB0YXJnZXRDaGFuZ2VzO1xuICAgICAgICB0aGlzLnRhcmdldE1pc21hdGNoZXMgPSB0YXJnZXRNaXNtYXRjaGVzO1xuICAgICAgICB0aGlzLmRvY3VtZW50VXBkYXRlcyA9IGRvY3VtZW50VXBkYXRlcztcbiAgICAgICAgdGhpcy5yZXNvbHZlZExpbWJvRG9jdW1lbnRzID0gcmVzb2x2ZWRMaW1ib0RvY3VtZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSEFDSzogVmlld3MgcmVxdWlyZSBSZW1vdGVFdmVudHMgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHZpZXcgaXNcbiAgICAgKiBDVVJSRU5ULCBidXQgc2Vjb25kYXJ5IHRhYnMgZG9uJ3QgcmVjZWl2ZSByZW1vdGUgZXZlbnRzLiBTbyB0aGlzIG1ldGhvZCBpc1xuICAgICAqIHVzZWQgdG8gY3JlYXRlIGEgc3ludGhlc2l6ZWQgUmVtb3RlRXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0byBhcHBseSBhXG4gICAgICogQ1VSUkVOVCBzdGF0dXMgY2hhbmdlIHRvIGEgVmlldywgZm9yIHF1ZXJpZXMgZXhlY3V0ZWQgaW4gYSBkaWZmZXJlbnQgdGFiLlxuICAgICAqL1xuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHlcbiAgICBzdGF0aWMgY3JlYXRlU3ludGhlc2l6ZWRSZW1vdGVFdmVudEZvckN1cnJlbnRDaGFuZ2UodGFyZ2V0SWQsIGN1cnJlbnQsIHJlc3VtZVRva2VuKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldENoYW5nZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRhcmdldENoYW5nZXMuc2V0KHRhcmdldElkLCBUYXJnZXRDaGFuZ2UuY3JlYXRlU3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2VGb3JDdXJyZW50Q2hhbmdlKHRhcmdldElkLCBjdXJyZW50LCByZXN1bWVUb2tlbikpO1xuICAgICAgICByZXR1cm4gbmV3IFJlbW90ZUV2ZW50KFNuYXBzaG90VmVyc2lvbi5taW4oKSwgdGFyZ2V0Q2hhbmdlcywgbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKSwgbXV0YWJsZURvY3VtZW50TWFwKCksIGRvY3VtZW50S2V5U2V0KCkpO1xuICAgIH1cbn1cbi8qKlxuICogQSBUYXJnZXRDaGFuZ2Ugc3BlY2lmaWVzIHRoZSBzZXQgb2YgY2hhbmdlcyBmb3IgYSBzcGVjaWZpYyB0YXJnZXQgYXMgcGFydCBvZlxuICogYSBSZW1vdGVFdmVudC4gVGhlc2UgY2hhbmdlcyB0cmFjayB3aGljaCBkb2N1bWVudHMgYXJlIGFkZGVkLCBtb2RpZmllZCBvclxuICogcmVtb3ZlZCwgYXMgd2VsbCBhcyB0aGUgdGFyZ2V0J3MgcmVzdW1lIHRva2VuIGFuZCB3aGV0aGVyIHRoZSB0YXJnZXQgaXNcbiAqIG1hcmtlZCBDVVJSRU5ULlxuICogVGhlIGFjdHVhbCBjaGFuZ2VzICp0byogZG9jdW1lbnRzIGFyZSBub3QgcGFydCBvZiB0aGUgVGFyZ2V0Q2hhbmdlIHNpbmNlXG4gKiBkb2N1bWVudHMgbWF5IGJlIHBhcnQgb2YgbXVsdGlwbGUgdGFyZ2V0cy5cbiAqL1xuY2xhc3MgVGFyZ2V0Q2hhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBBbiBvcGFxdWUsIHNlcnZlci1hc3NpZ25lZCB0b2tlbiB0aGF0IGFsbG93cyB3YXRjaGluZyBhIHF1ZXJ5IHRvIGJlIHJlc3VtZWRcbiAgICAgKiBhZnRlciBkaXNjb25uZWN0aW5nIHdpdGhvdXQgcmV0cmFuc21pdHRpbmcgYWxsIHRoZSBkYXRhIHRoYXQgbWF0Y2hlcyB0aGVcbiAgICAgKiBxdWVyeS4gVGhlIHJlc3VtZSB0b2tlbiBlc3NlbnRpYWxseSBpZGVudGlmaWVzIGEgcG9pbnQgaW4gdGltZSBmcm9tIHdoaWNoXG4gICAgICogdGhlIHNlcnZlciBzaG91bGQgcmVzdW1lIHNlbmRpbmcgcmVzdWx0cy5cbiAgICAgKi9cbiAgICByZXN1bWVUb2tlbiwgXG4gICAgLyoqXG4gICAgICogVGhlIFwiY3VycmVudFwiIChzeW5jZWQpIHN0YXR1cyBvZiB0aGlzIHRhcmdldC4gTm90ZSB0aGF0IFwiY3VycmVudFwiXG4gICAgICogaGFzIHNwZWNpYWwgbWVhbmluZyBpbiB0aGUgUlBDIHByb3RvY29sIHRoYXQgaW1wbGllcyB0aGF0IGEgdGFyZ2V0IGlzXG4gICAgICogYm90aCB1cC10by1kYXRlIGFuZCBjb25zaXN0ZW50IHdpdGggdGhlIHJlc3Qgb2YgdGhlIHdhdGNoIHN0cmVhbS5cbiAgICAgKi9cbiAgICBjdXJyZW50LCBcbiAgICAvKipcbiAgICAgKiBUaGUgc2V0IG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgbmV3bHkgYXNzaWduZWQgdG8gdGhpcyB0YXJnZXQgYXMgcGFydCBvZlxuICAgICAqIHRoaXMgcmVtb3RlIGV2ZW50LlxuICAgICAqL1xuICAgIGFkZGVkRG9jdW1lbnRzLCBcbiAgICAvKipcbiAgICAgKiBUaGUgc2V0IG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgYWxyZWFkeSBhc3NpZ25lZCB0byB0aGlzIHRhcmdldCBidXQgcmVjZWl2ZWRcbiAgICAgKiBhbiB1cGRhdGUgZHVyaW5nIHRoaXMgcmVtb3RlIGV2ZW50LlxuICAgICAqL1xuICAgIG1vZGlmaWVkRG9jdW1lbnRzLCBcbiAgICAvKipcbiAgICAgKiBUaGUgc2V0IG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgcmVtb3ZlZCBmcm9tIHRoaXMgdGFyZ2V0IGFzIHBhcnQgb2YgdGhpc1xuICAgICAqIHJlbW90ZSBldmVudC5cbiAgICAgKi9cbiAgICByZW1vdmVkRG9jdW1lbnRzKSB7XG4gICAgICAgIHRoaXMucmVzdW1lVG9rZW4gPSByZXN1bWVUb2tlbjtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgdGhpcy5hZGRlZERvY3VtZW50cyA9IGFkZGVkRG9jdW1lbnRzO1xuICAgICAgICB0aGlzLm1vZGlmaWVkRG9jdW1lbnRzID0gbW9kaWZpZWREb2N1bWVudHM7XG4gICAgICAgIHRoaXMucmVtb3ZlZERvY3VtZW50cyA9IHJlbW92ZWREb2N1bWVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gY3JlYXRlIGEgc3ludGhlc2l6ZWQgVGFyZ2V0Q2hhbmdlcyB0aGF0IGNhbiBiZSB1c2VkIHRvXG4gICAgICogYXBwbHkgYSBDVVJSRU5UIHN0YXR1cyBjaGFuZ2UgdG8gYSBWaWV3IChmb3IgcXVlcmllcyBleGVjdXRlZCBpbiBhIGRpZmZlcmVudFxuICAgICAqIHRhYikgb3IgZm9yIG5ldyBxdWVyaWVzICh0byByYWlzZSBzbmFwc2hvdHMgd2l0aCBjb3JyZWN0IENVUlJFTlQgc3RhdHVzKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU3ludGhlc2l6ZWRUYXJnZXRDaGFuZ2VGb3JDdXJyZW50Q2hhbmdlKHRhcmdldElkLCBjdXJyZW50LCByZXN1bWVUb2tlbikge1xuICAgICAgICByZXR1cm4gbmV3IFRhcmdldENoYW5nZShyZXN1bWVUb2tlbiwgY3VycmVudCwgZG9jdW1lbnRLZXlTZXQoKSwgZG9jdW1lbnRLZXlTZXQoKSwgZG9jdW1lbnRLZXlTZXQoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hhbmdlZCBkb2N1bWVudCBhbmQgYSBsaXN0IG9mIHRhcmdldCBpZHMgdG8gd2hpY2ggdGhpcyBjaGFuZ2VcbiAqIGFwcGxpZXMuXG4gKlxuICogSWYgZG9jdW1lbnQgaGFzIGJlZW4gZGVsZXRlZCBOb0RvY3VtZW50IHdpbGwgYmUgcHJvdmlkZWQuXG4gKi9cbmNsYXNzIERvY3VtZW50V2F0Y2hDaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgbmV3IGRvY3VtZW50IGFwcGxpZXMgdG8gYWxsIG9mIHRoZXNlIHRhcmdldHMuICovXG4gICAgdXBkYXRlZFRhcmdldElkcywgXG4gICAgLyoqIFRoZSBuZXcgZG9jdW1lbnQgaXMgcmVtb3ZlZCBmcm9tIGFsbCBvZiB0aGVzZSB0YXJnZXRzLiAqL1xuICAgIHJlbW92ZWRUYXJnZXRJZHMsIFxuICAgIC8qKiBUaGUga2V5IG9mIHRoZSBkb2N1bWVudCBmb3IgdGhpcyBjaGFuZ2UuICovXG4gICAga2V5LCBcbiAgICAvKipcbiAgICAgKiBUaGUgbmV3IGRvY3VtZW50IG9yIE5vRG9jdW1lbnQgaWYgaXQgd2FzIGRlbGV0ZWQuIElzIG51bGwgaWYgdGhlXG4gICAgICogZG9jdW1lbnQgd2VudCBvdXQgb2YgdmlldyB3aXRob3V0IHRoZSBzZXJ2ZXIgc2VuZGluZyBhIG5ldyBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBuZXdEb2MpIHtcbiAgICAgICAgdGhpcy51cGRhdGVkVGFyZ2V0SWRzID0gdXBkYXRlZFRhcmdldElkcztcbiAgICAgICAgdGhpcy5yZW1vdmVkVGFyZ2V0SWRzID0gcmVtb3ZlZFRhcmdldElkcztcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMubmV3RG9jID0gbmV3RG9jO1xuICAgIH1cbn1cbmNsYXNzIEV4aXN0ZW5jZUZpbHRlckNoYW5nZSB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0SWQsIGV4aXN0ZW5jZUZpbHRlcikge1xuICAgICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XG4gICAgICAgIHRoaXMuZXhpc3RlbmNlRmlsdGVyID0gZXhpc3RlbmNlRmlsdGVyO1xuICAgIH1cbn1cbmNsYXNzIFdhdGNoVGFyZ2V0Q2hhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogV2hhdCBraW5kIG9mIGNoYW5nZSBvY2N1cnJlZCB0byB0aGUgd2F0Y2ggdGFyZ2V0LiAqL1xuICAgIHN0YXRlLCBcbiAgICAvKiogVGhlIHRhcmdldCBJRHMgdGhhdCB3ZXJlIGFkZGVkL3JlbW92ZWQvc2V0LiAqL1xuICAgIHRhcmdldElkcywgXG4gICAgLyoqXG4gICAgICogQW4gb3BhcXVlLCBzZXJ2ZXItYXNzaWduZWQgdG9rZW4gdGhhdCBhbGxvd3Mgd2F0Y2hpbmcgYSB0YXJnZXQgdG8gYmVcbiAgICAgKiByZXN1bWVkIGFmdGVyIGRpc2Nvbm5lY3Rpbmcgd2l0aG91dCByZXRyYW5zbWl0dGluZyBhbGwgdGhlIGRhdGEgdGhhdFxuICAgICAqIG1hdGNoZXMgdGhlIHRhcmdldC4gVGhlIHJlc3VtZSB0b2tlbiBlc3NlbnRpYWxseSBpZGVudGlmaWVzIGEgcG9pbnQgaW5cbiAgICAgKiB0aW1lIGZyb20gd2hpY2ggdGhlIHNlcnZlciBzaG91bGQgcmVzdW1lIHNlbmRpbmcgcmVzdWx0cy5cbiAgICAgKi9cbiAgICByZXN1bWVUb2tlbiA9IEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcsIFxuICAgIC8qKiBBbiBSUEMgZXJyb3IgaW5kaWNhdGluZyB3aHkgdGhlIHdhdGNoIGZhaWxlZC4gKi9cbiAgICBjYXVzZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnRhcmdldElkcyA9IHRhcmdldElkcztcbiAgICAgICAgdGhpcy5yZXN1bWVUb2tlbiA9IHJlc3VtZVRva2VuO1xuICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgfVxufVxuLyoqIFRyYWNrcyB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgYSBXYXRjaCB0YXJnZXQuICovXG5jbGFzcyBUYXJnZXRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHBlbmRpbmcgcmVzcG9uc2VzIChhZGRzIG9yIHJlbW92ZXMpIHRoYXQgd2UgYXJlIHdhaXRpbmcgb24uXG4gICAgICAgICAqIFdlIG9ubHkgY29uc2lkZXIgdGFyZ2V0cyBhY3RpdmUgdGhhdCBoYXZlIG5vIHBlbmRpbmcgcmVzcG9uc2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBkb2N1bWVudCBjaGFuZ2VzIHNpbmNlIHRoZSBsYXN0IHJhaXNlZCBzbmFwc2hvdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlc2UgY2hhbmdlcyBhcmUgY29udGludW91c2x5IHVwZGF0ZWQgYXMgd2UgcmVjZWl2ZSBkb2N1bWVudCB1cGRhdGVzIGFuZFxuICAgICAgICAgKiBhbHdheXMgcmVmbGVjdCB0aGUgY3VycmVudCBzZXQgb2YgY2hhbmdlcyBhZ2FpbnN0IHRoZSBsYXN0IGlzc3VlZCBzbmFwc2hvdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZG9jdW1lbnRDaGFuZ2VzID0gc25hcHNob3RDaGFuZ2VzTWFwKCk7XG4gICAgICAgIC8qKiBTZWUgcHVibGljIGdldHRlcnMgZm9yIGV4cGxhbmF0aW9ucyBvZiB0aGVzZSBmaWVsZHMuICovXG4gICAgICAgIHRoaXMuX3Jlc3VtZVRva2VuID0gQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORztcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIHRhcmdldCBzdGF0ZSBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIG5leHQgc25hcHNob3QuIFdlXG4gICAgICAgICAqIGluaXRpYWxpemUgdG8gdHJ1ZSBzbyB0aGF0IG5ld2x5LWFkZGVkIHRhcmdldHMgYXJlIGluY2x1ZGVkIGluIHRoZSBuZXh0XG4gICAgICAgICAqIFJlbW90ZUV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgdGFyZ2V0IGhhcyBiZWVuIG1hcmtlZCAnY3VycmVudCcuXG4gICAgICpcbiAgICAgKiAnQ3VycmVudCcgaGFzIHNwZWNpYWwgbWVhbmluZyBpbiB0aGUgUlBDIHByb3RvY29sOiBJdCBpbXBsaWVzIHRoYXQgdGhlXG4gICAgICogV2F0Y2ggYmFja2VuZCBoYXMgc2VudCB1cyBhbGwgY2hhbmdlcyB1cCB0byB0aGUgcG9pbnQgYXQgd2hpY2ggdGhlIHRhcmdldFxuICAgICAqIHdhcyBhZGRlZCBhbmQgdGhhdCB0aGUgdGFyZ2V0IGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgcmVzdCBvZiB0aGUgd2F0Y2hcbiAgICAgKiBzdHJlYW0uXG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICAgIH1cbiAgICAvKiogVGhlIGxhc3QgcmVzdW1lIHRva2VuIHNlbnQgdG8gdXMgZm9yIHRoaXMgdGFyZ2V0LiAqL1xuICAgIGdldCByZXN1bWVUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VtZVRva2VuO1xuICAgIH1cbiAgICAvKiogV2hldGhlciB0aGlzIHRhcmdldCBoYXMgcGVuZGluZyB0YXJnZXQgYWRkcyBvciB0YXJnZXQgcmVtb3Zlcy4gKi9cbiAgICBnZXQgaXNQZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nUmVzcG9uc2VzICE9PSAwO1xuICAgIH1cbiAgICAvKiogV2hldGhlciB3ZSBoYXZlIG1vZGlmaWVkIGFueSBzdGF0ZSB0aGF0IHNob3VsZCB0cmlnZ2VyIGEgc25hcHNob3QuICovXG4gICAgZ2V0IGhhc1BlbmRpbmdDaGFuZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzUGVuZGluZ0NoYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIHJlc3VtZSB0b2tlbiB0byB0aGUgVGFyZ2V0Q2hhbmdlLCBidXQgb25seSB3aGVuIGl0IGhhcyBhIG5ld1xuICAgICAqIHZhbHVlLiBFbXB0eSByZXN1bWVUb2tlbnMgYXJlIGRpc2NhcmRlZC5cbiAgICAgKi9cbiAgICB1cGRhdGVSZXN1bWVUb2tlbihyZXN1bWVUb2tlbikge1xuICAgICAgICBpZiAocmVzdW1lVG9rZW4uYXBwcm94aW1hdGVCeXRlU2l6ZSgpID4gMCkge1xuICAgICAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVzdW1lVG9rZW4gPSByZXN1bWVUb2tlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGFyZ2V0IGNoYW5nZSBmcm9tIHRoZSBjdXJyZW50IHNldCBvZiBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogVG8gcmVzZXQgdGhlIGRvY3VtZW50IGNoYW5nZXMgYWZ0ZXIgcmFpc2luZyB0aGlzIHNuYXBzaG90LCBjYWxsXG4gICAgICogYGNsZWFyUGVuZGluZ0NoYW5nZXMoKWAuXG4gICAgICovXG4gICAgdG9UYXJnZXRDaGFuZ2UoKSB7XG4gICAgICAgIGxldCBhZGRlZERvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIGxldCBtb2RpZmllZERvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIGxldCByZW1vdmVkRG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudENoYW5nZXMuZm9yRWFjaCgoa2V5LCBjaGFuZ2VUeXBlKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYW5nZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgYWRkZWREb2N1bWVudHMgPSBhZGRlZERvY3VtZW50cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi86XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRG9jdW1lbnRzID0gbW9kaWZpZWREb2N1bWVudHMuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi86XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWREb2N1bWVudHMgPSByZW1vdmVkRG9jdW1lbnRzLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBmYWlsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFRhcmdldENoYW5nZSh0aGlzLl9yZXN1bWVUb2tlbiwgdGhpcy5fY3VycmVudCwgYWRkZWREb2N1bWVudHMsIG1vZGlmaWVkRG9jdW1lbnRzLCByZW1vdmVkRG9jdW1lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBkb2N1bWVudCBjaGFuZ2VzIGFuZCBzZXRzIGBoYXNQZW5kaW5nQ2hhbmdlc2AgdG8gZmFsc2UuXG4gICAgICovXG4gICAgY2xlYXJQZW5kaW5nQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudENoYW5nZXMgPSBzbmFwc2hvdENoYW5nZXNNYXAoKTtcbiAgICB9XG4gICAgYWRkRG9jdW1lbnRDaGFuZ2Uoa2V5LCBjaGFuZ2VUeXBlKSB7XG4gICAgICAgIHRoaXMuX2hhc1BlbmRpbmdDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudENoYW5nZXMgPSB0aGlzLmRvY3VtZW50Q2hhbmdlcy5pbnNlcnQoa2V5LCBjaGFuZ2VUeXBlKTtcbiAgICB9XG4gICAgcmVtb3ZlRG9jdW1lbnRDaGFuZ2Uoa2V5KSB7XG4gICAgICAgIHRoaXMuX2hhc1BlbmRpbmdDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudENoYW5nZXMgPSB0aGlzLmRvY3VtZW50Q2hhbmdlcy5yZW1vdmUoa2V5KTtcbiAgICB9XG4gICAgcmVjb3JkUGVuZGluZ1RhcmdldFJlcXVlc3QoKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcyArPSAxO1xuICAgIH1cbiAgICByZWNvcmRUYXJnZXRSZXNwb25zZSgpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzIC09IDE7XG4gICAgICAgIGhhcmRBc3NlcnQodGhpcy5wZW5kaW5nUmVzcG9uc2VzID49IDApO1xuICAgIH1cbiAgICBtYXJrQ3VycmVudCgpIHtcbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG59XG5jb25zdCBMT0dfVEFHJGcgPSAnV2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yJztcbi8qKlxuICogQSBoZWxwZXIgY2xhc3MgdG8gYWNjdW11bGF0ZSB3YXRjaCBjaGFuZ2VzIGludG8gYSBSZW1vdGVFdmVudC5cbiAqL1xuY2xhc3MgV2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YVByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGFQcm92aWRlciA9IG1ldGFkYXRhUHJvdmlkZXI7XG4gICAgICAgIC8qKiBUaGUgaW50ZXJuYWwgc3RhdGUgb2YgYWxsIHRyYWNrZWQgdGFyZ2V0cy4gKi9cbiAgICAgICAgdGhpcy50YXJnZXRTdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKiBLZWVwcyB0cmFjayBvZiB0aGUgZG9jdW1lbnRzIHRvIHVwZGF0ZSBzaW5jZSB0aGUgbGFzdCByYWlzZWQgc25hcHNob3QuICovXG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlcyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXNCeVRhcmdldCA9IGRvY3VtZW50VGFyZ2V0TWFwKCk7XG4gICAgICAgIC8qKiBBIG1hcHBpbmcgb2YgZG9jdW1lbnQga2V5cyB0byB0aGVpciBzZXQgb2YgdGFyZ2V0IElEcy4gKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID0gZG9jdW1lbnRUYXJnZXRNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIHRhcmdldHMgd2l0aCBleGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoZXMuIFRoZXNlIHRhcmdldHMgYXJlXG4gICAgICAgICAqIGtub3duIHRvIGJlIGluY29uc2lzdGVudCBhbmQgdGhlaXIgbGlzdGVucyBuZWVkcyB0byBiZSByZS1lc3RhYmxpc2hlZCBieVxuICAgICAgICAgKiBSZW1vdGVTdG9yZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVuZGluZ1RhcmdldFJlc2V0cyA9IG5ldyBTb3J0ZWRNYXAocHJpbWl0aXZlQ29tcGFyYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBhbmQgYWRkcyB0aGUgRG9jdW1lbnRXYXRjaENoYW5nZSB0byB0aGUgY3VycmVudCBzZXQgb2YgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVEb2N1bWVudENoYW5nZShkb2NDaGFuZ2UpIHtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiBkb2NDaGFuZ2UudXBkYXRlZFRhcmdldElkcykge1xuICAgICAgICAgICAgaWYgKGRvY0NoYW5nZS5uZXdEb2MgJiYgZG9jQ2hhbmdlLm5ld0RvYy5pc0ZvdW5kRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRG9jdW1lbnRUb1RhcmdldCh0YXJnZXRJZCwgZG9jQ2hhbmdlLm5ld0RvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwgZG9jQ2hhbmdlLmtleSwgZG9jQ2hhbmdlLm5ld0RvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXRJZCBvZiBkb2NDaGFuZ2UucmVtb3ZlZFRhcmdldElkcykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVEb2N1bWVudEZyb21UYXJnZXQodGFyZ2V0SWQsIGRvY0NoYW5nZS5rZXksIGRvY0NoYW5nZS5uZXdEb2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBQcm9jZXNzZXMgYW5kIGFkZHMgdGhlIFdhdGNoVGFyZ2V0Q2hhbmdlIHRvIHRoZSBjdXJyZW50IHNldCBvZiBjaGFuZ2VzLiAqL1xuICAgIGhhbmRsZVRhcmdldENoYW5nZSh0YXJnZXRDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoVGFyZ2V0KHRhcmdldENoYW5nZSwgdGFyZ2V0SWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0U3RhdGUgPSB0aGlzLmVuc3VyZVRhcmdldFN0YXRlKHRhcmdldElkKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFyZ2V0Q2hhbmdlLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuTm9DaGFuZ2UgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUudXBkYXRlUmVzdW1lVG9rZW4odGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5BZGRlZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBkZWNyZW1lbnQgdGhlIG51bWJlciBvZiBwZW5kaW5nIGFja3MgbmVlZGVkIGZyb20gd2F0Y2hcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRoaXMgdGFyZ2V0SWQuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLnJlY29yZFRhcmdldFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0U3RhdGUuaXNQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgZnJlc2hseSBhZGRlZCB0YXJnZXQsIHNvIHdlIG5lZWQgdG8gcmVzZXQgYW55IHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHdlIGhhZCBwcmV2aW91c2x5LiBUaGlzIGNhbiBoYXBwZW4gZS5nLiB3aGVuIHJlbW92ZSBhbmQgYWRkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiYWNrIGEgdGFyZ2V0IGZvciBleGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS5jbGVhclBlbmRpbmdDaGFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUudXBkYXRlUmVzdW1lVG9rZW4odGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVtb3ZlZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIHJlbW92ZWQgdGFyZ2V0cyB0byB3ZSBjYW4gcG9zdC1maWx0ZXIgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhbnkgdGFyZ2V0IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZGVjcmVtZW50IHRoZSBudW1iZXIgb2YgcGVuZGluZyBhY2tzIG5lZWRlZCBmcm9tIHdhdGNoXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciB0aGlzIHRhcmdldElkLlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS5yZWNvcmRUYXJnZXRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFN0YXRlLmlzUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLkN1cnJlbnQgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUubWFya0N1cnJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLnVwZGF0ZVJlc3VtZVRva2VuKHRhcmdldENoYW5nZS5yZXN1bWVUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVzZXQgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHRhcmdldCBhbmQgc3ludGhlc2l6ZXMgcmVtb3ZlcyBmb3IgYWxsIGV4aXN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb2N1bWVudHMuIFRoZSBiYWNrZW5kIHdpbGwgcmUtYWRkIGFueSBkb2N1bWVudHMgdGhhdCBzdGlsbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2ggdGhlIHRhcmdldCBiZWZvcmUgaXQgc2VuZHMgdGhlIG5leHQgZ2xvYmFsIHNuYXBzaG90LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldFRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS51cGRhdGVSZXN1bWVUb2tlbih0YXJnZXRDaGFuZ2UucmVzdW1lVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgYWxsIHRhcmdldElkcyB0aGF0IHRoZSB3YXRjaCBjaGFuZ2UgYXBwbGllcyB0bzogZWl0aGVyIHRoZVxuICAgICAqIHRhcmdldElkcyBleHBsaWNpdGx5IGxpc3RlZCBpbiB0aGUgY2hhbmdlIG9yIHRoZSB0YXJnZXRJZHMgb2YgYWxsIGN1cnJlbnRseVxuICAgICAqIGFjdGl2ZSB0YXJnZXRzLlxuICAgICAqL1xuICAgIGZvckVhY2hUYXJnZXQodGFyZ2V0Q2hhbmdlLCBmbikge1xuICAgICAgICBpZiAodGFyZ2V0Q2hhbmdlLnRhcmdldElkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0YXJnZXRDaGFuZ2UudGFyZ2V0SWRzLmZvckVhY2goZm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRTdGF0ZXMuZm9yRWFjaCgoXywgdGFyZ2V0SWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZVRhcmdldCh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4odGFyZ2V0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgZXhpc3RlbmNlIGZpbHRlcnMgYW5kIHN5bnRoZXNpemVzIGRlbGV0ZXMgZm9yIGZpbHRlciBtaXNtYXRjaGVzLlxuICAgICAqIFRhcmdldHMgdGhhdCBhcmUgaW52YWxpZGF0ZWQgYnkgZmlsdGVyIG1pc21hdGNoZXMgYXJlIGFkZGVkIHRvXG4gICAgICogYHBlbmRpbmdUYXJnZXRSZXNldHNgLlxuICAgICAqL1xuICAgIGhhbmRsZUV4aXN0ZW5jZUZpbHRlcih3YXRjaENoYW5nZSkge1xuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IHdhdGNoQ2hhbmdlLnRhcmdldElkO1xuICAgICAgICBjb25zdCBleHBlY3RlZENvdW50ID0gd2F0Y2hDaGFuZ2UuZXhpc3RlbmNlRmlsdGVyLmNvdW50O1xuICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gdGhpcy50YXJnZXREYXRhRm9yQWN0aXZlVGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgaWYgKHRhcmdldERhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldERhdGEudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHRhcmdldElzRG9jdW1lbnRUYXJnZXQodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBleGlzdGVuY2UgZmlsdGVyIHRvbGQgdXMgdGhlIGRvY3VtZW50IGRvZXMgbm90IGV4aXN0LiBXZSBkZWR1Y2VcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCB0aGlzIGRvY3VtZW50IGRvZXMgbm90IGV4aXN0IGFuZCBhcHBseSBhIGRlbGV0ZWQgZG9jdW1lbnQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gb3VyIHVwZGF0ZXMuIFdpdGhvdXQgYXBwbHlpbmcgdGhpcyBkZWxldGVkIGRvY3VtZW50IHRoZXJlIG1pZ2h0IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFub3RoZXIgcXVlcnkgdGhhdCB3aWxsIHJhaXNlIHRoaXMgZG9jdW1lbnQgYXMgcGFydCBvZiBhIHNuYXBzaG90XG4gICAgICAgICAgICAgICAgICAgIC8vIHVudGlsIGl0IGlzIHJlc29sdmVkLCBlc3NlbnRpYWxseSBleHBvc2luZyBpbmNvbnNpc3RlbmN5IGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gcXVlcmllcy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gbmV3IERvY3VtZW50S2V5KHRhcmdldC5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEb2N1bWVudEZyb21UYXJnZXQodGFyZ2V0SWQsIGtleSwgTXV0YWJsZURvY3VtZW50Lm5ld05vRG9jdW1lbnQoa2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZXhwZWN0ZWRDb3VudCA9PT0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNpemUgPSB0aGlzLmdldEN1cnJlbnREb2N1bWVudENvdW50Rm9yVGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgICAgICAgICAvLyBFeGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoLiBNYXJrIHRoZSBkb2N1bWVudHMgYXMgYmVpbmcgaW4gbGltYm8sIGFuZFxuICAgICAgICAgICAgICAgIC8vIHJhaXNlIGEgc25hcHNob3Qgd2l0aCBgaXNGcm9tQ2FjaGU6dHJ1ZWAuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTaXplICE9PSBleHBlY3RlZENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGJsb29tIGZpbHRlciB0byBpZGVudGlmeSBhbmQgbWFyayByZW1vdmVkIGRvY3VtZW50cy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvb21GaWx0ZXIgPSB0aGlzLnBhcnNlQmxvb21GaWx0ZXIod2F0Y2hDaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBibG9vbUZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmFwcGx5Qmxvb21GaWx0ZXIoYmxvb21GaWx0ZXIsIHdhdGNoQ2hhbmdlLCBjdXJyZW50U2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMSAvKiBCbG9vbUZpbHRlckFwcGxpY2F0aW9uU3RhdHVzLlNraXBwZWQgKi87XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgIT09IDAgLyogQmxvb21GaWx0ZXJBcHBsaWNhdGlvblN0YXR1cy5TdWNjZXNzICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBibG9vbSBmaWx0ZXIgYXBwbGljYXRpb24gZmFpbHMsIHdlIHJlc2V0IHRoZSBtYXBwaW5nIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlciByZS1ydW4gb2YgdGhlIHF1ZXJ5LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldFRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwdXJwb3NlID0gc3RhdHVzID09PSAyIC8qIEJsb29tRmlsdGVyQXBwbGljYXRpb25TdGF0dXMuRmFsc2VQb3NpdGl2ZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJUYXJnZXRQdXJwb3NlRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hCbG9vbVwiIC8qIFRhcmdldFB1cnBvc2UuRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hCbG9vbSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJUYXJnZXRQdXJwb3NlRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hcIiAvKiBUYXJnZXRQdXJwb3NlLkV4aXN0ZW5jZUZpbHRlck1pc21hdGNoICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGFyZ2V0UmVzZXRzID0gdGhpcy5wZW5kaW5nVGFyZ2V0UmVzZXRzLmluc2VydCh0YXJnZXRJZCwgcHVycG9zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGVzdGluZ0hvb2tzU3BpID09PSBudWxsIHx8IHRlc3RpbmdIb29rc1NwaSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGVzdGluZ0hvb2tzU3BpLm5vdGlmeU9uRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2goY3JlYXRlRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hJbmZvRm9yVGVzdGluZ0hvb2tzKGN1cnJlbnRTaXplLCB3YXRjaENoYW5nZS5leGlzdGVuY2VGaWx0ZXIsIHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXREYXRhYmFzZUlkKCksIGJsb29tRmlsdGVyLCBzdGF0dXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIGJsb29tIGZpbHRlciBmcm9tIHRoZSBcInVuY2hhbmdlZF9uYW1lc1wiIGZpZWxkIG9mIGFuIGV4aXN0ZW5jZVxuICAgICAqIGZpbHRlci5cbiAgICAgKi9cbiAgICBwYXJzZUJsb29tRmlsdGVyKHdhdGNoQ2hhbmdlKSB7XG4gICAgICAgIGNvbnN0IHVuY2hhbmdlZE5hbWVzID0gd2F0Y2hDaGFuZ2UuZXhpc3RlbmNlRmlsdGVyLnVuY2hhbmdlZE5hbWVzO1xuICAgICAgICBpZiAoIXVuY2hhbmdlZE5hbWVzIHx8ICF1bmNoYW5nZWROYW1lcy5iaXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGJpdHM6IHsgYml0bWFwID0gJycsIHBhZGRpbmcgPSAwIH0sIGhhc2hDb3VudCA9IDAgfSA9IHVuY2hhbmdlZE5hbWVzO1xuICAgICAgICBsZXQgbm9ybWFsaXplZEJpdG1hcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRCaXRtYXAgPSBub3JtYWxpemVCeXRlU3RyaW5nKGJpdG1hcCkudG9VaW50OEFycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEJhc2U2NERlY29kZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nV2FybignRGVjb2RpbmcgdGhlIGJhc2U2NCBibG9vbSBmaWx0ZXIgaW4gZXhpc3RlbmNlIGZpbHRlciBmYWlsZWQgKCcgK1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSArXG4gICAgICAgICAgICAgICAgICAgICcpOyBpZ25vcmluZyB0aGUgYmxvb20gZmlsdGVyIGFuZCBmYWxsaW5nIGJhY2sgdG8gZnVsbCByZS1xdWVyeS4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYmxvb21GaWx0ZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBCbG9vbUZpbHRlciB0aHJvd3MgZXJyb3IgaWYgdGhlIGlucHV0cyBhcmUgaW52YWxpZC5cbiAgICAgICAgICAgIGJsb29tRmlsdGVyID0gbmV3IEJsb29tRmlsdGVyKG5vcm1hbGl6ZWRCaXRtYXAsIHBhZGRpbmcsIGhhc2hDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEJsb29tRmlsdGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dXYXJuKCdCbG9vbUZpbHRlciBlcnJvcjogJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ1dhcm4oJ0FwcGx5aW5nIGJsb29tIGZpbHRlciBmYWlsZWQ6ICcsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvb21GaWx0ZXIuYml0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9vbUZpbHRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkgYmxvb20gZmlsdGVyIHRvIHJlbW92ZSB0aGUgZGVsZXRlZCBkb2N1bWVudHMsIGFuZCByZXR1cm4gdGhlXG4gICAgICogYXBwbGljYXRpb24gc3RhdHVzLlxuICAgICAqL1xuICAgIGFwcGx5Qmxvb21GaWx0ZXIoYmxvb21GaWx0ZXIsIHdhdGNoQ2hhbmdlLCBjdXJyZW50Q291bnQpIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRDb3VudCA9IHdhdGNoQ2hhbmdlLmV4aXN0ZW5jZUZpbHRlci5jb3VudDtcbiAgICAgICAgY29uc3QgcmVtb3ZlZERvY3VtZW50Q291bnQgPSB0aGlzLmZpbHRlclJlbW92ZWREb2N1bWVudHMoYmxvb21GaWx0ZXIsIHdhdGNoQ2hhbmdlLnRhcmdldElkKTtcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkQ291bnQgPT09IGN1cnJlbnRDb3VudCAtIHJlbW92ZWREb2N1bWVudENvdW50XG4gICAgICAgICAgICA/IDAgLyogQmxvb21GaWx0ZXJBcHBsaWNhdGlvblN0YXR1cy5TdWNjZXNzICovXG4gICAgICAgICAgICA6IDIgLyogQmxvb21GaWx0ZXJBcHBsaWNhdGlvblN0YXR1cy5GYWxzZVBvc2l0aXZlICovO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgb3V0IHJlbW92ZWQgZG9jdW1lbnRzIGJhc2VkIG9uIGJsb29tIGZpbHRlciBtZW1iZXJzaGlwIHJlc3VsdCBhbmRcbiAgICAgKiByZXR1cm4gbnVtYmVyIG9mIGRvY3VtZW50cyByZW1vdmVkLlxuICAgICAqL1xuICAgIGZpbHRlclJlbW92ZWREb2N1bWVudHMoYmxvb21GaWx0ZXIsIHRhcmdldElkKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgbGV0IHJlbW92YWxDb3VudCA9IDA7XG4gICAgICAgIGV4aXN0aW5nS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gdGhpcy5tZXRhZGF0YVByb3ZpZGVyLmdldERhdGFiYXNlSWQoKTtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50UGF0aCA9IGBwcm9qZWN0cy8ke2RhdGFiYXNlSWQucHJvamVjdElkfWAgK1xuICAgICAgICAgICAgICAgIGAvZGF0YWJhc2VzLyR7ZGF0YWJhc2VJZC5kYXRhYmFzZX1gICtcbiAgICAgICAgICAgICAgICBgL2RvY3VtZW50cy8ke2tleS5wYXRoLmNhbm9uaWNhbFN0cmluZygpfWA7XG4gICAgICAgICAgICBpZiAoIWJsb29tRmlsdGVyLm1pZ2h0Q29udGFpbihkb2N1bWVudFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEb2N1bWVudEZyb21UYXJnZXQodGFyZ2V0SWQsIGtleSwgLyp1cGRhdGVkRG9jdW1lbnQ9Ki8gbnVsbCk7XG4gICAgICAgICAgICAgICAgcmVtb3ZhbENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVtb3ZhbENvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY3VycmVudGx5IGFjY3VtdWxhdGVkIHN0YXRlIGludG8gYSByZW1vdGUgZXZlbnQgYXQgdGhlXG4gICAgICogcHJvdmlkZWQgc25hcHNob3QgdmVyc2lvbi4gUmVzZXRzIHRoZSBhY2N1bXVsYXRlZCBjaGFuZ2VzIGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICovXG4gICAgY3JlYXRlUmVtb3RlRXZlbnQoc25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldENoYW5nZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudGFyZ2V0U3RhdGVzLmZvckVhY2goKHRhcmdldFN0YXRlLCB0YXJnZXRJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IHRoaXMudGFyZ2V0RGF0YUZvckFjdGl2ZVRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRTdGF0ZS5jdXJyZW50ICYmIHRhcmdldElzRG9jdW1lbnRUYXJnZXQodGFyZ2V0RGF0YS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IHF1ZXJpZXMgZm9yIGRvY3VtZW50IHRoYXQgZG9uJ3QgZXhpc3QgY2FuIHByb2R1Y2UgYW4gZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0IHNldC4gVG8gdXBkYXRlIG91ciBsb2NhbCBjYWNoZSwgd2Ugc3ludGhlc2l6ZSBhIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBpZiB3ZSBoYXZlIG5vdCBwcmV2aW91c2x5IHJlY2VpdmVkIHRoZSBkb2N1bWVudCBmb3IgdGhpc1xuICAgICAgICAgICAgICAgICAgICAvLyB0YXJnZXQuIFRoaXMgcmVzb2x2ZXMgdGhlIGxpbWJvIHN0YXRlIG9mIHRoZSBkb2N1bWVudCwgcmVtb3ZpbmcgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSBsaW1ib0RvY3VtZW50UmVmcy5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiBJZGVhbGx5IHdlIHdvdWxkIGhhdmUgYW4gZXhwbGljaXQgbG9va3VwIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIHJlc3VsdGluZyBpbiBhbiBleHBsaWNpdCBkZWxldGUgbWVzc2FnZSBhbmQgd2UgY291bGRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoaXMgc3BlY2lhbCBsb2dpYy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gbmV3IERvY3VtZW50S2V5KHRhcmdldERhdGEudGFyZ2V0LnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZW5zdXJlRG9jdW1lbnRVcGRhdGVCeVRhcmdldChrZXkpLmhhcyh0YXJnZXRJZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLnRhcmdldENvbnRhaW5zRG9jdW1lbnQodGFyZ2V0SWQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnRGcm9tVGFyZ2V0KHRhcmdldElkLCBrZXksIE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGtleSwgc25hcHNob3RWZXJzaW9uKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFN0YXRlLmhhc1BlbmRpbmdDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENoYW5nZXMuc2V0KHRhcmdldElkLCB0YXJnZXRTdGF0ZS50b1RhcmdldENoYW5nZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUuY2xlYXJQZW5kaW5nQ2hhbmdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZXNvbHZlZExpbWJvRG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgLy8gV2UgZXh0cmFjdCB0aGUgc2V0IG9mIGxpbWJvLW9ubHkgZG9jdW1lbnQgdXBkYXRlcyBhcyB0aGUgR0MgbG9naWNcbiAgICAgICAgLy8gc3BlY2lhbC1jYXNlcyBkb2N1bWVudHMgdGhhdCBkbyBub3QgYXBwZWFyIGluIHRoZSB0YXJnZXQgY2FjaGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRPRE8oZ3NvbHRpcyk6IEV4cGFuZCBvbiB0aGlzIGNvbW1lbnQgb25jZSBHQyBpcyBhdmFpbGFibGUgaW4gdGhlIEpTXG4gICAgICAgIC8vIGNsaWVudC5cbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nLmZvckVhY2goKGtleSwgdGFyZ2V0cykgPT4ge1xuICAgICAgICAgICAgbGV0IGlzT25seUxpbWJvVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRhcmdldHMuZm9yRWFjaFdoaWxlKHRhcmdldElkID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gdGhpcy50YXJnZXREYXRhRm9yQWN0aXZlVGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXREYXRhLnB1cnBvc2UgIT09IFwiVGFyZ2V0UHVycG9zZUxpbWJvUmVzb2x1dGlvblwiIC8qIFRhcmdldFB1cnBvc2UuTGltYm9SZXNvbHV0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzT25seUxpbWJvVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc09ubHlMaW1ib1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkTGltYm9Eb2N1bWVudHMgPSByZXNvbHZlZExpbWJvRG9jdW1lbnRzLmFkZChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzLmZvckVhY2goKF8sIGRvYykgPT4gZG9jLnNldFJlYWRUaW1lKHNuYXBzaG90VmVyc2lvbikpO1xuICAgICAgICBjb25zdCByZW1vdGVFdmVudCA9IG5ldyBSZW1vdGVFdmVudChzbmFwc2hvdFZlcnNpb24sIHRhcmdldENoYW5nZXMsIHRoaXMucGVuZGluZ1RhcmdldFJlc2V0cywgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzLCByZXNvbHZlZExpbWJvRG9jdW1lbnRzKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlc0J5VGFyZ2V0ID0gZG9jdW1lbnRUYXJnZXRNYXAoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID0gZG9jdW1lbnRUYXJnZXRNYXAoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nVGFyZ2V0UmVzZXRzID0gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZUV2ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBwcm92aWRlZCBkb2N1bWVudCB0byB0aGUgaW50ZXJuYWwgbGlzdCBvZiBkb2N1bWVudCB1cGRhdGVzIGFuZFxuICAgICAqIGl0cyBkb2N1bWVudCBrZXkgdG8gdGhlIGdpdmVuIHRhcmdldCdzIG1hcHBpbmcuXG4gICAgICovXG4gICAgLy8gVmlzaWJsZSBmb3IgdGVzdGluZy5cbiAgICBhZGREb2N1bWVudFRvVGFyZ2V0KHRhcmdldElkLCBkb2N1bWVudCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlVHlwZSA9IHRoaXMudGFyZ2V0Q29udGFpbnNEb2N1bWVudCh0YXJnZXRJZCwgZG9jdW1lbnQua2V5KVxuICAgICAgICAgICAgPyAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi9cbiAgICAgICAgICAgIDogMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovO1xuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xuICAgICAgICB0YXJnZXRTdGF0ZS5hZGREb2N1bWVudENoYW5nZShkb2N1bWVudC5rZXksIGNoYW5nZVR5cGUpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMuaW5zZXJ0KGRvY3VtZW50LmtleSwgZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXNCeVRhcmdldCA9XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXNCeVRhcmdldC5pbnNlcnQoZG9jdW1lbnQua2V5LCB0aGlzLmVuc3VyZURvY3VtZW50VXBkYXRlQnlUYXJnZXQoZG9jdW1lbnQua2V5KS5hZGQodGFyZ2V0SWQpKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID1cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZy5pbnNlcnQoZG9jdW1lbnQua2V5LCB0aGlzLmVuc3VyZURvY3VtZW50VGFyZ2V0TWFwcGluZyhkb2N1bWVudC5rZXkpLmFkZCh0YXJnZXRJZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm92aWRlZCBkb2N1bWVudCBmcm9tIHRoZSB0YXJnZXQgbWFwcGluZy4gSWYgdGhlXG4gICAgICogZG9jdW1lbnQgbm8gbG9uZ2VyIG1hdGNoZXMgdGhlIHRhcmdldCwgYnV0IHRoZSBkb2N1bWVudCdzIHN0YXRlIGlzIHN0aWxsXG4gICAgICoga25vd24gKGUuZy4gd2Uga25vdyB0aGF0IHRoZSBkb2N1bWVudCB3YXMgZGVsZXRlZCBvciB3ZSByZWNlaXZlZCB0aGUgY2hhbmdlXG4gICAgICogdGhhdCBjYXVzZWQgdGhlIGZpbHRlciBtaXNtYXRjaCksIHRoZSBuZXcgZG9jdW1lbnQgY2FuIGJlIHByb3ZpZGVkXG4gICAgICogdG8gdXBkYXRlIHRoZSByZW1vdGUgZG9jdW1lbnQgY2FjaGUuXG4gICAgICovXG4gICAgLy8gVmlzaWJsZSBmb3IgdGVzdGluZy5cbiAgICByZW1vdmVEb2N1bWVudEZyb21UYXJnZXQodGFyZ2V0SWQsIGtleSwgdXBkYXRlZERvY3VtZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZVRhcmdldCh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xuICAgICAgICBpZiAodGhpcy50YXJnZXRDb250YWluc0RvY3VtZW50KHRhcmdldElkLCBrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXRTdGF0ZS5hZGREb2N1bWVudENoYW5nZShrZXksIDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBkb2N1bWVudCBtYXkgaGF2ZSBlbnRlcmVkIGFuZCBsZWZ0IHRoZSB0YXJnZXQgYmVmb3JlIHdlIHJhaXNlZCBhXG4gICAgICAgICAgICAvLyBzbmFwc2hvdCwgc28gd2UgY2FuIGp1c3QgaWdub3JlIHRoZSBjaGFuZ2UuXG4gICAgICAgICAgICB0YXJnZXRTdGF0ZS5yZW1vdmVEb2N1bWVudENoYW5nZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZyA9XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcuaW5zZXJ0KGtleSwgdGhpcy5lbnN1cmVEb2N1bWVudFRhcmdldE1hcHBpbmcoa2V5KS5kZWxldGUodGFyZ2V0SWQpKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID1cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZy5pbnNlcnQoa2V5LCB0aGlzLmVuc3VyZURvY3VtZW50VGFyZ2V0TWFwcGluZyhrZXkpLmFkZCh0YXJnZXRJZCkpO1xuICAgICAgICBpZiAodXBkYXRlZERvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMuaW5zZXJ0KGtleSwgdXBkYXRlZERvY3VtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgdGhpcy50YXJnZXRTdGF0ZXMuZGVsZXRlKHRhcmdldElkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBjb3VudCBvZiBkb2N1bWVudHMgaW4gdGhlIHRhcmdldC4gVGhpcyBpbmNsdWRlcyBib3RoXG4gICAgICogdGhlIG51bWJlciBvZiBkb2N1bWVudHMgdGhhdCB0aGUgTG9jYWxTdG9yZSBjb25zaWRlcnMgdG8gYmUgcGFydCBvZiB0aGVcbiAgICAgKiB0YXJnZXQgYXMgd2VsbCBhcyBhbnkgYWNjdW11bGF0ZWQgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBnZXRDdXJyZW50RG9jdW1lbnRDb3VudEZvclRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xuICAgICAgICBjb25zdCB0YXJnZXRDaGFuZ2UgPSB0YXJnZXRTdGF0ZS50b1RhcmdldENoYW5nZSgpO1xuICAgICAgICByZXR1cm4gKHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHRhcmdldElkKS5zaXplICtcbiAgICAgICAgICAgIHRhcmdldENoYW5nZS5hZGRlZERvY3VtZW50cy5zaXplIC1cbiAgICAgICAgICAgIHRhcmdldENoYW5nZS5yZW1vdmVkRG9jdW1lbnRzLnNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmNyZW1lbnQgdGhlIG51bWJlciBvZiBhY2tzIG5lZWRlZCBmcm9tIHdhdGNoIGJlZm9yZSB3ZSBjYW4gY29uc2lkZXIgdGhlXG4gICAgICogc2VydmVyIHRvIGJlICdpbi1zeW5jJyB3aXRoIHRoZSBjbGllbnQncyBhY3RpdmUgdGFyZ2V0cy5cbiAgICAgKi9cbiAgICByZWNvcmRQZW5kaW5nVGFyZ2V0UmVxdWVzdCh0YXJnZXRJZCkge1xuICAgICAgICAvLyBGb3IgZWFjaCByZXF1ZXN0IHdlIGdldCB3ZSBuZWVkIHRvIHJlY29yZCB3ZSBuZWVkIGEgcmVzcG9uc2UgZm9yIGl0LlxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xuICAgICAgICB0YXJnZXRTdGF0ZS5yZWNvcmRQZW5kaW5nVGFyZ2V0UmVxdWVzdCgpO1xuICAgIH1cbiAgICBlbnN1cmVUYXJnZXRTdGF0ZSh0YXJnZXRJZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy50YXJnZXRTdGF0ZXMuZ2V0KHRhcmdldElkKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUYXJnZXRTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRTdGF0ZXMuc2V0KHRhcmdldElkLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuc3VyZURvY3VtZW50VGFyZ2V0TWFwcGluZyhrZXkpIHtcbiAgICAgICAgbGV0IHRhcmdldE1hcHBpbmcgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcuZ2V0KGtleSk7XG4gICAgICAgIGlmICghdGFyZ2V0TWFwcGluZykge1xuICAgICAgICAgICAgdGFyZ2V0TWFwcGluZyA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcgPVxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZy5pbnNlcnQoa2V5LCB0YXJnZXRNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0TWFwcGluZztcbiAgICB9XG4gICAgZW5zdXJlRG9jdW1lbnRVcGRhdGVCeVRhcmdldChrZXkpIHtcbiAgICAgICAgbGV0IHRhcmdldE1hcHBpbmcgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXNCeVRhcmdldC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCF0YXJnZXRNYXBwaW5nKSB7XG4gICAgICAgICAgICB0YXJnZXRNYXBwaW5nID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlc0J5VGFyZ2V0ID1cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXNCeVRhcmdldC5pbnNlcnQoa2V5LCB0YXJnZXRNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0TWFwcGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhhdCB0aGUgdXNlciBpcyBzdGlsbCBpbnRlcmVzdGVkIGluIHRoaXMgdGFyZ2V0IChieSBjYWxsaW5nXG4gICAgICogYGdldFRhcmdldERhdGFGb3JUYXJnZXQoKWApIGFuZCB0aGF0IHdlIGFyZSBub3Qgd2FpdGluZyBmb3IgcGVuZGluZyBBRERzXG4gICAgICogZnJvbSB3YXRjaC5cbiAgICAgKi9cbiAgICBpc0FjdGl2ZVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCB0YXJnZXRBY3RpdmUgPSB0aGlzLnRhcmdldERhdGFGb3JBY3RpdmVUYXJnZXQodGFyZ2V0SWQpICE9PSBudWxsO1xuICAgICAgICBpZiAoIXRhcmdldEFjdGl2ZSkge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRnLCAnRGV0ZWN0ZWQgaW5hY3RpdmUgdGFyZ2V0JywgdGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRBY3RpdmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRhcmdldERhdGEgZm9yIGFuIGFjdGl2ZSB0YXJnZXQgKGkuZS4gYSB0YXJnZXQgdGhhdCB0aGUgdXNlclxuICAgICAqIGlzIHN0aWxsIGludGVyZXN0ZWQgaW4gdGhhdCBoYXMgbm8gb3V0c3RhbmRpbmcgdGFyZ2V0IGNoYW5nZSByZXF1ZXN0cykuXG4gICAgICovXG4gICAgdGFyZ2V0RGF0YUZvckFjdGl2ZVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMudGFyZ2V0U3RhdGVzLmdldCh0YXJnZXRJZCk7XG4gICAgICAgIHJldHVybiB0YXJnZXRTdGF0ZSAmJiB0YXJnZXRTdGF0ZS5pc1BlbmRpbmdcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiB0aGlzLm1ldGFkYXRhUHJvdmlkZXIuZ2V0VGFyZ2V0RGF0YUZvclRhcmdldCh0YXJnZXRJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgc3RhdGUgb2YgYSBXYXRjaCB0YXJnZXQgdG8gaXRzIGluaXRpYWwgc3RhdGUgKGUuZy4gc2V0c1xuICAgICAqICdjdXJyZW50JyB0byBmYWxzZSwgY2xlYXJzIHRoZSByZXN1bWUgdG9rZW4gYW5kIHJlbW92ZXMgaXRzIHRhcmdldCBtYXBwaW5nXG4gICAgICogZnJvbSBhbGwgZG9jdW1lbnRzKS5cbiAgICAgKi9cbiAgICByZXNldFRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLnRhcmdldFN0YXRlcy5zZXQodGFyZ2V0SWQsIG5ldyBUYXJnZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gVHJpZ2dlciByZW1vdmFsIGZvciBhbnkgZG9jdW1lbnRzIGN1cnJlbnRseSBtYXBwZWQgdG8gdGhpcyB0YXJnZXQuXG4gICAgICAgIC8vIFRoZXNlIHJlbW92YWxzIHdpbGwgYmUgcGFydCBvZiB0aGUgaW5pdGlhbCBzbmFwc2hvdCBpZiBXYXRjaCBkb2VzIG5vdFxuICAgICAgICAvLyByZXNlbmQgdGhlc2UgZG9jdW1lbnRzLlxuICAgICAgICBjb25zdCBleGlzdGluZ0tleXMgPSB0aGlzLm1ldGFkYXRhUHJvdmlkZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgIGV4aXN0aW5nS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwga2V5LCAvKnVwZGF0ZWREb2N1bWVudD0qLyBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgTG9jYWxTdG9yZSBjb25zaWRlcnMgdGhlIGRvY3VtZW50IHRvIGJlIHBhcnQgb2YgdGhlXG4gICAgICogc3BlY2lmaWVkIHRhcmdldC5cbiAgICAgKi9cbiAgICB0YXJnZXRDb250YWluc0RvY3VtZW50KHRhcmdldElkLCBrZXkpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdLZXlzID0gdGhpcy5tZXRhZGF0YVByb3ZpZGVyLmdldFJlbW90ZUtleXNGb3JUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdLZXlzLmhhcyhrZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRvY3VtZW50VGFyZ2V0TWFwKCkge1xuICAgIHJldHVybiBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xufVxuZnVuY3Rpb24gc25hcHNob3RDaGFuZ2VzTWFwKCkge1xuICAgIHJldHVybiBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xufVxuZnVuY3Rpb24gY3JlYXRlRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hJbmZvRm9yVGVzdGluZ0hvb2tzKGxvY2FsQ2FjaGVDb3VudCwgZXhpc3RlbmNlRmlsdGVyLCBkYXRhYmFzZUlkLCBibG9vbUZpbHRlciwgYmxvb21GaWx0ZXJTdGF0dXMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGxvY2FsQ2FjaGVDb3VudCxcbiAgICAgICAgZXhpc3RlbmNlRmlsdGVyQ291bnQ6IGV4aXN0ZW5jZUZpbHRlci5jb3VudCxcbiAgICAgICAgZGF0YWJhc2VJZDogZGF0YWJhc2VJZC5kYXRhYmFzZSxcbiAgICAgICAgcHJvamVjdElkOiBkYXRhYmFzZUlkLnByb2plY3RJZFxuICAgIH07XG4gICAgY29uc3QgdW5jaGFuZ2VkTmFtZXMgPSBleGlzdGVuY2VGaWx0ZXIudW5jaGFuZ2VkTmFtZXM7XG4gICAgaWYgKHVuY2hhbmdlZE5hbWVzKSB7XG4gICAgICAgIHJlc3VsdC5ibG9vbUZpbHRlciA9IHtcbiAgICAgICAgICAgIGFwcGxpZWQ6IGJsb29tRmlsdGVyU3RhdHVzID09PSAwIC8qIEJsb29tRmlsdGVyQXBwbGljYXRpb25TdGF0dXMuU3VjY2VzcyAqLyxcbiAgICAgICAgICAgIGhhc2hDb3VudDogKF9hID0gdW5jaGFuZ2VkTmFtZXMgPT09IG51bGwgfHwgdW5jaGFuZ2VkTmFtZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVuY2hhbmdlZE5hbWVzLmhhc2hDb3VudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCxcbiAgICAgICAgICAgIGJpdG1hcExlbmd0aDogKF9kID0gKF9jID0gKF9iID0gdW5jaGFuZ2VkTmFtZXMgPT09IG51bGwgfHwgdW5jaGFuZ2VkTmFtZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVuY2hhbmdlZE5hbWVzLmJpdHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5iaXRtYXApID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAoX2YgPSAoX2UgPSB1bmNoYW5nZWROYW1lcyA9PT0gbnVsbCB8fCB1bmNoYW5nZWROYW1lcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5jaGFuZ2VkTmFtZXMuYml0cykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnBhZGRpbmcpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IDAsXG4gICAgICAgICAgICBtaWdodENvbnRhaW46ICh2YWx1ZSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBibG9vbUZpbHRlciA9PT0gbnVsbCB8fCBibG9vbUZpbHRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmxvb21GaWx0ZXIubWlnaHRDb250YWluKHZhbHVlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7IH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERJUkVDVElPTlMgPSAoKCkgPT4ge1xuICAgIGNvbnN0IGRpcnMgPSB7fTtcbiAgICBkaXJzW1wiYXNjXCIgLyogRGlyZWN0aW9uLkFTQ0VORElORyAqL10gPSAnQVNDRU5ESU5HJztcbiAgICBkaXJzW1wiZGVzY1wiIC8qIERpcmVjdGlvbi5ERVNDRU5ESU5HICovXSA9ICdERVNDRU5ESU5HJztcbiAgICByZXR1cm4gZGlycztcbn0pKCk7XG5jb25zdCBPUEVSQVRPUlMgPSAoKCkgPT4ge1xuICAgIGNvbnN0IG9wcyA9IHt9O1xuICAgIG9wc1tcIjxcIiAvKiBPcGVyYXRvci5MRVNTX1RIQU4gKi9dID0gJ0xFU1NfVEhBTic7XG4gICAgb3BzW1wiPD1cIiAvKiBPcGVyYXRvci5MRVNTX1RIQU5fT1JfRVFVQUwgKi9dID0gJ0xFU1NfVEhBTl9PUl9FUVVBTCc7XG4gICAgb3BzW1wiPlwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTiAqL10gPSAnR1JFQVRFUl9USEFOJztcbiAgICBvcHNbXCI+PVwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTl9PUl9FUVVBTCAqL10gPSAnR1JFQVRFUl9USEFOX09SX0VRVUFMJztcbiAgICBvcHNbXCI9PVwiIC8qIE9wZXJhdG9yLkVRVUFMICovXSA9ICdFUVVBTCc7XG4gICAgb3BzW1wiIT1cIiAvKiBPcGVyYXRvci5OT1RfRVFVQUwgKi9dID0gJ05PVF9FUVVBTCc7XG4gICAgb3BzW1wiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqL10gPSAnQVJSQVlfQ09OVEFJTlMnO1xuICAgIG9wc1tcImluXCIgLyogT3BlcmF0b3IuSU4gKi9dID0gJ0lOJztcbiAgICBvcHNbXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi9dID0gJ05PVF9JTic7XG4gICAgb3BzW1wiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovXSA9ICdBUlJBWV9DT05UQUlOU19BTlknO1xuICAgIHJldHVybiBvcHM7XG59KSgpO1xuY29uc3QgQ09NUE9TSVRFX09QRVJBVE9SUyA9ICgoKSA9PiB7XG4gICAgY29uc3Qgb3BzID0ge307XG4gICAgb3BzW1wiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovXSA9ICdBTkQnO1xuICAgIG9wc1tcIm9yXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuT1IgKi9dID0gJ09SJztcbiAgICByZXR1cm4gb3BzO1xufSkoKTtcbmZ1bmN0aW9uIGFzc2VydFByZXNlbnQodmFsdWUsIGRlc2NyaXB0aW9uKSB7XG59XG4vKipcbiAqIFRoaXMgY2xhc3MgZ2VuZXJhdGVzIEpzb25PYmplY3QgdmFsdWVzIGZvciB0aGUgRGF0YXN0b3JlIEFQSSBzdWl0YWJsZSBmb3JcbiAqIHNlbmRpbmcgdG8gZWl0aGVyIEdSUEMgc3R1YiBtZXRob2RzIG9yIHZpYSB0aGUgSlNPTi9IVFRQIFJFU1QgQVBJLlxuICpcbiAqIFRoZSBzZXJpYWxpemVyIHN1cHBvcnRzIGJvdGggUHJvdG9idWYuanMgYW5kIFByb3RvMyBKU09OIGZvcm1hdHMuIEJ5XG4gKiBzZXR0aW5nIGB1c2VQcm90bzNKc29uYCB0byB0cnVlLCB0aGUgc2VyaWFsaXplciB3aWxsIHVzZSB0aGUgUHJvdG8zIEpTT05cbiAqIGZvcm1hdC5cbiAqXG4gKiBGb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgUHJvdG8zIEpTT04gZm9ybWF0IGNoZWNrXG4gKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvcHJvdG8zI2pzb25cbiAqXG4gKiBUT0RPKGtsaW10KTogV2UgY2FuIHJlbW92ZSB0aGUgZGF0YWJhc2VJZCBhcmd1bWVudCBpZiB3ZSBrZWVwIHRoZSBmdWxsXG4gKiByZXNvdXJjZSBuYW1lIGluIGRvY3VtZW50cy5cbiAqL1xuY2xhc3MgSnNvblByb3RvU2VyaWFsaXplciB7XG4gICAgY29uc3RydWN0b3IoZGF0YWJhc2VJZCwgdXNlUHJvdG8zSnNvbikge1xuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBkYXRhYmFzZUlkO1xuICAgICAgICB0aGlzLnVzZVByb3RvM0pzb24gPSB1c2VQcm90bzNKc29uO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21ScGNTdGF0dXMoc3RhdHVzKSB7XG4gICAgY29uc3QgY29kZSA9IHN0YXR1cy5jb2RlID09PSB1bmRlZmluZWQgPyBDb2RlLlVOS05PV04gOiBtYXBDb2RlRnJvbVJwY0NvZGUoc3RhdHVzLmNvZGUpO1xuICAgIHJldHVybiBuZXcgRmlyZXN0b3JlRXJyb3IoY29kZSwgc3RhdHVzLm1lc3NhZ2UgfHwgJycpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWUgZm9yIGEgbnVtYmVyIChvciBudWxsKSB0aGF0J3MgYXBwcm9wcmlhdGUgdG8gcHV0IGludG9cbiAqIGEgZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWUgcHJvdG8uXG4gKiBETyBOT1QgVVNFIFRISVMgRk9SIEFOWVRISU5HIEVMU0UuXG4gKiBUaGlzIG1ldGhvZCBjaGVhdHMuIEl0J3MgdHlwZWQgYXMgcmV0dXJuaW5nIFwibnVtYmVyXCIgYmVjYXVzZSB0aGF0J3Mgd2hhdFxuICogb3VyIGdlbmVyYXRlZCBwcm90byBpbnRlcmZhY2VzIHNheSBJbnQzMlZhbHVlIG11c3QgYmUuIEJ1dCBHUlBDIGFjdHVhbGx5XG4gKiBleHBlY3RzIGEgeyB2YWx1ZTogPG51bWJlcj4gfSBzdHJ1Y3QuXG4gKi9cbmZ1bmN0aW9uIHRvSW50MzJQcm90byhzZXJpYWxpemVyLCB2YWwpIHtcbiAgICBpZiAoc2VyaWFsaXplci51c2VQcm90bzNKc29uIHx8IGlzTnVsbE9yVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWwgfTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgKG9yIG51bGwpIGZyb20gYSBnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZSBwcm90by5cbiAqL1xuZnVuY3Rpb24gZnJvbUludDMyUHJvdG8odmFsKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmVzdWx0ID0gdmFsLnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gaXNOdWxsT3JVbmRlZmluZWQocmVzdWx0KSA/IG51bGwgOiByZXN1bHQ7XG59XG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSBmb3IgYSBEYXRlIHRoYXQncyBhcHByb3ByaWF0ZSB0byBwdXQgaW50byBhIHByb3RvLlxuICovXG5mdW5jdGlvbiB0b1RpbWVzdGFtcChzZXJpYWxpemVyLCB0aW1lc3RhbXApIHtcbiAgICBpZiAoc2VyaWFsaXplci51c2VQcm90bzNKc29uKSB7XG4gICAgICAgIC8vIFNlcmlhbGl6ZSB0byBJU08tODYwMSBkYXRlIGZvcm1hdCwgYnV0IHdpdGggZnVsbCBuYW5vIHJlc29sdXRpb24uXG4gICAgICAgIC8vIFNpbmNlIEpTIERhdGUgaGFzIG9ubHkgbWlsbGlzLCBsZXQncyBvbmx5IHVzZSBpdCBmb3IgdGhlIHNlY29uZHMgYW5kXG4gICAgICAgIC8vIHRoZW4gbWFudWFsbHkgYWRkIHRoZSBmcmFjdGlvbnMgdG8gdGhlIGVuZC5cbiAgICAgICAgY29uc3QganNEYXRlU3RyID0gbmV3IERhdGUodGltZXN0YW1wLnNlY29uZHMgKiAxMDAwKS50b0lTT1N0cmluZygpO1xuICAgICAgICAvLyBSZW1vdmUgLnh4eCBmcmFjIHBhcnQgYW5kIFogaW4gdGhlIGVuZC5cbiAgICAgICAgY29uc3Qgc3RyVW50aWxTZWNvbmRzID0ganNEYXRlU3RyLnJlcGxhY2UoL1xcLlxcZCovLCAnJykucmVwbGFjZSgnWicsICcnKTtcbiAgICAgICAgLy8gUGFkIHRoZSBmcmFjdGlvbiBvdXQgdG8gOSBkaWdpdHMgKG5hbm9zKS5cbiAgICAgICAgY29uc3QgbmFub1N0ciA9ICgnMDAwMDAwMDAwJyArIHRpbWVzdGFtcC5uYW5vc2Vjb25kcykuc2xpY2UoLTkpO1xuICAgICAgICByZXR1cm4gYCR7c3RyVW50aWxTZWNvbmRzfS4ke25hbm9TdHJ9WmA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2Vjb25kczogJycgKyB0aW1lc3RhbXAuc2Vjb25kcyxcbiAgICAgICAgICAgIG5hbm9zOiB0aW1lc3RhbXAubmFub3NlY29uZHNcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZnJvbVRpbWVzdGFtcChkYXRlKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKGRhdGUpO1xuICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHRpbWVzdGFtcC5zZWNvbmRzLCB0aW1lc3RhbXAubmFub3MpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWUgZm9yIGJ5dGVzIHRoYXQncyBhcHByb3ByaWF0ZSB0byBwdXQgaW4gYSBwcm90by5cbiAqXG4gKiBWaXNpYmxlIGZvciB0ZXN0aW5nLlxuICovXG5mdW5jdGlvbiB0b0J5dGVzKHNlcmlhbGl6ZXIsIGJ5dGVzKSB7XG4gICAgaWYgKHNlcmlhbGl6ZXIudXNlUHJvdG8zSnNvbikge1xuICAgICAgICByZXR1cm4gYnl0ZXMudG9CYXNlNjQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBieXRlcy50b1VpbnQ4QXJyYXkoKTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgYSBCeXRlU3RyaW5nIGJhc2VkIG9uIHRoZSBwcm90byBzdHJpbmcgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGZyb21CeXRlcyhzZXJpYWxpemVyLCB2YWx1ZSkge1xuICAgIGlmIChzZXJpYWxpemVyLnVzZVByb3RvM0pzb24pIHtcbiAgICAgICAgaGFyZEFzc2VydCh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpO1xuICAgICAgICByZXR1cm4gQnl0ZVN0cmluZy5mcm9tQmFzZTY0U3RyaW5nKHZhbHVlID8gdmFsdWUgOiAnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoYXJkQXNzZXJ0KHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBib3RoIEJ1ZmZlciBhbmQgVWludDhBcnJheSxcbiAgICAgICAgICAgIC8vIGRlc3BpdGUgdGhlIGZhY3QgdGhhdCBCdWZmZXIgZXh0ZW5kcyBVaW50OEFycmF5LiBJbiBzb21lXG4gICAgICAgICAgICAvLyBlbnZpcm9ubWVudHMsIHN1Y2ggYXMganNkb20sIHRoZSBwcm90b3R5cGUgY2hhaW4gb2YgQnVmZmVyXG4gICAgICAgICAgICAvLyBkb2VzIG5vdCBpbmRpY2F0ZSB0aGF0IGl0IGV4dGVuZHMgVWludDhBcnJheS5cbiAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgQnVmZmVyIHx8XG4gICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xuICAgICAgICByZXR1cm4gQnl0ZVN0cmluZy5mcm9tVWludDhBcnJheSh2YWx1ZSA/IHZhbHVlIDogbmV3IFVpbnQ4QXJyYXkoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9WZXJzaW9uKHNlcmlhbGl6ZXIsIHZlcnNpb24pIHtcbiAgICByZXR1cm4gdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgdmVyc2lvbi50b1RpbWVzdGFtcCgpKTtcbn1cbmZ1bmN0aW9uIGZyb21WZXJzaW9uKHZlcnNpb24pIHtcbiAgICBoYXJkQXNzZXJ0KCEhdmVyc2lvbik7XG4gICAgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5mcm9tVGltZXN0YW1wKGZyb21UaW1lc3RhbXAodmVyc2lvbikpO1xufVxuZnVuY3Rpb24gdG9SZXNvdXJjZU5hbWUoZGF0YWJhc2VJZCwgcGF0aCkge1xuICAgIHJldHVybiB0b1Jlc291cmNlUGF0aChkYXRhYmFzZUlkLCBwYXRoKS5jYW5vbmljYWxTdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIHRvUmVzb3VyY2VQYXRoKGRhdGFiYXNlSWQsIHBhdGgpIHtcbiAgICBjb25zdCByZXNvdXJjZVBhdGggPSBmdWxseVF1YWxpZmllZFByZWZpeFBhdGgoZGF0YWJhc2VJZCkuY2hpbGQoJ2RvY3VtZW50cycpO1xuICAgIHJldHVybiBwYXRoID09PSB1bmRlZmluZWQgPyByZXNvdXJjZVBhdGggOiByZXNvdXJjZVBhdGguY2hpbGQocGF0aCk7XG59XG5mdW5jdGlvbiBmcm9tUmVzb3VyY2VOYW1lKG5hbWUpIHtcbiAgICBjb25zdCByZXNvdXJjZSA9IFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKG5hbWUpO1xuICAgIGhhcmRBc3NlcnQoaXNWYWxpZFJlc291cmNlTmFtZShyZXNvdXJjZSkpO1xuICAgIHJldHVybiByZXNvdXJjZTtcbn1cbmZ1bmN0aW9uIHRvTmFtZShzZXJpYWxpemVyLCBrZXkpIHtcbiAgICByZXR1cm4gdG9SZXNvdXJjZU5hbWUoc2VyaWFsaXplci5kYXRhYmFzZUlkLCBrZXkucGF0aCk7XG59XG5mdW5jdGlvbiBmcm9tTmFtZShzZXJpYWxpemVyLCBuYW1lKSB7XG4gICAgY29uc3QgcmVzb3VyY2UgPSBmcm9tUmVzb3VyY2VOYW1lKG5hbWUpO1xuICAgIGlmIChyZXNvdXJjZS5nZXQoMSkgIT09IHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5wcm9qZWN0SWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RyaWVkIHRvIGRlc2VyaWFsaXplIGtleSBmcm9tIGRpZmZlcmVudCBwcm9qZWN0OiAnICtcbiAgICAgICAgICAgIHJlc291cmNlLmdldCgxKSArXG4gICAgICAgICAgICAnIHZzICcgK1xuICAgICAgICAgICAgc2VyaWFsaXplci5kYXRhYmFzZUlkLnByb2plY3RJZCk7XG4gICAgfVxuICAgIGlmIChyZXNvdXJjZS5nZXQoMykgIT09IHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5kYXRhYmFzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVHJpZWQgdG8gZGVzZXJpYWxpemUga2V5IGZyb20gZGlmZmVyZW50IGRhdGFiYXNlOiAnICtcbiAgICAgICAgICAgIHJlc291cmNlLmdldCgzKSArXG4gICAgICAgICAgICAnIHZzICcgK1xuICAgICAgICAgICAgc2VyaWFsaXplci5kYXRhYmFzZUlkLmRhdGFiYXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShleHRyYWN0TG9jYWxQYXRoRnJvbVJlc291cmNlTmFtZShyZXNvdXJjZSkpO1xufVxuZnVuY3Rpb24gdG9RdWVyeVBhdGgoc2VyaWFsaXplciwgcGF0aCkge1xuICAgIHJldHVybiB0b1Jlc291cmNlTmFtZShzZXJpYWxpemVyLmRhdGFiYXNlSWQsIHBhdGgpO1xufVxuZnVuY3Rpb24gZnJvbVF1ZXJ5UGF0aChuYW1lKSB7XG4gICAgY29uc3QgcmVzb3VyY2VOYW1lID0gZnJvbVJlc291cmNlTmFtZShuYW1lKTtcbiAgICAvLyBJbiB2MWJldGExIHF1ZXJpZXMgZm9yIGNvbGxlY3Rpb25zIGF0IHRoZSByb290IGRpZCBub3QgaGF2ZSBhIHRyYWlsaW5nXG4gICAgLy8gXCIvZG9jdW1lbnRzXCIuIEluIHYxIGFsbCByZXNvdXJjZSBwYXRocyBjb250YWluIFwiL2RvY3VtZW50c1wiLiBQcmVzZXJ2ZSB0aGVcbiAgICAvLyBhYmlsaXR5IHRvIHJlYWQgdGhlIHYxYmV0YTEgZm9ybSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHF1ZXJpZXMgcGVyc2lzdGVkXG4gICAgLy8gaW4gdGhlIGxvY2FsIHRhcmdldCBjYWNoZS5cbiAgICBpZiAocmVzb3VyY2VOYW1lLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICByZXR1cm4gUmVzb3VyY2VQYXRoLmVtcHR5UGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gZXh0cmFjdExvY2FsUGF0aEZyb21SZXNvdXJjZU5hbWUocmVzb3VyY2VOYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEVuY29kZWREYXRhYmFzZUlkKHNlcmlhbGl6ZXIpIHtcbiAgICBjb25zdCBwYXRoID0gbmV3IFJlc291cmNlUGF0aChbXG4gICAgICAgICdwcm9qZWN0cycsXG4gICAgICAgIHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5wcm9qZWN0SWQsXG4gICAgICAgICdkYXRhYmFzZXMnLFxuICAgICAgICBzZXJpYWxpemVyLmRhdGFiYXNlSWQuZGF0YWJhc2VcbiAgICBdKTtcbiAgICByZXR1cm4gcGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGZ1bGx5UXVhbGlmaWVkUHJlZml4UGF0aChkYXRhYmFzZUlkKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBhdGgoW1xuICAgICAgICAncHJvamVjdHMnLFxuICAgICAgICBkYXRhYmFzZUlkLnByb2plY3RJZCxcbiAgICAgICAgJ2RhdGFiYXNlcycsXG4gICAgICAgIGRhdGFiYXNlSWQuZGF0YWJhc2VcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RMb2NhbFBhdGhGcm9tUmVzb3VyY2VOYW1lKHJlc291cmNlTmFtZSkge1xuICAgIGhhcmRBc3NlcnQocmVzb3VyY2VOYW1lLmxlbmd0aCA+IDQgJiYgcmVzb3VyY2VOYW1lLmdldCg0KSA9PT0gJ2RvY3VtZW50cycpO1xuICAgIHJldHVybiByZXNvdXJjZU5hbWUucG9wRmlyc3QoNSk7XG59XG4vKiogQ3JlYXRlcyBhIERvY3VtZW50IHByb3RvIGZyb20ga2V5IGFuZCBmaWVsZHMgKGJ1dCBubyBjcmVhdGUvdXBkYXRlIHRpbWUpICovXG5mdW5jdGlvbiB0b011dGF0aW9uRG9jdW1lbnQoc2VyaWFsaXplciwga2V5LCBmaWVsZHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiB0b05hbWUoc2VyaWFsaXplciwga2V5KSxcbiAgICAgICAgZmllbGRzOiBmaWVsZHMudmFsdWUubWFwVmFsdWUuZmllbGRzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvRG9jdW1lbnQoc2VyaWFsaXplciwgZG9jdW1lbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiB0b05hbWUoc2VyaWFsaXplciwgZG9jdW1lbnQua2V5KSxcbiAgICAgICAgZmllbGRzOiBkb2N1bWVudC5kYXRhLnZhbHVlLm1hcFZhbHVlLmZpZWxkcyxcbiAgICAgICAgdXBkYXRlVGltZTogdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgZG9jdW1lbnQudmVyc2lvbi50b1RpbWVzdGFtcCgpKSxcbiAgICAgICAgY3JlYXRlVGltZTogdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgZG9jdW1lbnQuY3JlYXRlVGltZS50b1RpbWVzdGFtcCgpKVxuICAgIH07XG59XG5mdW5jdGlvbiBmcm9tRG9jdW1lbnQoc2VyaWFsaXplciwgZG9jdW1lbnQsIGhhc0NvbW1pdHRlZE11dGF0aW9ucykge1xuICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIGRvY3VtZW50Lm5hbWUpO1xuICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tVmVyc2lvbihkb2N1bWVudC51cGRhdGVUaW1lKTtcbiAgICAvLyBJZiB3ZSByZWFkIGEgZG9jdW1lbnQgZnJvbSBwZXJzaXN0ZW5jZSB0aGF0IGlzIG1pc3NpbmcgY3JlYXRlVGltZSwgaXQncyBkdWVcbiAgICAvLyB0byBvbGRlciBTREsgdmVyc2lvbnMgbm90IHN0b3JpbmcgdGhpcyBpbmZvcm1hdGlvbi4gSW4gc3VjaCBjYXNlcywgd2UnbGxcbiAgICAvLyBzZXQgdGhlIGNyZWF0ZVRpbWUgdG8gemVyby4gVGhpcyBjYW4gYmUgcmVtb3ZlZCBpbiB0aGUgbG9uZyB0ZXJtLlxuICAgIGNvbnN0IGNyZWF0ZVRpbWUgPSBkb2N1bWVudC5jcmVhdGVUaW1lXG4gICAgICAgID8gZnJvbVZlcnNpb24oZG9jdW1lbnQuY3JlYXRlVGltZSlcbiAgICAgICAgOiBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBPYmplY3RWYWx1ZSh7IG1hcFZhbHVlOiB7IGZpZWxkczogZG9jdW1lbnQuZmllbGRzIH0gfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gTXV0YWJsZURvY3VtZW50Lm5ld0ZvdW5kRG9jdW1lbnQoa2V5LCB2ZXJzaW9uLCBjcmVhdGVUaW1lLCBkYXRhKTtcbiAgICBpZiAoaGFzQ29tbWl0dGVkTXV0YXRpb25zKSB7XG4gICAgICAgIHJlc3VsdC5zZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0NvbW1pdHRlZE11dGF0aW9ucyA/IHJlc3VsdC5zZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKSA6IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZyb21Gb3VuZChzZXJpYWxpemVyLCBkb2MpIHtcbiAgICBoYXJkQXNzZXJ0KCEhZG9jLmZvdW5kKTtcbiAgICBhc3NlcnRQcmVzZW50KGRvYy5mb3VuZC5uYW1lKTtcbiAgICBhc3NlcnRQcmVzZW50KGRvYy5mb3VuZC51cGRhdGVUaW1lKTtcbiAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCBkb2MuZm91bmQubmFtZSk7XG4gICAgY29uc3QgdmVyc2lvbiA9IGZyb21WZXJzaW9uKGRvYy5mb3VuZC51cGRhdGVUaW1lKTtcbiAgICBjb25zdCBjcmVhdGVUaW1lID0gZG9jLmZvdW5kLmNyZWF0ZVRpbWVcbiAgICAgICAgPyBmcm9tVmVyc2lvbihkb2MuZm91bmQuY3JlYXRlVGltZSlcbiAgICAgICAgOiBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBPYmplY3RWYWx1ZSh7IG1hcFZhbHVlOiB7IGZpZWxkczogZG9jLmZvdW5kLmZpZWxkcyB9IH0pO1xuICAgIHJldHVybiBNdXRhYmxlRG9jdW1lbnQubmV3Rm91bmREb2N1bWVudChrZXksIHZlcnNpb24sIGNyZWF0ZVRpbWUsIGRhdGEpO1xufVxuZnVuY3Rpb24gZnJvbU1pc3Npbmcoc2VyaWFsaXplciwgcmVzdWx0KSB7XG4gICAgaGFyZEFzc2VydCghIXJlc3VsdC5taXNzaW5nKTtcbiAgICBoYXJkQXNzZXJ0KCEhcmVzdWx0LnJlYWRUaW1lKTtcbiAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCByZXN1bHQubWlzc2luZyk7XG4gICAgY29uc3QgdmVyc2lvbiA9IGZyb21WZXJzaW9uKHJlc3VsdC5yZWFkVGltZSk7XG4gICAgcmV0dXJuIE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGtleSwgdmVyc2lvbik7XG59XG5mdW5jdGlvbiBmcm9tQmF0Y2hHZXREb2N1bWVudHNSZXNwb25zZShzZXJpYWxpemVyLCByZXN1bHQpIHtcbiAgICBpZiAoJ2ZvdW5kJyBpbiByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGZyb21Gb3VuZChzZXJpYWxpemVyLCByZXN1bHQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnbWlzc2luZycgaW4gcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBmcm9tTWlzc2luZyhzZXJpYWxpemVyLCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gZmFpbCgpO1xufVxuZnVuY3Rpb24gZnJvbVdhdGNoQ2hhbmdlKHNlcmlhbGl6ZXIsIGNoYW5nZSkge1xuICAgIGxldCB3YXRjaENoYW5nZTtcbiAgICBpZiAoJ3RhcmdldENoYW5nZScgaW4gY2hhbmdlKSB7XG4gICAgICAgIGFzc2VydFByZXNlbnQoY2hhbmdlLnRhcmdldENoYW5nZSk7XG4gICAgICAgIC8vIHByb3RvMyBkZWZhdWx0IHZhbHVlIGlzIHVuc2V0IGluIEpTT04gKHVuZGVmaW5lZCksIHNvIHVzZSAnTk9fQ0hBTkdFJ1xuICAgICAgICAvLyBpZiB1bnNldFxuICAgICAgICBjb25zdCBzdGF0ZSA9IGZyb21XYXRjaFRhcmdldENoYW5nZVN0YXRlKGNoYW5nZS50YXJnZXRDaGFuZ2UudGFyZ2V0Q2hhbmdlVHlwZSB8fCAnTk9fQ0hBTkdFJyk7XG4gICAgICAgIGNvbnN0IHRhcmdldElkcyA9IGNoYW5nZS50YXJnZXRDaGFuZ2UudGFyZ2V0SWRzIHx8IFtdO1xuICAgICAgICBjb25zdCByZXN1bWVUb2tlbiA9IGZyb21CeXRlcyhzZXJpYWxpemVyLCBjaGFuZ2UudGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuKTtcbiAgICAgICAgY29uc3QgY2F1c2VQcm90byA9IGNoYW5nZS50YXJnZXRDaGFuZ2UuY2F1c2U7XG4gICAgICAgIGNvbnN0IGNhdXNlID0gY2F1c2VQcm90byAmJiBmcm9tUnBjU3RhdHVzKGNhdXNlUHJvdG8pO1xuICAgICAgICB3YXRjaENoYW5nZSA9IG5ldyBXYXRjaFRhcmdldENoYW5nZShzdGF0ZSwgdGFyZ2V0SWRzLCByZXN1bWVUb2tlbiwgY2F1c2UgfHwgbnVsbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdkb2N1bWVudENoYW5nZScgaW4gY2hhbmdlKSB7XG4gICAgICAgIGFzc2VydFByZXNlbnQoY2hhbmdlLmRvY3VtZW50Q2hhbmdlKTtcbiAgICAgICAgY29uc3QgZW50aXR5Q2hhbmdlID0gY2hhbmdlLmRvY3VtZW50Q2hhbmdlO1xuICAgICAgICBhc3NlcnRQcmVzZW50KGVudGl0eUNoYW5nZS5kb2N1bWVudCk7XG4gICAgICAgIGFzc2VydFByZXNlbnQoZW50aXR5Q2hhbmdlLmRvY3VtZW50Lm5hbWUpO1xuICAgICAgICBhc3NlcnRQcmVzZW50KGVudGl0eUNoYW5nZS5kb2N1bWVudC51cGRhdGVUaW1lKTtcbiAgICAgICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgZW50aXR5Q2hhbmdlLmRvY3VtZW50Lm5hbWUpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gZnJvbVZlcnNpb24oZW50aXR5Q2hhbmdlLmRvY3VtZW50LnVwZGF0ZVRpbWUpO1xuICAgICAgICBjb25zdCBjcmVhdGVUaW1lID0gZW50aXR5Q2hhbmdlLmRvY3VtZW50LmNyZWF0ZVRpbWVcbiAgICAgICAgICAgID8gZnJvbVZlcnNpb24oZW50aXR5Q2hhbmdlLmRvY3VtZW50LmNyZWF0ZVRpbWUpXG4gICAgICAgICAgICA6IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBPYmplY3RWYWx1ZSh7XG4gICAgICAgICAgICBtYXBWYWx1ZTogeyBmaWVsZHM6IGVudGl0eUNoYW5nZS5kb2N1bWVudC5maWVsZHMgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZG9jID0gTXV0YWJsZURvY3VtZW50Lm5ld0ZvdW5kRG9jdW1lbnQoa2V5LCB2ZXJzaW9uLCBjcmVhdGVUaW1lLCBkYXRhKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZFRhcmdldElkcyA9IGVudGl0eUNoYW5nZS50YXJnZXRJZHMgfHwgW107XG4gICAgICAgIGNvbnN0IHJlbW92ZWRUYXJnZXRJZHMgPSBlbnRpdHlDaGFuZ2UucmVtb3ZlZFRhcmdldElkcyB8fCBbXTtcbiAgICAgICAgd2F0Y2hDaGFuZ2UgPSBuZXcgRG9jdW1lbnRXYXRjaENoYW5nZSh1cGRhdGVkVGFyZ2V0SWRzLCByZW1vdmVkVGFyZ2V0SWRzLCBkb2Mua2V5LCBkb2MpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnZG9jdW1lbnREZWxldGUnIGluIGNoYW5nZSkge1xuICAgICAgICBhc3NlcnRQcmVzZW50KGNoYW5nZS5kb2N1bWVudERlbGV0ZSk7XG4gICAgICAgIGNvbnN0IGRvY0RlbGV0ZSA9IGNoYW5nZS5kb2N1bWVudERlbGV0ZTtcbiAgICAgICAgYXNzZXJ0UHJlc2VudChkb2NEZWxldGUuZG9jdW1lbnQpO1xuICAgICAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCBkb2NEZWxldGUuZG9jdW1lbnQpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gZG9jRGVsZXRlLnJlYWRUaW1lXG4gICAgICAgICAgICA/IGZyb21WZXJzaW9uKGRvY0RlbGV0ZS5yZWFkVGltZSlcbiAgICAgICAgICAgIDogU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgICAgICBjb25zdCBkb2MgPSBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudChrZXksIHZlcnNpb24pO1xuICAgICAgICBjb25zdCByZW1vdmVkVGFyZ2V0SWRzID0gZG9jRGVsZXRlLnJlbW92ZWRUYXJnZXRJZHMgfHwgW107XG4gICAgICAgIHdhdGNoQ2hhbmdlID0gbmV3IERvY3VtZW50V2F0Y2hDaGFuZ2UoW10sIHJlbW92ZWRUYXJnZXRJZHMsIGRvYy5rZXksIGRvYyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdkb2N1bWVudFJlbW92ZScgaW4gY2hhbmdlKSB7XG4gICAgICAgIGFzc2VydFByZXNlbnQoY2hhbmdlLmRvY3VtZW50UmVtb3ZlKTtcbiAgICAgICAgY29uc3QgZG9jUmVtb3ZlID0gY2hhbmdlLmRvY3VtZW50UmVtb3ZlO1xuICAgICAgICBhc3NlcnRQcmVzZW50KGRvY1JlbW92ZS5kb2N1bWVudCk7XG4gICAgICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIGRvY1JlbW92ZS5kb2N1bWVudCk7XG4gICAgICAgIGNvbnN0IHJlbW92ZWRUYXJnZXRJZHMgPSBkb2NSZW1vdmUucmVtb3ZlZFRhcmdldElkcyB8fCBbXTtcbiAgICAgICAgd2F0Y2hDaGFuZ2UgPSBuZXcgRG9jdW1lbnRXYXRjaENoYW5nZShbXSwgcmVtb3ZlZFRhcmdldElkcywga2V5LCBudWxsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2ZpbHRlcicgaW4gY2hhbmdlKSB7XG4gICAgICAgIC8vIFRPRE8oZGltb25kKTogaW1wbGVtZW50IGV4aXN0ZW5jZSBmaWx0ZXIgcGFyc2luZyB3aXRoIHN0cmF0ZWd5LlxuICAgICAgICBhc3NlcnRQcmVzZW50KGNoYW5nZS5maWx0ZXIpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSBjaGFuZ2UuZmlsdGVyO1xuICAgICAgICBhc3NlcnRQcmVzZW50KGZpbHRlci50YXJnZXRJZCk7XG4gICAgICAgIGNvbnN0IHsgY291bnQgPSAwLCB1bmNoYW5nZWROYW1lcyB9ID0gZmlsdGVyO1xuICAgICAgICBjb25zdCBleGlzdGVuY2VGaWx0ZXIgPSBuZXcgRXhpc3RlbmNlRmlsdGVyKGNvdW50LCB1bmNoYW5nZWROYW1lcyk7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gZmlsdGVyLnRhcmdldElkO1xuICAgICAgICB3YXRjaENoYW5nZSA9IG5ldyBFeGlzdGVuY2VGaWx0ZXJDaGFuZ2UodGFyZ2V0SWQsIGV4aXN0ZW5jZUZpbHRlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbiAgICByZXR1cm4gd2F0Y2hDaGFuZ2U7XG59XG5mdW5jdGlvbiBmcm9tV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZShzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9PT0gJ05PX0NIQU5HRScpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5Ob0NoYW5nZSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGUgPT09ICdBREQnKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuQWRkZWQgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlID09PSAnUkVNT1ZFJykge1xuICAgICAgICByZXR1cm4gMiAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLlJlbW92ZWQgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlID09PSAnQ1VSUkVOVCcpIHtcbiAgICAgICAgcmV0dXJuIDMgLyogV2F0Y2hUYXJnZXRDaGFuZ2VTdGF0ZS5DdXJyZW50ICovO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ1JFU0VUJykge1xuICAgICAgICByZXR1cm4gNCAvKiBXYXRjaFRhcmdldENoYW5nZVN0YXRlLlJlc2V0ICovO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2ZXJzaW9uRnJvbUxpc3RlblJlc3BvbnNlKGNoYW5nZSkge1xuICAgIC8vIFdlIGhhdmUgb25seSByZWFjaGVkIGEgY29uc2lzdGVudCBzbmFwc2hvdCBmb3IgdGhlIGVudGlyZSBzdHJlYW0gaWYgdGhlcmVcbiAgICAvLyBpcyBhIHJlYWRfdGltZSBzZXQgYW5kIGl0IGFwcGxpZXMgdG8gYWxsIHRhcmdldHMgKGkuZS4gdGhlIGxpc3Qgb2ZcbiAgICAvLyB0YXJnZXRzIGlzIGVtcHR5KS4gVGhlIGJhY2tlbmQgaXMgZ3VhcmFudGVlZCB0byBzZW5kIHN1Y2ggcmVzcG9uc2VzLlxuICAgIGlmICghKCd0YXJnZXRDaGFuZ2UnIGluIGNoYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0Q2hhbmdlID0gY2hhbmdlLnRhcmdldENoYW5nZTtcbiAgICBpZiAodGFyZ2V0Q2hhbmdlLnRhcmdldElkcyAmJiB0YXJnZXRDaGFuZ2UudGFyZ2V0SWRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgIH1cbiAgICBpZiAoIXRhcmdldENoYW5nZS5yZWFkVGltZSkge1xuICAgICAgICByZXR1cm4gU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbVZlcnNpb24odGFyZ2V0Q2hhbmdlLnJlYWRUaW1lKTtcbn1cbmZ1bmN0aW9uIHRvTXV0YXRpb24oc2VyaWFsaXplciwgbXV0YXRpb24pIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChtdXRhdGlvbiBpbnN0YW5jZW9mIFNldE11dGF0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHVwZGF0ZTogdG9NdXRhdGlvbkRvY3VtZW50KHNlcmlhbGl6ZXIsIG11dGF0aW9uLmtleSwgbXV0YXRpb24udmFsdWUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgRGVsZXRlTXV0YXRpb24pIHtcbiAgICAgICAgcmVzdWx0ID0geyBkZWxldGU6IHRvTmFtZShzZXJpYWxpemVyLCBtdXRhdGlvbi5rZXkpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgUGF0Y2hNdXRhdGlvbikge1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICB1cGRhdGU6IHRvTXV0YXRpb25Eb2N1bWVudChzZXJpYWxpemVyLCBtdXRhdGlvbi5rZXksIG11dGF0aW9uLmRhdGEpLFxuICAgICAgICAgICAgdXBkYXRlTWFzazogdG9Eb2N1bWVudE1hc2sobXV0YXRpb24uZmllbGRNYXNrKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChtdXRhdGlvbiBpbnN0YW5jZW9mIFZlcmlmeU11dGF0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHZlcmlmeTogdG9OYW1lKHNlcmlhbGl6ZXIsIG11dGF0aW9uLmtleSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQudXBkYXRlVHJhbnNmb3JtcyA9IG11dGF0aW9uLmZpZWxkVHJhbnNmb3Jtcy5tYXAodHJhbnNmb3JtID0+IHRvRmllbGRUcmFuc2Zvcm0oc2VyaWFsaXplciwgdHJhbnNmb3JtKSk7XG4gICAgfVxuICAgIGlmICghbXV0YXRpb24ucHJlY29uZGl0aW9uLmlzTm9uZSkge1xuICAgICAgICByZXN1bHQuY3VycmVudERvY3VtZW50ID0gdG9QcmVjb25kaXRpb24oc2VyaWFsaXplciwgbXV0YXRpb24ucHJlY29uZGl0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZyb21NdXRhdGlvbihzZXJpYWxpemVyLCBwcm90bykge1xuICAgIGNvbnN0IHByZWNvbmRpdGlvbiA9IHByb3RvLmN1cnJlbnREb2N1bWVudFxuICAgICAgICA/IGZyb21QcmVjb25kaXRpb24ocHJvdG8uY3VycmVudERvY3VtZW50KVxuICAgICAgICA6IFByZWNvbmRpdGlvbi5ub25lKCk7XG4gICAgY29uc3QgZmllbGRUcmFuc2Zvcm1zID0gcHJvdG8udXBkYXRlVHJhbnNmb3Jtc1xuICAgICAgICA/IHByb3RvLnVwZGF0ZVRyYW5zZm9ybXMubWFwKHRyYW5zZm9ybSA9PiBmcm9tRmllbGRUcmFuc2Zvcm0oc2VyaWFsaXplciwgdHJhbnNmb3JtKSlcbiAgICAgICAgOiBbXTtcbiAgICBpZiAocHJvdG8udXBkYXRlKSB7XG4gICAgICAgIGFzc2VydFByZXNlbnQocHJvdG8udXBkYXRlLm5hbWUpO1xuICAgICAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCBwcm90by51cGRhdGUubmFtZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IE9iamVjdFZhbHVlKHtcbiAgICAgICAgICAgIG1hcFZhbHVlOiB7IGZpZWxkczogcHJvdG8udXBkYXRlLmZpZWxkcyB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvdG8udXBkYXRlTWFzaykge1xuICAgICAgICAgICAgY29uc3QgZmllbGRNYXNrID0gZnJvbURvY3VtZW50TWFzayhwcm90by51cGRhdGVNYXNrKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGF0Y2hNdXRhdGlvbihrZXksIHZhbHVlLCBmaWVsZE1hc2ssIHByZWNvbmRpdGlvbiwgZmllbGRUcmFuc2Zvcm1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0TXV0YXRpb24oa2V5LCB2YWx1ZSwgcHJlY29uZGl0aW9uLCBmaWVsZFRyYW5zZm9ybXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3RvLmRlbGV0ZSkge1xuICAgICAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCBwcm90by5kZWxldGUpO1xuICAgICAgICByZXR1cm4gbmV3IERlbGV0ZU11dGF0aW9uKGtleSwgcHJlY29uZGl0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvdG8udmVyaWZ5KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIHByb3RvLnZlcmlmeSk7XG4gICAgICAgIHJldHVybiBuZXcgVmVyaWZ5TXV0YXRpb24oa2V5LCBwcmVjb25kaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1ByZWNvbmRpdGlvbihzZXJpYWxpemVyLCBwcmVjb25kaXRpb24pIHtcbiAgICBpZiAocHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXBkYXRlVGltZTogdG9WZXJzaW9uKHNlcmlhbGl6ZXIsIHByZWNvbmRpdGlvbi51cGRhdGVUaW1lKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChwcmVjb25kaXRpb24uZXhpc3RzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgZXhpc3RzOiBwcmVjb25kaXRpb24uZXhpc3RzIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21QcmVjb25kaXRpb24ocHJlY29uZGl0aW9uKSB7XG4gICAgaWYgKHByZWNvbmRpdGlvbi51cGRhdGVUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi51cGRhdGVUaW1lKGZyb21WZXJzaW9uKHByZWNvbmRpdGlvbi51cGRhdGVUaW1lKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByZWNvbmRpdGlvbi5leGlzdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gUHJlY29uZGl0aW9uLmV4aXN0cyhwcmVjb25kaXRpb24uZXhpc3RzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBQcmVjb25kaXRpb24ubm9uZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21Xcml0ZVJlc3VsdChwcm90bywgY29tbWl0VGltZSkge1xuICAgIC8vIE5PVEU6IERlbGV0ZXMgZG9uJ3QgaGF2ZSBhbiB1cGRhdGVUaW1lLlxuICAgIGxldCB2ZXJzaW9uID0gcHJvdG8udXBkYXRlVGltZVxuICAgICAgICA/IGZyb21WZXJzaW9uKHByb3RvLnVwZGF0ZVRpbWUpXG4gICAgICAgIDogZnJvbVZlcnNpb24oY29tbWl0VGltZSk7XG4gICAgaWYgKHZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XG4gICAgICAgIC8vIFRoZSBGaXJlc3RvcmUgRW11bGF0b3IgY3VycmVudGx5IHJldHVybnMgYW4gdXBkYXRlIHRpbWUgb2YgMCBmb3JcbiAgICAgICAgLy8gZGVsZXRlcyBvZiBub24tZXhpc3RpbmcgZG9jdW1lbnRzIChyYXRoZXIgdGhhbiBudWxsKS4gVGhpcyBicmVha3MgdGhlXG4gICAgICAgIC8vIHRlc3QgXCJnZXQgZGVsZXRlZCBkb2Mgd2hpbGUgb2ZmbGluZSB3aXRoIHNvdXJjZT1jYWNoZVwiIGFzIE5vRG9jdW1lbnRzXG4gICAgICAgIC8vIHdpdGggdmVyc2lvbiAwIGFyZSBmaWx0ZXJlZCBieSBJbmRleGVkRGIncyBSZW1vdGVEb2N1bWVudENhY2hlLlxuICAgICAgICAvLyBUT0RPKCMyMTQ5KTogUmVtb3ZlIHRoaXMgd2hlbiBFbXVsYXRvciBpcyBmaXhlZFxuICAgICAgICB2ZXJzaW9uID0gZnJvbVZlcnNpb24oY29tbWl0VGltZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTXV0YXRpb25SZXN1bHQodmVyc2lvbiwgcHJvdG8udHJhbnNmb3JtUmVzdWx0cyB8fCBbXSk7XG59XG5mdW5jdGlvbiBmcm9tV3JpdGVSZXN1bHRzKHByb3RvcywgY29tbWl0VGltZSkge1xuICAgIGlmIChwcm90b3MgJiYgcHJvdG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaGFyZEFzc2VydChjb21taXRUaW1lICE9PSB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gcHJvdG9zLm1hcChwcm90byA9PiBmcm9tV3JpdGVSZXN1bHQocHJvdG8sIGNvbW1pdFRpbWUpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0ZpZWxkVHJhbnNmb3JtKHNlcmlhbGl6ZXIsIGZpZWxkVHJhbnNmb3JtKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gZmllbGRUcmFuc2Zvcm0udHJhbnNmb3JtO1xuICAgIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpZWxkUGF0aDogZmllbGRUcmFuc2Zvcm0uZmllbGQuY2Fub25pY2FsU3RyaW5nKCksXG4gICAgICAgICAgICBzZXRUb1NlcnZlclZhbHVlOiAnUkVRVUVTVF9USU1FJ1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWVsZFBhdGg6IGZpZWxkVHJhbnNmb3JtLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpLFxuICAgICAgICAgICAgYXBwZW5kTWlzc2luZ0VsZW1lbnRzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiB0cmFuc2Zvcm0uZWxlbWVudHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpZWxkUGF0aDogZmllbGRUcmFuc2Zvcm0uZmllbGQuY2Fub25pY2FsU3RyaW5nKCksXG4gICAgICAgICAgICByZW1vdmVBbGxGcm9tQXJyYXk6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHRyYW5zZm9ybS5lbGVtZW50c1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWVsZFBhdGg6IGZpZWxkVHJhbnNmb3JtLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpLFxuICAgICAgICAgICAgaW5jcmVtZW50OiB0cmFuc2Zvcm0ub3BlcmFuZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21GaWVsZFRyYW5zZm9ybShzZXJpYWxpemVyLCBwcm90bykge1xuICAgIGxldCB0cmFuc2Zvcm0gPSBudWxsO1xuICAgIGlmICgnc2V0VG9TZXJ2ZXJWYWx1ZScgaW4gcHJvdG8pIHtcbiAgICAgICAgaGFyZEFzc2VydChwcm90by5zZXRUb1NlcnZlclZhbHVlID09PSAnUkVRVUVTVF9USU1FJyk7XG4gICAgICAgIHRyYW5zZm9ybSA9IG5ldyBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0oKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2FwcGVuZE1pc3NpbmdFbGVtZW50cycgaW4gcHJvdG8pIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gcHJvdG8uYXBwZW5kTWlzc2luZ0VsZW1lbnRzLnZhbHVlcyB8fCBbXTtcbiAgICAgICAgdHJhbnNmb3JtID0gbmV3IEFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24odmFsdWVzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3JlbW92ZUFsbEZyb21BcnJheScgaW4gcHJvdG8pIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gcHJvdG8ucmVtb3ZlQWxsRnJvbUFycmF5LnZhbHVlcyB8fCBbXTtcbiAgICAgICAgdHJhbnNmb3JtID0gbmV3IEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKHZhbHVlcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdpbmNyZW1lbnQnIGluIHByb3RvKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IG5ldyBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uKHNlcmlhbGl6ZXIsIHByb3RvLmluY3JlbWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmYWlsKCk7XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkUGF0aCA9IEZpZWxkUGF0aCQxLmZyb21TZXJ2ZXJGb3JtYXQocHJvdG8uZmllbGRQYXRoKTtcbiAgICByZXR1cm4gbmV3IEZpZWxkVHJhbnNmb3JtKGZpZWxkUGF0aCwgdHJhbnNmb3JtKTtcbn1cbmZ1bmN0aW9uIHRvRG9jdW1lbnRzVGFyZ2V0KHNlcmlhbGl6ZXIsIHRhcmdldCkge1xuICAgIHJldHVybiB7IGRvY3VtZW50czogW3RvUXVlcnlQYXRoKHNlcmlhbGl6ZXIsIHRhcmdldC5wYXRoKV0gfTtcbn1cbmZ1bmN0aW9uIGZyb21Eb2N1bWVudHNUYXJnZXQoZG9jdW1lbnRzVGFyZ2V0KSB7XG4gICAgY29uc3QgY291bnQgPSBkb2N1bWVudHNUYXJnZXQuZG9jdW1lbnRzLmxlbmd0aDtcbiAgICBoYXJkQXNzZXJ0KGNvdW50ID09PSAxKTtcbiAgICBjb25zdCBuYW1lID0gZG9jdW1lbnRzVGFyZ2V0LmRvY3VtZW50c1swXTtcbiAgICByZXR1cm4gcXVlcnlUb1RhcmdldChuZXdRdWVyeUZvclBhdGgoZnJvbVF1ZXJ5UGF0aChuYW1lKSkpO1xufVxuZnVuY3Rpb24gdG9RdWVyeVRhcmdldChzZXJpYWxpemVyLCB0YXJnZXQpIHtcbiAgICAvLyBEaXNzZWN0IHRoZSBwYXRoIGludG8gcGFyZW50LCBjb2xsZWN0aW9uSWQsIGFuZCBvcHRpb25hbCBrZXkgZmlsdGVyLlxuICAgIGNvbnN0IHF1ZXJ5VGFyZ2V0ID0geyBzdHJ1Y3R1cmVkUXVlcnk6IHt9IH07XG4gICAgY29uc3QgcGF0aCA9IHRhcmdldC5wYXRoO1xuICAgIGxldCBwYXJlbnQ7XG4gICAgaWYgKHRhcmdldC5jb2xsZWN0aW9uR3JvdXAgIT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50ID0gcGF0aDtcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5LmZyb20gPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbklkOiB0YXJnZXQuY29sbGVjdGlvbkdyb3VwLFxuICAgICAgICAgICAgICAgIGFsbERlc2NlbmRhbnRzOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJlbnQgPSBwYXRoLnBvcExhc3QoKTtcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5LmZyb20gPSBbeyBjb2xsZWN0aW9uSWQ6IHBhdGgubGFzdFNlZ21lbnQoKSB9XTtcbiAgICB9XG4gICAgcXVlcnlUYXJnZXQucGFyZW50ID0gdG9RdWVyeVBhdGgoc2VyaWFsaXplciwgcGFyZW50KTtcbiAgICBjb25zdCB3aGVyZSA9IHRvRmlsdGVycyh0YXJnZXQuZmlsdGVycyk7XG4gICAgaWYgKHdoZXJlKSB7XG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS53aGVyZSA9IHdoZXJlO1xuICAgIH1cbiAgICBjb25zdCBvcmRlckJ5ID0gdG9PcmRlcih0YXJnZXQub3JkZXJCeSk7XG4gICAgaWYgKG9yZGVyQnkpIHtcbiAgICAgICAgcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5Lm9yZGVyQnkgPSBvcmRlckJ5O1xuICAgIH1cbiAgICBjb25zdCBsaW1pdCA9IHRvSW50MzJQcm90byhzZXJpYWxpemVyLCB0YXJnZXQubGltaXQpO1xuICAgIGlmIChsaW1pdCAhPT0gbnVsbCkge1xuICAgICAgICBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnkubGltaXQgPSBsaW1pdDtcbiAgICB9XG4gICAgaWYgKHRhcmdldC5zdGFydEF0KSB7XG4gICAgICAgIHF1ZXJ5VGFyZ2V0LnN0cnVjdHVyZWRRdWVyeS5zdGFydEF0ID0gdG9TdGFydEF0Q3Vyc29yKHRhcmdldC5zdGFydEF0KTtcbiAgICB9XG4gICAgaWYgKHRhcmdldC5lbmRBdCkge1xuICAgICAgICBxdWVyeVRhcmdldC5zdHJ1Y3R1cmVkUXVlcnkuZW5kQXQgPSB0b0VuZEF0Q3Vyc29yKHRhcmdldC5lbmRBdCk7XG4gICAgfVxuICAgIHJldHVybiB7IHF1ZXJ5VGFyZ2V0LCBwYXJlbnQgfTtcbn1cbmZ1bmN0aW9uIHRvUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3Qoc2VyaWFsaXplciwgdGFyZ2V0LCBhZ2dyZWdhdGVzLCBza2lwQWxpYXNpbmcpIHtcbiAgICBjb25zdCB7IHF1ZXJ5VGFyZ2V0LCBwYXJlbnQgfSA9IHRvUXVlcnlUYXJnZXQoc2VyaWFsaXplciwgdGFyZ2V0KTtcbiAgICBjb25zdCBhbGlhc01hcCA9IHt9O1xuICAgIGNvbnN0IGFnZ3JlZ2F0aW9ucyA9IFtdO1xuICAgIGxldCBhZ2dyZWdhdGlvbk51bSA9IDA7XG4gICAgYWdncmVnYXRlcy5mb3JFYWNoKGFnZ3JlZ2F0ZSA9PiB7XG4gICAgICAgIC8vIE1hcCBhbGwgY2xpZW50LXNpZGUgYWxpYXNlcyB0byBhIHVuaXF1ZSBzaG9ydC1mb3JtXG4gICAgICAgIC8vIGFsaWFzLiBUaGlzIGF2b2lkcyBpc3N1ZXMgd2l0aCBjbGllbnQtc2lkZSBhbGlhc2VzIHRoYXRcbiAgICAgICAgLy8gZXhjZWVkIHRoZSAxNTAwLWJ5dGUgc3RyaW5nIHNpemUgbGltaXQuXG4gICAgICAgIGNvbnN0IHNlcnZlckFsaWFzID0gc2tpcEFsaWFzaW5nXG4gICAgICAgICAgICA/IGFnZ3JlZ2F0ZS5hbGlhc1xuICAgICAgICAgICAgOiBgYWdncmVnYXRlXyR7YWdncmVnYXRpb25OdW0rK31gO1xuICAgICAgICBhbGlhc01hcFtzZXJ2ZXJBbGlhc10gPSBhZ2dyZWdhdGUuYWxpYXM7XG4gICAgICAgIGlmIChhZ2dyZWdhdGUuYWdncmVnYXRlVHlwZSA9PT0gJ2NvdW50Jykge1xuICAgICAgICAgICAgYWdncmVnYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGFsaWFzOiBzZXJ2ZXJBbGlhcyxcbiAgICAgICAgICAgICAgICBjb3VudDoge31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFnZ3JlZ2F0ZS5hZ2dyZWdhdGVUeXBlID09PSAnYXZnJykge1xuICAgICAgICAgICAgYWdncmVnYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGFsaWFzOiBzZXJ2ZXJBbGlhcyxcbiAgICAgICAgICAgICAgICBhdmc6IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGFnZ3JlZ2F0ZS5maWVsZFBhdGgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWdncmVnYXRlLmFnZ3JlZ2F0ZVR5cGUgPT09ICdzdW0nKSB7XG4gICAgICAgICAgICBhZ2dyZWdhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgYWxpYXM6IHNlcnZlckFsaWFzLFxuICAgICAgICAgICAgICAgIHN1bToge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogdG9GaWVsZFBhdGhSZWZlcmVuY2UoYWdncmVnYXRlLmZpZWxkUGF0aClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgICAgIHN0cnVjdHVyZWRBZ2dyZWdhdGlvblF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgYWdncmVnYXRpb25zLFxuICAgICAgICAgICAgICAgIHN0cnVjdHVyZWRRdWVyeTogcXVlcnlUYXJnZXQuc3RydWN0dXJlZFF1ZXJ5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyZW50OiBxdWVyeVRhcmdldC5wYXJlbnRcbiAgICAgICAgfSxcbiAgICAgICAgYWxpYXNNYXAsXG4gICAgICAgIHBhcmVudFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0UXVlcnlUYXJnZXRUb1F1ZXJ5KHRhcmdldCkge1xuICAgIGxldCBwYXRoID0gZnJvbVF1ZXJ5UGF0aCh0YXJnZXQucGFyZW50KTtcbiAgICBjb25zdCBxdWVyeSA9IHRhcmdldC5zdHJ1Y3R1cmVkUXVlcnk7XG4gICAgY29uc3QgZnJvbUNvdW50ID0gcXVlcnkuZnJvbSA/IHF1ZXJ5LmZyb20ubGVuZ3RoIDogMDtcbiAgICBsZXQgY29sbGVjdGlvbkdyb3VwID0gbnVsbDtcbiAgICBpZiAoZnJvbUNvdW50ID4gMCkge1xuICAgICAgICBoYXJkQXNzZXJ0KGZyb21Db3VudCA9PT0gMSk7XG4gICAgICAgIGNvbnN0IGZyb20gPSBxdWVyeS5mcm9tWzBdO1xuICAgICAgICBpZiAoZnJvbS5hbGxEZXNjZW5kYW50cykge1xuICAgICAgICAgICAgY29sbGVjdGlvbkdyb3VwID0gZnJvbS5jb2xsZWN0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5jaGlsZChmcm9tLmNvbGxlY3Rpb25JZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGZpbHRlckJ5ID0gW107XG4gICAgaWYgKHF1ZXJ5LndoZXJlKSB7XG4gICAgICAgIGZpbHRlckJ5ID0gZnJvbUZpbHRlcnMocXVlcnkud2hlcmUpO1xuICAgIH1cbiAgICBsZXQgb3JkZXJCeSA9IFtdO1xuICAgIGlmIChxdWVyeS5vcmRlckJ5KSB7XG4gICAgICAgIG9yZGVyQnkgPSBmcm9tT3JkZXIocXVlcnkub3JkZXJCeSk7XG4gICAgfVxuICAgIGxldCBsaW1pdCA9IG51bGw7XG4gICAgaWYgKHF1ZXJ5LmxpbWl0KSB7XG4gICAgICAgIGxpbWl0ID0gZnJvbUludDMyUHJvdG8ocXVlcnkubGltaXQpO1xuICAgIH1cbiAgICBsZXQgc3RhcnRBdCA9IG51bGw7XG4gICAgaWYgKHF1ZXJ5LnN0YXJ0QXQpIHtcbiAgICAgICAgc3RhcnRBdCA9IGZyb21TdGFydEF0Q3Vyc29yKHF1ZXJ5LnN0YXJ0QXQpO1xuICAgIH1cbiAgICBsZXQgZW5kQXQgPSBudWxsO1xuICAgIGlmIChxdWVyeS5lbmRBdCkge1xuICAgICAgICBlbmRBdCA9IGZyb21FbmRBdEN1cnNvcihxdWVyeS5lbmRBdCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdRdWVyeShwYXRoLCBjb2xsZWN0aW9uR3JvdXAsIG9yZGVyQnksIGZpbHRlckJ5LCBsaW1pdCwgXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovLCBzdGFydEF0LCBlbmRBdCk7XG59XG5mdW5jdGlvbiBmcm9tUXVlcnlUYXJnZXQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHF1ZXJ5VG9UYXJnZXQoY29udmVydFF1ZXJ5VGFyZ2V0VG9RdWVyeSh0YXJnZXQpKTtcbn1cbmZ1bmN0aW9uIHRvTGlzdGVuUmVxdWVzdExhYmVscyhzZXJpYWxpemVyLCB0YXJnZXREYXRhKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0b0xhYmVsKHRhcmdldERhdGEucHVycG9zZSk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2dvb2ctbGlzdGVuLXRhZ3MnOiB2YWx1ZVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvTGFiZWwocHVycG9zZSkge1xuICAgIHN3aXRjaCAocHVycG9zZSkge1xuICAgICAgICBjYXNlIFwiVGFyZ2V0UHVycG9zZUxpc3RlblwiIC8qIFRhcmdldFB1cnBvc2UuTGlzdGVuICovOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJUYXJnZXRQdXJwb3NlRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hcIiAvKiBUYXJnZXRQdXJwb3NlLkV4aXN0ZW5jZUZpbHRlck1pc21hdGNoICovOlxuICAgICAgICAgICAgcmV0dXJuICdleGlzdGVuY2UtZmlsdGVyLW1pc21hdGNoJztcbiAgICAgICAgY2FzZSBcIlRhcmdldFB1cnBvc2VFeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaEJsb29tXCIgLyogVGFyZ2V0UHVycG9zZS5FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaEJsb29tICovOlxuICAgICAgICAgICAgcmV0dXJuICdleGlzdGVuY2UtZmlsdGVyLW1pc21hdGNoLWJsb29tJztcbiAgICAgICAgY2FzZSBcIlRhcmdldFB1cnBvc2VMaW1ib1Jlc29sdXRpb25cIiAvKiBUYXJnZXRQdXJwb3NlLkxpbWJvUmVzb2x1dGlvbiAqLzpcbiAgICAgICAgICAgIHJldHVybiAnbGltYm8tZG9jdW1lbnQnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1RhcmdldChzZXJpYWxpemVyLCB0YXJnZXREYXRhKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXREYXRhLnRhcmdldDtcbiAgICBpZiAodGFyZ2V0SXNEb2N1bWVudFRhcmdldCh0YXJnZXQpKSB7XG4gICAgICAgIHJlc3VsdCA9IHsgZG9jdW1lbnRzOiB0b0RvY3VtZW50c1RhcmdldChzZXJpYWxpemVyLCB0YXJnZXQpIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB7IHF1ZXJ5OiB0b1F1ZXJ5VGFyZ2V0KHNlcmlhbGl6ZXIsIHRhcmdldCkucXVlcnlUYXJnZXQgfTtcbiAgICB9XG4gICAgcmVzdWx0LnRhcmdldElkID0gdGFyZ2V0RGF0YS50YXJnZXRJZDtcbiAgICBpZiAodGFyZ2V0RGF0YS5yZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPiAwKSB7XG4gICAgICAgIHJlc3VsdC5yZXN1bWVUb2tlbiA9IHRvQnl0ZXMoc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5yZXN1bWVUb2tlbik7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQ291bnQgPSB0b0ludDMyUHJvdG8oc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5leHBlY3RlZENvdW50KTtcbiAgICAgICAgaWYgKGV4cGVjdGVkQ291bnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5leHBlY3RlZENvdW50ID0gZXhwZWN0ZWRDb3VudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbi5jb21wYXJlVG8oU25hcHNob3RWZXJzaW9uLm1pbigpKSA+IDApIHtcbiAgICAgICAgLy8gVE9ETyh3dWFuZHkpOiBDb25zaWRlciByZW1vdmluZyBhYm92ZSBjaGVjayBiZWNhdXNlIGl0IGlzIG1vc3QgbGlrZWx5IHRydWUuXG4gICAgICAgIC8vIFJpZ2h0IG5vdywgbWFueSB0ZXN0cyBkZXBlbmQgb24gdGhpcyBiZWhhdmlvdXIgdGhvdWdoIChsZWF2aW5nIG1pbigpIG91dFxuICAgICAgICAvLyBvZiBzZXJpYWxpemF0aW9uKS5cbiAgICAgICAgcmVzdWx0LnJlYWRUaW1lID0gdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24udG9UaW1lc3RhbXAoKSk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQ291bnQgPSB0b0ludDMyUHJvdG8oc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5leHBlY3RlZENvdW50KTtcbiAgICAgICAgaWYgKGV4cGVjdGVkQ291bnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5leHBlY3RlZENvdW50ID0gZXhwZWN0ZWRDb3VudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9GaWx0ZXJzKGZpbHRlcnMpIHtcbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdG9GaWx0ZXIoQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShmaWx0ZXJzLCBcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLykpO1xufVxuZnVuY3Rpb24gZnJvbUZpbHRlcnMoZmlsdGVyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZnJvbUZpbHRlcihmaWx0ZXIpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIgJiZcbiAgICAgICAgY29tcG9zaXRlRmlsdGVySXNGbGF0Q29uanVuY3Rpb24ocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmdldEZpbHRlcnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyZXN1bHRdO1xufVxuZnVuY3Rpb24gZnJvbUZpbHRlcihmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyLnVuYXJ5RmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZyb21VbmFyeUZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaWx0ZXIuZmllbGRGaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZnJvbUZpZWxkRmlsdGVyKGZpbHRlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbHRlci5jb21wb3NpdGVGaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZnJvbUNvbXBvc2l0ZUZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b09yZGVyKG9yZGVyQnlzKSB7XG4gICAgaWYgKG9yZGVyQnlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBvcmRlckJ5cy5tYXAob3JkZXIgPT4gdG9Qcm9wZXJ0eU9yZGVyKG9yZGVyKSk7XG59XG5mdW5jdGlvbiBmcm9tT3JkZXIob3JkZXJCeXMpIHtcbiAgICByZXR1cm4gb3JkZXJCeXMubWFwKG9yZGVyID0+IGZyb21Qcm9wZXJ0eU9yZGVyKG9yZGVyKSk7XG59XG5mdW5jdGlvbiB0b1N0YXJ0QXRDdXJzb3IoY3Vyc29yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmVmb3JlOiBjdXJzb3IuaW5jbHVzaXZlLFxuICAgICAgICB2YWx1ZXM6IGN1cnNvci5wb3NpdGlvblxuICAgIH07XG59XG5mdW5jdGlvbiB0b0VuZEF0Q3Vyc29yKGN1cnNvcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJlZm9yZTogIWN1cnNvci5pbmNsdXNpdmUsXG4gICAgICAgIHZhbHVlczogY3Vyc29yLnBvc2l0aW9uXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21TdGFydEF0Q3Vyc29yKGN1cnNvcikge1xuICAgIGNvbnN0IGluY2x1c2l2ZSA9ICEhY3Vyc29yLmJlZm9yZTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGN1cnNvci52YWx1ZXMgfHwgW107XG4gICAgcmV0dXJuIG5ldyBCb3VuZChwb3NpdGlvbiwgaW5jbHVzaXZlKTtcbn1cbmZ1bmN0aW9uIGZyb21FbmRBdEN1cnNvcihjdXJzb3IpIHtcbiAgICBjb25zdCBpbmNsdXNpdmUgPSAhY3Vyc29yLmJlZm9yZTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGN1cnNvci52YWx1ZXMgfHwgW107XG4gICAgcmV0dXJuIG5ldyBCb3VuZChwb3NpdGlvbiwgaW5jbHVzaXZlKTtcbn1cbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIHRvRGlyZWN0aW9uKGRpcikge1xuICAgIHJldHVybiBESVJFQ1RJT05TW2Rpcl07XG59XG4vLyB2aXNpYmxlIGZvciB0ZXN0aW5nXG5mdW5jdGlvbiBmcm9tRGlyZWN0aW9uKGRpcikge1xuICAgIHN3aXRjaCAoZGlyKSB7XG4gICAgICAgIGNhc2UgJ0FTQ0VORElORyc6XG4gICAgICAgICAgICByZXR1cm4gXCJhc2NcIiAvKiBEaXJlY3Rpb24uQVNDRU5ESU5HICovO1xuICAgICAgICBjYXNlICdERVNDRU5ESU5HJzpcbiAgICAgICAgICAgIHJldHVybiBcImRlc2NcIiAvKiBEaXJlY3Rpb24uREVTQ0VORElORyAqLztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xuZnVuY3Rpb24gdG9PcGVyYXRvck5hbWUob3ApIHtcbiAgICByZXR1cm4gT1BFUkFUT1JTW29wXTtcbn1cbmZ1bmN0aW9uIHRvQ29tcG9zaXRlT3BlcmF0b3JOYW1lKG9wKSB7XG4gICAgcmV0dXJuIENPTVBPU0lURV9PUEVSQVRPUlNbb3BdO1xufVxuZnVuY3Rpb24gZnJvbU9wZXJhdG9yTmFtZShvcCkge1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgY2FzZSAnRVFVQUwnOlxuICAgICAgICAgICAgcmV0dXJuIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLztcbiAgICAgICAgY2FzZSAnTk9UX0VRVUFMJzpcbiAgICAgICAgICAgIHJldHVybiBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovO1xuICAgICAgICBjYXNlICdHUkVBVEVSX1RIQU4nOlxuICAgICAgICAgICAgcmV0dXJuIFwiPlwiIC8qIE9wZXJhdG9yLkdSRUFURVJfVEhBTiAqLztcbiAgICAgICAgY2FzZSAnR1JFQVRFUl9USEFOX09SX0VRVUFMJzpcbiAgICAgICAgICAgIHJldHVybiBcIj49XCIgLyogT3BlcmF0b3IuR1JFQVRFUl9USEFOX09SX0VRVUFMICovO1xuICAgICAgICBjYXNlICdMRVNTX1RIQU4nOlxuICAgICAgICAgICAgcmV0dXJuIFwiPFwiIC8qIE9wZXJhdG9yLkxFU1NfVEhBTiAqLztcbiAgICAgICAgY2FzZSAnTEVTU19USEFOX09SX0VRVUFMJzpcbiAgICAgICAgICAgIHJldHVybiBcIjw9XCIgLyogT3BlcmF0b3IuTEVTU19USEFOX09SX0VRVUFMICovO1xuICAgICAgICBjYXNlICdBUlJBWV9DT05UQUlOUyc6XG4gICAgICAgICAgICByZXR1cm4gXCJhcnJheS1jb250YWluc1wiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TICovO1xuICAgICAgICBjYXNlICdJTic6XG4gICAgICAgICAgICByZXR1cm4gXCJpblwiIC8qIE9wZXJhdG9yLklOICovO1xuICAgICAgICBjYXNlICdOT1RfSU4nOlxuICAgICAgICAgICAgcmV0dXJuIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovO1xuICAgICAgICBjYXNlICdBUlJBWV9DT05UQUlOU19BTlknOlxuICAgICAgICAgICAgcmV0dXJuIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovO1xuICAgICAgICBjYXNlICdPUEVSQVRPUl9VTlNQRUNJRklFRCc6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmcm9tQ29tcG9zaXRlT3BlcmF0b3JOYW1lKG9wKSB7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlICdBTkQnOlxuICAgICAgICAgICAgcmV0dXJuIFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovO1xuICAgICAgICBjYXNlICdPUic6XG4gICAgICAgICAgICByZXR1cm4gXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShwYXRoKSB7XG4gICAgcmV0dXJuIHsgZmllbGRQYXRoOiBwYXRoLmNhbm9uaWNhbFN0cmluZygpIH07XG59XG5mdW5jdGlvbiBmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpZWxkUmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIEZpZWxkUGF0aCQxLmZyb21TZXJ2ZXJGb3JtYXQoZmllbGRSZWZlcmVuY2UuZmllbGRQYXRoKTtcbn1cbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIHRvUHJvcGVydHlPcmRlcihvcmRlckJ5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKG9yZGVyQnkuZmllbGQpLFxuICAgICAgICBkaXJlY3Rpb246IHRvRGlyZWN0aW9uKG9yZGVyQnkuZGlyKVxuICAgIH07XG59XG5mdW5jdGlvbiBmcm9tUHJvcGVydHlPcmRlcihvcmRlckJ5KSB7XG4gICAgcmV0dXJuIG5ldyBPcmRlckJ5KGZyb21GaWVsZFBhdGhSZWZlcmVuY2Uob3JkZXJCeS5maWVsZCksIGZyb21EaXJlY3Rpb24ob3JkZXJCeS5kaXJlY3Rpb24pKTtcbn1cbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIHRvRmlsdGVyKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcikge1xuICAgICAgICByZXR1cm4gdG9VbmFyeU9yRmllbGRGaWx0ZXIoZmlsdGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB0b0NvbXBvc2l0ZUZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0NvbXBvc2l0ZUZpbHRlcihmaWx0ZXIpIHtcbiAgICBjb25zdCBwcm90b3MgPSBmaWx0ZXIuZ2V0RmlsdGVycygpLm1hcChmaWx0ZXIgPT4gdG9GaWx0ZXIoZmlsdGVyKSk7XG4gICAgaWYgKHByb3Rvcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHByb3Rvc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcG9zaXRlRmlsdGVyOiB7XG4gICAgICAgICAgICBvcDogdG9Db21wb3NpdGVPcGVyYXRvck5hbWUoZmlsdGVyLm9wKSxcbiAgICAgICAgICAgIGZpbHRlcnM6IHByb3Rvc1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvVW5hcnlPckZpZWxkRmlsdGVyKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIub3AgPT09IFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLykge1xuICAgICAgICBpZiAoaXNOYW5WYWx1ZShmaWx0ZXIudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxuICAgICAgICAgICAgICAgICAgICBvcDogJ0lTX05BTidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVsbFZhbHVlKGZpbHRlci52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdW5hcnlGaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZCksXG4gICAgICAgICAgICAgICAgICAgIG9wOiAnSVNfTlVMTCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbHRlci5vcCA9PT0gXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLykge1xuICAgICAgICBpZiAoaXNOYW5WYWx1ZShmaWx0ZXIudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxuICAgICAgICAgICAgICAgICAgICBvcDogJ0lTX05PVF9OQU4nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc051bGxWYWx1ZShmaWx0ZXIudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxuICAgICAgICAgICAgICAgICAgICBvcDogJ0lTX05PVF9OVUxMJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmllbGRGaWx0ZXI6IHtcbiAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxuICAgICAgICAgICAgb3A6IHRvT3BlcmF0b3JOYW1lKGZpbHRlci5vcCksXG4gICAgICAgICAgICB2YWx1ZTogZmlsdGVyLnZhbHVlXG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbVVuYXJ5RmlsdGVyKGZpbHRlcikge1xuICAgIHN3aXRjaCAoZmlsdGVyLnVuYXJ5RmlsdGVyLm9wKSB7XG4gICAgICAgIGNhc2UgJ0lTX05BTic6XG4gICAgICAgICAgICBjb25zdCBuYW5GaWVsZCA9IGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLnVuYXJ5RmlsdGVyLmZpZWxkKTtcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobmFuRmllbGQsIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLywge1xuICAgICAgICAgICAgICAgIGRvdWJsZVZhbHVlOiBOYU5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlICdJU19OVUxMJzpcbiAgICAgICAgICAgIGNvbnN0IG51bGxGaWVsZCA9IGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLnVuYXJ5RmlsdGVyLmZpZWxkKTtcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobnVsbEZpZWxkLCBcIj09XCIgLyogT3BlcmF0b3IuRVFVQUwgKi8sIHtcbiAgICAgICAgICAgICAgICBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgJ0lTX05PVF9OQU4nOlxuICAgICAgICAgICAgY29uc3Qgbm90TmFuRmllbGQgPSBmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci51bmFyeUZpbHRlci5maWVsZCk7XG4gICAgICAgICAgICByZXR1cm4gRmllbGRGaWx0ZXIuY3JlYXRlKG5vdE5hbkZpZWxkLCBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovLCB7XG4gICAgICAgICAgICAgICAgZG91YmxlVmFsdWU6IE5hTlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgJ0lTX05PVF9OVUxMJzpcbiAgICAgICAgICAgIGNvbnN0IG5vdE51bGxGaWVsZCA9IGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLnVuYXJ5RmlsdGVyLmZpZWxkKTtcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobm90TnVsbEZpZWxkLCBcIiE9XCIgLyogT3BlcmF0b3IuTk9UX0VRVUFMICovLCB7XG4gICAgICAgICAgICAgICAgbnVsbFZhbHVlOiAnTlVMTF9WQUxVRSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlICdPUEVSQVRPUl9VTlNQRUNJRklFRCc6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmcm9tRmllbGRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgcmV0dXJuIEZpZWxkRmlsdGVyLmNyZWF0ZShmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZEZpbHRlci5maWVsZCksIGZyb21PcGVyYXRvck5hbWUoZmlsdGVyLmZpZWxkRmlsdGVyLm9wKSwgZmlsdGVyLmZpZWxkRmlsdGVyLnZhbHVlKTtcbn1cbmZ1bmN0aW9uIGZyb21Db21wb3NpdGVGaWx0ZXIoZmlsdGVyKSB7XG4gICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUoZmlsdGVyLmNvbXBvc2l0ZUZpbHRlci5maWx0ZXJzLm1hcChmaWx0ZXIgPT4gZnJvbUZpbHRlcihmaWx0ZXIpKSwgZnJvbUNvbXBvc2l0ZU9wZXJhdG9yTmFtZShmaWx0ZXIuY29tcG9zaXRlRmlsdGVyLm9wKSk7XG59XG5mdW5jdGlvbiB0b0RvY3VtZW50TWFzayhmaWVsZE1hc2spIHtcbiAgICBjb25zdCBjYW5vbmljYWxGaWVsZHMgPSBbXTtcbiAgICBmaWVsZE1hc2suZmllbGRzLmZvckVhY2goZmllbGQgPT4gY2Fub25pY2FsRmllbGRzLnB1c2goZmllbGQuY2Fub25pY2FsU3RyaW5nKCkpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWVsZFBhdGhzOiBjYW5vbmljYWxGaWVsZHNcbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbURvY3VtZW50TWFzayhwcm90bykge1xuICAgIGNvbnN0IHBhdGhzID0gcHJvdG8uZmllbGRQYXRocyB8fCBbXTtcbiAgICByZXR1cm4gbmV3IEZpZWxkTWFzayhwYXRocy5tYXAocGF0aCA9PiBGaWVsZFBhdGgkMS5mcm9tU2VydmVyRm9ybWF0KHBhdGgpKSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkUmVzb3VyY2VOYW1lKHBhdGgpIHtcbiAgICAvLyBSZXNvdXJjZSBuYW1lcyBoYXZlIGF0IGxlYXN0IDQgY29tcG9uZW50cyAocHJvamVjdCBJRCwgZGF0YWJhc2UgSUQpXG4gICAgcmV0dXJuIChwYXRoLmxlbmd0aCA+PSA0ICYmXG4gICAgICAgIHBhdGguZ2V0KDApID09PSAncHJvamVjdHMnICYmXG4gICAgICAgIHBhdGguZ2V0KDIpID09PSAnZGF0YWJhc2VzJyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGltbXV0YWJsZSBzZXQgb2YgbWV0YWRhdGEgdGhhdCB0aGUgbG9jYWwgc3RvcmUgdHJhY2tzIGZvciBlYWNoIHRhcmdldC5cbiAqL1xuY2xhc3MgVGFyZ2V0RGF0YSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRoZSB0YXJnZXQgYmVpbmcgbGlzdGVuZWQgdG8uICovXG4gICAgdGFyZ2V0LCBcbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IElEIHRvIHdoaWNoIHRoZSB0YXJnZXQgY29ycmVzcG9uZHM7IEFzc2lnbmVkIGJ5IHRoZVxuICAgICAqIExvY2FsU3RvcmUgZm9yIHVzZXIgbGlzdGVucyBhbmQgYnkgdGhlIFN5bmNFbmdpbmUgZm9yIGxpbWJvIHdhdGNoZXMuXG4gICAgICovXG4gICAgdGFyZ2V0SWQsIFxuICAgIC8qKiBUaGUgcHVycG9zZSBvZiB0aGUgdGFyZ2V0LiAqL1xuICAgIHB1cnBvc2UsIFxuICAgIC8qKlxuICAgICAqIFRoZSBzZXF1ZW5jZSBudW1iZXIgb2YgdGhlIGxhc3QgdHJhbnNhY3Rpb24gZHVyaW5nIHdoaWNoIHRoaXMgdGFyZ2V0IGRhdGFcbiAgICAgKiB3YXMgbW9kaWZpZWQuXG4gICAgICovXG4gICAgc2VxdWVuY2VOdW1iZXIsIFxuICAgIC8qKiBUaGUgbGF0ZXN0IHNuYXBzaG90IHZlcnNpb24gc2VlbiBmb3IgdGhpcyB0YXJnZXQuICovXG4gICAgc25hcHNob3RWZXJzaW9uID0gU25hcHNob3RWZXJzaW9uLm1pbigpLCBcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBzbmFwc2hvdCB2ZXJzaW9uIGF0IHdoaWNoIHRoZSBhc3NvY2lhdGVkIHZpZXdcbiAgICAgKiBjb250YWluZWQgbm8gbGltYm8gZG9jdW1lbnRzLlxuICAgICAqL1xuICAgIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gPSBTbmFwc2hvdFZlcnNpb24ubWluKCksIFxuICAgIC8qKlxuICAgICAqIEFuIG9wYXF1ZSwgc2VydmVyLWFzc2lnbmVkIHRva2VuIHRoYXQgYWxsb3dzIHdhdGNoaW5nIGEgdGFyZ2V0IHRvIGJlXG4gICAgICogcmVzdW1lZCBhZnRlciBkaXNjb25uZWN0aW5nIHdpdGhvdXQgcmV0cmFuc21pdHRpbmcgYWxsIHRoZSBkYXRhIHRoYXRcbiAgICAgKiBtYXRjaGVzIHRoZSB0YXJnZXQuIFRoZSByZXN1bWUgdG9rZW4gZXNzZW50aWFsbHkgaWRlbnRpZmllcyBhIHBvaW50IGluXG4gICAgICogdGltZSBmcm9tIHdoaWNoIHRoZSBzZXJ2ZXIgc2hvdWxkIHJlc3VtZSBzZW5kaW5nIHJlc3VsdHMuXG4gICAgICovXG4gICAgcmVzdW1lVG9rZW4gPSBCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HLCBcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRvY3VtZW50cyB0aGF0IGxhc3QgbWF0Y2hlZCB0aGUgcXVlcnkgYXQgdGhlIHJlc3VtZSB0b2tlbiBvclxuICAgICAqIHJlYWQgdGltZS4gRG9jdW1lbnRzIGFyZSBjb3VudGVkIG9ubHkgd2hlbiBtYWtpbmcgYSBsaXN0ZW4gcmVxdWVzdCB3aXRoXG4gICAgICogcmVzdW1lIHRva2VuIG9yIHJlYWQgdGltZSwgb3RoZXJ3aXNlLCBrZWVwIGl0IG51bGwuXG4gICAgICovXG4gICAgZXhwZWN0ZWRDb3VudCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcbiAgICAgICAgdGhpcy5wdXJwb3NlID0gcHVycG9zZTtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZU51bWJlciA9IHNlcXVlbmNlTnVtYmVyO1xuICAgICAgICB0aGlzLnNuYXBzaG90VmVyc2lvbiA9IHNuYXBzaG90VmVyc2lvbjtcbiAgICAgICAgdGhpcy5sYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uID0gbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbjtcbiAgICAgICAgdGhpcy5yZXN1bWVUb2tlbiA9IHJlc3VtZVRva2VuO1xuICAgICAgICB0aGlzLmV4cGVjdGVkQ291bnQgPSBleHBlY3RlZENvdW50O1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhIG5ldyB0YXJnZXQgZGF0YSBpbnN0YW5jZSB3aXRoIGFuIHVwZGF0ZWQgc2VxdWVuY2UgbnVtYmVyLiAqL1xuICAgIHdpdGhTZXF1ZW5jZU51bWJlcihzZXF1ZW5jZU51bWJlcikge1xuICAgICAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0SWQsIHRoaXMucHVycG9zZSwgc2VxdWVuY2VOdW1iZXIsIHRoaXMuc25hcHNob3RWZXJzaW9uLCB0aGlzLmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIHRoaXMucmVzdW1lVG9rZW4sIHRoaXMuZXhwZWN0ZWRDb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGFyZ2V0IGRhdGEgaW5zdGFuY2Ugd2l0aCBhbiB1cGRhdGVkIHJlc3VtZSB0b2tlbiBhbmRcbiAgICAgKiBzbmFwc2hvdCB2ZXJzaW9uLlxuICAgICAqL1xuICAgIHdpdGhSZXN1bWVUb2tlbihyZXN1bWVUb2tlbiwgc25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0RGF0YSh0aGlzLnRhcmdldCwgdGhpcy50YXJnZXRJZCwgdGhpcy5wdXJwb3NlLCB0aGlzLnNlcXVlbmNlTnVtYmVyLCBzbmFwc2hvdFZlcnNpb24sIHRoaXMubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiwgcmVzdW1lVG9rZW4sIFxuICAgICAgICAvKiBleHBlY3RlZENvdW50PSAqLyBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0YXJnZXQgZGF0YSBpbnN0YW5jZSB3aXRoIGFuIHVwZGF0ZWQgZXhwZWN0ZWQgY291bnQuXG4gICAgICovXG4gICAgd2l0aEV4cGVjdGVkQ291bnQoZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0SWQsIHRoaXMucHVycG9zZSwgdGhpcy5zZXF1ZW5jZU51bWJlciwgdGhpcy5zbmFwc2hvdFZlcnNpb24sIHRoaXMubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiwgdGhpcy5yZXN1bWVUb2tlbiwgZXhwZWN0ZWRDb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGFyZ2V0IGRhdGEgaW5zdGFuY2Ugd2l0aCBhbiB1cGRhdGVkIGxhc3QgbGltYm8gZnJlZVxuICAgICAqIHNuYXBzaG90IHZlcnNpb24gbnVtYmVyLlxuICAgICAqL1xuICAgIHdpdGhMYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXREYXRhKHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldElkLCB0aGlzLnB1cnBvc2UsIHRoaXMuc2VxdWVuY2VOdW1iZXIsIHRoaXMuc25hcHNob3RWZXJzaW9uLCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLCB0aGlzLnJlc3VtZVRva2VuLCB0aGlzLmV4cGVjdGVkQ291bnQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBTZXJpYWxpemVyIGZvciB2YWx1ZXMgc3RvcmVkIGluIHRoZSBMb2NhbFN0b3JlLiAqL1xuY2xhc3MgTG9jYWxTZXJpYWxpemVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZW1vdGVTZXJpYWxpemVyKSB7XG4gICAgICAgIHRoaXMucmVtb3RlU2VyaWFsaXplciA9IHJlbW90ZVNlcmlhbGl6ZXI7XG4gICAgfVxufVxuLyoqIERlY29kZXMgYSByZW1vdGUgZG9jdW1lbnQgZnJvbSBzdG9yYWdlIGxvY2FsbHkgdG8gYSBEb2N1bWVudC4gKi9cbmZ1bmN0aW9uIGZyb21EYlJlbW90ZURvY3VtZW50KGxvY2FsU2VyaWFsaXplciwgcmVtb3RlRG9jKSB7XG4gICAgbGV0IGRvYztcbiAgICBpZiAocmVtb3RlRG9jLmRvY3VtZW50KSB7XG4gICAgICAgIGRvYyA9IGZyb21Eb2N1bWVudChsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgcmVtb3RlRG9jLmRvY3VtZW50LCAhIXJlbW90ZURvYy5oYXNDb21taXR0ZWRNdXRhdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZW1vdGVEb2Mubm9Eb2N1bWVudCkge1xuICAgICAgICBjb25zdCBrZXkgPSBEb2N1bWVudEtleS5mcm9tU2VnbWVudHMocmVtb3RlRG9jLm5vRG9jdW1lbnQucGF0aCk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tRGJUaW1lc3RhbXAocmVtb3RlRG9jLm5vRG9jdW1lbnQucmVhZFRpbWUpO1xuICAgICAgICBkb2MgPSBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudChrZXksIHZlcnNpb24pO1xuICAgICAgICBpZiAocmVtb3RlRG9jLmhhc0NvbW1pdHRlZE11dGF0aW9ucykge1xuICAgICAgICAgICAgZG9jLnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQucGF0aCk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tRGJUaW1lc3RhbXAocmVtb3RlRG9jLnVua25vd25Eb2N1bWVudC52ZXJzaW9uKTtcbiAgICAgICAgZG9jID0gTXV0YWJsZURvY3VtZW50Lm5ld1Vua25vd25Eb2N1bWVudChrZXksIHZlcnNpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG4gICAgaWYgKHJlbW90ZURvYy5yZWFkVGltZSkge1xuICAgICAgICBkb2Muc2V0UmVhZFRpbWUoZnJvbURiVGltZXN0YW1wS2V5KHJlbW90ZURvYy5yZWFkVGltZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZG9jO1xufVxuLyoqIEVuY29kZXMgYSBkb2N1bWVudCBmb3Igc3RvcmFnZSBsb2NhbGx5LiAqL1xuZnVuY3Rpb24gdG9EYlJlbW90ZURvY3VtZW50KGxvY2FsU2VyaWFsaXplciwgZG9jdW1lbnQpIHtcbiAgICBjb25zdCBrZXkgPSBkb2N1bWVudC5rZXk7XG4gICAgY29uc3QgcmVtb3RlRG9jID0ge1xuICAgICAgICBwcmVmaXhQYXRoOiBrZXkuZ2V0Q29sbGVjdGlvblBhdGgoKS5wb3BMYXN0KCkudG9BcnJheSgpLFxuICAgICAgICBjb2xsZWN0aW9uR3JvdXA6IGtleS5jb2xsZWN0aW9uR3JvdXAsXG4gICAgICAgIGRvY3VtZW50SWQ6IGtleS5wYXRoLmxhc3RTZWdtZW50KCksXG4gICAgICAgIHJlYWRUaW1lOiB0b0RiVGltZXN0YW1wS2V5KGRvY3VtZW50LnJlYWRUaW1lKSxcbiAgICAgICAgaGFzQ29tbWl0dGVkTXV0YXRpb25zOiBkb2N1bWVudC5oYXNDb21taXR0ZWRNdXRhdGlvbnNcbiAgICB9O1xuICAgIGlmIChkb2N1bWVudC5pc0ZvdW5kRG9jdW1lbnQoKSkge1xuICAgICAgICByZW1vdGVEb2MuZG9jdW1lbnQgPSB0b0RvY3VtZW50KGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvY3VtZW50LmlzTm9Eb2N1bWVudCgpKSB7XG4gICAgICAgIHJlbW90ZURvYy5ub0RvY3VtZW50ID0ge1xuICAgICAgICAgICAgcGF0aDoga2V5LnBhdGgudG9BcnJheSgpLFxuICAgICAgICAgICAgcmVhZFRpbWU6IHRvRGJUaW1lc3RhbXAoZG9jdW1lbnQudmVyc2lvbilcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jdW1lbnQuaXNVbmtub3duRG9jdW1lbnQoKSkge1xuICAgICAgICByZW1vdGVEb2MudW5rbm93bkRvY3VtZW50ID0ge1xuICAgICAgICAgICAgcGF0aDoga2V5LnBhdGgudG9BcnJheSgpLFxuICAgICAgICAgICAgdmVyc2lvbjogdG9EYlRpbWVzdGFtcChkb2N1bWVudC52ZXJzaW9uKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW90ZURvYztcbn1cbmZ1bmN0aW9uIHRvRGJUaW1lc3RhbXBLZXkoc25hcHNob3RWZXJzaW9uKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gc25hcHNob3RWZXJzaW9uLnRvVGltZXN0YW1wKCk7XG4gICAgcmV0dXJuIFt0aW1lc3RhbXAuc2Vjb25kcywgdGltZXN0YW1wLm5hbm9zZWNvbmRzXTtcbn1cbmZ1bmN0aW9uIGZyb21EYlRpbWVzdGFtcEtleShkYlRpbWVzdGFtcEtleSkge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBUaW1lc3RhbXAoZGJUaW1lc3RhbXBLZXlbMF0sIGRiVGltZXN0YW1wS2V5WzFdKTtcbiAgICByZXR1cm4gU25hcHNob3RWZXJzaW9uLmZyb21UaW1lc3RhbXAodGltZXN0YW1wKTtcbn1cbmZ1bmN0aW9uIHRvRGJUaW1lc3RhbXAoc25hcHNob3RWZXJzaW9uKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gc25hcHNob3RWZXJzaW9uLnRvVGltZXN0YW1wKCk7XG4gICAgcmV0dXJuIHsgc2Vjb25kczogdGltZXN0YW1wLnNlY29uZHMsIG5hbm9zZWNvbmRzOiB0aW1lc3RhbXAubmFub3NlY29uZHMgfTtcbn1cbmZ1bmN0aW9uIGZyb21EYlRpbWVzdGFtcChkYlRpbWVzdGFtcCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBUaW1lc3RhbXAoZGJUaW1lc3RhbXAuc2Vjb25kcywgZGJUaW1lc3RhbXAubmFub3NlY29uZHMpO1xuICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24uZnJvbVRpbWVzdGFtcCh0aW1lc3RhbXApO1xufVxuLyoqIEVuY29kZXMgYSBiYXRjaCBvZiBtdXRhdGlvbnMgaW50byBhIERiTXV0YXRpb25CYXRjaCBmb3IgbG9jYWwgc3RvcmFnZS4gKi9cbmZ1bmN0aW9uIHRvRGJNdXRhdGlvbkJhdGNoKGxvY2FsU2VyaWFsaXplciwgdXNlcklkLCBiYXRjaCkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRCYXNlTXV0YXRpb25zID0gYmF0Y2guYmFzZU11dGF0aW9ucy5tYXAobSA9PiB0b011dGF0aW9uKGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCBtKSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZE11dGF0aW9ucyA9IGJhdGNoLm11dGF0aW9ucy5tYXAobSA9PiB0b011dGF0aW9uKGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCBtKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBiYXRjaElkOiBiYXRjaC5iYXRjaElkLFxuICAgICAgICBsb2NhbFdyaXRlVGltZU1zOiBiYXRjaC5sb2NhbFdyaXRlVGltZS50b01pbGxpcygpLFxuICAgICAgICBiYXNlTXV0YXRpb25zOiBzZXJpYWxpemVkQmFzZU11dGF0aW9ucyxcbiAgICAgICAgbXV0YXRpb25zOiBzZXJpYWxpemVkTXV0YXRpb25zXG4gICAgfTtcbn1cbi8qKiBEZWNvZGVzIGEgRGJNdXRhdGlvbkJhdGNoIGludG8gYSBNdXRhdGlvbkJhdGNoICovXG5mdW5jdGlvbiBmcm9tRGJNdXRhdGlvbkJhdGNoKGxvY2FsU2VyaWFsaXplciwgZGJCYXRjaCkge1xuICAgIGNvbnN0IGJhc2VNdXRhdGlvbnMgPSAoZGJCYXRjaC5iYXNlTXV0YXRpb25zIHx8IFtdKS5tYXAobSA9PiBmcm9tTXV0YXRpb24obG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIG0pKTtcbiAgICAvLyBTcXVhc2ggb2xkIHRyYW5zZm9ybSBtdXRhdGlvbnMgaW50byBleGlzdGluZyBwYXRjaCBvciBzZXQgbXV0YXRpb25zLlxuICAgIC8vIFRoZSByZXBsYWNlbWVudCBvZiByZXByZXNlbnRpbmcgYHRyYW5zZm9ybXNgIHdpdGggYHVwZGF0ZV90cmFuc2Zvcm1zYFxuICAgIC8vIG9uIHRoZSBTREsgbWVhbnMgdGhhdCBvbGQgYHRyYW5zZm9ybWAgbXV0YXRpb25zIHN0b3JlZCBpbiBJbmRleGVkREIgbmVlZFxuICAgIC8vIHRvIGJlIHVwZGF0ZWQgdG8gYHVwZGF0ZV90cmFuc2Zvcm1zYC5cbiAgICAvLyBUT0RPKGIvMTc0NjA4Mzc0KTogUmVtb3ZlIHRoaXMgY29kZSBvbmNlIHdlIHBlcmZvcm0gYSBzY2hlbWEgbWlncmF0aW9uLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGJCYXRjaC5tdXRhdGlvbnMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRNdXRhdGlvbiA9IGRiQmF0Y2gubXV0YXRpb25zW2ldO1xuICAgICAgICBjb25zdCBoYXNUcmFuc2Zvcm0gPSBpICsgMSA8IGRiQmF0Y2gubXV0YXRpb25zLmxlbmd0aCAmJlxuICAgICAgICAgICAgZGJCYXRjaC5tdXRhdGlvbnNbaSArIDFdLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaGFzVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1NdXRhdGlvbiA9IGRiQmF0Y2gubXV0YXRpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIGN1cnJlbnRNdXRhdGlvbi51cGRhdGVUcmFuc2Zvcm1zID1cbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1NdXRhdGlvbi50cmFuc2Zvcm0uZmllbGRUcmFuc2Zvcm1zO1xuICAgICAgICAgICAgZGJCYXRjaC5tdXRhdGlvbnMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtdXRhdGlvbnMgPSBkYkJhdGNoLm11dGF0aW9ucy5tYXAobSA9PiBmcm9tTXV0YXRpb24obG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIG0pKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBUaW1lc3RhbXAuZnJvbU1pbGxpcyhkYkJhdGNoLmxvY2FsV3JpdGVUaW1lTXMpO1xuICAgIHJldHVybiBuZXcgTXV0YXRpb25CYXRjaChkYkJhdGNoLmJhdGNoSWQsIHRpbWVzdGFtcCwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKTtcbn1cbi8qKiBEZWNvZGVzIGEgRGJUYXJnZXQgaW50byBUYXJnZXREYXRhICovXG5mdW5jdGlvbiBmcm9tRGJUYXJnZXQoZGJUYXJnZXQpIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gZnJvbURiVGltZXN0YW1wKGRiVGFyZ2V0LnJlYWRUaW1lKTtcbiAgICBjb25zdCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uID0gZGJUYXJnZXQubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gZnJvbURiVGltZXN0YW1wKGRiVGFyZ2V0Lmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pXG4gICAgICAgIDogU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgIGxldCB0YXJnZXQ7XG4gICAgaWYgKGlzRG9jdW1lbnRRdWVyeShkYlRhcmdldC5xdWVyeSkpIHtcbiAgICAgICAgdGFyZ2V0ID0gZnJvbURvY3VtZW50c1RhcmdldChkYlRhcmdldC5xdWVyeSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXQgPSBmcm9tUXVlcnlUYXJnZXQoZGJUYXJnZXQucXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGFyZ2V0LCBkYlRhcmdldC50YXJnZXRJZCwgXCJUYXJnZXRQdXJwb3NlTGlzdGVuXCIgLyogVGFyZ2V0UHVycG9zZS5MaXN0ZW4gKi8sIGRiVGFyZ2V0Lmxhc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciwgdmVyc2lvbiwgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiwgQnl0ZVN0cmluZy5mcm9tQmFzZTY0U3RyaW5nKGRiVGFyZ2V0LnJlc3VtZVRva2VuKSk7XG59XG4vKiogRW5jb2RlcyBUYXJnZXREYXRhIGludG8gYSBEYlRhcmdldCBmb3Igc3RvcmFnZSBsb2NhbGx5LiAqL1xuZnVuY3Rpb24gdG9EYlRhcmdldChsb2NhbFNlcmlhbGl6ZXIsIHRhcmdldERhdGEpIHtcbiAgICBjb25zdCBkYlRpbWVzdGFtcCA9IHRvRGJUaW1lc3RhbXAodGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24pO1xuICAgIGNvbnN0IGRiTGFzdExpbWJvRnJlZVRpbWVzdGFtcCA9IHRvRGJUaW1lc3RhbXAodGFyZ2V0RGF0YS5sYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKTtcbiAgICBsZXQgcXVlcnlQcm90bztcbiAgICBpZiAodGFyZ2V0SXNEb2N1bWVudFRhcmdldCh0YXJnZXREYXRhLnRhcmdldCkpIHtcbiAgICAgICAgcXVlcnlQcm90byA9IHRvRG9jdW1lbnRzVGFyZ2V0KGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCB0YXJnZXREYXRhLnRhcmdldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBxdWVyeVByb3RvID0gdG9RdWVyeVRhcmdldChsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgdGFyZ2V0RGF0YS50YXJnZXQpLnF1ZXJ5VGFyZ2V0O1xuICAgIH1cbiAgICAvLyBXZSBjYW4ndCBzdG9yZSB0aGUgcmVzdW1lVG9rZW4gYXMgYSBCeXRlU3RyaW5nIGluIEluZGV4ZWREYiwgc28gd2VcbiAgICAvLyBjb252ZXJ0IGl0IHRvIGEgYmFzZTY0IHN0cmluZyBmb3Igc3RvcmFnZS5cbiAgICBjb25zdCByZXN1bWVUb2tlbiA9IHRhcmdldERhdGEucmVzdW1lVG9rZW4udG9CYXNlNjQoKTtcbiAgICAvLyBsYXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgaXMgYWx3YXlzIDAgdW50aWwgd2UgZG8gcmVhbCBHQy5cbiAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXRJZDogdGFyZ2V0RGF0YS50YXJnZXRJZCxcbiAgICAgICAgY2Fub25pY2FsSWQ6IGNhbm9uaWZ5VGFyZ2V0KHRhcmdldERhdGEudGFyZ2V0KSxcbiAgICAgICAgcmVhZFRpbWU6IGRiVGltZXN0YW1wLFxuICAgICAgICByZXN1bWVUb2tlbixcbiAgICAgICAgbGFzdExpc3RlblNlcXVlbmNlTnVtYmVyOiB0YXJnZXREYXRhLnNlcXVlbmNlTnVtYmVyLFxuICAgICAgICBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uOiBkYkxhc3RMaW1ib0ZyZWVUaW1lc3RhbXAsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeVByb3RvXG4gICAgfTtcbn1cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gZm9yIGZpZ3VyaW5nIG91dCB3aGF0IGtpbmQgb2YgcXVlcnkgaGFzIGJlZW4gc3RvcmVkLlxuICovXG5mdW5jdGlvbiBpc0RvY3VtZW50UXVlcnkoZGJRdWVyeSkge1xuICAgIHJldHVybiBkYlF1ZXJ5LmRvY3VtZW50cyAhPT0gdW5kZWZpbmVkO1xufVxuLyoqIEVuY29kZXMgYSBEYkJ1bmRsZSB0byBhIEJ1bmRsZU1ldGFkYXRhIG9iamVjdC4gKi9cbmZ1bmN0aW9uIGZyb21EYkJ1bmRsZShkYkJ1bmRsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBkYkJ1bmRsZS5idW5kbGVJZCxcbiAgICAgICAgY3JlYXRlVGltZTogZnJvbURiVGltZXN0YW1wKGRiQnVuZGxlLmNyZWF0ZVRpbWUpLFxuICAgICAgICB2ZXJzaW9uOiBkYkJ1bmRsZS52ZXJzaW9uXG4gICAgfTtcbn1cbi8qKiBFbmNvZGVzIGEgQnVuZGxlTWV0YWRhdGEgdG8gYSBEYkJ1bmRsZS4gKi9cbmZ1bmN0aW9uIHRvRGJCdW5kbGUobWV0YWRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBidW5kbGVJZDogbWV0YWRhdGEuaWQsXG4gICAgICAgIGNyZWF0ZVRpbWU6IHRvRGJUaW1lc3RhbXAoZnJvbVZlcnNpb24obWV0YWRhdGEuY3JlYXRlVGltZSkpLFxuICAgICAgICB2ZXJzaW9uOiBtZXRhZGF0YS52ZXJzaW9uXG4gICAgfTtcbn1cbi8qKiBFbmNvZGVzIGEgRGJOYW1lZFF1ZXJ5IHRvIGEgTmFtZWRRdWVyeS4gKi9cbmZ1bmN0aW9uIGZyb21EYk5hbWVkUXVlcnkoZGJOYW1lZFF1ZXJ5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZGJOYW1lZFF1ZXJ5Lm5hbWUsXG4gICAgICAgIHF1ZXJ5OiBmcm9tQnVuZGxlZFF1ZXJ5KGRiTmFtZWRRdWVyeS5idW5kbGVkUXVlcnkpLFxuICAgICAgICByZWFkVGltZTogZnJvbURiVGltZXN0YW1wKGRiTmFtZWRRdWVyeS5yZWFkVGltZSlcbiAgICB9O1xufVxuLyoqIEVuY29kZXMgYSBOYW1lZFF1ZXJ5IGZyb20gYSBidW5kbGUgcHJvdG8gdG8gYSBEYk5hbWVkUXVlcnkuICovXG5mdW5jdGlvbiB0b0RiTmFtZWRRdWVyeShxdWVyeSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHF1ZXJ5Lm5hbWUsXG4gICAgICAgIHJlYWRUaW1lOiB0b0RiVGltZXN0YW1wKGZyb21WZXJzaW9uKHF1ZXJ5LnJlYWRUaW1lKSksXG4gICAgICAgIGJ1bmRsZWRRdWVyeTogcXVlcnkuYnVuZGxlZFF1ZXJ5XG4gICAgfTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIGBCdW5kbGVkUXVlcnlgIGZyb20gYnVuZGxlIHByb3RvIHRvIGEgUXVlcnkgb2JqZWN0LlxuICpcbiAqIFRoaXMgcmVjb25zdHJ1Y3RzIHRoZSBvcmlnaW5hbCBxdWVyeSB1c2VkIHRvIGJ1aWxkIHRoZSBidW5kbGUgYmVpbmcgbG9hZGVkLFxuICogaW5jbHVkaW5nIGZlYXR1cmVzIGV4aXN0cyBvbmx5IGluIFNES3MgKGZvciBleGFtcGxlOiBsaW1pdC10by1sYXN0KS5cbiAqL1xuZnVuY3Rpb24gZnJvbUJ1bmRsZWRRdWVyeShidW5kbGVkUXVlcnkpIHtcbiAgICBjb25zdCBxdWVyeSA9IGNvbnZlcnRRdWVyeVRhcmdldFRvUXVlcnkoe1xuICAgICAgICBwYXJlbnQ6IGJ1bmRsZWRRdWVyeS5wYXJlbnQsXG4gICAgICAgIHN0cnVjdHVyZWRRdWVyeTogYnVuZGxlZFF1ZXJ5LnN0cnVjdHVyZWRRdWVyeVxuICAgIH0pO1xuICAgIGlmIChidW5kbGVkUXVlcnkubGltaXRUeXBlID09PSAnTEFTVCcpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5V2l0aExpbWl0KHF1ZXJ5LCBxdWVyeS5saW1pdCwgXCJMXCIgLyogTGltaXRUeXBlLkxhc3QgKi8pO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnk7XG59XG4vKiogRW5jb2RlcyBhIE5hbWVkUXVlcnkgcHJvdG8gb2JqZWN0IHRvIGEgTmFtZWRRdWVyeSBtb2RlbCBvYmplY3QuICovXG5mdW5jdGlvbiBmcm9tUHJvdG9OYW1lZFF1ZXJ5KG5hbWVkUXVlcnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lZFF1ZXJ5Lm5hbWUsXG4gICAgICAgIHF1ZXJ5OiBmcm9tQnVuZGxlZFF1ZXJ5KG5hbWVkUXVlcnkuYnVuZGxlZFF1ZXJ5KSxcbiAgICAgICAgcmVhZFRpbWU6IGZyb21WZXJzaW9uKG5hbWVkUXVlcnkucmVhZFRpbWUpXG4gICAgfTtcbn1cbi8qKiBEZWNvZGVzIGEgQnVuZGxlTWV0YWRhdGEgcHJvdG8gaW50byBhIEJ1bmRsZU1ldGFkYXRhIG9iamVjdC4gKi9cbmZ1bmN0aW9uIGZyb21CdW5kbGVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBtZXRhZGF0YS5pZCxcbiAgICAgICAgdmVyc2lvbjogbWV0YWRhdGEudmVyc2lvbixcbiAgICAgICAgY3JlYXRlVGltZTogZnJvbVZlcnNpb24obWV0YWRhdGEuY3JlYXRlVGltZSlcbiAgICB9O1xufVxuLyoqIEVuY29kZXMgYSBEYkRvY3VtZW50T3ZlcmxheSBvYmplY3QgdG8gYW4gT3ZlcmxheSBtb2RlbCBvYmplY3QuICovXG5mdW5jdGlvbiBmcm9tRGJEb2N1bWVudE92ZXJsYXkobG9jYWxTZXJpYWxpemVyLCBkYkRvY3VtZW50T3ZlcmxheSkge1xuICAgIHJldHVybiBuZXcgT3ZlcmxheShkYkRvY3VtZW50T3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCwgZnJvbU11dGF0aW9uKGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCBkYkRvY3VtZW50T3ZlcmxheS5vdmVybGF5TXV0YXRpb24pKTtcbn1cbi8qKiBEZWNvZGVzIGFuIE92ZXJsYXkgbW9kZWwgb2JqZWN0IGludG8gYSBEYkRvY3VtZW50T3ZlcmxheSBvYmplY3QuICovXG5mdW5jdGlvbiB0b0RiRG9jdW1lbnRPdmVybGF5KGxvY2FsU2VyaWFsaXplciwgdXNlcklkLCBvdmVybGF5KSB7XG4gICAgY29uc3QgW18sIGNvbGxlY3Rpb25QYXRoLCBkb2N1bWVudElkXSA9IHRvRGJEb2N1bWVudE92ZXJsYXlLZXkodXNlcklkLCBvdmVybGF5Lm11dGF0aW9uLmtleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBjb2xsZWN0aW9uUGF0aCxcbiAgICAgICAgZG9jdW1lbnRJZCxcbiAgICAgICAgY29sbGVjdGlvbkdyb3VwOiBvdmVybGF5Lm11dGF0aW9uLmtleS5nZXRDb2xsZWN0aW9uR3JvdXAoKSxcbiAgICAgICAgbGFyZ2VzdEJhdGNoSWQ6IG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQsXG4gICAgICAgIG92ZXJsYXlNdXRhdGlvbjogdG9NdXRhdGlvbihsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgb3ZlcmxheS5tdXRhdGlvbilcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBEYkRvY3VtZW50T3ZlcmxheUtleSBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiB1c2VyIGFuZFxuICogZG9jdW1lbnQga2V5LlxuICovXG5mdW5jdGlvbiB0b0RiRG9jdW1lbnRPdmVybGF5S2V5KHVzZXJJZCwgZG9jS2V5KSB7XG4gICAgY29uc3QgZG9jSWQgPSBkb2NLZXkucGF0aC5sYXN0U2VnbWVudCgpO1xuICAgIGNvbnN0IGNvbGxlY3Rpb25QYXRoID0gZW5jb2RlUmVzb3VyY2VQYXRoKGRvY0tleS5wYXRoLnBvcExhc3QoKSk7XG4gICAgcmV0dXJuIFt1c2VySWQsIGNvbGxlY3Rpb25QYXRoLCBkb2NJZF07XG59XG5mdW5jdGlvbiB0b0RiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXhJZDogaW5kZXguaW5kZXhJZCxcbiAgICAgICAgY29sbGVjdGlvbkdyb3VwOiBpbmRleC5jb2xsZWN0aW9uR3JvdXAsXG4gICAgICAgIGZpZWxkczogaW5kZXguZmllbGRzLm1hcChzID0+IFtzLmZpZWxkUGF0aC5jYW5vbmljYWxTdHJpbmcoKSwgcy5raW5kXSlcbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbURiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4LCBzdGF0ZSkge1xuICAgIGNvbnN0IGRlY29kZWRTdGF0ZSA9IHN0YXRlXG4gICAgICAgID8gbmV3IEluZGV4U3RhdGUoc3RhdGUuc2VxdWVuY2VOdW1iZXIsIG5ldyBJbmRleE9mZnNldChmcm9tRGJUaW1lc3RhbXAoc3RhdGUucmVhZFRpbWUpLCBuZXcgRG9jdW1lbnRLZXkoZGVjb2RlUmVzb3VyY2VQYXRoKHN0YXRlLmRvY3VtZW50S2V5KSksIHN0YXRlLmxhcmdlc3RCYXRjaElkKSlcbiAgICAgICAgOiBJbmRleFN0YXRlLmVtcHR5KCk7XG4gICAgY29uc3QgZGVjb2RlZFNlZ21lbnRzID0gaW5kZXguZmllbGRzLm1hcCgoW2ZpZWxkUGF0aCwga2luZF0pID0+IG5ldyBJbmRleFNlZ21lbnQoRmllbGRQYXRoJDEuZnJvbVNlcnZlckZvcm1hdChmaWVsZFBhdGgpLCBraW5kKSk7XG4gICAgcmV0dXJuIG5ldyBGaWVsZEluZGV4KGluZGV4LmluZGV4SWQsIGluZGV4LmNvbGxlY3Rpb25Hcm91cCwgZGVjb2RlZFNlZ21lbnRzLCBkZWNvZGVkU3RhdGUpO1xufVxuZnVuY3Rpb24gdG9EYkluZGV4U3RhdGUoaW5kZXhJZCwgdWlkLCBzZXF1ZW5jZU51bWJlciwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXhJZCxcbiAgICAgICAgdWlkLFxuICAgICAgICBzZXF1ZW5jZU51bWJlcixcbiAgICAgICAgcmVhZFRpbWU6IHRvRGJUaW1lc3RhbXAob2Zmc2V0LnJlYWRUaW1lKSxcbiAgICAgICAgZG9jdW1lbnRLZXk6IGVuY29kZVJlc291cmNlUGF0aChvZmZzZXQuZG9jdW1lbnRLZXkucGF0aCksXG4gICAgICAgIGxhcmdlc3RCYXRjaElkOiBvZmZzZXQubGFyZ2VzdEJhdGNoSWRcbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgSW5kZXhlZERiQnVuZGxlQ2FjaGUge1xuICAgIGdldEJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVJZCkge1xuICAgICAgICByZXR1cm4gYnVuZGxlc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLmdldChidW5kbGVJZClcbiAgICAgICAgICAgIC5uZXh0KGJ1bmRsZSA9PiB7XG4gICAgICAgICAgICBpZiAoYnVuZGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYkJ1bmRsZShidW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNhdmVCdW5kbGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgYnVuZGxlTWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGJ1bmRsZXNTdG9yZSh0cmFuc2FjdGlvbikucHV0KHRvRGJCdW5kbGUoYnVuZGxlTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgZ2V0TmFtZWRRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnlOYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lZFF1ZXJpZXNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5nZXQocXVlcnlOYW1lKVxuICAgICAgICAgICAgLm5leHQocXVlcnkgPT4ge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYk5hbWVkUXVlcnkocXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNhdmVOYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSkge1xuICAgICAgICByZXR1cm4gbmFtZWRRdWVyaWVzU3RvcmUodHJhbnNhY3Rpb24pLnB1dCh0b0RiTmFtZWRRdWVyeShxdWVyeSkpO1xuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBidW5kbGVzIG9iamVjdCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gYnVuZGxlc1N0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiQnVuZGxlU3RvcmUpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIG5hbWVkUXVlcmllcyBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIG5hbWVkUXVlcmllc1N0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiTmFtZWRRdWVyeVN0b3JlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgRG9jdW1lbnRPdmVybGF5Q2FjaGUgdXNpbmcgSW5kZXhlZERiLlxuICovXG5jbGFzcyBJbmRleGVkRGJEb2N1bWVudE92ZXJsYXlDYWNoZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHNlcmlhbGl6ZXIgLSBUaGUgZG9jdW1lbnQgc2VyaWFsaXplci5cbiAgICAgKiBAcGFyYW0gdXNlcklkIC0gVGhlIHVzZXJJZCBmb3Igd2hpY2ggd2UgYXJlIGFjY2Vzc2luZyBvdmVybGF5cy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyLCB1c2VySWQpIHtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICAgICAgdGhpcy51c2VySWQgPSB1c2VySWQ7XG4gICAgfVxuICAgIHN0YXRpYyBmb3JVc2VyKHNlcmlhbGl6ZXIsIHVzZXIpIHtcbiAgICAgICAgY29uc3QgdXNlcklkID0gdXNlci51aWQgfHwgJyc7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiRG9jdW1lbnRPdmVybGF5Q2FjaGUoc2VyaWFsaXplciwgdXNlcklkKTtcbiAgICB9XG4gICAgZ2V0T3ZlcmxheSh0cmFuc2FjdGlvbiwga2V5KSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudE92ZXJsYXlTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5nZXQodG9EYkRvY3VtZW50T3ZlcmxheUtleSh0aGlzLnVzZXJJZCwga2V5KSlcbiAgICAgICAgICAgIC5uZXh0KGRiT3ZlcmxheSA9PiB7XG4gICAgICAgICAgICBpZiAoZGJPdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYkRvY3VtZW50T3ZlcmxheSh0aGlzLnNlcmlhbGl6ZXIsIGRiT3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE92ZXJsYXlzKHRyYW5zYWN0aW9uLCBrZXlzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld092ZXJsYXlNYXAoKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGtleXMsIChrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE92ZXJsYXkodHJhbnNhY3Rpb24sIGtleSkubmV4dChvdmVybGF5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICB9XG4gICAgc2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBsYXJnZXN0QmF0Y2hJZCwgb3ZlcmxheXMpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgb3ZlcmxheXMuZm9yRWFjaCgoXywgbXV0YXRpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBuZXcgT3ZlcmxheShsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnNhdmVPdmVybGF5KHRyYW5zYWN0aW9uLCBvdmVybGF5KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xuICAgIH1cbiAgICByZW1vdmVPdmVybGF5c0ZvckJhdGNoSWQodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cywgYmF0Y2hJZCkge1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uUGF0aHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8vIEdldCB0aGUgc2V0IG9mIHVuaXF1ZSBjb2xsZWN0aW9uIHBhdGhzLlxuICAgICAgICBkb2N1bWVudEtleXMuZm9yRWFjaChrZXkgPT4gY29sbGVjdGlvblBhdGhzLmFkZChlbmNvZGVSZXNvdXJjZVBhdGgoa2V5LmdldENvbGxlY3Rpb25QYXRoKCkpKSk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGNvbGxlY3Rpb25QYXRocy5mb3JFYWNoKGNvbGxlY3Rpb25QYXRoID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3RoaXMudXNlcklkLCBjb2xsZWN0aW9uUGF0aCwgYmF0Y2hJZF0sIFt0aGlzLnVzZXJJZCwgY29sbGVjdGlvblBhdGgsIGJhdGNoSWQgKyAxXSwgXG4gICAgICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXG4gICAgICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goZG9jdW1lbnRPdmVybGF5U3RvcmUodHJhbnNhY3Rpb24pLmRlbGV0ZUFsbChEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4LCByYW5nZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcbiAgICB9XG4gICAgZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uLCBzaW5jZUJhdGNoSWQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3T3ZlcmxheU1hcCgpO1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uUGF0aCA9IGVuY29kZVJlc291cmNlUGF0aChjb2xsZWN0aW9uKTtcbiAgICAgICAgLy8gV2Ugd2FudCBiYXRjaCBJRHMgbGFyZ2VyIHRoYW4gYHNpbmNlQmF0Y2hJZGAsIGFuZCBzbyB0aGUgbG93ZXIgYm91bmRcbiAgICAgICAgLy8gaXMgbm90IGluY2x1c2l2ZS5cbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGhpcy51c2VySWQsIGNvbGxlY3Rpb25QYXRoLCBzaW5jZUJhdGNoSWRdLCBbdGhpcy51c2VySWQsIGNvbGxlY3Rpb25QYXRoLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldLCBcbiAgICAgICAgLypsb3dlck9wZW49Ki8gdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkb2N1bWVudE92ZXJsYXlTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5sb2FkQWxsKERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvblBhdGhPdmVybGF5SW5kZXgsIHJhbmdlKVxuICAgICAgICAgICAgLm5leHQoZGJPdmVybGF5cyA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRiT3ZlcmxheSBvZiBkYk92ZXJsYXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGZyb21EYkRvY3VtZW50T3ZlcmxheSh0aGlzLnNlcmlhbGl6ZXIsIGRiT3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChvdmVybGF5LmdldEtleSgpLCBvdmVybGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRPdmVybGF5c0ZvckNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBzaW5jZUJhdGNoSWQsIGNvdW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld092ZXJsYXlNYXAoKTtcbiAgICAgICAgbGV0IGN1cnJlbnRCYXRjaElkID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBXZSB3YW50IGJhdGNoIElEcyBsYXJnZXIgdGhhbiBgc2luY2VCYXRjaElkYCwgYW5kIHNvIHRoZSBsb3dlciBib3VuZFxuICAgICAgICAvLyBpcyBub3QgaW5jbHVzaXZlLlxuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0aGlzLnVzZXJJZCwgY29sbGVjdGlvbkdyb3VwLCBzaW5jZUJhdGNoSWRdLCBbdGhpcy51c2VySWQsIGNvbGxlY3Rpb25Hcm91cCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSwgXG4gICAgICAgIC8qbG93ZXJPcGVuPSovIHRydWUpO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRPdmVybGF5U3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuaXRlcmF0ZSh7XG4gICAgICAgICAgICBpbmRleDogRGJEb2N1bWVudE92ZXJsYXlDb2xsZWN0aW9uR3JvdXBPdmVybGF5SW5kZXgsXG4gICAgICAgICAgICByYW5nZVxuICAgICAgICB9LCAoXywgZGJPdmVybGF5LCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byByZXR1cm4gcGFydGlhbCBiYXRjaCBvdmVybGF5cywgZXZlbiBpZiB0aGUgc2l6ZVxuICAgICAgICAgICAgLy8gb2YgdGhlIHJlc3VsdCBzZXQgZXhjZWVkcyB0aGUgZ2l2ZW4gYGNvdW50YCBhcmd1bWVudC4gVGhlcmVmb3JlLCB3ZVxuICAgICAgICAgICAgLy8gY29udGludWUgdG8gYWdncmVnYXRlIHJlc3VsdHMgZXZlbiBhZnRlciB0aGUgcmVzdWx0IHNpemUgZXhjZWVkc1xuICAgICAgICAgICAgLy8gYGNvdW50YCBpZiB0aGVyZSBhcmUgbW9yZSBvdmVybGF5cyBmcm9tIHRoZSBgY3VycmVudEJhdGNoSWRgLlxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGZyb21EYkRvY3VtZW50T3ZlcmxheSh0aGlzLnNlcmlhbGl6ZXIsIGRiT3ZlcmxheSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnNpemUoKSA8IGNvdW50IHx8XG4gICAgICAgICAgICAgICAgb3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCA9PT0gY3VycmVudEJhdGNoSWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KG92ZXJsYXkuZ2V0S2V5KCksIG92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCYXRjaElkID0gb3ZlcmxheS5sYXJnZXN0QmF0Y2hJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICB9XG4gICAgc2F2ZU92ZXJsYXkodHJhbnNhY3Rpb24sIG92ZXJsYXkpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50T3ZlcmxheVN0b3JlKHRyYW5zYWN0aW9uKS5wdXQodG9EYkRvY3VtZW50T3ZlcmxheSh0aGlzLnNlcmlhbGl6ZXIsIHRoaXMudXNlcklkLCBvdmVybGF5KSk7XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGRvY3VtZW50IG92ZXJsYXkgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBkb2N1bWVudE92ZXJsYXlTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkRvY3VtZW50T3ZlcmxheVN0b3JlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEluZGV4ZWREYkdsb2JhbHNDYWNoZSB7XG4gICAgZ2xvYmFsc1N0b3JlKHR4bikge1xuICAgICAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkdsb2JhbHNTdG9yZSk7XG4gICAgfVxuICAgIGdldFNlc3Npb25Ub2tlbih0eG4pIHtcbiAgICAgICAgY29uc3QgZ2xvYmFscyA9IHRoaXMuZ2xvYmFsc1N0b3JlKHR4bik7XG4gICAgICAgIHJldHVybiBnbG9iYWxzLmdldCgnc2Vzc2lvblRva2VuJykubmV4dChnbG9iYWwgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnbG9iYWwgPT09IG51bGwgfHwgZ2xvYmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnbG9iYWwudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgICAgICA/IEJ5dGVTdHJpbmcuZnJvbVVpbnQ4QXJyYXkodmFsdWUpXG4gICAgICAgICAgICAgICAgOiBCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0U2Vzc2lvblRva2VuKHR4biwgc2Vzc2lvblRva2VuKSB7XG4gICAgICAgIGNvbnN0IGdsb2JhbHMgPSB0aGlzLmdsb2JhbHNTdG9yZSh0eG4pO1xuICAgICAgICByZXR1cm4gZ2xvYmFscy5wdXQoe1xuICAgICAgICAgICAgbmFtZTogJ3Nlc3Npb25Ub2tlbicsXG4gICAgICAgICAgICB2YWx1ZTogc2Vzc2lvblRva2VuLnRvVWludDhBcnJheSgpXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIE5vdGU6IFRoaXMgY29kZSBpcyBjb3BpZWQgZnJvbSB0aGUgYmFja2VuZC4gQ29kZSB0aGF0IGlzIG5vdCB1c2VkIGJ5XG4vLyBGaXJlc3RvcmUgd2FzIHJlbW92ZWQuXG5jb25zdCBJTkRFWF9UWVBFX05VTEwgPSA1O1xuY29uc3QgSU5ERVhfVFlQRV9CT09MRUFOID0gMTA7XG5jb25zdCBJTkRFWF9UWVBFX05BTiA9IDEzO1xuY29uc3QgSU5ERVhfVFlQRV9OVU1CRVIgPSAxNTtcbmNvbnN0IElOREVYX1RZUEVfVElNRVNUQU1QID0gMjA7XG5jb25zdCBJTkRFWF9UWVBFX1NUUklORyA9IDI1O1xuY29uc3QgSU5ERVhfVFlQRV9CTE9CID0gMzA7XG5jb25zdCBJTkRFWF9UWVBFX1JFRkVSRU5DRSA9IDM3O1xuY29uc3QgSU5ERVhfVFlQRV9HRU9QT0lOVCA9IDQ1O1xuY29uc3QgSU5ERVhfVFlQRV9BUlJBWSA9IDUwO1xuY29uc3QgSU5ERVhfVFlQRV9WRUNUT1IgPSA1MztcbmNvbnN0IElOREVYX1RZUEVfTUFQID0gNTU7XG5jb25zdCBJTkRFWF9UWVBFX1JFRkVSRU5DRV9TRUdNRU5UID0gNjA7XG4vLyBBIHRlcm1pbmF0b3IgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhIHRydW5jYXRhYmxlIHZhbHVlIHdhcyBub3QgdHJ1bmNhdGVkLlxuLy8gVGhpcyBtdXN0IGJlIHNtYWxsZXIgdGhhbiBhbGwgb3RoZXIgdHlwZSBsYWJlbHMuXG5jb25zdCBOT1RfVFJVTkNBVEVEID0gMjtcbi8qKiBGaXJlc3RvcmUgaW5kZXggdmFsdWUgd3JpdGVyLiAgKi9cbmNsYXNzIEZpcmVzdG9yZUluZGV4VmFsdWVXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgLy8gVGhlIHdyaXRlIG1ldGhvZHMgYmVsb3cgc2hvcnQtY2lyY3VpdCB3cml0aW5nIHRlcm1pbmF0b3JzIGZvciB2YWx1ZXNcbiAgICAvLyBjb250YWluaW5nIGEgKHRlcm1pbmF0aW5nKSB0cnVuY2F0ZWQgdmFsdWUuXG4gICAgLy9cbiAgICAvLyBBcyBhbiBleGFtcGxlLCBjb25zaWRlciB0aGUgcmVzdWx0aW5nIGVuY29kaW5nIGZvcjpcbiAgICAvL1xuICAgIC8vIFtcImJhclwiLCBbMiwgXCJmb29cIl1dIC0+IChTVFJJTkcsIFwiYmFyXCIsIFRFUk0sIEFSUkFZLCBOVU1CRVIsIDIsIFNUUklORywgXCJmb29cIiwgVEVSTSwgVEVSTSwgVEVSTSlcbiAgICAvLyBbXCJiYXJcIiwgWzIsIHRydW5jYXRlZChcImZvb1wiKV1dIC0+IChTVFJJTkcsIFwiYmFyXCIsIFRFUk0sIEFSUkFZLCBOVU1CRVIsIDIsIFNUUklORywgXCJmb29cIiwgVFJVTkMpXG4gICAgLy8gW1wiYmFyXCIsIHRydW5jYXRlZChbXCJmb29cIl0pXSAtPiAoU1RSSU5HLCBcImJhclwiLCBURVJNLCBBUlJBWS4gU1RSSU5HLCBcImZvb1wiLCBURVJNLCBUUlVOQylcbiAgICAvKiogV3JpdGVzIGFuIGluZGV4IHZhbHVlLiAgKi9cbiAgICB3cml0ZUluZGV4VmFsdWUodmFsdWUsIGVuY29kZXIpIHtcbiAgICAgICAgdGhpcy53cml0ZUluZGV4VmFsdWVBdXgodmFsdWUsIGVuY29kZXIpO1xuICAgICAgICAvLyBXcml0ZSBzZXBhcmF0b3IgdG8gc3BsaXQgaW5kZXggdmFsdWVzXG4gICAgICAgIC8vIChzZWUgZ28vZmlyZXN0b3JlLXN0b3JhZ2UtZm9ybWF0I2VuY29kaW5ncykuXG4gICAgICAgIGVuY29kZXIud3JpdGVJbmZpbml0eSgpO1xuICAgIH1cbiAgICB3cml0ZUluZGV4VmFsdWVBdXgoaW5kZXhWYWx1ZSwgZW5jb2Rlcikge1xuICAgICAgICBpZiAoJ251bGxWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTlVMTCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ2Jvb2xlYW5WYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfQk9PTEVBTik7XG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlTnVtYmVyKGluZGV4VmFsdWUuYm9vbGVhblZhbHVlID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX05VTUJFUik7XG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlTnVtYmVyKG5vcm1hbGl6ZU51bWJlcihpbmRleFZhbHVlLmludGVnZXJWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdkb3VibGVWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IG5vcm1hbGl6ZU51bWJlcihpbmRleFZhbHVlLmRvdWJsZVZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc05hTihuKSkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX05BTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9OVU1CRVIpO1xuICAgICAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlWmVybyhuKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAtMC4wLCAwIGFuZCAwLjAgYXJlIGFsbCBjb25zaWRlcmVkIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoMC4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIobik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCd0aW1lc3RhbXBWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgbGV0IHRpbWVzdGFtcCA9IGluZGV4VmFsdWUudGltZXN0YW1wVmFsdWU7XG4gICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9USU1FU1RBTVApO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aW1lc3RhbXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKHRpbWVzdGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKGAke3RpbWVzdGFtcC5zZWNvbmRzIHx8ICcnfWApO1xuICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcih0aW1lc3RhbXAubmFub3MgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ3N0cmluZ1ZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhTdHJpbmcoaW5kZXhWYWx1ZS5zdHJpbmdWYWx1ZSwgZW5jb2Rlcik7XG4gICAgICAgICAgICB0aGlzLndyaXRlVHJ1bmNhdGlvbk1hcmtlcihlbmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnYnl0ZXNWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfQkxPQik7XG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlQnl0ZXMobm9ybWFsaXplQnl0ZVN0cmluZyhpbmRleFZhbHVlLmJ5dGVzVmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVUcnVuY2F0aW9uTWFya2VyKGVuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdyZWZlcmVuY2VWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4RW50aXR5UmVmKGluZGV4VmFsdWUucmVmZXJlbmNlVmFsdWUsIGVuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdnZW9Qb2ludFZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBnZW9Qb2ludCA9IGluZGV4VmFsdWUuZ2VvUG9pbnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX0dFT1BPSU5UKTtcbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoZ2VvUG9pbnQubGF0aXR1ZGUgfHwgMCk7XG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlTnVtYmVyKGdlb1BvaW50LmxvbmdpdHVkZSB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnbWFwVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc01heFZhbHVlKGluZGV4VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVmVjdG9yVmFsdWUoaW5kZXhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhWZWN0b3IoaW5kZXhWYWx1ZS5tYXBWYWx1ZSwgZW5jb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhNYXAoaW5kZXhWYWx1ZS5tYXBWYWx1ZSwgZW5jb2Rlcik7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVRydW5jYXRpb25NYXJrZXIoZW5jb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ2FycmF5VmFsdWUnIGluIGluZGV4VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleEFycmF5KGluZGV4VmFsdWUuYXJyYXlWYWx1ZSwgZW5jb2Rlcik7XG4gICAgICAgICAgICB0aGlzLndyaXRlVHJ1bmNhdGlvbk1hcmtlcihlbmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUluZGV4U3RyaW5nKHN0cmluZ0luZGV4VmFsdWUsIGVuY29kZXIpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfU1RSSU5HKTtcbiAgICAgICAgdGhpcy53cml0ZVVubGFiZWxlZEluZGV4U3RyaW5nKHN0cmluZ0luZGV4VmFsdWUsIGVuY29kZXIpO1xuICAgIH1cbiAgICB3cml0ZVVubGFiZWxlZEluZGV4U3RyaW5nKHN0cmluZ0luZGV4VmFsdWUsIGVuY29kZXIpIHtcbiAgICAgICAgZW5jb2Rlci53cml0ZVN0cmluZyhzdHJpbmdJbmRleFZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVJbmRleE1hcChtYXBJbmRleFZhbHVlLCBlbmNvZGVyKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IG1hcEluZGV4VmFsdWUuZmllbGRzIHx8IHt9O1xuICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9NQVApO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtYXApKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhTdHJpbmcoa2V5LCBlbmNvZGVyKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleFZhbHVlQXV4KG1hcFtrZXldLCBlbmNvZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUluZGV4VmVjdG9yKG1hcEluZGV4VmFsdWUsIGVuY29kZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWFwID0gbWFwSW5kZXhWYWx1ZS5maWVsZHMgfHwge307XG4gICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX1ZFQ1RPUik7XG4gICAgICAgIC8vIFZlY3RvcnMgc29ydCBmaXJzdCBieSBsZW5ndGhcbiAgICAgICAgY29uc3Qga2V5ID0gVkVDVE9SX01BUF9WRUNUT1JTX0tFWTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gKChfYiA9IChfYSA9IG1hcFtrZXldLmFycmF5VmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpIHx8IDA7XG4gICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX05VTUJFUik7XG4gICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIobm9ybWFsaXplTnVtYmVyKGxlbmd0aCkpO1xuICAgICAgICAvLyBWZWN0b3JzIHRoZW4gc29ydCBieSBwb3NpdGlvbiB2YWx1ZVxuICAgICAgICB0aGlzLndyaXRlSW5kZXhTdHJpbmcoa2V5LCBlbmNvZGVyKTtcbiAgICAgICAgdGhpcy53cml0ZUluZGV4VmFsdWVBdXgobWFwW2tleV0sIGVuY29kZXIpO1xuICAgIH1cbiAgICB3cml0ZUluZGV4QXJyYXkoYXJyYXlJbmRleFZhbHVlLCBlbmNvZGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGFycmF5SW5kZXhWYWx1ZS52YWx1ZXMgfHwgW107XG4gICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX0FSUkFZKTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHZhbHVlcykge1xuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4VmFsdWVBdXgoZWxlbWVudCwgZW5jb2Rlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVJbmRleEVudGl0eVJlZihyZWZlcmVuY2VWYWx1ZSwgZW5jb2Rlcikge1xuICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9SRUZFUkVOQ0UpO1xuICAgICAgICBjb25zdCBwYXRoID0gRG9jdW1lbnRLZXkuZnJvbU5hbWUocmVmZXJlbmNlVmFsdWUpLnBhdGg7XG4gICAgICAgIHBhdGguZm9yRWFjaChzZWdtZW50ID0+IHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX1JFRkVSRU5DRV9TRUdNRU5UKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVVbmxhYmVsZWRJbmRleFN0cmluZyhzZWdtZW50LCBlbmNvZGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgdHlwZU9yZGVyKSB7XG4gICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIodHlwZU9yZGVyKTtcbiAgICB9XG4gICAgd3JpdGVUcnVuY2F0aW9uTWFya2VyKGVuY29kZXIpIHtcbiAgICAgICAgLy8gV2hpbGUgdGhlIFNESyBkb2VzIG5vdCBpbXBsZW1lbnQgdHJ1bmNhdGlvbiwgdGhlIHRydW5jYXRpb24gbWFya2VyIGlzXG4gICAgICAgIC8vIHVzZWQgdG8gdGVybWluYXRlIGFsbCB2YXJpYWJsZSBsZW5ndGggdmFsdWVzICh3aGljaCBhcmUgc3RyaW5ncywgYnl0ZXMsXG4gICAgICAgIC8vIHJlZmVyZW5jZXMsIGFycmF5cyBhbmQgbWFwcykuXG4gICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoTk9UX1RSVU5DQVRFRCk7XG4gICAgfVxufVxuRmlyZXN0b3JlSW5kZXhWYWx1ZVdyaXRlci5JTlNUQU5DRSA9IG5ldyBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyKCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgfCBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyB8IENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIHwgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogVGhlc2UgY29uc3RhbnRzIGFyZSB0YWtlbiBmcm9tIHRoZSBiYWNrZW5kLiAqL1xuY29uc3QgTUlOX1NVUlJPR0FURSA9ICdcXHVEODAwJztcbmNvbnN0IE1BWF9TVVJST0dBVEUgPSAnXFx1REJGRic7XG5jb25zdCBFU0NBUEUxID0gMHgwMDtcbmNvbnN0IE5VTExfQllURSA9IDB4ZmY7IC8vIENvbWJpbmVkIHdpdGggRVNDQVBFMVxuY29uc3QgU0VQQVJBVE9SID0gMHgwMTsgLy8gQ29tYmluZWQgd2l0aCBFU0NBUEUxXG5jb25zdCBFU0NBUEUyID0gMHhmZjtcbmNvbnN0IElORklOSVRZID0gMHhmZjsgLy8gQ29tYmluZWQgd2l0aCBFU0NBUEUyXG5jb25zdCBGRl9CWVRFID0gMHgwMDsgLy8gQ29tYmluZWQgd2l0aCBFU0NBUEUyXG5jb25zdCBMT05HX1NJWkUgPSA2NDtcbmNvbnN0IEJZVEVfU0laRSA9IDg7XG4vKipcbiAqIFRoZSBkZWZhdWx0IHNpemUgb2YgdGhlIGJ1ZmZlci4gVGhpcyBpcyBhcmJpdHJhcnksIGJ1dCBsaWtlbHkgbGFyZ2VyIHRoYW5cbiAqIG1vc3QgaW5kZXggdmFsdWVzIHNvIHRoYXQgbGVzcyBjb3BpZXMgb2YgdGhlIHVuZGVybHlpbmcgYnVmZmVyIHdpbGwgYmUgbWFkZS5cbiAqIEZvciBsYXJnZSB2YWx1ZXMsIGEgc2luZ2xlIGNvcHkgd2lsbCBtYWRlIHRvIGRvdWJsZSB0aGUgYnVmZmVyIGxlbmd0aC5cbiAqL1xuY29uc3QgREVGQVVMVF9CVUZGRVJfU0laRSA9IDEwMjQ7XG4vKiogQ29udmVydHMgYSBKYXZhU2NyaXB0IG51bWJlciB0byBhIGJ5dGUgYXJyYXkgKHVzaW5nIGJpZyBlbmRpYW4gZW5jb2RpbmcpLiAqL1xuZnVuY3Rpb24gZG91YmxlVG9Mb25nQml0cyh2YWx1ZSkge1xuICAgIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcig4KSk7XG4gICAgZHYuc2V0RmxvYXQ2NCgwLCB2YWx1ZSwgLyogbGl0dGxlRW5kaWFuPSAqLyBmYWxzZSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGR2LmJ1ZmZlcik7XG59XG4vKipcbiAqIENvdW50cyB0aGUgbnVtYmVyIG9mIHplcm9zIGluIGEgYnl0ZS5cbiAqXG4gKiBWaXNpYmxlIGZvciB0ZXN0aW5nLlxuICovXG5mdW5jdGlvbiBudW1iZXJPZkxlYWRpbmdaZXJvc0luQnl0ZSh4KSB7XG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxuICAgIGxldCB6ZXJvcyA9IDA7XG4gICAgaWYgKHggPj4gNCA9PT0gMCkge1xuICAgICAgICAvLyBUZXN0IGlmIHRoZSBmaXJzdCBmb3VyIGJpdHMgYXJlIHplcm8uXG4gICAgICAgIHplcm9zICs9IDQ7XG4gICAgICAgIHggPSB4IDw8IDQ7XG4gICAgfVxuICAgIGlmICh4ID4+IDYgPT09IDApIHtcbiAgICAgICAgLy8gVGVzdCBpZiB0aGUgZmlyc3QgdHdvIChvciBuZXh0IHR3bykgYml0cyBhcmUgemVyby5cbiAgICAgICAgemVyb3MgKz0gMjtcbiAgICAgICAgeCA9IHggPDwgMjtcbiAgICB9XG4gICAgaWYgKHggPj4gNyA9PT0gMCkge1xuICAgICAgICAvLyBUZXN0IGlmIHRoZSByZW1haW5pbmcgYml0IGlzIHplcm8uXG4gICAgICAgIHplcm9zICs9IDE7XG4gICAgfVxuICAgIHJldHVybiB6ZXJvcztcbn1cbi8qKiBDb3VudHMgdGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIGluIHRoZSBnaXZlbiBieXRlIGFycmF5LiAqL1xuZnVuY3Rpb24gbnVtYmVyT2ZMZWFkaW5nWmVyb3MoYnl0ZXMpIHtcbiAgICBsZXQgbGVhZGluZ1plcm9zID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgICBjb25zdCB6ZXJvcyA9IG51bWJlck9mTGVhZGluZ1plcm9zSW5CeXRlKGJ5dGVzW2ldICYgMHhmZik7XG4gICAgICAgIGxlYWRpbmdaZXJvcyArPSB6ZXJvcztcbiAgICAgICAgaWYgKHplcm9zICE9PSA4KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVhZGluZ1plcm9zO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQgdG8gc3RvcmUgXCJ2YWx1ZVwiLiBMZWFkaW5nIHplcm8gYnl0ZXNcbiAqIGFyZSBza2lwcGVkLlxuICovXG5mdW5jdGlvbiB1bnNpZ25lZE51bUxlbmd0aCh2YWx1ZSkge1xuICAgIC8vIFRoaXMgaXMganVzdCB0aGUgbnVtYmVyIG9mIGJ5dGVzIGZvciB0aGUgdW5zaWduZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlci5cbiAgICBjb25zdCBudW1CaXRzID0gTE9OR19TSVpFIC0gbnVtYmVyT2ZMZWFkaW5nWmVyb3ModmFsdWUpO1xuICAgIHJldHVybiBNYXRoLmNlaWwobnVtQml0cyAvIEJZVEVfU0laRSk7XG59XG4vKipcbiAqIE9yZGVyZWRDb2RlV3JpdGVyIGlzIGEgbWluaW1hbC1hbGxvY2F0aW9uIGltcGxlbWVudGF0aW9uIG9mIHRoZSB3cml0aW5nXG4gKiBiZWhhdmlvciBkZWZpbmVkIGJ5IHRoZSBiYWNrZW5kLlxuICpcbiAqIFRoZSBjb2RlIGlzIHBvcnRlZCBmcm9tIGl0cyBKYXZhIGNvdW50ZXJwYXJ0LlxuICovXG5jbGFzcyBPcmRlcmVkQ29kZVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoREVGQVVMVF9CVUZGRVJfU0laRSk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAwO1xuICAgIH1cbiAgICB3cml0ZUJ5dGVzQXNjZW5kaW5nKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGl0ID0gdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICBsZXQgYnl0ZSA9IGl0Lm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFieXRlLmRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKGJ5dGUudmFsdWUpO1xuICAgICAgICAgICAgYnl0ZSA9IGl0Lm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlU2VwYXJhdG9yQXNjZW5kaW5nKCk7XG4gICAgfVxuICAgIHdyaXRlQnl0ZXNEZXNjZW5kaW5nKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGl0ID0gdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICBsZXQgYnl0ZSA9IGl0Lm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFieXRlLmRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZyhieXRlLnZhbHVlKTtcbiAgICAgICAgICAgIGJ5dGUgPSBpdC5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZVNlcGFyYXRvckRlc2NlbmRpbmcoKTtcbiAgICB9XG4gICAgLyoqIFdyaXRlcyB1dGY4IGJ5dGVzIGludG8gdGhpcyBieXRlIHNlcXVlbmNlLCBhc2NlbmRpbmcuICovXG4gICAgd3JpdGVVdGY4QXNjZW5kaW5nKHNlcXVlbmNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBzZXF1ZW5jZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhckNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoY2hhckNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhckNvZGUgPCAweDgwMCkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKCgweDBmIDw8IDYpIHwgKGNoYXJDb2RlID4+PiA2KSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY2hhckNvZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPCBNSU5fU1VSUk9HQVRFIHx8IE1BWF9TVVJST0dBVEUgPCBjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoKDB4MGYgPDwgNSkgfCAoY2hhckNvZGUgPj4+IDEyKSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgKGNoYXJDb2RlID4+PiA2KSkpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIGNoYXJDb2RlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBjLmNvZGVQb2ludEF0KDApO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKCgweDBmIDw8IDQpIHwgKGNvZGVQb2ludCA+Pj4gMTgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY29kZVBvaW50ID4+PiAxMikpKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY29kZVBvaW50ID4+PiA2KSkpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIGNvZGVQb2ludCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVTZXBhcmF0b3JBc2NlbmRpbmcoKTtcbiAgICB9XG4gICAgLyoqIFdyaXRlcyB1dGY4IGJ5dGVzIGludG8gdGhpcyBieXRlIHNlcXVlbmNlLCBkZXNjZW5kaW5nICovXG4gICAgd3JpdGVVdGY4RGVzY2VuZGluZyhzZXF1ZW5jZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2Ygc2VxdWVuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlID0gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZyhjaGFyQ29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyQ29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKCgweDBmIDw8IDYpIHwgKGNoYXJDb2RlID4+PiA2KSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIGNoYXJDb2RlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjIDwgTUlOX1NVUlJPR0FURSB8fCBNQVhfU1VSUk9HQVRFIDwgYykge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygoMHgwZiA8PCA1KSB8IChjaGFyQ29kZSA+Pj4gMTIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgKGNoYXJDb2RlID4+PiA2KSkpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygweDgwIHwgKDB4M2YgJiBjaGFyQ29kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZVBvaW50ID0gYy5jb2RlUG9pbnRBdCgwKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoKDB4MGYgPDwgNCkgfCAoY29kZVBvaW50ID4+PiAxOCkpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY29kZVBvaW50ID4+PiAxMikpKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgKGNvZGVQb2ludCA+Pj4gNikpKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY29kZVBvaW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZVNlcGFyYXRvckRlc2NlbmRpbmcoKTtcbiAgICB9XG4gICAgd3JpdGVOdW1iZXJBc2NlbmRpbmcodmFsKSB7XG4gICAgICAgIC8vIFZhbHVlcyBhcmUgZW5jb2RlZCB3aXRoIGEgc2luZ2xlIGJ5dGUgbGVuZ3RoIHByZWZpeCwgZm9sbG93ZWQgYnkgdGhlXG4gICAgICAgIC8vIGFjdHVhbCB2YWx1ZSBpbiBiaWctZW5kaWFuIGZvcm1hdCB3aXRoIGxlYWRpbmcgMCBieXRlcyBkcm9wcGVkLlxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudG9PcmRlcmVkQml0cyh2YWwpO1xuICAgICAgICBjb25zdCBsZW4gPSB1bnNpZ25lZE51bUxlbmd0aCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDEgKyBsZW4pO1xuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uKytdID0gbGVuICYgMHhmZjsgLy8gV3JpdGUgdGhlIGxlbmd0aFxuICAgICAgICBmb3IgKGxldCBpID0gdmFsdWUubGVuZ3RoIC0gbGVuOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSB2YWx1ZVtpXSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVOdW1iZXJEZXNjZW5kaW5nKHZhbCkge1xuICAgICAgICAvLyBWYWx1ZXMgYXJlIGVuY29kZWQgd2l0aCBhIHNpbmdsZSBieXRlIGxlbmd0aCBwcmVmaXgsIGZvbGxvd2VkIGJ5IHRoZVxuICAgICAgICAvLyBpbnZlcnRlZCB2YWx1ZSBpbiBiaWctZW5kaWFuIGZvcm1hdCB3aXRoIGxlYWRpbmcgMCBieXRlcyBkcm9wcGVkLlxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudG9PcmRlcmVkQml0cyh2YWwpO1xuICAgICAgICBjb25zdCBsZW4gPSB1bnNpZ25lZE51bUxlbmd0aCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDEgKyBsZW4pO1xuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uKytdID0gfihsZW4gJiAweGZmKTsgLy8gV3JpdGUgdGhlIGxlbmd0aFxuICAgICAgICBmb3IgKGxldCBpID0gdmFsdWUubGVuZ3RoIC0gbGVuOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSB+KHZhbHVlW2ldICYgMHhmZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIHRoZSBcImluZmluaXR5XCIgYnl0ZSBzZXF1ZW5jZSB0aGF0IHNvcnRzIGFmdGVyIGFsbCBvdGhlciBieXRlXG4gICAgICogc2VxdWVuY2VzIHdyaXR0ZW4gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICAgICAqL1xuICAgIHdyaXRlSW5maW5pdHlBc2NlbmRpbmcoKSB7XG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhFU0NBUEUyKTtcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKElORklOSVRZKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIHRoZSBcImluZmluaXR5XCIgYnl0ZSBzZXF1ZW5jZSB0aGF0IHNvcnRzIGJlZm9yZSBhbGwgb3RoZXIgYnl0ZVxuICAgICAqIHNlcXVlbmNlcyB3cml0dGVuIGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICovXG4gICAgd3JpdGVJbmZpbml0eURlc2NlbmRpbmcoKSB7XG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoRVNDQVBFMik7XG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoSU5GSU5JVFkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGJ1ZmZlciBzdWNoIHRoYXQgaXQgaXMgdGhlIHNhbWUgYXMgd2hlbiBpdCB3YXMgbmV3bHlcbiAgICAgKiBjb25zdHJ1Y3RlZC5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgfVxuICAgIHNlZWQoZW5jb2RlZEJ5dGVzKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKGVuY29kZWRCeXRlcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zZXQoZW5jb2RlZEJ5dGVzLCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBlbmNvZGVkQnl0ZXMubGVuZ3RoO1xuICAgIH1cbiAgICAvKiogTWFrZXMgYSBjb3B5IG9mIHRoZSBlbmNvZGVkIGJ5dGVzIGluIHRoaXMgYnVmZmVyLiAgKi9cbiAgICBlbmNvZGVkQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zbGljZSgwLCB0aGlzLnBvc2l0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBgdmFsYCBpbnRvIGFuIGVuY29kaW5nIHNvIHRoYXQgdGhlIG9yZGVyIG1hdGNoZXMgdGhlIElFRUUgNzU0XG4gICAgICogZmxvYXRpbmctcG9pbnQgY29tcGFyaXNvbiByZXN1bHRzIHdpdGggdGhlIGZvbGxvd2luZyBleGNlcHRpb25zOlxuICAgICAqICAgLTAuMCA8IDAuMFxuICAgICAqICAgYWxsIG5vbi1OYU4gPCBOYU5cbiAgICAgKiAgIE5hTiA9IE5hTlxuICAgICAqL1xuICAgIHRvT3JkZXJlZEJpdHModmFsKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZG91YmxlVG9Mb25nQml0cyh2YWwpO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgZmlyc3QgYml0IGlzIHNldC4gV2UgdXNlIGEgYml0IG1hc2sgc2luY2UgdmFsdWVbMF0gaXNcbiAgICAgICAgLy8gZW5jb2RlZCBhcyBhIG51bWJlciBmcm9tIDAgdG8gMjU1LlxuICAgICAgICBjb25zdCBpc05lZ2F0aXZlID0gKHZhbHVlWzBdICYgMHg4MCkgIT09IDA7XG4gICAgICAgIC8vIFJldmVydCB0aGUgdHdvIGNvbXBsZW1lbnQgdG8gZ2V0IG5hdHVyYWwgb3JkZXJpbmdcbiAgICAgICAgdmFsdWVbMF0gXj0gaXNOZWdhdGl2ZSA/IDB4ZmYgOiAweDgwO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YWx1ZVtpXSBePSBpc05lZ2F0aXZlID8gMHhmZiA6IDB4MDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKiogV3JpdGVzIGEgc2luZ2xlIGJ5dGUgYXNjZW5kaW5nIHRvIHRoZSBidWZmZXIuICovXG4gICAgd3JpdGVCeXRlQXNjZW5kaW5nKGIpIHtcbiAgICAgICAgY29uc3QgbWFza2VkID0gYiAmIDB4ZmY7XG4gICAgICAgIGlmIChtYXNrZWQgPT09IEVTQ0FQRTEpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhFU0NBUEUxKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhOVUxMX0JZVEUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hc2tlZCA9PT0gRVNDQVBFMikge1xuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKEVTQ0FQRTIpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKEZGX0JZVEUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKG1hc2tlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFdyaXRlcyBhIHNpbmdsZSBieXRlIGRlc2NlbmRpbmcgdG8gdGhlIGJ1ZmZlci4gICovXG4gICAgd3JpdGVCeXRlRGVzY2VuZGluZyhiKSB7XG4gICAgICAgIGNvbnN0IG1hc2tlZCA9IGIgJiAweGZmO1xuICAgICAgICBpZiAobWFza2VkID09PSBFU0NBUEUxKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVEZXNjZW5kaW5nKEVTQ0FQRTEpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhOVUxMX0JZVEUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hc2tlZCA9PT0gRVNDQVBFMikge1xuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhFU0NBUEUyKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoRkZfQllURSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVEZXNjZW5kaW5nKGIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdyaXRlU2VwYXJhdG9yQXNjZW5kaW5nKCkge1xuICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoRVNDQVBFMSk7XG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhTRVBBUkFUT1IpO1xuICAgIH1cbiAgICB3cml0ZVNlcGFyYXRvckRlc2NlbmRpbmcoKSB7XG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoRVNDQVBFMSk7XG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoU0VQQVJBVE9SKTtcbiAgICB9XG4gICAgd3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhiKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDEpO1xuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uKytdID0gYjtcbiAgICB9XG4gICAgd3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoYikge1xuICAgICAgICB0aGlzLmVuc3VyZUF2YWlsYWJsZSgxKTtcbiAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IH5iO1xuICAgIH1cbiAgICBlbnN1cmVBdmFpbGFibGUoYnl0ZXMpIHtcbiAgICAgICAgY29uc3QgbWluQ2FwYWNpdHkgPSBieXRlcyArIHRoaXMucG9zaXRpb247XG4gICAgICAgIGlmIChtaW5DYXBhY2l0eSA8PSB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgZG91YmxpbmcuXG4gICAgICAgIGxldCBuZXdMZW5ndGggPSB0aGlzLmJ1ZmZlci5sZW5ndGggKiAyO1xuICAgICAgICAvLyBTdGlsbCBub3QgYmlnIGVub3VnaD8gSnVzdCBhbGxvY2F0ZSB0aGUgcmlnaHQgc2l6ZS5cbiAgICAgICAgaWYgKG5ld0xlbmd0aCA8IG1pbkNhcGFjaXR5KSB7XG4gICAgICAgICAgICBuZXdMZW5ndGggPSBtaW5DYXBhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBidWZmZXIuXG4gICAgICAgIGNvbnN0IG5ld0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gICAgICAgIG5ld0J1ZmZlci5zZXQodGhpcy5idWZmZXIpOyAvLyBjb3B5IG9sZCBkYXRhXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3QnVmZmVyO1xuICAgIH1cbn1cblxuY2xhc3MgQXNjZW5kaW5nSW5kZXhCeXRlRW5jb2RlciB7XG4gICAgY29uc3RydWN0b3Iob3JkZXJlZENvZGUpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZSA9IG9yZGVyZWRDb2RlO1xuICAgIH1cbiAgICB3cml0ZUJ5dGVzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUud3JpdGVCeXRlc0FzY2VuZGluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHdyaXRlU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUud3JpdGVVdGY4QXNjZW5kaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZU51bWJlckFzY2VuZGluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHdyaXRlSW5maW5pdHkoKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUud3JpdGVJbmZpbml0eUFzY2VuZGluZygpO1xuICAgIH1cbn1cbmNsYXNzIERlc2NlbmRpbmdJbmRleEJ5dGVFbmNvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcmRlcmVkQ29kZSkge1xuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlID0gb3JkZXJlZENvZGU7XG4gICAgfVxuICAgIHdyaXRlQnl0ZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZUJ5dGVzRGVzY2VuZGluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHdyaXRlU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUud3JpdGVVdGY4RGVzY2VuZGluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHdyaXRlTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUud3JpdGVOdW1iZXJEZXNjZW5kaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVJbmZpbml0eSgpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZUluZmluaXR5RGVzY2VuZGluZygpO1xuICAgIH1cbn1cbi8qKlxuICogSW1wbGVtZW50cyBgRGlyZWN0aW9uYWxJbmRleEJ5dGVFbmNvZGVyYCB1c2luZyBgT3JkZXJlZENvZGVXcml0ZXJgIGZvciB0aGVcbiAqIGFjdHVhbCBlbmNvZGluZy5cbiAqL1xuY2xhc3MgSW5kZXhCeXRlRW5jb2RlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUgPSBuZXcgT3JkZXJlZENvZGVXcml0ZXIoKTtcbiAgICAgICAgdGhpcy5hc2NlbmRpbmcgPSBuZXcgQXNjZW5kaW5nSW5kZXhCeXRlRW5jb2Rlcih0aGlzLm9yZGVyZWRDb2RlKTtcbiAgICAgICAgdGhpcy5kZXNjZW5kaW5nID0gbmV3IERlc2NlbmRpbmdJbmRleEJ5dGVFbmNvZGVyKHRoaXMub3JkZXJlZENvZGUpO1xuICAgIH1cbiAgICBzZWVkKGVuY29kZWRCeXRlcykge1xuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLnNlZWQoZW5jb2RlZEJ5dGVzKTtcbiAgICB9XG4gICAgZm9yS2luZChraW5kKSB7XG4gICAgICAgIHJldHVybiBraW5kID09PSAwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi8gPyB0aGlzLmFzY2VuZGluZyA6IHRoaXMuZGVzY2VuZGluZztcbiAgICB9XG4gICAgZW5jb2RlZEJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmRlcmVkQ29kZS5lbmNvZGVkQnl0ZXMoKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUucmVzZXQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogUmVwcmVzZW50cyBhbiBpbmRleCBlbnRyeSBzYXZlZCBieSB0aGUgU0RLIGluIHBlcnNpc3RlZCBzdG9yYWdlLiAqL1xuY2xhc3MgSW5kZXhFbnRyeSB7XG4gICAgY29uc3RydWN0b3IoaW5kZXhJZCwgZG9jdW1lbnRLZXksIGFycmF5VmFsdWUsIGRpcmVjdGlvbmFsVmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbmRleElkID0gaW5kZXhJZDtcbiAgICAgICAgdGhpcy5kb2N1bWVudEtleSA9IGRvY3VtZW50S2V5O1xuICAgICAgICB0aGlzLmFycmF5VmFsdWUgPSBhcnJheVZhbHVlO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbmFsVmFsdWUgPSBkaXJlY3Rpb25hbFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIEluZGV4RW50cnkgZW50cnkgdGhhdCBzb3J0cyBpbW1lZGlhdGVseSBhZnRlciB0aGUgY3VycmVudFxuICAgICAqIGRpcmVjdGlvbmFsIHZhbHVlLlxuICAgICAqL1xuICAgIHN1Y2Nlc3NvcigpIHtcbiAgICAgICAgY29uc3QgY3VycmVudExlbmd0aCA9IHRoaXMuZGlyZWN0aW9uYWxWYWx1ZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IGN1cnJlbnRMZW5ndGggPT09IDAgfHwgdGhpcy5kaXJlY3Rpb25hbFZhbHVlW2N1cnJlbnRMZW5ndGggLSAxXSA9PT0gMjU1XG4gICAgICAgICAgICA/IGN1cnJlbnRMZW5ndGggKyAxXG4gICAgICAgICAgICA6IGN1cnJlbnRMZW5ndGg7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NvciA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gICAgICAgIHN1Y2Nlc3Nvci5zZXQodGhpcy5kaXJlY3Rpb25hbFZhbHVlLCAwKTtcbiAgICAgICAgaWYgKG5ld0xlbmd0aCAhPT0gY3VycmVudExlbmd0aCkge1xuICAgICAgICAgICAgc3VjY2Vzc29yLnNldChbMF0sIHRoaXMuZGlyZWN0aW9uYWxWYWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKytzdWNjZXNzb3Jbc3VjY2Vzc29yLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhFbnRyeSh0aGlzLmluZGV4SWQsIHRoaXMuZG9jdW1lbnRLZXksIHRoaXMuYXJyYXlWYWx1ZSwgc3VjY2Vzc29yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbmRleEVudHJ5Q29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xuICAgIGxldCBjbXAgPSBsZWZ0LmluZGV4SWQgLSByaWdodC5pbmRleElkO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG4gICAgY21wID0gY29tcGFyZUJ5dGVBcnJheXMobGVmdC5hcnJheVZhbHVlLCByaWdodC5hcnJheVZhbHVlKTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIGNtcCA9IGNvbXBhcmVCeXRlQXJyYXlzKGxlZnQuZGlyZWN0aW9uYWxWYWx1ZSwgcmlnaHQuZGlyZWN0aW9uYWxWYWx1ZSk7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICByZXR1cm4gRG9jdW1lbnRLZXkuY29tcGFyYXRvcihsZWZ0LmRvY3VtZW50S2V5LCByaWdodC5kb2N1bWVudEtleSk7XG59XG5mdW5jdGlvbiBjb21wYXJlQnl0ZUFycmF5cyhsZWZ0LCByaWdodCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5sZW5ndGggJiYgaSA8IHJpZ2h0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNvbXBhcmUgPSBsZWZ0W2ldIC0gcmlnaHRbaV07XG4gICAgICAgIGlmIChjb21wYXJlICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVmdC5sZW5ndGggLSByaWdodC5sZW5ndGg7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgbGlnaHQgcXVlcnkgcGxhbm5lciBmb3IgRmlyZXN0b3JlLlxuICpcbiAqIFRoaXMgY2xhc3MgbWF0Y2hlcyBhIGBGaWVsZEluZGV4YCBhZ2FpbnN0IGEgRmlyZXN0b3JlIFF1ZXJ5IGBUYXJnZXRgLiBJdFxuICogZGV0ZXJtaW5lcyB3aGV0aGVyIGEgZ2l2ZW4gaW5kZXggY2FuIGJlIHVzZWQgdG8gc2VydmUgdGhlIHNwZWNpZmllZCB0YXJnZXQuXG4gKlxuICogVGhlIGZvbGxvd2luZyB0YWJsZSBzaG93Y2FzZXMgc29tZSBwb3NzaWJsZSBpbmRleCBjb25maWd1cmF0aW9uczpcbiAqXG4gKiBRdWVyeSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBJbmRleFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIHdoZXJlKCdhJywgJz09JywgJ2EnKS53aGVyZSgnYicsICc9PScsICdiJykgICAgICAgICB8IGEgQVNDLCBiIERFU0NcbiAqIHdoZXJlKCdhJywgJz09JywgJ2EnKS53aGVyZSgnYicsICc9PScsICdiJykgICAgICAgICB8IGEgQVNDXG4gKiB3aGVyZSgnYScsICc9PScsICdhJykud2hlcmUoJ2InLCAnPT0nLCAnYicpICAgICAgICAgfCBiIERFU0NcbiAqIHdoZXJlKCdhJywgJz49JywgJ2EnKS5vcmRlckJ5KCdhJykgICAgICAgICAgICAgICAgICB8IGEgQVNDXG4gKiB3aGVyZSgnYScsICc+PScsICdhJykub3JkZXJCeSgnYScsICdkZXNjJykgICAgICAgICAgfCBhIERFU0NcbiAqIHdoZXJlKCdhJywgJz49JywgJ2EnKS5vcmRlckJ5KCdhJykub3JkZXJCeSgnYicpICAgICB8IGEgQVNDLCBiIEFTQ1xuICogd2hlcmUoJ2EnLCAnPj0nLCAnYScpLm9yZGVyQnkoJ2EnKS5vcmRlckJ5KCdiJykgICAgIHwgYSBBU0NcbiAqIHdoZXJlKCdhJywgJ2FycmF5LWNvbnRhaW5zJywgJ2EnKS5vcmRlckJ5KCdiJykgICAgICB8IGEgQ09OVEFJTlMsIGIgQVNDRU5ESU5HXG4gKiB3aGVyZSgnYScsICdhcnJheS1jb250YWlucycsICdhJykub3JkZXJCeSgnYicpICAgICAgfCBhIENPTlRBSU5TXG4gKi9cbmNsYXNzIFRhcmdldEluZGV4TWF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgICAgIC8vIFRoZSBpbmVxdWFsaXR5IGZpbHRlcnMgb2YgdGhlIHRhcmdldCAoaWYgaXQgZXhpc3RzKS5cbiAgICAgICAgLy8gTm90ZTogVGhlIHNvcnQgb24gRmllbGRGaWx0ZXJzIGlzIG5vdCByZXF1aXJlZC4gVXNpbmcgU29ydGVkU2V0IGhlcmUganVzdCB0byB1dGlsaXplIHRoZSBjdXN0b21cbiAgICAgICAgLy8gY29tcGFyYXRvci5cbiAgICAgICAgdGhpcy5pbmVxdWFsaXR5RmlsdGVycyA9IG5ldyBTb3J0ZWRTZXQoKGxocywgcmhzKSA9PiBGaWVsZFBhdGgkMS5jb21wYXJhdG9yKGxocy5maWVsZCwgcmhzLmZpZWxkKSk7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbklkID1cbiAgICAgICAgICAgIHRhcmdldC5jb2xsZWN0aW9uR3JvdXAgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cFxuICAgICAgICAgICAgICAgIDogdGFyZ2V0LnBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICAgICAgdGhpcy5vcmRlckJ5cyA9IHRhcmdldC5vcmRlckJ5O1xuICAgICAgICB0aGlzLmVxdWFsaXR5RmlsdGVycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiB0YXJnZXQuZmlsdGVycykge1xuICAgICAgICAgICAgY29uc3QgZmllbGRGaWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgICAgICBpZiAoZmllbGRGaWx0ZXIuaXNJbmVxdWFsaXR5KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZXF1YWxpdHlGaWx0ZXJzID0gdGhpcy5pbmVxdWFsaXR5RmlsdGVycy5hZGQoZmllbGRGaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcXVhbGl0eUZpbHRlcnMucHVzaChmaWVsZEZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhhc011bHRpcGxlSW5lcXVhbGl0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5lcXVhbGl0eUZpbHRlcnMuc2l6ZSA+IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgaW5kZXggY2FuIGJlIHVzZWQgdG8gc2VydmUgdGhlIFRhcmdldEluZGV4TWF0Y2hlcidzXG4gICAgICogdGFyZ2V0LlxuICAgICAqXG4gICAgICogQW4gaW5kZXggaXMgY29uc2lkZXJlZCBjYXBhYmxlIG9mIHNlcnZpbmcgdGhlIHRhcmdldCB3aGVuOlxuICAgICAqIC0gVGhlIHRhcmdldCB1c2VzIGFsbCBpbmRleCBzZWdtZW50cyBmb3IgaXRzIGZpbHRlcnMgYW5kIG9yZGVyQnkgY2xhdXNlcy5cbiAgICAgKiAgIFRoZSB0YXJnZXQgY2FuIGhhdmUgYWRkaXRpb25hbCBmaWx0ZXIgYW5kIG9yZGVyQnkgY2xhdXNlcywgYnV0IG5vdFxuICAgICAqICAgZmV3ZXIuXG4gICAgICogLSBJZiBhbiBBcnJheUNvbnRhaW5zL0FycmF5Q29udGFpbnNBbnlmaWx0ZXIgaXMgdXNlZCwgdGhlIGluZGV4IG11c3QgYWxzb1xuICAgICAqICAgaGF2ZSBhIGNvcnJlc3BvbmRpbmcgYENPTlRBSU5TYCBzZWdtZW50LlxuICAgICAqIC0gQWxsIGRpcmVjdGlvbmFsIGluZGV4IHNlZ21lbnRzIGNhbiBiZSBtYXBwZWQgdG8gdGhlIHRhcmdldCBhcyBhIHNlcmllcyBvZlxuICAgICAqICAgZXF1YWxpdHkgZmlsdGVycywgYSBzaW5nbGUgaW5lcXVhbGl0eSBmaWx0ZXIgYW5kIGEgc2VyaWVzIG9mIG9yZGVyQnlcbiAgICAgKiAgIGNsYXVzZXMuXG4gICAgICogLSBUaGUgc2VnbWVudHMgdGhhdCByZXByZXNlbnQgdGhlIGVxdWFsaXR5IGZpbHRlcnMgbWF5IGFwcGVhciBvdXQgb2Ygb3JkZXIuXG4gICAgICogLSBUaGUgb3B0aW9uYWwgc2VnbWVudCBmb3IgdGhlIGluZXF1YWxpdHkgZmlsdGVyIG11c3QgYXBwZWFyIGFmdGVyIGFsbFxuICAgICAqICAgZXF1YWxpdHkgc2VnbWVudHMuXG4gICAgICogLSBUaGUgc2VnbWVudHMgdGhhdCByZXByZXNlbnQgdGhhdCBvcmRlckJ5IGNsYXVzZSBvZiB0aGUgdGFyZ2V0IG11c3QgYXBwZWFyXG4gICAgICogICBpbiBvcmRlciBhZnRlciBhbGwgZXF1YWxpdHkgYW5kIGluZXF1YWxpdHkgc2VnbWVudHMuIFNpbmdsZSBvcmRlckJ5XG4gICAgICogICBjbGF1c2VzIGNhbm5vdCBiZSBza2lwcGVkLCBidXQgYSBjb250aW51b3VzIG9yZGVyQnkgc3VmZml4IG1heSBiZVxuICAgICAqICAgb21pdHRlZC5cbiAgICAgKi9cbiAgICBzZXJ2ZWRCeUluZGV4KGluZGV4KSB7XG4gICAgICAgIGhhcmRBc3NlcnQoaW5kZXguY29sbGVjdGlvbkdyb3VwID09PSB0aGlzLmNvbGxlY3Rpb25JZCk7XG4gICAgICAgIGlmICh0aGlzLmhhc011bHRpcGxlSW5lcXVhbGl0eSkge1xuICAgICAgICAgICAgLy8gT25seSBzaW5nbGUgaW5lcXVhbGl0eSBpcyBzdXBwb3J0ZWQgZm9yIG5vdy5cbiAgICAgICAgICAgIC8vIFRPRE8oQWRkIHN1cHBvcnQgZm9yIG11bHRpcGxlIGluZXF1YWxpdHkgcXVlcnkpOiBiLzI5ODQ0MTA0M1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGFycmF5IGVsZW1lbnQsIGZpbmQgYSBtYXRjaGluZyBmaWx0ZXIuXG4gICAgICAgIGNvbnN0IGFycmF5U2VnbWVudCA9IGZpZWxkSW5kZXhHZXRBcnJheVNlZ21lbnQoaW5kZXgpO1xuICAgICAgICBpZiAoYXJyYXlTZWdtZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICF0aGlzLmhhc01hdGNoaW5nRXF1YWxpdHlGaWx0ZXIoYXJyYXlTZWdtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoaW5kZXgpO1xuICAgICAgICBsZXQgZXF1YWxpdHlTZWdtZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IHNlZ21lbnRJbmRleCA9IDA7XG4gICAgICAgIGxldCBvcmRlckJ5c0luZGV4ID0gMDtcbiAgICAgICAgLy8gUHJvY2VzcyBhbGwgZXF1YWxpdGllcyBmaXJzdC4gRXF1YWxpdGllcyBjYW4gYXBwZWFyIG91dCBvZiBvcmRlci5cbiAgICAgICAgZm9yICg7IHNlZ21lbnRJbmRleCA8IHNlZ21lbnRzLmxlbmd0aDsgKytzZWdtZW50SW5kZXgpIHtcbiAgICAgICAgICAgIC8vIFdlIGF0dGVtcHQgdG8gZ3JlZWRpbHkgbWF0Y2ggYWxsIHNlZ21lbnRzIHRvIGVxdWFsaXR5IGZpbHRlcnMuIElmIGFcbiAgICAgICAgICAgIC8vIGZpbHRlciBtYXRjaGVzIGFuIGluZGV4IHNlZ21lbnQsIHdlIGNhbiBtYXJrIHRoZSBzZWdtZW50IGFzIHVzZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNNYXRjaGluZ0VxdWFsaXR5RmlsdGVyKHNlZ21lbnRzW3NlZ21lbnRJbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgZXF1YWxpdHlTZWdtZW50cyA9IGVxdWFsaXR5U2VnbWVudHMuYWRkKHNlZ21lbnRzW3NlZ21lbnRJbmRleF0uZmllbGRQYXRoLmNhbm9uaWNhbFN0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbm5vdCBmaW5kIGEgbWF0Y2hpbmcgZmlsdGVyLCB3ZSBuZWVkIHRvIHZlcmlmeSB3aGV0aGVyIHRoZVxuICAgICAgICAgICAgICAgIC8vIHJlbWFpbmluZyBzZWdtZW50cyBtYXAgdG8gdGhlIHRhcmdldCdzIGluZXF1YWxpdHkgYW5kIGl0cyBvcmRlckJ5XG4gICAgICAgICAgICAgICAgLy8gY2xhdXNlcy5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgcHJvY2Vzc2VkIGFsbCBzZWdtZW50cywgYWxsIHNlZ21lbnRzIGFyZSB1c2VkIHRvIHNlcnZlXG4gICAgICAgIC8vIHRoZSBlcXVhbGl0eSBmaWx0ZXJzIGFuZCB3ZSBkbyBub3QgbmVlZCB0byBtYXAgYW55IHNlZ21lbnRzIHRvIHRoZVxuICAgICAgICAvLyB0YXJnZXQncyBpbmVxdWFsaXR5IGFuZCBvcmRlckJ5IGNsYXVzZXMuXG4gICAgICAgIGlmIChzZWdtZW50SW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5lcXVhbGl0eUZpbHRlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYSBzaW5nbGUgaW5lcXVhbGl0eSBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLiBHZXQgdGhlIG9ubHkgZW50cnkgaW4gdGhlIHNldC5cbiAgICAgICAgICAgIGNvbnN0IGluZXF1YWxpdHlGaWx0ZXIgPSB0aGlzLmluZXF1YWxpdHlGaWx0ZXJzLmdldEl0ZXJhdG9yKCkuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaW5lcXVhbGl0eSBmaWx0ZXIgYW5kIHRoZSBmaWVsZCB3YXMgbm90IGluIG9uZSBvZiB0aGVcbiAgICAgICAgICAgIC8vIGVxdWFsaXR5IGZpbHRlcnMgYWJvdmUsIHRoZSBuZXh0IHNlZ21lbnQgbXVzdCBtYXRjaCBib3RoIHRoZSBmaWx0ZXJcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgZmlyc3Qgb3JkZXJCeSBjbGF1c2UuXG4gICAgICAgICAgICBpZiAoIWVxdWFsaXR5U2VnbWVudHMuaGFzKGluZXF1YWxpdHlGaWx0ZXIuZmllbGQuY2Fub25pY2FsU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW3NlZ21lbnRJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoZXNGaWx0ZXIoaW5lcXVhbGl0eUZpbHRlciwgc2VnbWVudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMubWF0Y2hlc09yZGVyQnkodGhpcy5vcmRlckJ5c1tvcmRlckJ5c0luZGV4KytdLCBzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytzZWdtZW50SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsIHJlbWFpbmluZyBzZWdtZW50cyBuZWVkIHRvIHJlcHJlc2VudCB0aGUgcHJlZml4IG9mIHRoZSB0YXJnZXQnc1xuICAgICAgICAvLyBvcmRlckJ5LlxuICAgICAgICBmb3IgKDsgc2VnbWVudEluZGV4IDwgc2VnbWVudHMubGVuZ3RoOyArK3NlZ21lbnRJbmRleCkge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW3NlZ21lbnRJbmRleF07XG4gICAgICAgICAgICBpZiAob3JkZXJCeXNJbmRleCA+PSB0aGlzLm9yZGVyQnlzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICF0aGlzLm1hdGNoZXNPcmRlckJ5KHRoaXMub3JkZXJCeXNbb3JkZXJCeXNJbmRleCsrXSwgc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdWxsIG1hdGNoZWQgZmllbGQgaW5kZXggZm9yIHRoaXMgdGFyZ2V0LiBDdXJyZW50bHkgbXVsdGlwbGVcbiAgICAgKiBpbmVxdWFsaXR5IHF1ZXJ5IGlzIG5vdCBzdXBwb3J0ZWQgc28gZnVuY3Rpb24gcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIGJ1aWxkVGFyZ2V0SW5kZXgoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc011bHRpcGxlSW5lcXVhbGl0eSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugd2FudCB0byBtYWtlIHN1cmUgb25seSBvbmUgc2VnbWVudCBjcmVhdGVkIGZvciBvbmUgZmllbGQuIEZvciBleGFtcGxlLFxuICAgICAgICAvLyBpbiBjYXNlIGxpa2UgYSA9PSAzIGFuZCBhID4gMiwgSW5kZXgge2EgQVNDRU5ESU5HfSB3aWxsIG9ubHkgYmUgY3JlYXRlZFxuICAgICAgICAvLyBvbmNlLlxuICAgICAgICBsZXQgdW5pcXVlRmllbGRzID0gbmV3IFNvcnRlZFNldChGaWVsZFBhdGgkMS5jb21wYXJhdG9yKTtcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgdGhpcy5lcXVhbGl0eUZpbHRlcnMpIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIuZmllbGQuaXNLZXlGaWVsZCgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc0FycmF5T3BlcmF0b3IgPSBmaWx0ZXIub3AgPT09IFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLyB8fFxuICAgICAgICAgICAgICAgIGZpbHRlci5vcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi87XG4gICAgICAgICAgICBpZiAoaXNBcnJheU9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChuZXcgSW5kZXhTZWdtZW50KGZpbHRlci5maWVsZCwgMiAvKiBJbmRleEtpbmQuQ09OVEFJTlMgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh1bmlxdWVGaWVsZHMuaGFzKGZpbHRlci5maWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuaXF1ZUZpZWxkcyA9IHVuaXF1ZUZpZWxkcy5hZGQoZmlsdGVyLmZpZWxkKTtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBJbmRleFNlZ21lbnQoZmlsdGVyLmZpZWxkLCAwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBXZSBkbyBub3QgZXhwbGljaXRseSBjaGVjayBgdGhpcy5pbmVxdWFsaXR5RmlsdGVyYCBidXQgcmF0aGVyIHJlbHlcbiAgICAgICAgLy8gb24gdGhlIHRhcmdldCBkZWZpbmluZyBhbiBhcHByb3ByaWF0ZSBcIm9yZGVyIGJ5XCIgdG8gZW5zdXJlIHRoYXQgdGhlXG4gICAgICAgIC8vIHJlcXVpcmVkIGluZGV4IHNlZ21lbnQgaXMgYWRkZWQuIFRoZSBxdWVyeSBlbmdpbmUgd291bGQgcmVqZWN0IGEgcXVlcnlcbiAgICAgICAgLy8gd2l0aCBhbiBpbmVxdWFsaXR5IGZpbHRlciB0aGF0IGxhY2tzIHRoZSByZXF1aXJlZCBvcmRlci1ieSBjbGF1c2UuXG4gICAgICAgIGZvciAoY29uc3Qgb3JkZXJCeSBvZiB0aGlzLm9yZGVyQnlzKSB7XG4gICAgICAgICAgICAvLyBTdG9wIGFkZGluZyBtb3JlIHNlZ21lbnRzIGlmIHdlIHNlZSBhIG9yZGVyLWJ5IG9uIGtleS4gVHlwaWNhbGx5IHRoaXNcbiAgICAgICAgICAgIC8vIGlzIHRoZSBkZWZhdWx0IGltcGxpY2l0IG9yZGVyLWJ5IHdoaWNoIGlzIGNvdmVyZWQgaW4gdGhlIGluZGV4X2VudHJ5XG4gICAgICAgICAgICAvLyB0YWJsZSBhcyBhIHNlcGFyYXRlIGNvbHVtbi4gSWYgaXQgaXMgbm90IHRoZSBkZWZhdWx0IG9yZGVyLWJ5LCB0aGVcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlZCBpbmRleCB3aWxsIGJlIG1pc3Npbmcgc29tZSBzZWdtZW50cyBvcHRpbWl6ZWQgZm9yIG9yZGVyLWJ5cyxcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIHByb2JhYmx5IGZpbmUuXG4gICAgICAgICAgICBpZiAob3JkZXJCeS5maWVsZC5pc0tleUZpZWxkKCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmlxdWVGaWVsZHMuaGFzKG9yZGVyQnkuZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bmlxdWVGaWVsZHMgPSB1bmlxdWVGaWVsZHMuYWRkKG9yZGVyQnkuZmllbGQpO1xuICAgICAgICAgICAgc2VnbWVudHMucHVzaChuZXcgSW5kZXhTZWdtZW50KG9yZGVyQnkuZmllbGQsIG9yZGVyQnkuZGlyID09PSBcImFzY1wiIC8qIERpcmVjdGlvbi5BU0NFTkRJTkcgKi9cbiAgICAgICAgICAgICAgICA/IDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqL1xuICAgICAgICAgICAgICAgIDogMSAvKiBJbmRleEtpbmQuREVTQ0VORElORyAqLykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRJbmRleChGaWVsZEluZGV4LlVOS05PV05fSUQsIHRoaXMuY29sbGVjdGlvbklkLCBzZWdtZW50cywgSW5kZXhTdGF0ZS5lbXB0eSgpKTtcbiAgICB9XG4gICAgaGFzTWF0Y2hpbmdFcXVhbGl0eUZpbHRlcihzZWdtZW50KSB7XG4gICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHRoaXMuZXF1YWxpdHlGaWx0ZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXRjaGVzRmlsdGVyKGZpbHRlciwgc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1hdGNoZXNGaWx0ZXIoZmlsdGVyLCBzZWdtZW50KSB7XG4gICAgICAgIGlmIChmaWx0ZXIgPT09IHVuZGVmaW5lZCB8fCAhZmlsdGVyLmZpZWxkLmlzRXF1YWwoc2VnbWVudC5maWVsZFBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNBcnJheU9wZXJhdG9yID0gZmlsdGVyLm9wID09PSBcImFycmF5LWNvbnRhaW5zXCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlMgKi8gfHxcbiAgICAgICAgICAgIGZpbHRlci5vcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi87XG4gICAgICAgIHJldHVybiAoc2VnbWVudC5raW5kID09PSAyIC8qIEluZGV4S2luZC5DT05UQUlOUyAqLykgPT09IGlzQXJyYXlPcGVyYXRvcjtcbiAgICB9XG4gICAgbWF0Y2hlc09yZGVyQnkob3JkZXJCeSwgc2VnbWVudCkge1xuICAgICAgICBpZiAoIW9yZGVyQnkuZmllbGQuaXNFcXVhbChzZWdtZW50LmZpZWxkUGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKChzZWdtZW50LmtpbmQgPT09IDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqLyAmJlxuICAgICAgICAgICAgb3JkZXJCeS5kaXIgPT09IFwiYXNjXCIgLyogRGlyZWN0aW9uLkFTQ0VORElORyAqLykgfHxcbiAgICAgICAgICAgIChzZWdtZW50LmtpbmQgPT09IDEgLyogSW5kZXhLaW5kLkRFU0NFTkRJTkcgKi8gJiZcbiAgICAgICAgICAgICAgICBvcmRlckJ5LmRpciA9PT0gXCJkZXNjXCIgLyogRGlyZWN0aW9uLkRFU0NFTkRJTkcgKi8pKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVzIHV0aWxpdHkgZnVuY3Rpb25zIHRoYXQgaGVscCB3aXRoIGJvb2xlYW4gbG9naWMgdHJhbnNmb3JtYXRpb25zIG5lZWRlZCBmb3IgaGFuZGxpbmdcbiAqIGNvbXBsZXggZmlsdGVycyB1c2VkIGluIHF1ZXJpZXMuXG4gKi9cbi8qKlxuICogVGhlIGBpbmAgZmlsdGVyIGlzIG9ubHkgYSBzeW50YWN0aWMgc3VnYXIgb3ZlciBhIGRpc2p1bmN0aW9uIG9mIGVxdWFsaXRpZXMuIEZvciBpbnN0YW5jZTogYGEgaW5cbiAqIFsxLDIsM11gIGlzIGluIGZhY3QgYGE9PTEgfHwgYT09MiB8fCBhPT0zYC4gVGhpcyBtZXRob2QgZXhwYW5kcyBhbnkgYGluYCBmaWx0ZXIgaW4gdGhlIGdpdmVuXG4gKiBpbnB1dCBpbnRvIGEgZGlzanVuY3Rpb24gb2YgZXF1YWxpdHkgZmlsdGVycyBhbmQgcmV0dXJucyB0aGUgZXhwYW5kZWQgZmlsdGVyLlxuICovXG5mdW5jdGlvbiBjb21wdXRlSW5FeHBhbnNpb24oZmlsdGVyKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBoYXJkQXNzZXJ0KGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyIHx8IGZpbHRlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcik7XG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBJbkZpbHRlcikge1xuICAgICAgICAgICAgY29uc3QgZXhwYW5kZWRGaWx0ZXJzID0gKChfYiA9IChfYSA9IGZpbHRlci52YWx1ZS5hcnJheVZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWFwKHZhbHVlID0+IEZpZWxkRmlsdGVyLmNyZWF0ZShmaWx0ZXIuZmllbGQsIFwiPT1cIiAvKiBPcGVyYXRvci5FUVVBTCAqLywgdmFsdWUpKSkgfHwgW107XG4gICAgICAgICAgICByZXR1cm4gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShleHBhbmRlZEZpbHRlcnMsIFwib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHJlYWNoZWQgb3RoZXIga2luZHMgb2YgZmllbGQgZmlsdGVycy5cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgaGF2ZSBhIGNvbXBvc2l0ZSBmaWx0ZXIuXG4gICAgY29uc3QgZXhwYW5kZWRGaWx0ZXJzID0gZmlsdGVyLmZpbHRlcnMubWFwKHN1YmZpbHRlciA9PiBjb21wdXRlSW5FeHBhbnNpb24oc3ViZmlsdGVyKSk7XG4gICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUoZXhwYW5kZWRGaWx0ZXJzLCBmaWx0ZXIub3ApO1xufVxuLyoqXG4gKiBHaXZlbiBhIGNvbXBvc2l0ZSBmaWx0ZXIsIHJldHVybnMgdGhlIGxpc3Qgb2YgdGVybXMgaW4gaXRzIGRpc2p1bmN0aXZlIG5vcm1hbCBmb3JtLlxuICpcbiAqIDxwPkVhY2ggZWxlbWVudCBpbiB0aGUgcmV0dXJuIHZhbHVlIGlzIG9uZSB0ZXJtIG9mIHRoZSByZXN1bHRpbmcgRE5GLiBGb3IgaW5zdGFuY2U6IEZvciB0aGVcbiAqIGlucHV0OiAoQSB8fCBCKSAmJiBDLCB0aGUgRE5GIGZvcm0gaXM6IChBICYmIEMpIHx8IChCICYmIEMpLCBhbmQgdGhlIHJldHVybiB2YWx1ZSBpcyBhIGxpc3RcbiAqIHdpdGggdHdvIGVsZW1lbnRzOiBhIGNvbXBvc2l0ZSBmaWx0ZXIgdGhhdCBwZXJmb3JtcyAoQSAmJiBDKSwgYW5kIGEgY29tcG9zaXRlIGZpbHRlciB0aGF0XG4gKiBwZXJmb3JtcyAoQiAmJiBDKS5cbiAqXG4gKiBAcGFyYW0gZmlsdGVyIHRoZSBjb21wb3NpdGUgZmlsdGVyIHRvIGNhbGN1bGF0ZSBETkYgdHJhbnNmb3JtIGZvci5cbiAqIEByZXR1cm4gdGhlIHRlcm1zIGluIHRoZSBETkYgdHJhbnNmb3JtLlxuICovXG5mdW5jdGlvbiBnZXREbmZUZXJtcyhmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyLmdldEZpbHRlcnMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBjb21wdXRlRGlzdHJpYnV0ZWROb3JtYWxGb3JtKGNvbXB1dGVJbkV4cGFuc2lvbihmaWx0ZXIpKTtcbiAgICBoYXJkQXNzZXJ0KGlzRGlzanVuY3RpdmVOb3JtYWxGb3JtKHJlc3VsdCkpO1xuICAgIGlmIChpc1NpbmdsZUZpZWxkRmlsdGVyKHJlc3VsdCkgfHwgaXNGbGF0Q29uanVuY3Rpb24ocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gW3Jlc3VsdF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuZ2V0RmlsdGVycygpO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZmlsdGVyIGlzIGEgc2luZ2xlIGZpZWxkIGZpbHRlci4gZS5nLiAoYSA9PSAxMCkuICovXG5mdW5jdGlvbiBpc1NpbmdsZUZpZWxkRmlsdGVyKGZpbHRlcikge1xuICAgIHJldHVybiBmaWx0ZXIgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmaWx0ZXIgaXMgdGhlIGNvbmp1bmN0aW9uIG9mIG9uZSBvciBtb3JlIGZpZWxkIGZpbHRlcnMuIGUuZy4gKGEgPT0gMTBcbiAqICYmIGIgPT0gMjApXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdENvbmp1bmN0aW9uKGZpbHRlcikge1xuICAgIHJldHVybiAoZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyICYmXG4gICAgICAgIGNvbXBvc2l0ZUZpbHRlcklzRmxhdENvbmp1bmN0aW9uKGZpbHRlcikpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBmaWx0ZXIgaXMgaW4gZGlzanVuY3RpdmUgbm9ybWFsIGZvcm0gKERORikuXG4gKlxuICogPHA+SW4gYm9vbGVhbiBsb2dpYywgYSBkaXNqdW5jdGl2ZSBub3JtYWwgZm9ybSAoRE5GKSBpcyBhIGNhbm9uaWNhbCBub3JtYWwgZm9ybSBvZiBhIGxvZ2ljYWxcbiAqIGZvcm11bGEgY29uc2lzdGluZyBvZiBhIGRpc2p1bmN0aW9uIG9mIGNvbmp1bmN0aW9uczsgaXQgY2FuIGFsc28gYmUgZGVzY3JpYmVkIGFzIGFuIE9SIG9mIEFORHMuXG4gKlxuICogPHA+Rm9yIG1vcmUgaW5mbywgdmlzaXQ6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc2p1bmN0aXZlX25vcm1hbF9mb3JtXG4gKi9cbmZ1bmN0aW9uIGlzRGlzanVuY3RpdmVOb3JtYWxGb3JtKGZpbHRlcikge1xuICAgIHJldHVybiAoaXNTaW5nbGVGaWVsZEZpbHRlcihmaWx0ZXIpIHx8XG4gICAgICAgIGlzRmxhdENvbmp1bmN0aW9uKGZpbHRlcikgfHxcbiAgICAgICAgaXNEaXNqdW5jdGlvbk9mRmllbGRGaWx0ZXJzQW5kRmxhdENvbmp1bmN0aW9ucyhmaWx0ZXIpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmaWx0ZXIgaXMgdGhlIGRpc2p1bmN0aW9uIG9mIG9uZSBvciBtb3JlIFwiZmxhdCBjb25qdW5jdGlvbnNcIiBhbmRcbiAqIGZpZWxkIGZpbHRlcnMuIGUuZy4gKGEgPT0gMTApIHx8IChiPT0yMCAmJiBjPT0zMClcbiAqL1xuZnVuY3Rpb24gaXNEaXNqdW5jdGlvbk9mRmllbGRGaWx0ZXJzQW5kRmxhdENvbmp1bmN0aW9ucyhmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKSB7XG4gICAgICAgIGlmIChjb21wb3NpdGVGaWx0ZXJJc0Rpc2p1bmN0aW9uKGZpbHRlcikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViRmlsdGVyIG9mIGZpbHRlci5nZXRGaWx0ZXJzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzU2luZ2xlRmllbGRGaWx0ZXIoc3ViRmlsdGVyKSAmJiAhaXNGbGF0Q29uanVuY3Rpb24oc3ViRmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29tcHV0ZURpc3RyaWJ1dGVkTm9ybWFsRm9ybShmaWx0ZXIpIHtcbiAgICBoYXJkQXNzZXJ0KGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyIHx8IGZpbHRlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcik7XG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfVxuICAgIGlmIChmaWx0ZXIuZmlsdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVEaXN0cmlidXRlZE5vcm1hbEZvcm0oZmlsdGVyLmZpbHRlcnNbMF0pO1xuICAgIH1cbiAgICAvLyBDb21wdXRlIERORiBmb3IgZWFjaCBvZiB0aGUgc3ViZmlsdGVycyBmaXJzdFxuICAgIGNvbnN0IHJlc3VsdCA9IGZpbHRlci5maWx0ZXJzLm1hcChzdWJmaWx0ZXIgPT4gY29tcHV0ZURpc3RyaWJ1dGVkTm9ybWFsRm9ybShzdWJmaWx0ZXIpKTtcbiAgICBsZXQgbmV3RmlsdGVyID0gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShyZXN1bHQsIGZpbHRlci5vcCk7XG4gICAgbmV3RmlsdGVyID0gYXBwbHlBc3NvY2lhdGlvbihuZXdGaWx0ZXIpO1xuICAgIGlmIChpc0Rpc2p1bmN0aXZlTm9ybWFsRm9ybShuZXdGaWx0ZXIpKSB7XG4gICAgICAgIHJldHVybiBuZXdGaWx0ZXI7XG4gICAgfVxuICAgIGhhcmRBc3NlcnQobmV3RmlsdGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlRmlsdGVyKTtcbiAgICBoYXJkQXNzZXJ0KGNvbXBvc2l0ZUZpbHRlcklzQ29uanVuY3Rpb24obmV3RmlsdGVyKSk7XG4gICAgaGFyZEFzc2VydChuZXdGaWx0ZXIuZmlsdGVycy5sZW5ndGggPiAxKTtcbiAgICByZXR1cm4gbmV3RmlsdGVyLmZpbHRlcnMucmVkdWNlKChydW5uaW5nUmVzdWx0LCBmaWx0ZXIpID0+IGFwcGx5RGlzdHJpYnV0aW9uKHJ1bm5pbmdSZXN1bHQsIGZpbHRlcikpO1xufVxuZnVuY3Rpb24gYXBwbHlEaXN0cmlidXRpb24obGhzLCByaHMpIHtcbiAgICBoYXJkQXNzZXJ0KGxocyBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyIHx8IGxocyBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcik7XG4gICAgaGFyZEFzc2VydChyaHMgaW5zdGFuY2VvZiBGaWVsZEZpbHRlciB8fCByaHMgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGxocyBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgIGlmIChyaHMgaW5zdGFuY2VvZiBGaWVsZEZpbHRlcikge1xuICAgICAgICAgICAgLy8gRmllbGRGaWx0ZXIgRmllbGRGaWx0ZXJcbiAgICAgICAgICAgIHJlc3VsdCA9IGFwcGx5RGlzdHJpYnV0aW9uRmllbGRGaWx0ZXJzKGxocywgcmhzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpZWxkRmlsdGVyIENvbXBvc2l0ZUZpbHRlclxuICAgICAgICAgICAgcmVzdWx0ID0gYXBwbHlEaXN0cmlidXRpb25GaWVsZEFuZENvbXBvc2l0ZUZpbHRlcnMobGhzLCByaHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAocmhzIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIpIHtcbiAgICAgICAgICAgIC8vIENvbXBvc2l0ZUZpbHRlciBGaWVsZEZpbHRlclxuICAgICAgICAgICAgcmVzdWx0ID0gYXBwbHlEaXN0cmlidXRpb25GaWVsZEFuZENvbXBvc2l0ZUZpbHRlcnMocmhzLCBsaHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29tcG9zaXRlRmlsdGVyIENvbXBvc2l0ZUZpbHRlclxuICAgICAgICAgICAgcmVzdWx0ID0gYXBwbHlEaXN0cmlidXRpb25Db21wb3NpdGVGaWx0ZXJzKGxocywgcmhzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXBwbHlBc3NvY2lhdGlvbihyZXN1bHQpO1xufVxuZnVuY3Rpb24gYXBwbHlEaXN0cmlidXRpb25GaWVsZEZpbHRlcnMobGhzLCByaHMpIHtcbiAgICAvLyBDb25qdW5jdGlvbiBkaXN0cmlidXRpb24gZm9yIHR3byBmaWVsZCBmaWx0ZXJzIGlzIHRoZSBjb25qdW5jdGlvbiBvZiB0aGVtLlxuICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKFtsaHMsIHJoc10sIFwiYW5kXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuQU5EICovKTtcbn1cbmZ1bmN0aW9uIGFwcGx5RGlzdHJpYnV0aW9uQ29tcG9zaXRlRmlsdGVycyhsaHMsIHJocykge1xuICAgIGhhcmRBc3NlcnQobGhzLmZpbHRlcnMubGVuZ3RoID4gMCAmJiByaHMuZmlsdGVycy5sZW5ndGggPiAwKTtcbiAgICAvLyBUaGVyZSBhcmUgZm91ciBjYXNlczpcbiAgICAvLyAoQSAmIEIpICYgKEMgJiBEKSAtLT4gKEEgJiBCICYgQyAmIEQpXG4gICAgLy8gKEEgJiBCKSAmIChDIHwgRCkgLS0+IChBICYgQiAmIEMpIHwgKEEgJiBCICYgRClcbiAgICAvLyAoQSB8IEIpICYgKEMgJiBEKSAtLT4gKEMgJiBEICYgQSkgfCAoQyAmIEQgJiBCKVxuICAgIC8vIChBIHwgQikgJiAoQyB8IEQpIC0tPiAoQSAmIEMpIHwgKEEgJiBEKSB8IChCICYgQykgfCAoQiAmIEQpXG4gICAgLy8gQ2FzZSAxIGlzIGEgbWVyZ2UuXG4gICAgaWYgKGNvbXBvc2l0ZUZpbHRlcklzQ29uanVuY3Rpb24obGhzKSAmJiBjb21wb3NpdGVGaWx0ZXJJc0Nvbmp1bmN0aW9uKHJocykpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUZpbHRlcldpdGhBZGRlZEZpbHRlcnMobGhzLCByaHMuZ2V0RmlsdGVycygpKTtcbiAgICB9XG4gICAgLy8gQ2FzZSAyLDMsNCBhbGwgaGF2ZSBhdCBsZWFzdCBvbmUgc2lkZSAobGhzIG9yIHJocykgdGhhdCBpcyBhIGRpc2p1bmN0aW9uLiBJbiBhbGwgdGhyZWUgY2FzZXNcbiAgICAvLyB3ZSBzaG91bGQgdGFrZSBlYWNoIGVsZW1lbnQgb2YgdGhlIGRpc2p1bmN0aW9uIGFuZCBkaXN0cmlidXRlIGl0IG92ZXIgdGhlIG90aGVyIHNpZGUsIGFuZFxuICAgIC8vIHJldHVybiB0aGUgZGlzanVuY3Rpb24gb2YgdGhlIGRpc3RyaWJ1dGlvbiByZXN1bHRzLlxuICAgIGNvbnN0IGRpc2p1bmN0aW9uU2lkZSA9IGNvbXBvc2l0ZUZpbHRlcklzRGlzanVuY3Rpb24obGhzKSA/IGxocyA6IHJocztcbiAgICBjb25zdCBvdGhlclNpZGUgPSBjb21wb3NpdGVGaWx0ZXJJc0Rpc2p1bmN0aW9uKGxocykgPyByaHMgOiBsaHM7XG4gICAgY29uc3QgcmVzdWx0cyA9IGRpc2p1bmN0aW9uU2lkZS5maWx0ZXJzLm1hcChzdWJmaWx0ZXIgPT4gYXBwbHlEaXN0cmlidXRpb24oc3ViZmlsdGVyLCBvdGhlclNpZGUpKTtcbiAgICByZXR1cm4gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShyZXN1bHRzLCBcIm9yXCIgLyogQ29tcG9zaXRlT3BlcmF0b3IuT1IgKi8pO1xufVxuZnVuY3Rpb24gYXBwbHlEaXN0cmlidXRpb25GaWVsZEFuZENvbXBvc2l0ZUZpbHRlcnMoZmllbGRGaWx0ZXIsIGNvbXBvc2l0ZUZpbHRlcikge1xuICAgIC8vIFRoZXJlIGFyZSB0d28gY2FzZXM6XG4gICAgLy8gQSAmIChCICYgQykgLS0+IChBICYgQiAmIEMpXG4gICAgLy8gQSAmIChCIHwgQykgLS0+IChBICYgQikgfCAoQSAmIEMpXG4gICAgaWYgKGNvbXBvc2l0ZUZpbHRlcklzQ29uanVuY3Rpb24oY29tcG9zaXRlRmlsdGVyKSkge1xuICAgICAgICAvLyBDYXNlIDFcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUZpbHRlcldpdGhBZGRlZEZpbHRlcnMoY29tcG9zaXRlRmlsdGVyLCBmaWVsZEZpbHRlci5nZXRGaWx0ZXJzKCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQ2FzZSAyXG4gICAgICAgIGNvbnN0IG5ld0ZpbHRlcnMgPSBjb21wb3NpdGVGaWx0ZXIuZmlsdGVycy5tYXAoc3ViZmlsdGVyID0+IGFwcGx5RGlzdHJpYnV0aW9uKGZpZWxkRmlsdGVyLCBzdWJmaWx0ZXIpKTtcbiAgICAgICAgcmV0dXJuIENvbXBvc2l0ZUZpbHRlci5jcmVhdGUobmV3RmlsdGVycywgXCJvclwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLk9SICovKTtcbiAgICB9XG59XG4vKipcbiAqIEFwcGxpZXMgdGhlIGFzc29jaWF0aXZpdHkgcHJvcGVydHkgdG8gdGhlIGdpdmVuIGZpbHRlciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIGZpbHRlci5cbiAqXG4gKiA8dWw+XG4gKiAgIDxsaT5BIHwgKEIgfCBDKSA9PSAoQSB8IEIpIHwgQyA9PSAoQSB8IEIgfCBDKVxuICogICA8bGk+QSAmIChCICYgQykgPT0gKEEgJiBCKSAmIEMgPT0gKEEgJiBCICYgQylcbiAqIDwvdWw+XG4gKlxuICogPHA+Rm9yIG1vcmUgaW5mbywgdmlzaXQ6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Fzc29jaWF0aXZlX3Byb3BlcnR5I1Byb3Bvc2l0aW9uYWxfbG9naWNcbiAqL1xuZnVuY3Rpb24gYXBwbHlBc3NvY2lhdGlvbihmaWx0ZXIpIHtcbiAgICBoYXJkQXNzZXJ0KGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyIHx8IGZpbHRlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUZpbHRlcik7XG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcnMgPSBmaWx0ZXIuZ2V0RmlsdGVycygpO1xuICAgIC8vIElmIHRoZSBjb21wb3NpdGUgZmlsdGVyIG9ubHkgY29udGFpbnMgMSBmaWx0ZXIsIGFwcGx5IGFzc29jaWF0aXZpdHkgdG8gaXQuXG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBhcHBseUFzc29jaWF0aW9uKGZpbHRlcnNbMF0pO1xuICAgIH1cbiAgICAvLyBBc3NvY2lhdGl2aXR5IGFwcGxpZWQgdG8gYSBmbGF0IGNvbXBvc2l0ZSBmaWx0ZXIgcmVzdWx0cyBpcyBpdHNlbGYuXG4gICAgaWYgKGNvbXBvc2l0ZUZpbHRlcklzRmxhdChmaWx0ZXIpKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfVxuICAgIC8vIEZpcnN0IGFwcGx5IGFzc29jaWF0aXZpdHkgdG8gYWxsIHN1YmZpbHRlcnMuIFRoaXMgd2lsbCBpbiB0dXJuIHJlY3Vyc2l2ZWx5IGFwcGx5XG4gICAgLy8gYXNzb2NpYXRpdml0eSB0byBhbGwgbmVzdGVkIGNvbXBvc2l0ZSBmaWx0ZXJzIGFuZCBmaWVsZCBmaWx0ZXJzLlxuICAgIGNvbnN0IHVwZGF0ZWRGaWx0ZXJzID0gZmlsdGVycy5tYXAoc3ViZmlsdGVyID0+IGFwcGx5QXNzb2NpYXRpb24oc3ViZmlsdGVyKSk7XG4gICAgLy8gRm9yIGNvbXBvc2l0ZSBzdWJmaWx0ZXJzIHRoYXQgcGVyZm9ybSB0aGUgc2FtZSBraW5kIG9mIGxvZ2ljYWwgb3BlcmF0aW9uIGFzIGBjb21wb3NpdGVGaWx0ZXJgXG4gICAgLy8gdGFrZSBvdXQgdGhlaXIgZmlsdGVycyBhbmQgYWRkIHRoZW0gdG8gYGNvbXBvc2l0ZUZpbHRlcmAuIEZvciBleGFtcGxlOlxuICAgIC8vIGNvbXBvc2l0ZUZpbHRlciA9IChBIHwgKEIgfCBDIHwgRCkpXG4gICAgLy8gY29tcG9zaXRlU3ViZmlsdGVyID0gKEIgfCBDIHwgRClcbiAgICAvLyBSZXN1bHQ6IChBIHwgQiB8IEMgfCBEKVxuICAgIC8vIE5vdGUgdGhhdCB0aGUgYGNvbXBvc2l0ZVN1YmZpbHRlcmAgaGFzIGJlZW4gZWxpbWluYXRlZCwgYW5kIGl0cyBmaWx0ZXJzIChCLCBDLCBEKSBoYXZlIGJlZW5cbiAgICAvLyBhZGRlZCB0byB0aGUgdG9wLWxldmVsIFwiY29tcG9zaXRlRmlsdGVyXCIuXG4gICAgY29uc3QgbmV3U3ViZmlsdGVycyA9IFtdO1xuICAgIHVwZGF0ZWRGaWx0ZXJzLmZvckVhY2goc3ViZmlsdGVyID0+IHtcbiAgICAgICAgaWYgKHN1YmZpbHRlciBpbnN0YW5jZW9mIEZpZWxkRmlsdGVyKSB7XG4gICAgICAgICAgICBuZXdTdWJmaWx0ZXJzLnB1c2goc3ViZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdWJmaWx0ZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVGaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmIChzdWJmaWx0ZXIub3AgPT09IGZpbHRlci5vcCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0ZUZpbHRlcjogKEEgfCAoQiB8IEMpKVxuICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0ZVN1YmZpbHRlcjogKEIgfCBDKVxuICAgICAgICAgICAgICAgIC8vIFJlc3VsdDogKEEgfCBCIHwgQylcbiAgICAgICAgICAgICAgICBuZXdTdWJmaWx0ZXJzLnB1c2goLi4uc3ViZmlsdGVyLmZpbHRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29tcG9zaXRlRmlsdGVyOiAoQSB8IChCICYgQykpXG4gICAgICAgICAgICAgICAgLy8gY29tcG9zaXRlU3ViZmlsdGVyOiAoQiAmIEMpXG4gICAgICAgICAgICAgICAgLy8gUmVzdWx0OiAoQSB8IChCICYgQykpXG4gICAgICAgICAgICAgICAgbmV3U3ViZmlsdGVycy5wdXNoKHN1YmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobmV3U3ViZmlsdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ld1N1YmZpbHRlcnNbMF07XG4gICAgfVxuICAgIHJldHVybiBDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKG5ld1N1YmZpbHRlcnMsIGZpbHRlci5vcCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGluLW1lbW9yeSBpbXBsZW1lbnRhdGlvbiBvZiBJbmRleE1hbmFnZXIuXG4gKi9cbmNsYXNzIE1lbW9yeUluZGV4TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblBhcmVudEluZGV4ID0gbmV3IE1lbW9yeUNvbGxlY3Rpb25QYXJlbnRJbmRleCgpO1xuICAgIH1cbiAgICBhZGRUb0NvbGxlY3Rpb25QYXJlbnRJbmRleCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvblBhdGgpIHtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uUGFyZW50SW5kZXguYWRkKGNvbGxlY3Rpb25QYXRoKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldENvbGxlY3Rpb25QYXJlbnRzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29sbGVjdGlvblBhcmVudEluZGV4LmdldEVudHJpZXMoY29sbGVjdGlvbklkKSk7XG4gICAgfVxuICAgIGFkZEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIGluZGV4KSB7XG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBkZWxldGVGaWVsZEluZGV4KHRyYW5zYWN0aW9uLCBpbmRleCkge1xuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZGVsZXRlQWxsRmllbGRJbmRleGVzKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjcmVhdGVUYXJnZXRJbmRleGVzKHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldERvY3VtZW50c01hdGNoaW5nVGFyZ2V0KHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBnZXRJbmRleFR5cGUodHJhbnNhY3Rpb24sIHRhcmdldCkge1xuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoMCAvKiBJbmRleFR5cGUuTk9ORSAqLyk7XG4gICAgfVxuICAgIGdldEZpZWxkSW5kZXhlcyh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwKSB7XG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIGdldE5leHRDb2xsZWN0aW9uR3JvdXBUb1VwZGF0ZSh0cmFuc2FjdGlvbikge1xuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfVxuICAgIGdldE1pbk9mZnNldCh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShJbmRleE9mZnNldC5taW4oKSk7XG4gICAgfVxuICAgIGdldE1pbk9mZnNldEZyb21Db2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoSW5kZXhPZmZzZXQubWluKCkpO1xuICAgIH1cbiAgICB1cGRhdGVDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVJbmRleEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50cykge1xuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG59XG4vKipcbiAqIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSBjb2xsZWN0aW9uLXBhcmVudCBpbmRleCBleHBvc2VkIGJ5IE1lbW9yeUluZGV4TWFuYWdlci5cbiAqIEFsc28gdXNlZCBmb3IgaW4tbWVtb3J5IGNhY2hpbmcgYnkgSW5kZXhlZERiSW5kZXhNYW5hZ2VyIGFuZCBpbml0aWFsIGluZGV4IHBvcHVsYXRpb25cbiAqIGluIGluZGV4ZWRkYl9zY2hlbWEudHNcbiAqL1xuY2xhc3MgTWVtb3J5Q29sbGVjdGlvblBhcmVudEluZGV4IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IHt9O1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGZhbHNlIGlmIHRoZSBlbnRyeSBhbHJlYWR5IGV4aXN0ZWQuXG4gICAgYWRkKGNvbGxlY3Rpb25QYXRoKSB7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IGNvbGxlY3Rpb25QYXRoLmxhc3RTZWdtZW50KCk7XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBjb2xsZWN0aW9uUGF0aC5wb3BMYXN0KCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUGFyZW50cyA9IHRoaXMuaW5kZXhbY29sbGVjdGlvbklkXSB8fFxuICAgICAgICAgICAgbmV3IFNvcnRlZFNldChSZXNvdXJjZVBhdGguY29tcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IGFkZGVkID0gIWV4aXN0aW5nUGFyZW50cy5oYXMocGFyZW50UGF0aCk7XG4gICAgICAgIHRoaXMuaW5kZXhbY29sbGVjdGlvbklkXSA9IGV4aXN0aW5nUGFyZW50cy5hZGQocGFyZW50UGF0aCk7XG4gICAgICAgIHJldHVybiBhZGRlZDtcbiAgICB9XG4gICAgaGFzKGNvbGxlY3Rpb25QYXRoKSB7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IGNvbGxlY3Rpb25QYXRoLmxhc3RTZWdtZW50KCk7XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBjb2xsZWN0aW9uUGF0aC5wb3BMYXN0KCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUGFyZW50cyA9IHRoaXMuaW5kZXhbY29sbGVjdGlvbklkXTtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUGFyZW50cyAmJiBleGlzdGluZ1BhcmVudHMuaGFzKHBhcmVudFBhdGgpO1xuICAgIH1cbiAgICBnZXRFbnRyaWVzKGNvbGxlY3Rpb25JZCkge1xuICAgICAgICBjb25zdCBwYXJlbnRQYXRocyA9IHRoaXMuaW5kZXhbY29sbGVjdGlvbklkXSB8fFxuICAgICAgICAgICAgbmV3IFNvcnRlZFNldChSZXNvdXJjZVBhdGguY29tcGFyYXRvcik7XG4gICAgICAgIHJldHVybiBwYXJlbnRQYXRocy50b0FycmF5KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyRmID0gJ0luZGV4ZWREYkluZGV4TWFuYWdlcic7XG5jb25zdCBFTVBUWV9WQUxVRSA9IG5ldyBVaW50OEFycmF5KDApO1xuLyoqXG4gKiBBIHBlcnNpc3RlZCBpbXBsZW1lbnRhdGlvbiBvZiBJbmRleE1hbmFnZXIuXG4gKlxuICogUE9SVElORyBOT1RFOiBVbmxpa2UgaU9TIGFuZCBBbmRyb2lkLCB0aGUgV2ViIFNESyBkb2VzIG5vdCBtZW1vaXplIGluZGV4XG4gKiBkYXRhIGFzIGl0IHN1cHBvcnRzIG11bHRpLXRhYiBhY2Nlc3MuXG4gKi9cbmNsYXNzIEluZGV4ZWREYkluZGV4TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IodXNlciwgZGF0YWJhc2VJZCkge1xuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBkYXRhYmFzZUlkO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW4tbWVtb3J5IGNvcHkgb2YgdGhlIGluZGV4IGVudHJpZXMgd2UndmUgYWxyZWFkeSB3cml0dGVuIHNpbmNlIHRoZSBTREtcbiAgICAgICAgICogbGF1bmNoZWQuIFVzZWQgdG8gYXZvaWQgcmUtd3JpdGluZyB0aGUgc2FtZSBlbnRyeSByZXBlYXRlZGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzICpOT1QqIGEgY29tcGxldGUgY2FjaGUgb2Ygd2hhdCdzIGluIHBlcnNpc3RlbmNlIGFuZCBzbyBjYW4gbmV2ZXIgYmVcbiAgICAgICAgICogdXNlZCB0byBzYXRpc2Z5IHJlYWRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uUGFyZW50c0NhY2hlID0gbmV3IE1lbW9yeUNvbGxlY3Rpb25QYXJlbnRJbmRleCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwcyBmcm9tIGEgdGFyZ2V0IHRvIGl0cyBlcXVpdmFsZW50IGxpc3Qgb2Ygc3ViLXRhcmdldHMuIEVhY2ggc3ViLXRhcmdldFxuICAgICAgICAgKiBjb250YWlucyBvbmx5IG9uZSB0ZXJtIGZyb20gdGhlIHRhcmdldCdzIGRpc2p1bmN0aXZlIG5vcm1hbCBmb3JtIChETkYpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YXJnZXRUb0RuZlN1YlRhcmdldHMgPSBuZXcgT2JqZWN0TWFwKHQgPT4gY2Fub25pZnlUYXJnZXQodCksIChsLCByKSA9PiB0YXJnZXRFcXVhbHMobCwgcikpO1xuICAgICAgICB0aGlzLnVpZCA9IHVzZXIudWlkIHx8ICcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGVudHJ5IHRvIHRoZSBjb2xsZWN0aW9uIHBhcmVudCBpbmRleC5cbiAgICAgKlxuICAgICAqIFJlcGVhdGVkIGNhbGxzIGZvciB0aGUgc2FtZSBjb2xsZWN0aW9uUGF0aCBzaG91bGQgYmUgYXZvaWRlZCB3aXRoaW4gYVxuICAgICAqIHRyYW5zYWN0aW9uIGFzIEluZGV4ZWREYkluZGV4TWFuYWdlciBvbmx5IGNhY2hlcyB3cml0ZXMgb25jZSBhIHRyYW5zYWN0aW9uXG4gICAgICogaGFzIGJlZW4gY29tbWl0dGVkLlxuICAgICAqL1xuICAgIGFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uUGF0aCkge1xuICAgICAgICBpZiAoIXRoaXMuY29sbGVjdGlvblBhcmVudHNDYWNoZS5oYXMoY29sbGVjdGlvblBhdGgpKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBjb2xsZWN0aW9uUGF0aC5sYXN0U2VnbWVudCgpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IGNvbGxlY3Rpb25QYXRoLnBvcExhc3QoKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZE9uQ29tbWl0dGVkTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29sbGVjdGlvbiB0byB0aGUgaW4gbWVtb3J5IGNhY2hlIG9ubHkgaWYgdGhlIHRyYW5zYWN0aW9uIHdhc1xuICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWxseSBjb21taXR0ZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uUGFyZW50c0NhY2hlLmFkZChjb2xsZWN0aW9uUGF0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25QYXJlbnQgPSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbklkLFxuICAgICAgICAgICAgICAgIHBhcmVudDogZW5jb2RlUmVzb3VyY2VQYXRoKHBhcmVudFBhdGgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25QYXJlbnRzU3RvcmUodHJhbnNhY3Rpb24pLnB1dChjb2xsZWN0aW9uUGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0Q29sbGVjdGlvblBhcmVudHModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25JZCkge1xuICAgICAgICBjb25zdCBwYXJlbnRQYXRocyA9IFtdO1xuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFtjb2xsZWN0aW9uSWQsICcnXSwgW2ltbWVkaWF0ZVN1Y2Nlc3Nvcihjb2xsZWN0aW9uSWQpLCAnJ10sIFxuICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXG4gICAgICAgIC8qdXBwZXJPcGVuPSovIHRydWUpO1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvblBhcmVudHNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5sb2FkQWxsKHJhbmdlKVxuICAgICAgICAgICAgLm5leHQoZW50cmllcyA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvbGxlY3Rpb25JZCBndWFyZCBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5IChhbmQgaXNuJ3QgYXMgbG9uZ1xuICAgICAgICAgICAgICAgIC8vIGFzIHdlJ3JlIHJ1bm5pbmcgaW4gYSByZWFsIGJyb3dzZXIpLCBidXQgdGhlcmUncyBhIGJ1ZyBpblxuICAgICAgICAgICAgICAgIC8vIGluZGV4ZWRkYnNoaW0gdGhhdCBicmVha3Mgb3VyIHJhbmdlIGluIG91ciB0ZXN0cyBydW5uaW5nIGluIG5vZGU6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F4ZW1jbGlvbi9JbmRleGVkREJTaGltL2lzc3Vlcy8zMzRcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuY29sbGVjdGlvbklkICE9PSBjb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudFBhdGhzLnB1c2goZGVjb2RlUmVzb3VyY2VQYXRoKGVudHJ5LnBhcmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFBhdGhzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgLy8gVE9ETyhpbmRleGluZyk6IFZlcmlmeSB0aGF0IHRoZSBhdXRvLWluY3JlbWVudGluZyBpbmRleCBJRCB3b3JrcyBpblxuICAgICAgICAvLyBTYWZhcmkgJiBGaXJlZm94LlxuICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhDb25maWd1cmF0aW9uU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBkYkluZGV4ID0gdG9EYkluZGV4Q29uZmlndXJhdGlvbihpbmRleCk7XG4gICAgICAgIGRlbGV0ZSBkYkluZGV4LmluZGV4SWQ7IC8vIGBpbmRleElkYCBpcyBhdXRvLXBvcHVsYXRlZCBieSBJbmRleGVkRGJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW5kZXhlcy5hZGQoZGJJbmRleCk7XG4gICAgICAgIGlmIChpbmRleC5pbmRleFN0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZXMgPSBpbmRleFN0YXRlU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5uZXh0KGluZGV4SWQgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRlcy5wdXQodG9EYkluZGV4U3RhdGUoaW5kZXhJZCwgdGhpcy51aWQsIGluZGV4LmluZGV4U3RhdGUuc2VxdWVuY2VOdW1iZXIsIGluZGV4LmluZGV4U3RhdGUub2Zmc2V0KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZUZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBpbmRleENvbmZpZ3VyYXRpb25TdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGluZGV4U3RhdGVTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBpbmRleEVudHJpZXNTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIHJldHVybiBpbmRleGVzXG4gICAgICAgICAgICAuZGVsZXRlKGluZGV4LmluZGV4SWQpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBzdGF0ZXMuZGVsZXRlKElEQktleVJhbmdlLmJvdW5kKFtpbmRleC5pbmRleElkXSwgW2luZGV4LmluZGV4SWQgKyAxXSwgXG4gICAgICAgIC8qbG93ZXJPcGVuPSovIGZhbHNlLCBcbiAgICAgICAgLyp1cHBlck9wZW49Ki8gdHJ1ZSkpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZW50cmllcy5kZWxldGUoSURCS2V5UmFuZ2UuYm91bmQoW2luZGV4LmluZGV4SWRdLCBbaW5kZXguaW5kZXhJZCArIDFdLCBcbiAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKSkpO1xuICAgIH1cbiAgICBkZWxldGVBbGxGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IGluZGV4Q29uZmlndXJhdGlvblN0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IGluZGV4RW50cmllc1N0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gaW5kZXhTdGF0ZVN0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ZXNcbiAgICAgICAgICAgIC5kZWxldGVBbGwoKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZW50cmllcy5kZWxldGVBbGwoKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHN0YXRlcy5kZWxldGVBbGwoKSk7XG4gICAgfVxuICAgIGNyZWF0ZVRhcmdldEluZGV4ZXModHJhbnNhY3Rpb24sIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godGhpcy5nZXRTdWJUYXJnZXRzKHRhcmdldCksIChzdWJUYXJnZXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEluZGV4VHlwZSh0cmFuc2FjdGlvbiwgc3ViVGFyZ2V0KS5uZXh0KHR5cGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAwIC8qIEluZGV4VHlwZS5OT05FICovIHx8IHR5cGUgPT09IDEgLyogSW5kZXhUeXBlLlBBUlRJQUwgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0SW5kZXhNYXRjaGVyID0gbmV3IFRhcmdldEluZGV4TWF0Y2hlcihzdWJUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZEluZGV4ID0gdGFyZ2V0SW5kZXhNYXRjaGVyLmJ1aWxkVGFyZ2V0SW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldERvY3VtZW50c01hdGNoaW5nVGFyZ2V0KHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgaW5kZXhFbnRyaWVzID0gaW5kZXhFbnRyaWVzU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICBsZXQgY2FuU2VydmVUYXJnZXQgPSB0cnVlO1xuICAgICAgICBjb25zdCBpbmRleGVzID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godGhpcy5nZXRTdWJUYXJnZXRzKHRhcmdldCksIChzdWJUYXJnZXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIHN1YlRhcmdldCkubmV4dChpbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgY2FuU2VydmVUYXJnZXQgJiYgKGNhblNlcnZlVGFyZ2V0ID0gISFpbmRleCk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5zZXQoc3ViVGFyZ2V0LCBpbmRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNhblNlcnZlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4aXN0aW5nS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGluZGV4ZXMsIChpbmRleCwgc3ViVGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckZiwgYFVzaW5nIGluZGV4ICR7ZmllbGRJbmRleFRvU3RyaW5nKGluZGV4KX0gdG8gZXhlY3V0ZSAke2Nhbm9uaWZ5VGFyZ2V0KHRhcmdldCl9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5VmFsdWVzID0gdGFyZ2V0R2V0QXJyYXlWYWx1ZXMoc3ViVGFyZ2V0LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdEluVmFsdWVzID0gdGFyZ2V0R2V0Tm90SW5WYWx1ZXMoc3ViVGFyZ2V0LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvd2VyQm91bmQgPSB0YXJnZXRHZXRMb3dlckJvdW5kKHN1YlRhcmdldCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gdGFyZ2V0R2V0VXBwZXJCb3VuZChzdWJUYXJnZXQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG93ZXJCb3VuZEVuY29kZWQgPSB0aGlzLmVuY29kZUJvdW5kKGluZGV4LCBzdWJUYXJnZXQsIGxvd2VyQm91bmQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kRW5jb2RlZCA9IHRoaXMuZW5jb2RlQm91bmQoaW5kZXgsIHN1YlRhcmdldCwgdXBwZXJCb3VuZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdEluRW5jb2RlZCA9IHRoaXMuZW5jb2RlVmFsdWVzKGluZGV4LCBzdWJUYXJnZXQsIG5vdEluVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXhSYW5nZXMgPSB0aGlzLmdlbmVyYXRlSW5kZXhSYW5nZXMoaW5kZXguaW5kZXhJZCwgYXJyYXlWYWx1ZXMsIGxvd2VyQm91bmRFbmNvZGVkLCBsb3dlckJvdW5kLmluY2x1c2l2ZSwgdXBwZXJCb3VuZEVuY29kZWQsIHVwcGVyQm91bmQuaW5jbHVzaXZlLCBub3RJbkVuY29kZWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goaW5kZXhSYW5nZXMsIChpbmRleFJhbmdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhFbnRyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmxvYWRGaXJzdChpbmRleFJhbmdlLCB0YXJnZXQubGltaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5leHQoZW50cmllcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRLZXkgPSBEb2N1bWVudEtleS5mcm9tU2VnbWVudHMoZW50cnkuZG9jdW1lbnRLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nS2V5cy5oYXMoZG9jdW1lbnRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0tleXMgPSBleGlzdGluZ0tleXMuYWRkKGRvY3VtZW50S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRvY3VtZW50S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFN1YlRhcmdldHModGFyZ2V0KSB7XG4gICAgICAgIGxldCBzdWJUYXJnZXRzID0gdGhpcy50YXJnZXRUb0RuZlN1YlRhcmdldHMuZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmIChzdWJUYXJnZXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ViVGFyZ2V0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0LmZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdWJUYXJnZXRzID0gW3RhcmdldF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBhbiBpbXBsaWNpdCBBTkQgb3BlcmF0aW9uIGJldHdlZW4gYWxsIHRoZSBmaWx0ZXJzIHN0b3JlZCBpbiB0aGUgdGFyZ2V0XG4gICAgICAgICAgICBjb25zdCBkbmYgPSBnZXREbmZUZXJtcyhDb21wb3NpdGVGaWx0ZXIuY3JlYXRlKHRhcmdldC5maWx0ZXJzLCBcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLykpO1xuICAgICAgICAgICAgc3ViVGFyZ2V0cyA9IGRuZi5tYXAodGVybSA9PiBuZXdUYXJnZXQodGFyZ2V0LnBhdGgsIHRhcmdldC5jb2xsZWN0aW9uR3JvdXAsIHRhcmdldC5vcmRlckJ5LCB0ZXJtLmdldEZpbHRlcnMoKSwgdGFyZ2V0LmxpbWl0LCB0YXJnZXQuc3RhcnRBdCwgdGFyZ2V0LmVuZEF0KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YXJnZXRUb0RuZlN1YlRhcmdldHMuc2V0KHRhcmdldCwgc3ViVGFyZ2V0cyk7XG4gICAgICAgIHJldHVybiBzdWJUYXJnZXRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEga2V5IHJhbmdlIHF1ZXJ5IG9uIGBEYkluZGV4RW50cnlTdG9yZWAgdGhhdCB1bmlvbnMgYWxsXG4gICAgICogYm91bmRzLlxuICAgICAqL1xuICAgIGdlbmVyYXRlSW5kZXhSYW5nZXMoaW5kZXhJZCwgYXJyYXlWYWx1ZXMsIGxvd2VyQm91bmRzLCBsb3dlckJvdW5kSW5jbHVzaXZlLCB1cHBlckJvdW5kcywgdXBwZXJCb3VuZEluY2x1c2l2ZSwgbm90SW5WYWx1ZXMpIHtcbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiB0b3RhbCBpbmRleCBzY2FucyB3ZSB1bmlvbiB0b2dldGhlci4gVGhpcyBpcyBzaW1pbGFyIHRvIGFcbiAgICAgICAgLy8gZGlzdHJpYnV0ZWQgbm9ybWFsIGZvcm0sIGJ1dCBhZGFwdGVkIGZvciBhcnJheSB2YWx1ZXMuIFdlIGNyZWF0ZSBhIHNpbmdsZVxuICAgICAgICAvLyBpbmRleCByYW5nZSBwZXIgdmFsdWUgaW4gYW4gQVJSQVlfQ09OVEFJTlMgb3IgQVJSQVlfQ09OVEFJTlNfQU5ZIGZpbHRlclxuICAgICAgICAvLyBjb21iaW5lZCB3aXRoIHRoZSB2YWx1ZXMgZnJvbSB0aGUgcXVlcnkgYm91bmRzLlxuICAgICAgICBjb25zdCB0b3RhbFNjYW5zID0gKGFycmF5VmFsdWVzICE9IG51bGwgPyBhcnJheVZhbHVlcy5sZW5ndGggOiAxKSAqXG4gICAgICAgICAgICBNYXRoLm1heChsb3dlckJvdW5kcy5sZW5ndGgsIHVwcGVyQm91bmRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHNjYW5zUGVyQXJyYXlFbGVtZW50ID0gdG90YWxTY2FucyAvIChhcnJheVZhbHVlcyAhPSBudWxsID8gYXJyYXlWYWx1ZXMubGVuZ3RoIDogMSk7XG4gICAgICAgIGNvbnN0IGluZGV4UmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxTY2FuczsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheVZhbHVlID0gYXJyYXlWYWx1ZXNcbiAgICAgICAgICAgICAgICA/IHRoaXMuZW5jb2RlU2luZ2xlRWxlbWVudChhcnJheVZhbHVlc1tpIC8gc2NhbnNQZXJBcnJheUVsZW1lbnRdKVxuICAgICAgICAgICAgICAgIDogRU1QVFlfVkFMVUU7XG4gICAgICAgICAgICBjb25zdCBsb3dlckJvdW5kID0gdGhpcy5nZW5lcmF0ZUxvd2VyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgbG93ZXJCb3VuZHNbaSAlIHNjYW5zUGVyQXJyYXlFbGVtZW50XSwgbG93ZXJCb3VuZEluY2x1c2l2ZSk7XG4gICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gdGhpcy5nZW5lcmF0ZVVwcGVyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgdXBwZXJCb3VuZHNbaSAlIHNjYW5zUGVyQXJyYXlFbGVtZW50XSwgdXBwZXJCb3VuZEluY2x1c2l2ZSk7XG4gICAgICAgICAgICBjb25zdCBub3RJbkJvdW5kID0gbm90SW5WYWx1ZXMubWFwKG5vdEluID0+IHRoaXMuZ2VuZXJhdGVMb3dlckJvdW5kKGluZGV4SWQsIGFycmF5VmFsdWUsIG5vdEluLCBcbiAgICAgICAgICAgIC8qIGluY2x1c2l2ZT0gKi8gdHJ1ZSkpO1xuICAgICAgICAgICAgaW5kZXhSYW5nZXMucHVzaCguLi50aGlzLmNyZWF0ZVJhbmdlKGxvd2VyQm91bmQsIHVwcGVyQm91bmQsIG5vdEluQm91bmQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXhSYW5nZXM7XG4gICAgfVxuICAgIC8qKiBHZW5lcmF0ZXMgdGhlIGxvd2VyIGJvdW5kIGZvciBgYXJyYXlWYWx1ZWAgYW5kIGBkaXJlY3Rpb25hbFZhbHVlYC4gKi9cbiAgICBnZW5lcmF0ZUxvd2VyQm91bmQoaW5kZXhJZCwgYXJyYXlWYWx1ZSwgZGlyZWN0aW9uYWxWYWx1ZSwgaW5jbHVzaXZlKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gbmV3IEluZGV4RW50cnkoaW5kZXhJZCwgRG9jdW1lbnRLZXkuZW1wdHkoKSwgYXJyYXlWYWx1ZSwgZGlyZWN0aW9uYWxWYWx1ZSk7XG4gICAgICAgIHJldHVybiBpbmNsdXNpdmUgPyBlbnRyeSA6IGVudHJ5LnN1Y2Nlc3NvcigpO1xuICAgIH1cbiAgICAvKiogR2VuZXJhdGVzIHRoZSB1cHBlciBib3VuZCBmb3IgYGFycmF5VmFsdWVgIGFuZCBgZGlyZWN0aW9uYWxWYWx1ZWAuICovXG4gICAgZ2VuZXJhdGVVcHBlckJvdW5kKGluZGV4SWQsIGFycmF5VmFsdWUsIGRpcmVjdGlvbmFsVmFsdWUsIGluY2x1c2l2ZSkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IG5ldyBJbmRleEVudHJ5KGluZGV4SWQsIERvY3VtZW50S2V5LmVtcHR5KCksIGFycmF5VmFsdWUsIGRpcmVjdGlvbmFsVmFsdWUpO1xuICAgICAgICByZXR1cm4gaW5jbHVzaXZlID8gZW50cnkuc3VjY2Vzc29yKCkgOiBlbnRyeTtcbiAgICB9XG4gICAgZ2V0RmllbGRJbmRleCh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEluZGV4TWF0Y2hlciA9IG5ldyBUYXJnZXRJbmRleE1hdGNoZXIodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbkdyb3VwID0gdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCAhPSBudWxsXG4gICAgICAgICAgICA/IHRhcmdldC5jb2xsZWN0aW9uR3JvdXBcbiAgICAgICAgICAgIDogdGFyZ2V0LnBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApLm5leHQoaW5kZXhlcyA9PiB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGluZGV4IHdpdGggdGhlIG1vc3QgbnVtYmVyIG9mIHNlZ21lbnRzLlxuICAgICAgICAgICAgbGV0IGluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdGFyZ2V0SW5kZXhNYXRjaGVyLnNlcnZlZEJ5SW5kZXgoY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyAmJlxuICAgICAgICAgICAgICAgICAgICAoIWluZGV4IHx8IGNhbmRpZGF0ZS5maWVsZHMubGVuZ3RoID4gaW5kZXguZmllbGRzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SW5kZXhUeXBlKHRyYW5zYWN0aW9uLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IGluZGV4VHlwZSA9IDIgLyogSW5kZXhUeXBlLkZVTEwgKi87XG4gICAgICAgIGNvbnN0IHN1YlRhcmdldHMgPSB0aGlzLmdldFN1YlRhcmdldHModGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHN1YlRhcmdldHMsICh0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIHRhcmdldCkubmV4dChpbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleFR5cGUgPSAwIC8qIEluZGV4VHlwZS5OT05FICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmRleFR5cGUgIT09IDAgLyogSW5kZXhUeXBlLk5PTkUgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgaW5kZXguZmllbGRzLmxlbmd0aCA8IHRhcmdldEdldFNlZ21lbnRDb3VudCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4VHlwZSA9IDEgLyogSW5kZXhUeXBlLlBBUlRJQUwgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gT1IgcXVlcmllcyBoYXZlIG1vcmUgdGhhbiBvbmUgc3ViLXRhcmdldCAob25lIHN1Yi10YXJnZXQgcGVyIERORiB0ZXJtKS4gV2UgY3VycmVudGx5IGNvbnNpZGVyXG4gICAgICAgICAgICAvLyBPUiBxdWVyaWVzIHRoYXQgaGF2ZSBhIGBsaW1pdGAgdG8gaGF2ZSBhIHBhcnRpYWwgaW5kZXguIEZvciBzdWNoIHF1ZXJpZXMgd2UgcGVyZm9ybSBzb3J0aW5nXG4gICAgICAgICAgICAvLyBhbmQgYXBwbHkgdGhlIGxpbWl0IGluIG1lbW9yeSBhcyBhIHBvc3QtcHJvY2Vzc2luZyBzdGVwLlxuICAgICAgICAgICAgaWYgKHRhcmdldEhhc0xpbWl0KHRhcmdldCkgJiZcbiAgICAgICAgICAgICAgICBzdWJUYXJnZXRzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICBpbmRleFR5cGUgPT09IDIgLyogSW5kZXhUeXBlLkZVTEwgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBJbmRleFR5cGUuUEFSVElBTCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbmRleFR5cGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBieXRlIGVuY29kZWQgZm9ybSBvZiB0aGUgZGlyZWN0aW9uYWwgdmFsdWVzIGluIHRoZSBmaWVsZCBpbmRleC5cbiAgICAgKiBSZXR1cm5zIGBudWxsYCBpZiB0aGUgZG9jdW1lbnQgZG9lcyBub3QgaGF2ZSBhbGwgZmllbGRzIHNwZWNpZmllZCBpbiB0aGVcbiAgICAgKiBpbmRleC5cbiAgICAgKi9cbiAgICBlbmNvZGVEaXJlY3Rpb25hbEVsZW1lbnRzKGZpZWxkSW5kZXgsIGRvY3VtZW50KSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgSW5kZXhCeXRlRW5jb2RlcigpO1xuICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoZmllbGRJbmRleCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZG9jdW1lbnQuZGF0YS5maWVsZChzZWdtZW50LmZpZWxkUGF0aCk7XG4gICAgICAgICAgICBpZiAoZmllbGQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uYWxFbmNvZGVyID0gZW5jb2Rlci5mb3JLaW5kKHNlZ21lbnQua2luZCk7XG4gICAgICAgICAgICBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyLklOU1RBTkNFLndyaXRlSW5kZXhWYWx1ZShmaWVsZCwgZGlyZWN0aW9uYWxFbmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGVkQnl0ZXMoKTtcbiAgICB9XG4gICAgLyoqIEVuY29kZXMgYSBzaW5nbGUgdmFsdWUgdG8gdGhlIGFzY2VuZGluZyBpbmRleCBmb3JtYXQuICovXG4gICAgZW5jb2RlU2luZ2xlRWxlbWVudCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IEluZGV4Qnl0ZUVuY29kZXIoKTtcbiAgICAgICAgRmlyZXN0b3JlSW5kZXhWYWx1ZVdyaXRlci5JTlNUQU5DRS53cml0ZUluZGV4VmFsdWUodmFsdWUsIGVuY29kZXIuZm9yS2luZCgwIC8qIEluZGV4S2luZC5BU0NFTkRJTkcgKi8pKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZXIuZW5jb2RlZEJ5dGVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gZW5jb2RlZCBmb3JtIG9mIHRoZSBkb2N1bWVudCBrZXkgdGhhdCBzb3J0cyBiYXNlZCBvbiB0aGUga2V5XG4gICAgICogb3JkZXJpbmcgb2YgdGhlIGZpZWxkIGluZGV4LlxuICAgICAqL1xuICAgIGVuY29kZURpcmVjdGlvbmFsS2V5KGZpZWxkSW5kZXgsIGRvY3VtZW50S2V5KSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgSW5kZXhCeXRlRW5jb2RlcigpO1xuICAgICAgICBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyLklOU1RBTkNFLndyaXRlSW5kZXhWYWx1ZShyZWZWYWx1ZSh0aGlzLmRhdGFiYXNlSWQsIGRvY3VtZW50S2V5KSwgZW5jb2Rlci5mb3JLaW5kKGZpZWxkSW5kZXhHZXRLZXlPcmRlcihmaWVsZEluZGV4KSkpO1xuICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGVkQnl0ZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gZmllbGQgdmFsdWVzIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBpbiBgdGFyZ2V0YC5cbiAgICAgKiBGb3IgSU4gcXVlcmllcywgYSBsaXN0IG9mIHBvc3NpYmxlIHZhbHVlcyBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBlbmNvZGVWYWx1ZXMoZmllbGRJbmRleCwgdGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbmNvZGVycyA9IFtdO1xuICAgICAgICBlbmNvZGVycy5wdXNoKG5ldyBJbmRleEJ5dGVFbmNvZGVyKCkpO1xuICAgICAgICBsZXQgdmFsdWVJZHggPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoZmllbGRJbmRleCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3ZhbHVlSWR4KytdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGVyIG9mIGVuY29kZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbkZpbHRlcih0YXJnZXQsIHNlZ21lbnQuZmllbGRQYXRoKSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVycyA9IHRoaXMuZXhwYW5kSW5kZXhWYWx1ZXMoZW5jb2RlcnMsIHNlZ21lbnQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbmFsRW5jb2RlciA9IGVuY29kZXIuZm9yS2luZChzZWdtZW50LmtpbmQpO1xuICAgICAgICAgICAgICAgICAgICBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyLklOU1RBTkNFLndyaXRlSW5kZXhWYWx1ZSh2YWx1ZSwgZGlyZWN0aW9uYWxFbmNvZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5jb2RlZEJ5dGVzKGVuY29kZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyB0aGUgZ2l2ZW4gYm91bmRzIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBpbiBgdGFyZ2V0YC4gRm9yIElOXG4gICAgICogcXVlcmllcywgYSBsaXN0IG9mIHBvc3NpYmxlIHZhbHVlcyBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBlbmNvZGVCb3VuZChmaWVsZEluZGV4LCB0YXJnZXQsIGJvdW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZVZhbHVlcyhmaWVsZEluZGV4LCB0YXJnZXQsIGJvdW5kLnBvc2l0aW9uKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIGJ5dGUgcmVwcmVzZW50YXRpb24gZm9yIHRoZSBwcm92aWRlZCBlbmNvZGVycy4gKi9cbiAgICBnZXRFbmNvZGVkQnl0ZXMoZW5jb2RlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IGVuY29kZXJzW2ldLmVuY29kZWRCeXRlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzZXBhcmF0ZSBlbmNvZGVyIGZvciBlYWNoIGVsZW1lbnQgb2YgYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBUaGUgbWV0aG9kIGFwcGVuZHMgZWFjaCB2YWx1ZSB0byBhbGwgZXhpc3RpbmcgZW5jb2RlcnMgKGUuZy4gZmlsdGVyKFwiYVwiLFxuICAgICAqIFwiPT1cIiwgXCJhMVwiKS5maWx0ZXIoXCJiXCIsIFwiaW5cIiwgW1wiYjFcIiwgXCJiMlwiXSkgYmVjb21lcyBbXCJhMSxiMVwiLCBcImExLGIyXCJdKS4gQVxuICAgICAqIGxpc3Qgb2YgbmV3IGVuY29kZXJzIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGV4cGFuZEluZGV4VmFsdWVzKGVuY29kZXJzLCBzZWdtZW50LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBwcmVmaXhlcyA9IFsuLi5lbmNvZGVyc107XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBhcnJheUVsZW1lbnQgb2YgdmFsdWUuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkRW5jb2RlciA9IG5ldyBJbmRleEJ5dGVFbmNvZGVyKCk7XG4gICAgICAgICAgICAgICAgY2xvbmVkRW5jb2Rlci5zZWVkKHByZWZpeC5lbmNvZGVkQnl0ZXMoKSk7XG4gICAgICAgICAgICAgICAgRmlyZXN0b3JlSW5kZXhWYWx1ZVdyaXRlci5JTlNUQU5DRS53cml0ZUluZGV4VmFsdWUoYXJyYXlFbGVtZW50LCBjbG9uZWRFbmNvZGVyLmZvcktpbmQoc2VnbWVudC5raW5kKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNsb25lZEVuY29kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBpc0luRmlsdGVyKHRhcmdldCwgZmllbGRQYXRoKSB7XG4gICAgICAgIHJldHVybiAhIXRhcmdldC5maWx0ZXJzLmZpbmQoZiA9PiBmIGluc3RhbmNlb2YgRmllbGRGaWx0ZXIgJiZcbiAgICAgICAgICAgIGYuZmllbGQuaXNFcXVhbChmaWVsZFBhdGgpICYmXG4gICAgICAgICAgICAoZi5vcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovIHx8IGYub3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovKSk7XG4gICAgfVxuICAgIGdldEZpZWxkSW5kZXhlcyh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBpbmRleENvbmZpZ3VyYXRpb25TdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGluZGV4U3RhdGVTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIHJldHVybiAoY29sbGVjdGlvbkdyb3VwXG4gICAgICAgICAgICA/IGluZGV4ZXMubG9hZEFsbChEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4LCBJREJLZXlSYW5nZS5ib3VuZChjb2xsZWN0aW9uR3JvdXAsIGNvbGxlY3Rpb25Hcm91cCkpXG4gICAgICAgICAgICA6IGluZGV4ZXMubG9hZEFsbCgpKS5uZXh0KGluZGV4Q29uZmlncyA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChpbmRleENvbmZpZ3MsIChpbmRleENvbmZpZykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgLmdldChbaW5kZXhDb25maWcuaW5kZXhJZCwgdGhpcy51aWRdKVxuICAgICAgICAgICAgICAgICAgICAubmV4dChpbmRleFN0YXRlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbURiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4Q29uZmlnLCBpbmRleFN0YXRlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KS5uZXh0KCgpID0+IHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXROZXh0Q29sbGVjdGlvbkdyb3VwVG9VcGRhdGUodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uKS5uZXh0KGluZGV4ZXMgPT4ge1xuICAgICAgICAgICAgaWYgKGluZGV4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleGVzLnNvcnQoKGwsIHIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbXAgPSBsLmluZGV4U3RhdGUuc2VxdWVuY2VOdW1iZXIgLSByLmluZGV4U3RhdGUuc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNtcCAhPT0gMFxuICAgICAgICAgICAgICAgICAgICA/IGNtcFxuICAgICAgICAgICAgICAgICAgICA6IHByaW1pdGl2ZUNvbXBhcmF0b3IobC5jb2xsZWN0aW9uR3JvdXAsIHIuY29sbGVjdGlvbkdyb3VwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4ZXNbMF0uY29sbGVjdGlvbkdyb3VwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhDb25maWd1cmF0aW9uU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBpbmRleFN0YXRlU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROZXh0U2VxdWVuY2VOdW1iZXIodHJhbnNhY3Rpb24pLm5leHQobmV4dFNlcXVlbmNlTnVtYmVyID0+IGluZGV4ZXNcbiAgICAgICAgICAgIC5sb2FkQWxsKERiSW5kZXhDb25maWd1cmF0aW9uQ29sbGVjdGlvbkdyb3VwSW5kZXgsIElEQktleVJhbmdlLmJvdW5kKGNvbGxlY3Rpb25Hcm91cCwgY29sbGVjdGlvbkdyb3VwKSlcbiAgICAgICAgICAgIC5uZXh0KGNvbmZpZ3MgPT4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goY29uZmlncywgKGNvbmZpZykgPT4gc3RhdGVzLnB1dCh0b0RiSW5kZXhTdGF0ZShjb25maWcuaW5kZXhJZCwgdGhpcy51aWQsIG5leHRTZXF1ZW5jZU51bWJlciwgb2Zmc2V0KSkpKSk7XG4gICAgfVxuICAgIHVwZGF0ZUluZGV4RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRzKSB7XG4gICAgICAgIC8vIFBvcnRpbmcgTm90ZTogYGdldEZpZWxkSW5kZXhlcygpYCBvbiBXZWIgZG9lcyBub3QgY2FjaGUgaW5kZXggbG9va3VwcyBhc1xuICAgICAgICAvLyBpdCBjb3VsZCBiZSB1c2VkIGFjcm9zcyBkaWZmZXJlbnQgSW5kZXhlZERCIHRyYW5zYWN0aW9ucy4gQXMgYW55IGNhY2hlZFxuICAgICAgICAvLyBkYXRhIG1pZ2h0IGJlIGludmFsaWRhdGVkIGJ5IG90aGVyIG11bHRpLXRhYiBjbGllbnRzLCB3ZSBjYW4gb25seSB0cnVzdFxuICAgICAgICAvLyBkYXRhIHdpdGhpbiBhIHNpbmdsZSBJbmRleGVkREIgdHJhbnNhY3Rpb24uIFdlIHRoZXJlZm9yZSBhZGQgYSBjYWNoZVxuICAgICAgICAvLyBoZXJlLlxuICAgICAgICBjb25zdCBtZW1vaXplZEluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChkb2N1bWVudHMsIChrZXksIGRvYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVtb2l6ZWRDb2xsZWN0aW9uSW5kZXhlcyA9IG1lbW9pemVkSW5kZXhlcy5nZXQoa2V5LmNvbGxlY3Rpb25Hcm91cCk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZEluZGV4ZXMgPSBtZW1vaXplZENvbGxlY3Rpb25JbmRleGVzXG4gICAgICAgICAgICAgICAgPyBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShtZW1vaXplZENvbGxlY3Rpb25JbmRleGVzKVxuICAgICAgICAgICAgICAgIDogdGhpcy5nZXRGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24sIGtleS5jb2xsZWN0aW9uR3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkSW5kZXhlcy5uZXh0KGZpZWxkSW5kZXhlcyA9PiB7XG4gICAgICAgICAgICAgICAgbWVtb2l6ZWRJbmRleGVzLnNldChrZXkuY29sbGVjdGlvbkdyb3VwLCBmaWVsZEluZGV4ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChmaWVsZEluZGV4ZXMsIChmaWVsZEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEV4aXN0aW5nSW5kZXhFbnRyaWVzKHRyYW5zYWN0aW9uLCBrZXksIGZpZWxkSW5kZXgpLm5leHQoZXhpc3RpbmdFbnRyaWVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VudHJpZXMgPSB0aGlzLmNvbXB1dGVJbmRleEVudHJpZXMoZG9jLCBmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmdFbnRyaWVzLmlzRXF1YWwobmV3RW50cmllcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2MsIGZpZWxkSW5kZXgsIGV4aXN0aW5nRW50cmllcywgbmV3RW50cmllcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZEluZGV4RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50LCBmaWVsZEluZGV4LCBpbmRleEVudHJ5KSB7XG4gICAgICAgIGNvbnN0IGluZGV4RW50cmllcyA9IGluZGV4RW50cmllc1N0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGluZGV4RW50cmllcy5wdXQoe1xuICAgICAgICAgICAgaW5kZXhJZDogaW5kZXhFbnRyeS5pbmRleElkLFxuICAgICAgICAgICAgdWlkOiB0aGlzLnVpZCxcbiAgICAgICAgICAgIGFycmF5VmFsdWU6IGluZGV4RW50cnkuYXJyYXlWYWx1ZSxcbiAgICAgICAgICAgIGRpcmVjdGlvbmFsVmFsdWU6IGluZGV4RW50cnkuZGlyZWN0aW9uYWxWYWx1ZSxcbiAgICAgICAgICAgIG9yZGVyZWREb2N1bWVudEtleTogdGhpcy5lbmNvZGVEaXJlY3Rpb25hbEtleShmaWVsZEluZGV4LCBkb2N1bWVudC5rZXkpLFxuICAgICAgICAgICAgZG9jdW1lbnRLZXk6IGRvY3VtZW50LmtleS5wYXRoLnRvQXJyYXkoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVsZXRlSW5kZXhFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnQsIGZpZWxkSW5kZXgsIGluZGV4RW50cnkpIHtcbiAgICAgICAgY29uc3QgaW5kZXhFbnRyaWVzID0gaW5kZXhFbnRyaWVzU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gaW5kZXhFbnRyaWVzLmRlbGV0ZShbXG4gICAgICAgICAgICBpbmRleEVudHJ5LmluZGV4SWQsXG4gICAgICAgICAgICB0aGlzLnVpZCxcbiAgICAgICAgICAgIGluZGV4RW50cnkuYXJyYXlWYWx1ZSxcbiAgICAgICAgICAgIGluZGV4RW50cnkuZGlyZWN0aW9uYWxWYWx1ZSxcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlRGlyZWN0aW9uYWxLZXkoZmllbGRJbmRleCwgZG9jdW1lbnQua2V5KSxcbiAgICAgICAgICAgIGRvY3VtZW50LmtleS5wYXRoLnRvQXJyYXkoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgZ2V0RXhpc3RpbmdJbmRleEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5LCBmaWVsZEluZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZGV4RW50cmllcyA9IGluZGV4RW50cmllc1N0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBuZXcgU29ydGVkU2V0KGluZGV4RW50cnlDb21wYXJhdG9yKTtcbiAgICAgICAgcmV0dXJuIGluZGV4RW50cmllc1xuICAgICAgICAgICAgLml0ZXJhdGUoe1xuICAgICAgICAgICAgaW5kZXg6IERiSW5kZXhFbnRyeURvY3VtZW50S2V5SW5kZXgsXG4gICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2Uub25seShbXG4gICAgICAgICAgICAgICAgZmllbGRJbmRleC5pbmRleElkLFxuICAgICAgICAgICAgICAgIHRoaXMudWlkLFxuICAgICAgICAgICAgICAgIHRoaXMuZW5jb2RlRGlyZWN0aW9uYWxLZXkoZmllbGRJbmRleCwgZG9jdW1lbnRLZXkpXG4gICAgICAgICAgICBdKVxuICAgICAgICB9LCAoXywgZW50cnkpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmFkZChuZXcgSW5kZXhFbnRyeShmaWVsZEluZGV4LmluZGV4SWQsIGRvY3VtZW50S2V5LCBlbnRyeS5hcnJheVZhbHVlLCBlbnRyeS5kaXJlY3Rpb25hbFZhbHVlKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiByZXN1bHRzKTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZXMgdGhlIGluZGV4IGVudHJpZXMgZm9yIHRoZSBnaXZlbiBkb2N1bWVudC4gKi9cbiAgICBjb21wdXRlSW5kZXhFbnRyaWVzKGRvY3VtZW50LCBmaWVsZEluZGV4KSB7XG4gICAgICAgIGxldCByZXN1bHRzID0gbmV3IFNvcnRlZFNldChpbmRleEVudHJ5Q29tcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbmFsVmFsdWUgPSB0aGlzLmVuY29kZURpcmVjdGlvbmFsRWxlbWVudHMoZmllbGRJbmRleCwgZG9jdW1lbnQpO1xuICAgICAgICBpZiAoZGlyZWN0aW9uYWxWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcnJheVNlZ21lbnQgPSBmaWVsZEluZGV4R2V0QXJyYXlTZWdtZW50KGZpZWxkSW5kZXgpO1xuICAgICAgICBpZiAoYXJyYXlTZWdtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9jdW1lbnQuZGF0YS5maWVsZChhcnJheVNlZ21lbnQuZmllbGRQYXRoKTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXJyYXlWYWx1ZSBvZiB2YWx1ZS5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5hZGQobmV3IEluZGV4RW50cnkoZmllbGRJbmRleC5pbmRleElkLCBkb2N1bWVudC5rZXksIHRoaXMuZW5jb2RlU2luZ2xlRWxlbWVudChhcnJheVZhbHVlKSwgZGlyZWN0aW9uYWxWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmFkZChuZXcgSW5kZXhFbnRyeShmaWVsZEluZGV4LmluZGV4SWQsIGRvY3VtZW50LmtleSwgRU1QVFlfVkFMVUUsIGRpcmVjdGlvbmFsVmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgaW5kZXggZW50cmllcyBmb3IgdGhlIHByb3ZpZGVkIGRvY3VtZW50IGJ5IGRlbGV0aW5nIGVudHJpZXNcbiAgICAgKiB0aGF0IGFyZSBubyBsb25nZXIgcmVmZXJlbmNlZCBpbiBgbmV3RW50cmllc2AgYW5kIGFkZGluZyBhbGwgbmV3bHkgYWRkZWRcbiAgICAgKiBlbnRyaWVzLlxuICAgICAqL1xuICAgIHVwZGF0ZUVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50LCBmaWVsZEluZGV4LCBleGlzdGluZ0VudHJpZXMsIG5ld0VudHJpZXMpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRmLCBcIlVwZGF0aW5nIGluZGV4IGVudHJpZXMgZm9yIGRvY3VtZW50ICclcydcIiwgZG9jdW1lbnQua2V5KTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZGlmZlNvcnRlZFNldHMoZXhpc3RpbmdFbnRyaWVzLCBuZXdFbnRyaWVzLCBpbmRleEVudHJ5Q29tcGFyYXRvciwgXG4gICAgICAgIC8qIG9uQWRkPSAqLyBlbnRyeSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuYWRkSW5kZXhFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnQsIGZpZWxkSW5kZXgsIGVudHJ5KSk7XG4gICAgICAgIH0sIFxuICAgICAgICAvKiBvblJlbW92ZT0gKi8gZW50cnkgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRlbGV0ZUluZGV4RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50LCBmaWVsZEluZGV4LCBlbnRyeSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcbiAgICB9XG4gICAgZ2V0TmV4dFNlcXVlbmNlTnVtYmVyKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGxldCBuZXh0U2VxdWVuY2VOdW1iZXIgPSAxO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBpbmRleFN0YXRlU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gc3RhdGVzXG4gICAgICAgICAgICAuaXRlcmF0ZSh7XG4gICAgICAgICAgICBpbmRleDogRGJJbmRleFN0YXRlU2VxdWVuY2VOdW1iZXJJbmRleCxcbiAgICAgICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgICAgICByYW5nZTogSURCS2V5UmFuZ2UudXBwZXJCb3VuZChbdGhpcy51aWQsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXSlcbiAgICAgICAgfSwgKF8sIHN0YXRlLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmRvbmUoKTtcbiAgICAgICAgICAgIG5leHRTZXF1ZW5jZU51bWJlciA9IHN0YXRlLnNlcXVlbmNlTnVtYmVyICsgMTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IG5leHRTZXF1ZW5jZU51bWJlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgc2V0IG9mIElEQiByYW5nZXMgdGhhdCBzcGxpdHMgdGhlIGV4aXN0aW5nIHJhbmdlIGFuZCBleGNsdWRlc1xuICAgICAqIGFueSB2YWx1ZXMgdGhhdCBtYXRjaCB0aGUgYG5vdEluVmFsdWVgIGZyb20gdGhlc2UgcmFuZ2VzLiBBcyBhbiBleGFtcGxlLFxuICAgICAqICdbZm9vID4gMiAmJiBmb28gIT0gM11gIGJlY29tZXMgIGBbZm9vID4gMiAmJiA8IDMsIGZvbyA+IDNdYC5cbiAgICAgKi9cbiAgICBjcmVhdGVSYW5nZShsb3dlciwgdXBwZXIsIG5vdEluVmFsdWVzKSB7XG4gICAgICAgIC8vIFRoZSBub3RJbiB2YWx1ZXMgbmVlZCB0byBiZSBzb3J0ZWQgYW5kIHVuaXF1ZSBzbyB0aGF0IHdlIGNhbiByZXR1cm4gYVxuICAgICAgICAvLyBzb3J0ZWQgc2V0IG9mIG5vbi1vdmVybGFwcGluZyByYW5nZXMuXG4gICAgICAgIG5vdEluVmFsdWVzID0gbm90SW5WYWx1ZXNcbiAgICAgICAgICAgIC5zb3J0KChsLCByKSA9PiBpbmRleEVudHJ5Q29tcGFyYXRvcihsLCByKSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGVsLCBpLCB2YWx1ZXMpID0+ICFpIHx8IGluZGV4RW50cnlDb21wYXJhdG9yKGVsLCB2YWx1ZXNbaSAtIDFdKSAhPT0gMCk7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IFtdO1xuICAgICAgICBib3VuZHMucHVzaChsb3dlcik7XG4gICAgICAgIGZvciAoY29uc3Qgbm90SW5WYWx1ZSBvZiBub3RJblZhbHVlcykge1xuICAgICAgICAgICAgY29uc3QgY21wVG9Mb3dlciA9IGluZGV4RW50cnlDb21wYXJhdG9yKG5vdEluVmFsdWUsIGxvd2VyKTtcbiAgICAgICAgICAgIGNvbnN0IGNtcFRvVXBwZXIgPSBpbmRleEVudHJ5Q29tcGFyYXRvcihub3RJblZhbHVlLCB1cHBlcik7XG4gICAgICAgICAgICBpZiAoY21wVG9Mb3dlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGBub3RJblZhbHVlYCBpcyB0aGUgbG93ZXIgYm91bmQuIFdlIHRoZXJlZm9yZSBuZWVkIHRvIHJhaXNlIHRoZSBib3VuZFxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBuZXh0IHZhbHVlLlxuICAgICAgICAgICAgICAgIGJvdW5kc1swXSA9IGxvd2VyLnN1Y2Nlc3NvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wVG9Mb3dlciA+IDAgJiYgY21wVG9VcHBlciA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBgbm90SW5WYWx1ZWAgaXMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICBib3VuZHMucHVzaChub3RJblZhbHVlKTtcbiAgICAgICAgICAgICAgICBib3VuZHMucHVzaChub3RJblZhbHVlLnN1Y2Nlc3NvcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcFRvVXBwZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gYG5vdEluVmFsdWVgIChhbmQgYWxsIGZvbGxvd2luZyB2YWx1ZXMpIGFyZSBvdXQgb2YgdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYm91bmRzLnB1c2godXBwZXIpO1xuICAgICAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGVuY291bnRlciB0d28gYm91bmRzIHRoYXQgd2lsbCBjcmVhdGUgYW4gdW5tYXRjaGFibGUga2V5IHJhbmdlLFxuICAgICAgICAgICAgLy8gdGhlbiB3ZSByZXR1cm4gYW4gZW1wdHkgc2V0IG9mIGtleSByYW5nZXMuXG4gICAgICAgICAgICBpZiAodGhpcy5pc1JhbmdlTWF0Y2hhYmxlKGJvdW5kc1tpXSwgYm91bmRzW2kgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb3dlckJvdW5kID0gW1xuICAgICAgICAgICAgICAgIGJvdW5kc1tpXS5pbmRleElkLFxuICAgICAgICAgICAgICAgIHRoaXMudWlkLFxuICAgICAgICAgICAgICAgIGJvdW5kc1tpXS5hcnJheVZhbHVlLFxuICAgICAgICAgICAgICAgIGJvdW5kc1tpXS5kaXJlY3Rpb25hbFZhbHVlLFxuICAgICAgICAgICAgICAgIEVNUFRZX1ZBTFVFLFxuICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgdXBwZXJCb3VuZCA9IFtcbiAgICAgICAgICAgICAgICBib3VuZHNbaSArIDFdLmluZGV4SWQsXG4gICAgICAgICAgICAgICAgdGhpcy51aWQsXG4gICAgICAgICAgICAgICAgYm91bmRzW2kgKyAxXS5hcnJheVZhbHVlLFxuICAgICAgICAgICAgICAgIGJvdW5kc1tpICsgMV0uZGlyZWN0aW9uYWxWYWx1ZSxcbiAgICAgICAgICAgICAgICBFTVBUWV9WQUxVRSxcbiAgICAgICAgICAgICAgICBbXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKElEQktleVJhbmdlLmJvdW5kKGxvd2VyQm91bmQsIHVwcGVyQm91bmQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cbiAgICBpc1JhbmdlTWF0Y2hhYmxlKGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgICAgICAgLy8gSWYgbG93ZXIgYm91bmQgaXMgZ3JlYXRlciB0aGFuIHRoZSB1cHBlciBib3VuZCwgdGhlbiB0aGUga2V5XG4gICAgICAgIC8vIHJhbmdlIGNhbiBuZXZlciBiZSBtYXRjaGVkLlxuICAgICAgICByZXR1cm4gaW5kZXhFbnRyeUNvbXBhcmF0b3IobG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkgPiAwO1xuICAgIH1cbiAgICBnZXRNaW5PZmZzZXRGcm9tQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApLm5leHQoZ2V0TWluT2Zmc2V0RnJvbUZpZWxkSW5kZXhlcyk7XG4gICAgfVxuICAgIGdldE1pbk9mZnNldCh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UubWFwQXJyYXkodGhpcy5nZXRTdWJUYXJnZXRzKHRhcmdldCksIChzdWJUYXJnZXQpID0+IHRoaXMuZ2V0RmllbGRJbmRleCh0cmFuc2FjdGlvbiwgc3ViVGFyZ2V0KS5uZXh0KGluZGV4ID0+IGluZGV4ID8gaW5kZXggOiBmYWlsKCkpKS5uZXh0KGdldE1pbk9mZnNldEZyb21GaWVsZEluZGV4ZXMpO1xuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBjb2xsZWN0aW9uUGFyZW50c1xuICogZG9jdW1lbnQgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3Rpb25QYXJlbnRzU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJDb2xsZWN0aW9uUGFyZW50U3RvcmUpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGluZGV4IGVudHJ5IG9iamVjdCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gaW5kZXhFbnRyaWVzU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJJbmRleEVudHJ5U3RvcmUpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGluZGV4IGNvbmZpZ3VyYXRpb24gb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBpbmRleENvbmZpZ3VyYXRpb25TdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkluZGV4Q29uZmlndXJhdGlvblN0b3JlKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBpbmRleCBzdGF0ZSBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIGluZGV4U3RhdGVTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkluZGV4U3RhdGVTdG9yZSk7XG59XG5mdW5jdGlvbiBnZXRNaW5PZmZzZXRGcm9tRmllbGRJbmRleGVzKGZpZWxkSW5kZXhlcykge1xuICAgIGhhcmRBc3NlcnQoZmllbGRJbmRleGVzLmxlbmd0aCAhPT0gMCk7XG4gICAgbGV0IG1pbk9mZnNldCA9IGZpZWxkSW5kZXhlc1swXS5pbmRleFN0YXRlLm9mZnNldDtcbiAgICBsZXQgbWF4QmF0Y2hJZCA9IG1pbk9mZnNldC5sYXJnZXN0QmF0Y2hJZDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGZpZWxkSW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBuZXdPZmZzZXQgPSBmaWVsZEluZGV4ZXNbaV0uaW5kZXhTdGF0ZS5vZmZzZXQ7XG4gICAgICAgIGlmIChpbmRleE9mZnNldENvbXBhcmF0b3IobmV3T2Zmc2V0LCBtaW5PZmZzZXQpIDwgMCkge1xuICAgICAgICAgICAgbWluT2Zmc2V0ID0gbmV3T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhCYXRjaElkIDwgbmV3T2Zmc2V0Lmxhcmdlc3RCYXRjaElkKSB7XG4gICAgICAgICAgICBtYXhCYXRjaElkID0gbmV3T2Zmc2V0Lmxhcmdlc3RCYXRjaElkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgSW5kZXhPZmZzZXQobWluT2Zmc2V0LnJlYWRUaW1lLCBtaW5PZmZzZXQuZG9jdW1lbnRLZXksIG1heEJhdGNoSWQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEZWxldGUgYSBtdXRhdGlvbiBiYXRjaCBhbmQgdGhlIGFzc29jaWF0ZWQgZG9jdW1lbnQgbXV0YXRpb25zLlxuICogQHJldHVybnMgQSBQZXJzaXN0ZW5jZVByb21pc2Ugb2YgdGhlIGRvY3VtZW50IG11dGF0aW9ucyB0aGF0IHdlcmUgcmVtb3ZlZC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTXV0YXRpb25CYXRjaCh0eG4sIHVzZXJJZCwgYmF0Y2gpIHtcbiAgICBjb25zdCBtdXRhdGlvblN0b3JlID0gdHhuLnN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcbiAgICBjb25zdCBpbmRleFR4biA9IHR4bi5zdG9yZShEYkRvY3VtZW50TXV0YXRpb25TdG9yZSk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLm9ubHkoYmF0Y2guYmF0Y2hJZCk7XG4gICAgbGV0IG51bURlbGV0ZWQgPSAwO1xuICAgIGNvbnN0IHJlbW92ZVByb21pc2UgPSBtdXRhdGlvblN0b3JlLml0ZXJhdGUoeyByYW5nZSB9LCAoa2V5LCB2YWx1ZSwgY29udHJvbCkgPT4ge1xuICAgICAgICBudW1EZWxldGVkKys7XG4gICAgICAgIHJldHVybiBjb250cm9sLmRlbGV0ZSgpO1xuICAgIH0pO1xuICAgIHByb21pc2VzLnB1c2gocmVtb3ZlUHJvbWlzZS5uZXh0KCgpID0+IHtcbiAgICAgICAgaGFyZEFzc2VydChudW1EZWxldGVkID09PSAxKTtcbiAgICB9KSk7XG4gICAgY29uc3QgcmVtb3ZlZERvY3VtZW50cyA9IFtdO1xuICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgYmF0Y2gubXV0YXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGluZGV4S2V5ID0gbmV3RGJEb2N1bWVudE11dGF0aW9uS2V5KHVzZXJJZCwgbXV0YXRpb24ua2V5LnBhdGgsIGJhdGNoLmJhdGNoSWQpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKGluZGV4VHhuLmRlbGV0ZShpbmRleEtleSkpO1xuICAgICAgICByZW1vdmVkRG9jdW1lbnRzLnB1c2gobXV0YXRpb24ua2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKS5uZXh0KCgpID0+IHJlbW92ZWREb2N1bWVudHMpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGFwcHJveGltYXRlIHNpemUgZm9yIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAqL1xuZnVuY3Rpb24gZGJEb2N1bWVudFNpemUoZG9jKSB7XG4gICAgaWYgKCFkb2MpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCB2YWx1ZTtcbiAgICBpZiAoZG9jLmRvY3VtZW50KSB7XG4gICAgICAgIHZhbHVlID0gZG9jLmRvY3VtZW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChkb2MudW5rbm93bkRvY3VtZW50KSB7XG4gICAgICAgIHZhbHVlID0gZG9jLnVua25vd25Eb2N1bWVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jLm5vRG9jdW1lbnQpIHtcbiAgICAgICAgdmFsdWUgPSBkb2Mubm9Eb2N1bWVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IGZhaWwoKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5sZW5ndGg7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogQSBtdXRhdGlvbiBxdWV1ZSBmb3IgYSBzcGVjaWZpYyB1c2VyLCBiYWNrZWQgYnkgSW5kZXhlZERCLiAqL1xuY2xhc3MgSW5kZXhlZERiTXV0YXRpb25RdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIG5vcm1hbGl6ZWQgdXNlcklkIChlLmcuIG51bGwgVUlEID0+IFwiXCIgdXNlcklkKSB1c2VkIHRvIHN0b3JlIC9cbiAgICAgKiByZXRyaWV2ZSBtdXRhdGlvbnMuXG4gICAgICovXG4gICAgdXNlcklkLCBzZXJpYWxpemVyLCBpbmRleE1hbmFnZXIsIHJlZmVyZW5jZURlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMudXNlcklkID0gdXNlcklkO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IGluZGV4TWFuYWdlcjtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZSA9IHJlZmVyZW5jZURlbGVnYXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FjaGVzIHRoZSBkb2N1bWVudCBrZXlzIGZvciBwZW5kaW5nIG11dGF0aW9uIGJhdGNoZXMuIElmIHRoZSBtdXRhdGlvblxuICAgICAgICAgKiBoYXMgYmVlbiByZW1vdmVkIGZyb20gSW5kZXhlZERiLCB0aGUgY2FjaGVkIHZhbHVlIG1heSBjb250aW51ZSB0b1xuICAgICAgICAgKiBiZSB1c2VkIHRvIHJldHJpZXZlIHRoZSBiYXRjaCdzIGRvY3VtZW50IGtleXMuIFRvIHJlbW92ZSBhIGNhY2hlZCB2YWx1ZVxuICAgICAgICAgKiBsb2NhbGx5LCBgcmVtb3ZlQ2FjaGVkTXV0YXRpb25LZXlzKClgIHNob3VsZCBiZSBpbnZva2VkIGVpdGhlciBkaXJlY3RseVxuICAgICAgICAgKiBvciB0aHJvdWdoIGByZW1vdmVNdXRhdGlvbkJhdGNoZXMoKWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdpdGggbXVsdGktdGFiLCB3aGVuIHRoZSBwcmltYXJ5IGNsaWVudCBhY2tub3dsZWRnZXMgb3IgcmVqZWN0cyBhIG11dGF0aW9uLFxuICAgICAgICAgKiB0aGlzIGNhY2hlIGlzIHVzZWQgYnkgc2Vjb25kYXJ5IGNsaWVudHMgdG8gaW52YWxpZGF0ZSB0aGUgbG9jYWxcbiAgICAgICAgICogdmlldyBvZiB0aGUgZG9jdW1lbnRzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGFmZmVjdGVkIGJ5IHRoZSBtdXRhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkuXG4gICAgICAgIHRoaXMuZG9jdW1lbnRLZXlzQnlCYXRjaElkID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgbXV0YXRpb24gcXVldWUgZm9yIHRoZSBnaXZlbiB1c2VyLlxuICAgICAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIgZm9yIHdoaWNoIHRvIGNyZWF0ZSBhIG11dGF0aW9uIHF1ZXVlLlxuICAgICAqIEBwYXJhbSBzZXJpYWxpemVyIC0gVGhlIHNlcmlhbGl6ZXIgdG8gdXNlIHdoZW4gcGVyc2lzdGluZyB0byBJbmRleGVkRGIuXG4gICAgICovXG4gICAgc3RhdGljIGZvclVzZXIodXNlciwgc2VyaWFsaXplciwgaW5kZXhNYW5hZ2VyLCByZWZlcmVuY2VEZWxlZ2F0ZSkge1xuICAgICAgICAvLyBUT0RPKG1jZyk6IEZpZ3VyZSBvdXQgd2hhdCBjb25zdHJhaW50cyB0aGVyZSBhcmUgb24gdXNlcklEc1xuICAgICAgICAvLyBJbiBwYXJ0aWN1bGFyLCBhcmUgdGhlcmUgYW55IHJlc2VydmVkIGNoYXJhY3RlcnM/IGFyZSBlbXB0eSBpZHMgYWxsb3dlZD9cbiAgICAgICAgLy8gRm9yIHRoZSBtb21lbnQgc3RvcmUgdGhlc2UgdG9nZXRoZXIgaW4gdGhlIHNhbWUgbXV0YXRpb25zIHRhYmxlIGFzc3VtaW5nXG4gICAgICAgIC8vIHRoYXQgZW1wdHkgdXNlcklEcyBhcmVuJ3QgYWxsb3dlZC5cbiAgICAgICAgaGFyZEFzc2VydCh1c2VyLnVpZCAhPT0gJycpO1xuICAgICAgICBjb25zdCB1c2VySWQgPSB1c2VyLmlzQXV0aGVudGljYXRlZCgpID8gdXNlci51aWQgOiAnJztcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleGVkRGJNdXRhdGlvblF1ZXVlKHVzZXJJZCwgc2VyaWFsaXplciwgaW5kZXhNYW5hZ2VyLCByZWZlcmVuY2VEZWxlZ2F0ZSk7XG4gICAgfVxuICAgIGNoZWNrRW1wdHkodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgbGV0IGVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGhpcy51c2VySWQsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sIFt0aGlzLnVzZXJJZCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSk7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5pdGVyYXRlKHsgaW5kZXg6IERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNJbmRleCwgcmFuZ2UgfSwgKGtleSwgdmFsdWUsIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGVtcHR5KTtcbiAgICB9XG4gICAgYWRkTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbiwgbG9jYWxXcml0ZVRpbWUsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucykge1xuICAgICAgICBjb25zdCBkb2N1bWVudFN0b3JlID0gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uU3RvcmUgPSBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIC8vIFRoZSBJbmRleGVkRGIgaW1wbGVtZW50YXRpb24gaW4gQ2hyb21lIChhbmQgRmlyZWZveCkgZG9lcyBub3QgaGFuZGxlXG4gICAgICAgIC8vIGNvbXBvdW5kIGluZGljZXMgdGhhdCBpbmNsdWRlIGF1dG8tZ2VuZXJhdGVkIGtleXMgY29ycmVjdGx5LiBUbyBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB0aGUgaW5kZXggZW50cnkgaXMgYWRkZWQgY29ycmVjdGx5IGluIGFsbCBicm93c2Vycywgd2UgcGVyZm9ybSB0d29cbiAgICAgICAgLy8gd3JpdGVzOiBUaGUgZmlyc3Qgd3JpdGUgaXMgdXNlZCB0byByZXRyaWV2ZSB0aGUgbmV4dCBhdXRvLWdlbmVyYXRlZCBCYXRjaFxuICAgICAgICAvLyBJRCwgYW5kIHRoZSBzZWNvbmQgd3JpdGUgcG9wdWxhdGVzIHRoZSBpbmRleCBhbmQgc3RvcmVzIHRoZSBhY3R1YWxcbiAgICAgICAgLy8gbXV0YXRpb24gYmF0Y2guXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NzAxOTcyXG4gICAgICAgIC8vIFdlIHdyaXRlIGFuIGVtcHR5IG9iamVjdCB0byBvYnRhaW4ga2V5XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBtdXRhdGlvblN0b3JlLmFkZCh7fSkubmV4dChiYXRjaElkID0+IHtcbiAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIGJhdGNoSWQgPT09ICdudW1iZXInKTtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gbmV3IE11dGF0aW9uQmF0Y2goYmF0Y2hJZCwgbG9jYWxXcml0ZVRpbWUsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBkYkJhdGNoID0gdG9EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCB0aGlzLnVzZXJJZCwgYmF0Y2gpO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGxldCBjb2xsZWN0aW9uUGFyZW50cyA9IG5ldyBTb3J0ZWRTZXQoKGwsIHIpID0+IHByaW1pdGl2ZUNvbXBhcmF0b3IobC5jYW5vbmljYWxTdHJpbmcoKSwgci5jYW5vbmljYWxTdHJpbmcoKSkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleEtleSA9IG5ld0RiRG9jdW1lbnRNdXRhdGlvbktleSh0aGlzLnVzZXJJZCwgbXV0YXRpb24ua2V5LnBhdGgsIGJhdGNoSWQpO1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25QYXJlbnRzID0gY29sbGVjdGlvblBhcmVudHMuYWRkKG11dGF0aW9uLmtleS5wYXRoLnBvcExhc3QoKSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChtdXRhdGlvblN0b3JlLnB1dChkYkJhdGNoKSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkb2N1bWVudFN0b3JlLnB1dChpbmRleEtleSwgRGJEb2N1bWVudE11dGF0aW9uUGxhY2Vob2xkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbGxlY3Rpb25QYXJlbnRzLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuaW5kZXhNYW5hZ2VyLmFkZFRvQ29sbGVjdGlvblBhcmVudEluZGV4KHRyYW5zYWN0aW9uLCBwYXJlbnQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWRkT25Db21taXR0ZWRMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWRbYmF0Y2hJZF0gPSBiYXRjaC5rZXlzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykubmV4dCgoKSA9PiBiYXRjaCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb29rdXBNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLCBiYXRjaElkKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5nZXQoYmF0Y2hJZClcbiAgICAgICAgICAgIC5uZXh0KGRiQmF0Y2ggPT4ge1xuICAgICAgICAgICAgaWYgKGRiQmF0Y2gpIHtcbiAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KGRiQmF0Y2gudXNlcklkID09PSB0aGlzLnVzZXJJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCBkYkJhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZG9jdW1lbnQga2V5cyBmb3IgdGhlIG11dGF0aW9uIGJhdGNoIHdpdGggdGhlIGdpdmVuIGJhdGNoSWQuXG4gICAgICogRm9yIHByaW1hcnkgY2xpZW50cywgdGhpcyBtZXRob2QgcmV0dXJucyBgbnVsbGAgYWZ0ZXJcbiAgICAgKiBgcmVtb3ZlTXV0YXRpb25CYXRjaGVzKClgIGhhcyBiZWVuIGNhbGxlZC4gU2Vjb25kYXJ5IGNsaWVudHMgcmV0dXJuIGFcbiAgICAgKiBjYWNoZWQgcmVzdWx0IHVudGlsIGByZW1vdmVDYWNoZWRNdXRhdGlvbktleXMoKWAgaXMgaW52b2tlZC5cbiAgICAgKi9cbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxuICAgIGxvb2t1cE11dGF0aW9uS2V5cyh0cmFuc2FjdGlvbiwgYmF0Y2hJZCkge1xuICAgICAgICBpZiAodGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWRbYmF0Y2hJZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmRvY3VtZW50S2V5c0J5QmF0Y2hJZFtiYXRjaElkXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb29rdXBNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLCBiYXRjaElkKS5uZXh0KGJhdGNoID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IGJhdGNoLmtleXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWRbYmF0Y2hJZF0gPSBrZXlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE5leHRNdXRhdGlvbkJhdGNoQWZ0ZXJCYXRjaElkKHRyYW5zYWN0aW9uLCBiYXRjaElkKSB7XG4gICAgICAgIGNvbnN0IG5leHRCYXRjaElkID0gYmF0Y2hJZCArIDE7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChbdGhpcy51c2VySWQsIG5leHRCYXRjaElkXSk7XG4gICAgICAgIGxldCBmb3VuZEJhdGNoID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoeyBpbmRleDogRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0luZGV4LCByYW5nZSB9LCAoa2V5LCBkYkJhdGNoLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGJCYXRjaC51c2VySWQgPT09IHRoaXMudXNlcklkKSB7XG4gICAgICAgICAgICAgICAgaGFyZEFzc2VydChkYkJhdGNoLmJhdGNoSWQgPj0gbmV4dEJhdGNoSWQpO1xuICAgICAgICAgICAgICAgIGZvdW5kQmF0Y2ggPSBmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgZGJCYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGZvdW5kQmF0Y2gpO1xuICAgIH1cbiAgICBnZXRIaWdoZXN0VW5hY2tub3dsZWRnZWRCYXRjaElkKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UudXBwZXJCb3VuZChbXG4gICAgICAgICAgICB0aGlzLnVzZXJJZCxcbiAgICAgICAgICAgIE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgICAgICBdKTtcbiAgICAgICAgbGV0IGJhdGNoSWQgPSBCQVRDSElEX1VOS05PV047XG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5pdGVyYXRlKHsgaW5kZXg6IERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNJbmRleCwgcmFuZ2UsIHJldmVyc2U6IHRydWUgfSwgKGtleSwgZGJCYXRjaCwgY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgYmF0Y2hJZCA9IGRiQmF0Y2guYmF0Y2hJZDtcbiAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gYmF0Y2hJZCk7XG4gICAgfVxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlcyh0cmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0aGlzLnVzZXJJZCwgQkFUQ0hJRF9VTktOT1dOXSwgW3RoaXMudXNlcklkLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldKTtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLmxvYWRBbGwoRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0luZGV4LCByYW5nZSlcbiAgICAgICAgICAgIC5uZXh0KGRiQmF0Y2hlcyA9PiBkYkJhdGNoZXMubWFwKGRiQmF0Y2ggPT4gZnJvbURiTXV0YXRpb25CYXRjaCh0aGlzLnNlcmlhbGl6ZXIsIGRiQmF0Y2gpKSk7XG4gICAgfVxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ0RvY3VtZW50S2V5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSkge1xuICAgICAgICAvLyBTY2FuIHRoZSBkb2N1bWVudC1tdXRhdGlvbiBpbmRleCBzdGFydGluZyB3aXRoIGEgcHJlZml4IHN0YXJ0aW5nIHdpdGhcbiAgICAgICAgLy8gdGhlIGdpdmVuIGRvY3VtZW50S2V5LlxuICAgICAgICBjb25zdCBpbmRleFByZWZpeCA9IG5ld0RiRG9jdW1lbnRNdXRhdGlvblByZWZpeEZvclBhdGgodGhpcy51c2VySWQsIGRvY3VtZW50S2V5LnBhdGgpO1xuICAgICAgICBjb25zdCBpbmRleFN0YXJ0ID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChpbmRleFByZWZpeCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50TXV0YXRpb25zU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IHJhbmdlOiBpbmRleFN0YXJ0IH0sIChpbmRleEtleSwgXywgY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3VzZXJJRCwgZW5jb2RlZFBhdGgsIGJhdGNoSWRdID0gaW5kZXhLZXk7XG4gICAgICAgICAgICAvLyBPbmx5IGNvbnNpZGVyIHJvd3MgbWF0Y2hpbmcgZXhhY3RseSB0aGUgc3BlY2lmaWMga2V5IG9mXG4gICAgICAgICAgICAvLyBpbnRlcmVzdC4gTm90ZSB0aGF0IGJlY2F1c2Ugd2Ugb3JkZXIgYnkgcGF0aCBmaXJzdCwgYW5kIHdlXG4gICAgICAgICAgICAvLyBvcmRlciB0ZXJtaW5hdG9ycyBiZWZvcmUgcGF0aCBzZXBhcmF0b3JzLCB3ZSdsbCBlbmNvdW50ZXIgYWxsXG4gICAgICAgICAgICAvLyB0aGUgaW5kZXggcm93cyBmb3IgZG9jdW1lbnRLZXkgY29udGlndW91c2x5LiBJbiBwYXJ0aWN1bGFyLCBhbGxcbiAgICAgICAgICAgIC8vIHRoZSByb3dzIGZvciBkb2N1bWVudEtleSB3aWxsIG9jY3VyIGJlZm9yZSBhbnkgcm93cyBmb3JcbiAgICAgICAgICAgIC8vIGRvY3VtZW50cyBuZXN0ZWQgaW4gYSBzdWJjb2xsZWN0aW9uIGJlbmVhdGggZG9jdW1lbnRLZXkgc28gd2VcbiAgICAgICAgICAgIC8vIGNhbiBzdG9wIGFzIHNvb24gYXMgd2UgaGl0IGFueSBzdWNoIHJvdy5cbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZWNvZGVSZXNvdXJjZVBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgICAgICAgaWYgKHVzZXJJRCAhPT0gdGhpcy51c2VySWQgfHwgIWRvY3VtZW50S2V5LnBhdGguaXNFcXVhbChwYXRoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExvb2sgdXAgdGhlIG11dGF0aW9uIGJhdGNoIGluIHRoZSBzdG9yZS5cbiAgICAgICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAuZ2V0KGJhdGNoSWQpXG4gICAgICAgICAgICAgICAgLm5leHQobXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgICAgIGlmICghbXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KG11dGF0aW9uLnVzZXJJZCA9PT0gdGhpcy51c2VySWQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgbXV0YXRpb24pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0cyk7XG4gICAgfVxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ0RvY3VtZW50S2V5cyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XG4gICAgICAgIGxldCB1bmlxdWVCYXRjaElEcyA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGRvY3VtZW50S2V5cy5mb3JFYWNoKGRvY3VtZW50S2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4U3RhcnQgPSBuZXdEYkRvY3VtZW50TXV0YXRpb25QcmVmaXhGb3JQYXRoKHRoaXMudXNlcklkLCBkb2N1bWVudEtleS5wYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChpbmRleFN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBkb2N1bWVudE11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKS5pdGVyYXRlKHsgcmFuZ2UgfSwgKGluZGV4S2V5LCBfLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3VzZXJJRCwgZW5jb2RlZFBhdGgsIGJhdGNoSURdID0gaW5kZXhLZXk7XG4gICAgICAgICAgICAgICAgLy8gT25seSBjb25zaWRlciByb3dzIG1hdGNoaW5nIGV4YWN0bHkgdGhlIHNwZWNpZmljIGtleSBvZlxuICAgICAgICAgICAgICAgIC8vIGludGVyZXN0LiBOb3RlIHRoYXQgYmVjYXVzZSB3ZSBvcmRlciBieSBwYXRoIGZpcnN0LCBhbmQgd2VcbiAgICAgICAgICAgICAgICAvLyBvcmRlciB0ZXJtaW5hdG9ycyBiZWZvcmUgcGF0aCBzZXBhcmF0b3JzLCB3ZSdsbCBlbmNvdW50ZXIgYWxsXG4gICAgICAgICAgICAgICAgLy8gdGhlIGluZGV4IHJvd3MgZm9yIGRvY3VtZW50S2V5IGNvbnRpZ3VvdXNseS4gSW4gcGFydGljdWxhciwgYWxsXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJvd3MgZm9yIGRvY3VtZW50S2V5IHdpbGwgb2NjdXIgYmVmb3JlIGFueSByb3dzIGZvclxuICAgICAgICAgICAgICAgIC8vIGRvY3VtZW50cyBuZXN0ZWQgaW4gYSBzdWJjb2xsZWN0aW9uIGJlbmVhdGggZG9jdW1lbnRLZXkgc28gd2VcbiAgICAgICAgICAgICAgICAvLyBjYW4gc3RvcCBhcyBzb29uIGFzIHdlIGhpdCBhbnkgc3VjaCByb3cuXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRlY29kZVJlc291cmNlUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJJRCAhPT0gdGhpcy51c2VySWQgfHwgIWRvY3VtZW50S2V5LnBhdGguaXNFcXVhbChwYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmlxdWVCYXRjaElEcyA9IHVuaXF1ZUJhdGNoSURzLmFkZChiYXRjaElEKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykubmV4dCgoKSA9PiB0aGlzLmxvb2t1cE11dGF0aW9uQmF0Y2hlcyh0cmFuc2FjdGlvbiwgdW5pcXVlQmF0Y2hJRHMpKTtcbiAgICB9XG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGF0aCA9IHF1ZXJ5LnBhdGg7XG4gICAgICAgIGNvbnN0IGltbWVkaWF0ZUNoaWxkcmVuTGVuZ3RoID0gcXVlcnlQYXRoLmxlbmd0aCArIDE7XG4gICAgICAgIC8vIFRPRE8obWNnKTogQWN0dWFsbHkgaW1wbGVtZW50IGEgc2luZ2xlLWNvbGxlY3Rpb24gcXVlcnlcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBpcyBhY3R1YWxseSBleGVjdXRpbmcgYW4gYW5jZXN0b3IgcXVlcnksIHRyYXZlcnNpbmcgdGhlIHdob2xlXG4gICAgICAgIC8vIHN1YnRyZWUgYmVsb3cgdGhlIGNvbGxlY3Rpb24gd2hpY2ggY2FuIGJlIGhvcnJpZmljYWxseSBpbmVmZmljaWVudCBmb3JcbiAgICAgICAgLy8gc29tZSBzdHJ1Y3R1cmVzLiBUaGUgcmlnaHQgd2F5IHRvIHNvbHZlIHRoaXMgaXMgdG8gaW1wbGVtZW50IHRoZSBmdWxsXG4gICAgICAgIC8vIHZhbHVlIGluZGV4LCBidXQgdGhhdCdzIG5vdCBpbiB0aGUgY2FyZHMgaW4gdGhlIG5lYXIgZnV0dXJlIHNvIHRoaXMgaXNcbiAgICAgICAgLy8gdGhlIGJlc3Qgd2UgY2FuIGRvIGZvciB0aGUgbW9tZW50LlxuICAgICAgICAvL1xuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCB5ZXQgaW5kZXggdGhlIGFjdHVhbCBwcm9wZXJ0aWVzIGluIHRoZSBtdXRhdGlvbnMsIG91clxuICAgICAgICAvLyBjdXJyZW50IGFwcHJvYWNoIGlzIHRvIGp1c3QgcmV0dXJuIGFsbCBtdXRhdGlvbiBiYXRjaGVzIHRoYXQgYWZmZWN0XG4gICAgICAgIC8vIGRvY3VtZW50cyBpbiB0aGUgY29sbGVjdGlvbiBiZWluZyBxdWVyaWVkLlxuICAgICAgICBjb25zdCBpbmRleFByZWZpeCA9IG5ld0RiRG9jdW1lbnRNdXRhdGlvblByZWZpeEZvclBhdGgodGhpcy51c2VySWQsIHF1ZXJ5UGF0aCk7XG4gICAgICAgIGNvbnN0IGluZGV4U3RhcnQgPSBJREJLZXlSYW5nZS5sb3dlckJvdW5kKGluZGV4UHJlZml4KTtcbiAgICAgICAgLy8gQ29sbGVjdCB1cCB1bmlxdWUgYmF0Y2hJRHMgZW5jb3VudGVyZWQgZHVyaW5nIGEgc2NhbiBvZiB0aGUgaW5kZXguIFVzZSBhXG4gICAgICAgIC8vIFNvcnRlZFNldCB0byBhY2N1bXVsYXRlIGJhdGNoIElEcyBzbyB0aGV5IGNhbiBiZSB0cmF2ZXJzZWQgaW4gb3JkZXIgaW4gYVxuICAgICAgICAvLyBzY2FuIG9mIHRoZSBtYWluIHRhYmxlLlxuICAgICAgICBsZXQgdW5pcXVlQmF0Y2hJRHMgPSBuZXcgU29ydGVkU2V0KHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5pdGVyYXRlKHsgcmFuZ2U6IGluZGV4U3RhcnQgfSwgKGluZGV4S2V5LCBfLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbdXNlcklELCBlbmNvZGVkUGF0aCwgYmF0Y2hJRF0gPSBpbmRleEtleTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZWNvZGVSZXNvdXJjZVBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgICAgICAgaWYgKHVzZXJJRCAhPT0gdGhpcy51c2VySWQgfHwgIXF1ZXJ5UGF0aC5pc1ByZWZpeE9mKHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUm93cyB3aXRoIGRvY3VtZW50IGtleXMgbW9yZSB0aGFuIG9uZSBzZWdtZW50IGxvbmdlciB0aGFuIHRoZVxuICAgICAgICAgICAgLy8gcXVlcnkgcGF0aCBjYW4ndCBiZSBtYXRjaGVzLiBGb3IgZXhhbXBsZSwgYSBxdWVyeSBvbiAncm9vbXMnXG4gICAgICAgICAgICAvLyBjYW4ndCBtYXRjaCB0aGUgZG9jdW1lbnQgL3Jvb21zL2FiYy9tZXNzYWdlcy94eXguXG4gICAgICAgICAgICAvLyBUT0RPKG1jZyk6IHdlJ2xsIG5lZWQgYSBkaWZmZXJlbnQgc2Nhbm5lciB3aGVuIHdlIGltcGxlbWVudFxuICAgICAgICAgICAgLy8gYW5jZXN0b3IgcXVlcmllcy5cbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gaW1tZWRpYXRlQ2hpbGRyZW5MZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bmlxdWVCYXRjaElEcyA9IHVuaXF1ZUJhdGNoSURzLmFkZChiYXRjaElEKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMubG9va3VwTXV0YXRpb25CYXRjaGVzKHRyYW5zYWN0aW9uLCB1bmlxdWVCYXRjaElEcykpO1xuICAgIH1cbiAgICBsb29rdXBNdXRhdGlvbkJhdGNoZXModHJhbnNhY3Rpb24sIGJhdGNoSURzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgLy8gVE9ETyhyb2Nrd29vZCk6IEltcGxlbWVudCB0aGlzIHVzaW5nIGl0ZXJhdGUuXG4gICAgICAgIGJhdGNoSURzLmZvckVhY2goYmF0Y2hJZCA9PiB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgIC5nZXQoYmF0Y2hJZClcbiAgICAgICAgICAgICAgICAubmV4dChtdXRhdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFyZEFzc2VydChtdXRhdGlvbi51c2VySWQgPT09IHRoaXMudXNlcklkKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZnJvbURiTXV0YXRpb25CYXRjaCh0aGlzLnNlcmlhbGl6ZXIsIG11dGF0aW9uKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpLm5leHQoKCkgPT4gcmVzdWx0cyk7XG4gICAgfVxuICAgIHJlbW92ZU11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGJhdGNoKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLnNpbXBsZURiVHJhbnNhY3Rpb24sIHRoaXMudXNlcklkLCBiYXRjaCkubmV4dChyZW1vdmVkRG9jdW1lbnRzID0+IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZE9uQ29tbWl0dGVkTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2FjaGVkTXV0YXRpb25LZXlzKGJhdGNoLmJhdGNoSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2gocmVtb3ZlZERvY3VtZW50cywgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZURlbGVnYXRlLm1hcmtQb3RlbnRpYWxseU9ycGhhbmVkKHRyYW5zYWN0aW9uLCBrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGNhY2hlZCBrZXlzIGZvciBhIG11dGF0aW9uIGJhdGNoLiBUaGlzIG1ldGhvZCBzaG91bGQgYmVcbiAgICAgKiBjYWxsZWQgYnkgc2Vjb25kYXJ5IGNsaWVudHMgYWZ0ZXIgdGhleSBwcm9jZXNzIG11dGF0aW9uIHVwZGF0ZXMuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgZG9lcyBub3QgaGF2ZSB0byBiZSBjYWxsZWQgZnJvbSBwcmltYXJ5IGNsaWVudHMgYXNcbiAgICAgKiB0aGUgY29ycmVzcG9uZGluZyBjYWNoZSBlbnRyaWVzIGFyZSBjbGVhcmVkIHdoZW4gYW4gYWNrbm93bGVkZ2VkIG9yXG4gICAgICogcmVqZWN0ZWQgYmF0Y2ggaXMgcmVtb3ZlZCBmcm9tIHRoZSBtdXRhdGlvbiBxdWV1ZS5cbiAgICAgKi9cbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5XG4gICAgcmVtb3ZlQ2FjaGVkTXV0YXRpb25LZXlzKGJhdGNoSWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZG9jdW1lbnRLZXlzQnlCYXRjaElkW2JhdGNoSWRdO1xuICAgIH1cbiAgICBwZXJmb3JtQ29uc2lzdGVuY3lDaGVjayh0eG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tFbXB0eSh0eG4pLm5leHQoZW1wdHkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlbXB0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlcmUgYXJlIG5vIGVudHJpZXMgaW4gdGhlIGRvY3VtZW50TXV0YXRpb25zIGluZGV4IGlmXG4gICAgICAgICAgICAvLyB0aGUgcXVldWUgaXMgZW1wdHkuXG4gICAgICAgICAgICBjb25zdCBzdGFydFJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChuZXdEYkRvY3VtZW50TXV0YXRpb25QcmVmaXhGb3JVc2VyKHRoaXMudXNlcklkKSk7XG4gICAgICAgICAgICBjb25zdCBkYW5nbGluZ011dGF0aW9uUmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50TXV0YXRpb25zU3RvcmUodHhuKVxuICAgICAgICAgICAgICAgIC5pdGVyYXRlKHsgcmFuZ2U6IHN0YXJ0UmFuZ2UgfSwgKGtleSwgXywgY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJJRCA9IGtleVswXTtcbiAgICAgICAgICAgICAgICBpZiAodXNlcklEICE9PSB0aGlzLnVzZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRlY29kZVJlc291cmNlUGF0aChrZXlbMV0pO1xuICAgICAgICAgICAgICAgICAgICBkYW5nbGluZ011dGF0aW9uUmVmZXJlbmNlcy5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZGFuZ2xpbmdNdXRhdGlvblJlZmVyZW5jZXMubGVuZ3RoID09PSAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29udGFpbnNLZXkodHhuLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uUXVldWVDb250YWluc0tleSh0eG4sIHRoaXMudXNlcklkLCBrZXkpO1xuICAgIH1cbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5IChzdGF0ZSBpcyBoZWxkIGluIG1lbW9yeSBpbiBvdGhlciBjbGllbnRzKS5cbiAgICAvKiogUmV0dXJucyB0aGUgbXV0YXRpb24gcXVldWUncyBtZXRhZGF0YSBmcm9tIEluZGV4ZWREYi4gKi9cbiAgICBnZXRNdXRhdGlvblF1ZXVlTWV0YWRhdGEodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uUXVldWVzU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuZ2V0KHRoaXMudXNlcklkKVxuICAgICAgICAgICAgLm5leHQoKG1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKG1ldGFkYXRhIHx8IHtcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHRoaXMudXNlcklkLFxuICAgICAgICAgICAgICAgIGxhc3RBY2tub3dsZWRnZWRCYXRjaElkOiBCQVRDSElEX1VOS05PV04sXG4gICAgICAgICAgICAgICAgbGFzdFN0cmVhbVRva2VuOiAnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbXV0YXRpb24gcXVldWUgZm9yIHRoZSBnaXZlbiB1c2VyIGNvbnRhaW5zIGEgcGVuZGluZ1xuICogICAgICAgICBtdXRhdGlvbiBmb3IgdGhlIGdpdmVuIGtleS5cbiAqL1xuZnVuY3Rpb24gbXV0YXRpb25RdWV1ZUNvbnRhaW5zS2V5KHR4biwgdXNlcklkLCBrZXkpIHtcbiAgICBjb25zdCBpbmRleEtleSA9IG5ld0RiRG9jdW1lbnRNdXRhdGlvblByZWZpeEZvclBhdGgodXNlcklkLCBrZXkucGF0aCk7XG4gICAgY29uc3QgZW5jb2RlZFBhdGggPSBpbmRleEtleVsxXTtcbiAgICBjb25zdCBzdGFydFJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChpbmRleEtleSk7XG4gICAgbGV0IGNvbnRhaW5zS2V5ID0gZmFsc2U7XG4gICAgcmV0dXJuIGRvY3VtZW50TXV0YXRpb25zU3RvcmUodHhuKVxuICAgICAgICAuaXRlcmF0ZSh7IHJhbmdlOiBzdGFydFJhbmdlLCBrZXlzT25seTogdHJ1ZSB9LCAoa2V5LCB2YWx1ZSwgY29udHJvbCkgPT4ge1xuICAgICAgICBjb25zdCBbdXNlcklELCBrZXlQYXRoLCAvKmJhdGNoSUQqLyBfXSA9IGtleTtcbiAgICAgICAgaWYgKHVzZXJJRCA9PT0gdXNlcklkICYmIGtleVBhdGggPT09IGVuY29kZWRQYXRoKSB7XG4gICAgICAgICAgICBjb250YWluc0tleSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbC5kb25lKCk7XG4gICAgfSlcbiAgICAgICAgLm5leHQoKCkgPT4gY29udGFpbnNLZXkpO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiBhbnkgbXV0YXRpb24gcXVldWUgY29udGFpbnMgdGhlIGdpdmVuIGRvY3VtZW50LiAqL1xuZnVuY3Rpb24gbXV0YXRpb25RdWV1ZXNDb250YWluS2V5KHR4biwgZG9jS2V5KSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgcmV0dXJuIG11dGF0aW9uUXVldWVzU3RvcmUodHhuKVxuICAgICAgICAuaXRlcmF0ZVNlcmlhbCh1c2VySWQgPT4ge1xuICAgICAgICByZXR1cm4gbXV0YXRpb25RdWV1ZUNvbnRhaW5zS2V5KHR4biwgdXNlcklkLCBkb2NLZXkpLm5leHQoY29udGFpbnNLZXkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zS2V5KSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCFjb250YWluc0tleSk7XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgICAgIC5uZXh0KCgpID0+IGZvdW5kKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBtdXRhdGlvbnMgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBtdXRhdGlvbnNTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYk11dGF0aW9uQmF0Y2hTdG9yZSk7XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgbXV0YXRpb25RdWV1ZXMgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBkb2N1bWVudE11dGF0aW9uc1N0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiRG9jdW1lbnRNdXRhdGlvblN0b3JlKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBtdXRhdGlvblF1ZXVlcyBvYmplY3Qgc3RvcmUuXG4gKi9cbmZ1bmN0aW9uIG11dGF0aW9uUXVldWVzU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJNdXRhdGlvblF1ZXVlU3RvcmUpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIE9mZnNldCB0byBlbnN1cmUgbm9uLW92ZXJsYXBwaW5nIHRhcmdldCBpZHMuICovXG5jb25zdCBPRkZTRVQgPSAyO1xuLyoqXG4gKiBHZW5lcmF0ZXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIHRhcmdldCBJRHMgZm9yIHNlbmRpbmcgdGFyZ2V0cyB0byB0aGVcbiAqIHdhdGNoIHN0cmVhbS5cbiAqXG4gKiBUaGUgY2xpZW50IGNvbnN0cnVjdHMgdHdvIGdlbmVyYXRvcnMsIG9uZSBmb3IgdGhlIHRhcmdldCBjYWNoZSwgYW5kIG9uZSBmb3JcbiAqIGZvciB0aGUgc3luYyBlbmdpbmUgKHRvIGdlbmVyYXRlIGxpbWJvIGRvY3VtZW50cyB0YXJnZXRzKS4gVGhlc2VcbiAqIGdlbmVyYXRvcnMgcHJvZHVjZSBub24tb3ZlcmxhcHBpbmcgSURzIChieSB1c2luZyBldmVuIGFuZCBvZGQgSURzXG4gKiByZXNwZWN0aXZlbHkpLlxuICpcbiAqIEJ5IHNlcGFyYXRpbmcgdGhlIHRhcmdldCBJRCBzcGFjZSwgdGhlIHF1ZXJ5IGNhY2hlIGNhbiBnZW5lcmF0ZSB0YXJnZXQgSURzXG4gKiB0aGF0IHBlcnNpc3QgYWNyb3NzIGNsaWVudCByZXN0YXJ0cywgd2hpbGUgc3luYyBlbmdpbmUgY2FuIGluZGVwZW5kZW50bHlcbiAqIGdlbmVyYXRlIGluLW1lbW9yeSB0YXJnZXQgSURzIHRoYXQgYXJlIHRyYW5zaWVudCBhbmQgY2FuIGJlIHJldXNlZCBhZnRlciBhXG4gKiByZXN0YXJ0LlxuICovXG5jbGFzcyBUYXJnZXRJZEdlbmVyYXRvciB7XG4gICAgY29uc3RydWN0b3IobGFzdElkKSB7XG4gICAgICAgIHRoaXMubGFzdElkID0gbGFzdElkO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICB0aGlzLmxhc3RJZCArPSBPRkZTRVQ7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RJZDtcbiAgICB9XG4gICAgc3RhdGljIGZvclRhcmdldENhY2hlKCkge1xuICAgICAgICAvLyBUaGUgdGFyZ2V0IGNhY2hlIGdlbmVyYXRvciBtdXN0IHJldHVybiAnMicgaW4gaXRzIGZpcnN0IGNhbGwgdG8gYG5leHQoKWBcbiAgICAgICAgLy8gYXMgdGhlcmUgaXMgbm8gZGlmZmVyZW50aWF0aW9uIGluIHRoZSBwcm90b2NvbCBsYXllciBiZXR3ZWVuIGFuIHVuc2V0XG4gICAgICAgIC8vIG51bWJlciBhbmQgdGhlIG51bWJlciAnMCcuIElmIHdlIHdlcmUgdG8gc2VudCBhIHRhcmdldCB3aXRoIHRhcmdldCBJRFxuICAgICAgICAvLyAnMCcsIHRoZSBiYWNrZW5kIHdvdWxkIGNvbnNpZGVyIGl0IHVuc2V0IGFuZCByZXBsYWNlIGl0IHdpdGggaXRzIG93biBJRC5cbiAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXRJZEdlbmVyYXRvcigyIC0gT0ZGU0VUKTtcbiAgICB9XG4gICAgc3RhdGljIGZvclN5bmNFbmdpbmUoKSB7XG4gICAgICAgIC8vIFN5bmMgZW5naW5lIGFzc2lnbnMgdGFyZ2V0IElEcyBmb3IgbGltYm8gZG9jdW1lbnQgZGV0ZWN0aW9uLlxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldElkR2VuZXJhdG9yKDEgLSBPRkZTRVQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEluZGV4ZWREYlRhcmdldENhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihyZWZlcmVuY2VEZWxlZ2F0ZSwgc2VyaWFsaXplcikge1xuICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlID0gcmVmZXJlbmNlRGVsZWdhdGU7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgfVxuICAgIC8vIFBPUlRJTkcgTk9URTogV2UgZG9uJ3QgY2FjaGUgZ2xvYmFsIG1ldGFkYXRhIGZvciB0aGUgdGFyZ2V0IGNhY2hlLCBzaW5jZVxuICAgIC8vIHNvbWUgb2YgaXQgKGluIHBhcnRpY3VsYXIgYGhpZ2hlc3RUYXJnZXRJZGApIGNhbiBiZSBtb2RpZmllZCBieSBzZWNvbmRhcnlcbiAgICAvLyB0YWJzLiBXZSBjb3VsZCBwZXJoYXBzIGJlIG1vcmUgZ3JhbnVsYXIgKGFuZCBlLmcuIHN0aWxsIGNhY2hlXG4gICAgLy8gYGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb25gIGluIG1lbW9yeSkgYnV0IGZvciBzaW1wbGljaXR5IHdlIGN1cnJlbnRseSBnb1xuICAgIC8vIHRvIEluZGV4ZWREYiB3aGVuZXZlciB3ZSBuZWVkIHRvIHJlYWQgbWV0YWRhdGEuIFdlIGNhbiByZXZpc2l0IGlmIGl0IHR1cm5zXG4gICAgLy8gb3V0IHRvIGhhdmUgYSBtZWFuaW5nZnVsIHBlcmZvcm1hbmNlIGltcGFjdC5cbiAgICBhbGxvY2F0ZVRhcmdldElkKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldHJpZXZlTWV0YWRhdGEodHJhbnNhY3Rpb24pLm5leHQobWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0SWRHZW5lcmF0b3IgPSBuZXcgVGFyZ2V0SWRHZW5lcmF0b3IobWV0YWRhdGEuaGlnaGVzdFRhcmdldElkKTtcbiAgICAgICAgICAgIG1ldGFkYXRhLmhpZ2hlc3RUYXJnZXRJZCA9IHRhcmdldElkR2VuZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpLm5leHQoKCkgPT4gbWV0YWRhdGEuaGlnaGVzdFRhcmdldElkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gU25hcHNob3RWZXJzaW9uLmZyb21UaW1lc3RhbXAobmV3IFRpbWVzdGFtcChtZXRhZGF0YS5sYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uLnNlY29uZHMsIG1ldGFkYXRhLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24ubmFub3NlY29uZHMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEhpZ2hlc3RTZXF1ZW5jZU51bWJlcih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KHRhcmdldEdsb2JhbCA9PiB0YXJnZXRHbG9iYWwuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyKTtcbiAgICB9XG4gICAgc2V0VGFyZ2V0c01ldGFkYXRhKHRyYW5zYWN0aW9uLCBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIsIGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPSBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICBpZiAobGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbikge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPVxuICAgICAgICAgICAgICAgICAgICBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uLnRvVGltZXN0YW1wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyID4gbWV0YWRhdGEuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyID0gaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBtZXRhZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGRUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhdmVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldHJpZXZlTWV0YWRhdGEodHJhbnNhY3Rpb24pLm5leHQobWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLnRhcmdldENvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNZXRhZGF0YUZyb21UYXJnZXREYXRhKHRhcmdldERhdGEsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlTWV0YWRhdGEodHJhbnNhY3Rpb24sIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zYXZlVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSk7XG4gICAgfVxuICAgIHJlbW92ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHJhbnNhY3Rpb24sIHRhcmdldERhdGEudGFyZ2V0SWQpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB0YXJnZXRzU3RvcmUodHJhbnNhY3Rpb24pLmRlbGV0ZSh0YXJnZXREYXRhLnRhcmdldElkKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikpXG4gICAgICAgICAgICAubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICBoYXJkQXNzZXJ0KG1ldGFkYXRhLnRhcmdldENvdW50ID4gMCk7XG4gICAgICAgICAgICBtZXRhZGF0YS50YXJnZXRDb3VudCAtPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBtZXRhZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcm9wcyBhbnkgdGFyZ2V0cyB3aXRoIHNlcXVlbmNlIG51bWJlciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHVwcGVyIGJvdW5kLCBleGNlcHRpbmcgdGhvc2VcbiAgICAgKiBwcmVzZW50IGluIGBhY3RpdmVUYXJnZXRJZHNgLiBEb2N1bWVudCBhc3NvY2lhdGlvbnMgZm9yIHRoZSByZW1vdmVkIHRhcmdldHMgYXJlIGFsc28gcmVtb3ZlZC5cbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGFyZ2V0cyByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0eG4pXG4gICAgICAgICAgICAuaXRlcmF0ZSgoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IGZyb21EYlRhcmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlciA8PSB1cHBlckJvdW5kICYmXG4gICAgICAgICAgICAgICAgYWN0aXZlVGFyZ2V0SWRzLmdldCh0YXJnZXREYXRhLnRhcmdldElkKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnJlbW92ZVRhcmdldERhdGEodHhuLCB0YXJnZXREYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBjb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgcHJvdmlkZWQgZnVuY3Rpb24gd2l0aCBlYWNoIGBUYXJnZXREYXRhYCB0aGF0IHdlIGhhdmUgY2FjaGVkLlxuICAgICAqL1xuICAgIGZvckVhY2hUYXJnZXQodHhuLCBmKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRzU3RvcmUodHhuKS5pdGVyYXRlKChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gZnJvbURiVGFyZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGYodGFyZ2V0RGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUYXJnZXRTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5nZXQoRGJUYXJnZXRHbG9iYWxLZXkpXG4gICAgICAgICAgICAubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICBoYXJkQXNzZXJ0KG1ldGFkYXRhICE9PSBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNhdmVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRhcmdldFN0b3JlKHRyYW5zYWN0aW9uKS5wdXQoRGJUYXJnZXRHbG9iYWxLZXksIG1ldGFkYXRhKTtcbiAgICB9XG4gICAgc2F2ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0cmFuc2FjdGlvbikucHV0KHRvRGJUYXJnZXQodGhpcy5zZXJpYWxpemVyLCB0YXJnZXREYXRhKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluLXBsYWNlIHVwZGF0ZXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIHRvIGFjY291bnQgZm9yIHZhbHVlcyBpbiB0aGUgZ2l2ZW5cbiAgICAgKiBUYXJnZXREYXRhLiBTYXZpbmcgaXMgZG9uZSBzZXBhcmF0ZWx5LiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgd2VyZSBhbnlcbiAgICAgKiBjaGFuZ2VzIHRvIHRoZSBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICB1cGRhdGVNZXRhZGF0YUZyb21UYXJnZXREYXRhKHRhcmdldERhdGEsIG1ldGFkYXRhKSB7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0YXJnZXREYXRhLnRhcmdldElkID4gbWV0YWRhdGEuaGlnaGVzdFRhcmdldElkKSB7XG4gICAgICAgICAgICBtZXRhZGF0YS5oaWdoZXN0VGFyZ2V0SWQgPSB0YXJnZXREYXRhLnRhcmdldElkO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIgPiBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhLmhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciA9IHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0Q291bnQodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dChtZXRhZGF0YSA9PiBtZXRhZGF0YS50YXJnZXRDb3VudCk7XG4gICAgfVxuICAgIGdldFRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldCkge1xuICAgICAgICAvLyBJdGVyYXRpbmcgYnkgdGhlIGNhbm9uaWNhbElkIG1heSB5aWVsZCBtb3JlIHRoYW4gb25lIHJlc3VsdCBiZWNhdXNlXG4gICAgICAgIC8vIGNhbm9uaWNhbElkIHZhbHVlcyBhcmUgbm90IHJlcXVpcmVkIHRvIGJlIHVuaXF1ZSBwZXIgdGFyZ2V0LiBUaGlzIHF1ZXJ5XG4gICAgICAgIC8vIGRlcGVuZHMgb24gdGhlIHF1ZXJ5VGFyZ2V0cyBpbmRleCB0byBiZSBlZmZpY2llbnQuXG4gICAgICAgIGNvbnN0IGNhbm9uaWNhbElkID0gY2Fub25pZnlUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbY2Fub25pY2FsSWQsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sIFtjYW5vbmljYWxJZCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGFyZ2V0c1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoeyByYW5nZSwgaW5kZXg6IERiVGFyZ2V0UXVlcnlUYXJnZXRzSW5kZXhOYW1lIH0sIChrZXksIHZhbHVlLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb3VuZCA9IGZyb21EYlRhcmdldCh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBBZnRlciBmaW5kaW5nIGEgcG90ZW50aWFsIG1hdGNoLCBjaGVjayB0aGF0IHRoZSB0YXJnZXQgaXNcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGVxdWFsIHRvIHRoZSByZXF1ZXN0ZWQgdGFyZ2V0LlxuICAgICAgICAgICAgaWYgKHRhcmdldEVxdWFscyh0YXJnZXQsIGZvdW5kLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmb3VuZDtcbiAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHJlc3VsdCk7XG4gICAgfVxuICAgIGFkZE1hdGNoaW5nS2V5cyh0eG4sIGtleXMsIHRhcmdldElkKSB7XG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogVGhlIHJldmVyc2UgaW5kZXggKGRvY3VtZW50c1RhcmdldHMpIGlzIG1haW50YWluZWQgYnlcbiAgICAgICAgLy8gSW5kZXhlZERiLlxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBjb25zdCBzdG9yZSA9IGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZW5jb2RlUmVzb3VyY2VQYXRoKGtleS5wYXRoKTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goc3RvcmUucHV0KHsgdGFyZ2V0SWQsIHBhdGggfSkpO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnJlZmVyZW5jZURlbGVnYXRlLmFkZFJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XG4gICAgfVxuICAgIHJlbW92ZU1hdGNoaW5nS2V5cyh0eG4sIGtleXMsIHRhcmdldElkKSB7XG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogVGhlIHJldmVyc2UgaW5kZXggKGRvY3VtZW50c1RhcmdldHMpIGlzIG1haW50YWluZWQgYnlcbiAgICAgICAgLy8gSW5kZXhlZERiLlxuICAgICAgICBjb25zdCBzdG9yZSA9IGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGtleXMsIChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBlbmNvZGVSZXNvdXJjZVBhdGgoa2V5LnBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKFtcbiAgICAgICAgICAgICAgICBzdG9yZS5kZWxldGUoW3RhcmdldElkLCBwYXRoXSksXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZS5yZW1vdmVSZWZlcmVuY2UodHhuLCB0YXJnZXRJZCwga2V5KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0eG4sIHRhcmdldElkKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pO1xuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0YXJnZXRJZF0sIFt0YXJnZXRJZCArIDFdLCBcbiAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlLmRlbGV0ZShyYW5nZSk7XG4gICAgfVxuICAgIGdldE1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0SWQpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGFyZ2V0SWRdLCBbdGFyZ2V0SWQgKyAxXSwgXG4gICAgICAgIC8qbG93ZXJPcGVuPSovIGZhbHNlLCBcbiAgICAgICAgLyp1cHBlck9wZW49Ki8gdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IHJhbmdlLCBrZXlzT25seTogdHJ1ZSB9LCAoa2V5LCBfLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZGVjb2RlUmVzb3VyY2VQYXRoKGtleVsxXSk7XG4gICAgICAgICAgICBjb25zdCBkb2NLZXkgPSBuZXcgRG9jdW1lbnRLZXkocGF0aCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGRvY0tleSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiByZXN1bHQpO1xuICAgIH1cbiAgICBjb250YWluc0tleSh0eG4sIGtleSkge1xuICAgICAgICBjb25zdCBwYXRoID0gZW5jb2RlUmVzb3VyY2VQYXRoKGtleS5wYXRoKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbcGF0aF0sIFtpbW1lZGlhdGVTdWNjZXNzb3IocGF0aCldLCBcbiAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxuICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKVxuICAgICAgICAgICAgLml0ZXJhdGUoe1xuICAgICAgICAgICAgaW5kZXg6IERiVGFyZ2V0RG9jdW1lbnREb2N1bWVudFRhcmdldHNJbmRleCxcbiAgICAgICAgICAgIGtleXNPbmx5OiB0cnVlLFxuICAgICAgICAgICAgcmFuZ2VcbiAgICAgICAgfSwgKFt0YXJnZXRJZCwgcGF0aF0sIF8sIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIC8vIEhhdmluZyBhIHNlbnRpbmVsIHJvdyBmb3IgYSBkb2N1bWVudCBkb2VzIG5vdCBjb3VudCBhcyBjb250YWluaW5nIHRoYXQgZG9jdW1lbnQ7XG4gICAgICAgICAgICAvLyBGb3IgdGhlIHRhcmdldCBjYWNoZSwgY29udGFpbmluZyB0aGUgZG9jdW1lbnQgbWVhbnMgdGhlIGRvY3VtZW50IGlzIHBhcnQgb2Ygc29tZVxuICAgICAgICAgICAgLy8gdGFyZ2V0LlxuICAgICAgICAgICAgaWYgKHRhcmdldElkICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNvdW50ID4gMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIGEgVGFyZ2V0RGF0YSBlbnRyeSBieSB0YXJnZXQgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0SWQgLSBUaGUgdGFyZ2V0IElEIG9mIHRoZSBUYXJnZXREYXRhIGVudHJ5IHRvIGxvb2sgdXAuXG4gICAgICogQHJldHVybnMgVGhlIGNhY2hlZCBUYXJnZXREYXRhIGVudHJ5LCBvciBudWxsIGlmIHRoZSBjYWNoZSBoYXMgbm8gZW50cnkgZm9yXG4gICAgICogdGhlIHRhcmdldC5cbiAgICAgKi9cbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxuICAgIGdldFRhcmdldERhdGFGb3JUYXJnZXQodHJhbnNhY3Rpb24sIHRhcmdldElkKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRzU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuZ2V0KHRhcmdldElkKVxuICAgICAgICAgICAgLm5leHQoZm91bmQgPT4ge1xuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYlRhcmdldChmb3VuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIHF1ZXJpZXMgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiB0YXJnZXRzU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJUYXJnZXRTdG9yZSk7XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgdGFyZ2V0IGdsb2JhbHMgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBnbG9iYWxUYXJnZXRTdG9yZSh0eG4pIHtcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYlRhcmdldEdsb2JhbFN0b3JlKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBkb2N1bWVudCB0YXJnZXQgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBkb2N1bWVudFRhcmdldFN0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiVGFyZ2V0RG9jdW1lbnRTdG9yZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBHQ19ESURfTk9UX1JVTiA9IHtcbiAgICBkaWRSdW46IGZhbHNlLFxuICAgIHNlcXVlbmNlTnVtYmVyc0NvbGxlY3RlZDogMCxcbiAgICB0YXJnZXRzUmVtb3ZlZDogMCxcbiAgICBkb2N1bWVudHNSZW1vdmVkOiAwXG59O1xuY29uc3QgTFJVX0NPTExFQ1RJT05fRElTQUJMRUQgPSAtMTtcbmNvbnN0IExSVV9ERUZBVUxUX0NBQ0hFX1NJWkVfQllURVMgPSA0MCAqIDEwMjQgKiAxMDI0O1xuY2xhc3MgTHJ1UGFyYW1zIHtcbiAgICBzdGF0aWMgd2l0aENhY2hlU2l6ZShjYWNoZVNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMcnVQYXJhbXMoY2FjaGVTaXplLCBMcnVQYXJhbXMuREVGQVVMVF9DT0xMRUNUSU9OX1BFUkNFTlRJTEUsIExydVBhcmFtcy5ERUZBVUxUX01BWF9TRVFVRU5DRV9OVU1CRVJTX1RPX0NPTExFQ1QpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBXaGVuIHdlIGF0dGVtcHQgdG8gY29sbGVjdCwgd2Ugd2lsbCBvbmx5IGRvIHNvIGlmIHRoZSBjYWNoZSBzaXplIGlzIGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAgLy8gdGhyZXNob2xkLiBQYXNzaW5nIGBDT0xMRUNUSU9OX0RJU0FCTEVEYCBoZXJlIHdpbGwgY2F1c2UgY29sbGVjdGlvbiB0byBhbHdheXMgYmUgc2tpcHBlZC5cbiAgICBjYWNoZVNpemVDb2xsZWN0aW9uVGhyZXNob2xkLCBcbiAgICAvLyBUaGUgcGVyY2VudGFnZSBvZiBzZXF1ZW5jZSBudW1iZXJzIHRoYXQgd2Ugd2lsbCBhdHRlbXB0IHRvIGNvbGxlY3RcbiAgICBwZXJjZW50aWxlVG9Db2xsZWN0LCBcbiAgICAvLyBBIGNhcCBvbiB0aGUgdG90YWwgbnVtYmVyIG9mIHNlcXVlbmNlIG51bWJlcnMgdGhhdCB3aWxsIGJlIGNvbGxlY3RlZC4gVGhpcyBwcmV2ZW50c1xuICAgIC8vIHVzIGZyb20gY29sbGVjdGluZyBhIGh1Z2UgbnVtYmVyIG9mIHNlcXVlbmNlIG51bWJlcnMgaWYgdGhlIGNhY2hlIGhhcyBncm93biB2ZXJ5IGxhcmdlLlxuICAgIG1heGltdW1TZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QpIHtcbiAgICAgICAgdGhpcy5jYWNoZVNpemVDb2xsZWN0aW9uVGhyZXNob2xkID0gY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZDtcbiAgICAgICAgdGhpcy5wZXJjZW50aWxlVG9Db2xsZWN0ID0gcGVyY2VudGlsZVRvQ29sbGVjdDtcbiAgICAgICAgdGhpcy5tYXhpbXVtU2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0ID0gbWF4aW11bVNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdDtcbiAgICB9XG59XG5McnVQYXJhbXMuREVGQVVMVF9DT0xMRUNUSU9OX1BFUkNFTlRJTEUgPSAxMDtcbkxydVBhcmFtcy5ERUZBVUxUX01BWF9TRVFVRU5DRV9OVU1CRVJTX1RPX0NPTExFQ1QgPSAxMDAwO1xuTHJ1UGFyYW1zLkRFRkFVTFQgPSBuZXcgTHJ1UGFyYW1zKExSVV9ERUZBVUxUX0NBQ0hFX1NJWkVfQllURVMsIExydVBhcmFtcy5ERUZBVUxUX0NPTExFQ1RJT05fUEVSQ0VOVElMRSwgTHJ1UGFyYW1zLkRFRkFVTFRfTUFYX1NFUVVFTkNFX05VTUJFUlNfVE9fQ09MTEVDVCk7XG5McnVQYXJhbXMuRElTQUJMRUQgPSBuZXcgTHJ1UGFyYW1zKExSVV9DT0xMRUNUSU9OX0RJU0FCTEVELCAwLCAwKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckZSA9ICdMcnVHYXJiYWdlQ29sbGVjdG9yJztcbmNvbnN0IExSVV9NSU5JTVVNX0NBQ0hFX1NJWkVfQllURVMgPSAxICogMTAyNCAqIDEwMjQ7XG4vKiogSG93IGxvbmcgd2Ugd2FpdCB0byB0cnkgcnVubmluZyBMUlUgR0MgYWZ0ZXIgU0RLIGluaXRpYWxpemF0aW9uLiAqL1xuY29uc3QgSU5JVElBTF9HQ19ERUxBWV9NUyA9IDEgKiA2MCAqIDEwMDA7XG4vKiogTWluaW11bSBhbW91bnQgb2YgdGltZSBiZXR3ZWVuIEdDIGNoZWNrcywgYWZ0ZXIgdGhlIGZpcnN0IG9uZS4gKi9cbmNvbnN0IFJFR1VMQVJfR0NfREVMQVlfTVMgPSA1ICogNjAgKiAxMDAwO1xuZnVuY3Rpb24gYnVmZmVyRW50cnlDb21wYXJhdG9yKFthU2VxdWVuY2UsIGFJbmRleF0sIFtiU2VxdWVuY2UsIGJJbmRleF0pIHtcbiAgICBjb25zdCBzZXFDbXAgPSBwcmltaXRpdmVDb21wYXJhdG9yKGFTZXF1ZW5jZSwgYlNlcXVlbmNlKTtcbiAgICBpZiAoc2VxQ21wID09PSAwKSB7XG4gICAgICAgIC8vIFRoaXMgb3JkZXIgZG9lc24ndCBtYXR0ZXIsIGJ1dCB3ZSBjYW4gYmlhcyBhZ2FpbnN0IGNodXJuIGJ5IHNvcnRpbmdcbiAgICAgICAgLy8gZW50cmllcyBjcmVhdGVkIGVhcmxpZXIgYXMgbGVzcyB0aGFuIG5ld2VyIGVudHJpZXMuXG4gICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGFJbmRleCwgYkluZGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzZXFDbXA7XG4gICAgfVxufVxuLyoqXG4gKiBVc2VkIHRvIGNhbGN1bGF0ZSB0aGUgbnRoIHNlcXVlbmNlIG51bWJlci4gS2VlcHMgYSByb2xsaW5nIGJ1ZmZlciBvZiB0aGVcbiAqIGxvd2VzdCBuIHZhbHVlcyBwYXNzZWQgdG8gYGFkZEVsZW1lbnRgLCBhbmQgZmluYWxseSByZXBvcnRzIHRoZSBsYXJnZXN0IG9mXG4gKiB0aGVtIGluIGBtYXhWYWx1ZWAuXG4gKi9cbmNsYXNzIFJvbGxpbmdTZXF1ZW5jZU51bWJlckJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IobWF4RWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5tYXhFbGVtZW50cyA9IG1heEVsZW1lbnRzO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBTb3J0ZWRTZXQoYnVmZmVyRW50cnlDb21wYXJhdG9yKTtcbiAgICAgICAgdGhpcy5wcmV2aW91c0luZGV4ID0gMDtcbiAgICB9XG4gICAgbmV4dEluZGV4KCkge1xuICAgICAgICByZXR1cm4gKyt0aGlzLnByZXZpb3VzSW5kZXg7XG4gICAgfVxuICAgIGFkZEVsZW1lbnQoc2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBbc2VxdWVuY2VOdW1iZXIsIHRoaXMubmV4dEluZGV4KCldO1xuICAgICAgICBpZiAodGhpcy5idWZmZXIuc2l6ZSA8IHRoaXMubWF4RWxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuYWRkKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hlc3RWYWx1ZSA9IHRoaXMuYnVmZmVyLmxhc3QoKTtcbiAgICAgICAgICAgIGlmIChidWZmZXJFbnRyeUNvbXBhcmF0b3IoZW50cnksIGhpZ2hlc3RWYWx1ZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5kZWxldGUoaGlnaGVzdFZhbHVlKS5hZGQoZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgLy8gR3VhcmFudGVlZCB0byBiZSBub24tZW1wdHkuIElmIHdlIGRlY2lkZSB3ZSBhcmUgbm90IGNvbGxlY3RpbmcgYW55XG4gICAgICAgIC8vIHNlcXVlbmNlIG51bWJlcnMsIG50aFNlcXVlbmNlTnVtYmVyIGJlbG93IHNob3J0LWNpcmN1aXRzLiBJZiB3ZSBoYXZlXG4gICAgICAgIC8vIGRlY2lkZWQgdGhhdCB3ZSBhcmUgY29sbGVjdGluZyBuIHNlcXVlbmNlIG51bWJlcnMsIGl0J3MgYmVjYXVzZSBuIGlzIHNvbWVcbiAgICAgICAgLy8gcGVyY2VudGFnZSBvZiB0aGUgZXhpc3Rpbmcgc2VxdWVuY2UgbnVtYmVycy4gVGhhdCBtZWFucyB3ZSBzaG91bGQgbmV2ZXJcbiAgICAgICAgLy8gYmUgaW4gYSBzaXR1YXRpb24gd2hlcmUgd2UgYXJlIGNvbGxlY3Rpbmcgc2VxdWVuY2UgbnVtYmVycyBidXQgZG9uJ3RcbiAgICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhbnkuXG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sYXN0KClbMF07XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgc2NoZWR1bGluZyBvZiBMUlUgZ2FyYmFnZSBjb2xsZWN0aW9uLiBJdCBoYW5kbGVzIGNoZWNraW5nXG4gKiB3aGV0aGVyIG9yIG5vdCBHQyBpcyBlbmFibGVkLCBhcyB3ZWxsIGFzIHdoaWNoIGRlbGF5IHRvIHVzZSBiZWZvcmUgdGhlIG5leHQgcnVuLlxuICovXG5jbGFzcyBMcnVTY2hlZHVsZXIge1xuICAgIGNvbnN0cnVjdG9yKGdhcmJhZ2VDb2xsZWN0b3IsIGFzeW5jUXVldWUsIGxvY2FsU3RvcmUpIHtcbiAgICAgICAgdGhpcy5nYXJiYWdlQ29sbGVjdG9yID0gZ2FyYmFnZUNvbGxlY3RvcjtcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcbiAgICAgICAgdGhpcy5sb2NhbFN0b3JlID0gbG9jYWxTdG9yZTtcbiAgICAgICAgdGhpcy5nY1Rhc2sgPSBudWxsO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2FyYmFnZUNvbGxlY3Rvci5wYXJhbXMuY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZCAhPT1cbiAgICAgICAgICAgIExSVV9DT0xMRUNUSU9OX0RJU0FCTEVEKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlR0MoSU5JVElBTF9HQ19ERUxBWV9NUyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2NUYXNrKSB7XG4gICAgICAgICAgICB0aGlzLmdjVGFzay5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuZ2NUYXNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2NUYXNrICE9PSBudWxsO1xuICAgIH1cbiAgICBzY2hlZHVsZUdDKGRlbGF5KSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckZSwgYEdhcmJhZ2UgY29sbGVjdGlvbiBzY2hlZHVsZWQgaW4gJHtkZWxheX1tc2ApO1xuICAgICAgICB0aGlzLmdjVGFzayA9IHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheShcImxydV9nYXJiYWdlX2NvbGxlY3Rpb25cIiAvKiBUaW1lcklkLkxydUdhcmJhZ2VDb2xsZWN0aW9uICovLCBkZWxheSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5nY1Rhc2sgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmxvY2FsU3RvcmUuY29sbGVjdEdhcmJhZ2UodGhpcy5nYXJiYWdlQ29sbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGUsICdJZ25vcmluZyBJbmRleGVkREIgZXJyb3IgZHVyaW5nIGdhcmJhZ2UgY29sbGVjdGlvbjogJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zY2hlZHVsZUdDKFJFR1VMQVJfR0NfREVMQVlfTVMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEltcGxlbWVudHMgdGhlIHN0ZXBzIGZvciBMUlUgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICovXG5jbGFzcyBMcnVHYXJiYWdlQ29sbGVjdG9ySW1wbCB7XG4gICAgY29uc3RydWN0b3IoZGVsZWdhdGUsIHBhcmFtcykge1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIH1cbiAgICBjYWxjdWxhdGVUYXJnZXRDb3VudCh0eG4sIHBlcmNlbnRpbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuZ2V0U2VxdWVuY2VOdW1iZXJDb3VudCh0eG4pLm5leHQodGFyZ2V0Q291bnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHBlcmNlbnRpbGUgLyAxMDAuMCkgKiB0YXJnZXRDb3VudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBudGhTZXF1ZW5jZU51bWJlcih0eG4sIG4pIHtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgUm9sbGluZ1NlcXVlbmNlTnVtYmVyQnVmZmVyKG4pO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZVxuICAgICAgICAgICAgLmZvckVhY2hUYXJnZXQodHhuLCB0YXJnZXQgPT4gYnVmZmVyLmFkZEVsZW1lbnQodGFyZ2V0LnNlcXVlbmNlTnVtYmVyKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmZvckVhY2hPcnBoYW5lZERvY3VtZW50U2VxdWVuY2VOdW1iZXIodHhuLCBzZXF1ZW5jZU51bWJlciA9PiBidWZmZXIuYWRkRWxlbWVudChzZXF1ZW5jZU51bWJlcikpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gYnVmZmVyLm1heFZhbHVlKTtcbiAgICB9XG4gICAgcmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5yZW1vdmVUYXJnZXRzKHR4biwgdXBwZXJCb3VuZCwgYWN0aXZlVGFyZ2V0SWRzKTtcbiAgICB9XG4gICAgcmVtb3ZlT3JwaGFuZWREb2N1bWVudHModHhuLCB1cHBlckJvdW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnJlbW92ZU9ycGhhbmVkRG9jdW1lbnRzKHR4biwgdXBwZXJCb3VuZCk7XG4gICAgfVxuICAgIGNvbGxlY3QodHhuLCBhY3RpdmVUYXJnZXRJZHMpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGQgPT09IExSVV9DT0xMRUNUSU9OX0RJU0FCTEVEKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZygnTHJ1R2FyYmFnZUNvbGxlY3RvcicsICdHYXJiYWdlIGNvbGxlY3Rpb24gc2tpcHBlZDsgZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShHQ19ESURfTk9UX1JVTik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FjaGVTaXplKHR4bikubmV4dChjYWNoZVNpemUgPT4ge1xuICAgICAgICAgICAgaWYgKGNhY2hlU2l6ZSA8IHRoaXMucGFyYW1zLmNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnTHJ1R2FyYmFnZUNvbGxlY3RvcicsIGBHYXJiYWdlIGNvbGxlY3Rpb24gc2tpcHBlZDsgQ2FjaGUgc2l6ZSAke2NhY2hlU2l6ZX0gYCArXG4gICAgICAgICAgICAgICAgICAgIGBpcyBsb3dlciB0aGFuIHRocmVzaG9sZCAke3RoaXMucGFyYW1zLmNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEdDX0RJRF9OT1RfUlVOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVuR2FyYmFnZUNvbGxlY3Rpb24odHhuLCBhY3RpdmVUYXJnZXRJZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q2FjaGVTaXplKHR4bikge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5nZXRDYWNoZVNpemUodHhuKTtcbiAgICB9XG4gICAgcnVuR2FyYmFnZUNvbGxlY3Rpb24odHhuLCBhY3RpdmVUYXJnZXRJZHMpIHtcbiAgICAgICAgbGV0IHVwcGVyQm91bmRTZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgbGV0IHNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCwgdGFyZ2V0c1JlbW92ZWQ7XG4gICAgICAgIC8vIFRpbWVzdGFtcHMgZm9yIHZhcmlvdXMgcGllY2VzIG9mIHRoZSBwcm9jZXNzXG4gICAgICAgIGxldCBjb3VudGVkVGFyZ2V0c1RzLCBmb3VuZFVwcGVyQm91bmRUcywgcmVtb3ZlZFRhcmdldHNUcywgcmVtb3ZlZERvY3VtZW50c1RzO1xuICAgICAgICBjb25zdCBzdGFydFRzID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlVGFyZ2V0Q291bnQodHhuLCB0aGlzLnBhcmFtcy5wZXJjZW50aWxlVG9Db2xsZWN0KVxuICAgICAgICAgICAgLm5leHQoc2VxdWVuY2VOdW1iZXJzID0+IHtcbiAgICAgICAgICAgIC8vIENhcCBhdCB0aGUgY29uZmlndXJlZCBtYXhcbiAgICAgICAgICAgIGlmIChzZXF1ZW5jZU51bWJlcnMgPiB0aGlzLnBhcmFtcy5tYXhpbXVtU2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0KSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0xydUdhcmJhZ2VDb2xsZWN0b3InLCAnQ2FwcGluZyBzZXF1ZW5jZSBudW1iZXJzIHRvIGNvbGxlY3QgZG93biAnICtcbiAgICAgICAgICAgICAgICAgICAgYHRvIHRoZSBtYXhpbXVtIG9mICR7dGhpcy5wYXJhbXMubWF4aW11bVNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdH0gYCArXG4gICAgICAgICAgICAgICAgICAgIGBmcm9tICR7c2VxdWVuY2VOdW1iZXJzfWApO1xuICAgICAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zLm1heGltdW1TZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QgPSBzZXF1ZW5jZU51bWJlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVkVGFyZ2V0c1RzID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm50aFNlcXVlbmNlTnVtYmVyKHR4biwgc2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KHVwcGVyQm91bmQgPT4ge1xuICAgICAgICAgICAgdXBwZXJCb3VuZFNlcXVlbmNlTnVtYmVyID0gdXBwZXJCb3VuZDtcbiAgICAgICAgICAgIGZvdW5kVXBwZXJCb3VuZFRzID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kU2VxdWVuY2VOdW1iZXIsIGFjdGl2ZVRhcmdldElkcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChudW1UYXJnZXRzUmVtb3ZlZCA9PiB7XG4gICAgICAgICAgICB0YXJnZXRzUmVtb3ZlZCA9IG51bVRhcmdldHNSZW1vdmVkO1xuICAgICAgICAgICAgcmVtb3ZlZFRhcmdldHNUcyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVPcnBoYW5lZERvY3VtZW50cyh0eG4sIHVwcGVyQm91bmRTZXF1ZW5jZU51bWJlcik7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudHNSZW1vdmVkID0+IHtcbiAgICAgICAgICAgIHJlbW92ZWREb2N1bWVudHNUcyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBpZiAoZ2V0TG9nTGV2ZWwoKSA8PSBMb2dMZXZlbC5ERUJVRykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2MgPSAnTFJVIEdhcmJhZ2UgQ29sbGVjdGlvblxcbicgK1xuICAgICAgICAgICAgICAgICAgICBgXFx0Q291bnRlZCB0YXJnZXRzIGluICR7Y291bnRlZFRhcmdldHNUcyAtIHN0YXJ0VHN9bXNcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYFxcdERldGVybWluZWQgbGVhc3QgcmVjZW50bHkgdXNlZCAke3NlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdH0gaW4gYCArXG4gICAgICAgICAgICAgICAgICAgIGAke2ZvdW5kVXBwZXJCb3VuZFRzIC0gY291bnRlZFRhcmdldHNUc31tc1xcbmAgK1xuICAgICAgICAgICAgICAgICAgICBgXFx0UmVtb3ZlZCAke3RhcmdldHNSZW1vdmVkfSB0YXJnZXRzIGluIGAgK1xuICAgICAgICAgICAgICAgICAgICBgJHtyZW1vdmVkVGFyZ2V0c1RzIC0gZm91bmRVcHBlckJvdW5kVHN9bXNcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYFxcdFJlbW92ZWQgJHtkb2N1bWVudHNSZW1vdmVkfSBkb2N1bWVudHMgaW4gYCArXG4gICAgICAgICAgICAgICAgICAgIGAke3JlbW92ZWREb2N1bWVudHNUcyAtIHJlbW92ZWRUYXJnZXRzVHN9bXNcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYFRvdGFsIER1cmF0aW9uOiAke3JlbW92ZWREb2N1bWVudHNUcyAtIHN0YXJ0VHN9bXNgO1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdMcnVHYXJiYWdlQ29sbGVjdG9yJywgZGVzYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgIGRpZFJ1bjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZU51bWJlcnNDb2xsZWN0ZWQ6IHNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCxcbiAgICAgICAgICAgICAgICB0YXJnZXRzUmVtb3ZlZCxcbiAgICAgICAgICAgICAgICBkb2N1bWVudHNSZW1vdmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3THJ1R2FyYmFnZUNvbGxlY3RvcihkZWxlZ2F0ZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBMcnVHYXJiYWdlQ29sbGVjdG9ySW1wbChkZWxlZ2F0ZSwgcGFyYW1zKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBQcm92aWRlcyBMUlUgZnVuY3Rpb25hbGl0eSBmb3IgSW5kZXhlZERCIHBlcnNpc3RlbmNlLiAqL1xuY2xhc3MgSW5kZXhlZERiTHJ1RGVsZWdhdGVJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihkYiwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgdGhpcy5nYXJiYWdlQ29sbGVjdG9yID0gbmV3THJ1R2FyYmFnZUNvbGxlY3Rvcih0aGlzLCBwYXJhbXMpO1xuICAgIH1cbiAgICBnZXRTZXF1ZW5jZU51bWJlckNvdW50KHR4bikge1xuICAgICAgICBjb25zdCBkb2NDb3VudFByb21pc2UgPSB0aGlzLm9ycGhhbmVkRG9jdW1lbnRDb3VudCh0eG4pO1xuICAgICAgICBjb25zdCB0YXJnZXRDb3VudFByb21pc2UgPSB0aGlzLmRiLmdldFRhcmdldENhY2hlKCkuZ2V0VGFyZ2V0Q291bnQodHhuKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldENvdW50UHJvbWlzZS5uZXh0KHRhcmdldENvdW50ID0+IGRvY0NvdW50UHJvbWlzZS5uZXh0KGRvY0NvdW50ID0+IHRhcmdldENvdW50ICsgZG9jQ291bnQpKTtcbiAgICB9XG4gICAgb3JwaGFuZWREb2N1bWVudENvdW50KHR4bikge1xuICAgICAgICBsZXQgb3JwaGFuZWRDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzLmZvckVhY2hPcnBoYW5lZERvY3VtZW50U2VxdWVuY2VOdW1iZXIodHhuLCBfID0+IHtcbiAgICAgICAgICAgIG9ycGhhbmVkQ291bnQrKztcbiAgICAgICAgfSkubmV4dCgoKSA9PiBvcnBoYW5lZENvdW50KTtcbiAgICB9XG4gICAgZm9yRWFjaFRhcmdldCh0eG4sIGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGIuZ2V0VGFyZ2V0Q2FjaGUoKS5mb3JFYWNoVGFyZ2V0KHR4biwgZik7XG4gICAgfVxuICAgIGZvckVhY2hPcnBoYW5lZERvY3VtZW50U2VxdWVuY2VOdW1iZXIodHhuLCBmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvckVhY2hPcnBoYW5lZERvY3VtZW50KHR4biwgKGRvY0tleSwgc2VxdWVuY2VOdW1iZXIpID0+IGYoc2VxdWVuY2VOdW1iZXIpKTtcbiAgICB9XG4gICAgYWRkUmVmZXJlbmNlKHR4biwgdGFyZ2V0SWQsIGtleSkge1xuICAgICAgICByZXR1cm4gd3JpdGVTZW50aW5lbEtleSh0eG4sIGtleSk7XG4gICAgfVxuICAgIHJlbW92ZVJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlU2VudGluZWxLZXkodHhuLCBrZXkpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXRzKHR4biwgdXBwZXJCb3VuZCwgYWN0aXZlVGFyZ2V0SWRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRiLmdldFRhcmdldENhY2hlKCkucmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcyk7XG4gICAgfVxuICAgIG1hcmtQb3RlbnRpYWxseU9ycGhhbmVkKHR4biwga2V5KSB7XG4gICAgICAgIHJldHVybiB3cml0ZVNlbnRpbmVsS2V5KHR4biwga2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFueXRoaW5nIHdvdWxkIHByZXZlbnQgdGhpcyBkb2N1bWVudCBmcm9tIGJlaW5nIGdhcmJhZ2VcbiAgICAgKiBjb2xsZWN0ZWQsIGdpdmVuIHRoYXQgdGhlIGRvY3VtZW50IGluIHF1ZXN0aW9uIGlzIG5vdCBwcmVzZW50IGluIGFueVxuICAgICAqIHRhcmdldHMgYW5kIGhhcyBhIHNlcXVlbmNlIG51bWJlciBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHVwcGVyIGJvdW5kIGZvclxuICAgICAqIHRoZSBjb2xsZWN0aW9uIHJ1bi5cbiAgICAgKi9cbiAgICBpc1Bpbm5lZCh0eG4sIGRvY0tleSkge1xuICAgICAgICByZXR1cm4gbXV0YXRpb25RdWV1ZXNDb250YWluS2V5KHR4biwgZG9jS2V5KTtcbiAgICB9XG4gICAgcmVtb3ZlT3JwaGFuZWREb2N1bWVudHModHhuLCB1cHBlckJvdW5kKSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50Q2FjaGUgPSB0aGlzLmRiLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKTtcbiAgICAgICAgY29uc3QgY2hhbmdlQnVmZmVyID0gZG9jdW1lbnRDYWNoZS5uZXdDaGFuZ2VCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgbGV0IGRvY3VtZW50Q291bnQgPSAwO1xuICAgICAgICBjb25zdCBpdGVyYXRpb24gPSB0aGlzLmZvckVhY2hPcnBoYW5lZERvY3VtZW50KHR4biwgKGRvY0tleSwgc2VxdWVuY2VOdW1iZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChzZXF1ZW5jZU51bWJlciA8PSB1cHBlckJvdW5kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuaXNQaW5uZWQodHhuLCBkb2NLZXkpLm5leHQoaXNQaW5uZWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUGlubmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdXIgc2l6ZSBhY2NvdW50aW5nIHJlcXVpcmVzIHVzIHRvIHJlYWQgYWxsIGRvY3VtZW50cyBiZWZvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92aW5nIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlQnVmZmVyLmdldEVudHJ5KHR4biwgZG9jS2V5KS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VCdWZmZXIucmVtb3ZlRW50cnkoZG9jS2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudFRhcmdldFN0b3JlKHR4bikuZGVsZXRlKHNlbnRpbmVsS2V5JDEoZG9jS2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlcmF0aW9uXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBjaGFuZ2VCdWZmZXIuYXBwbHkodHhuKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGRvY3VtZW50Q291bnQpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXQodHhuLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWQgPSB0YXJnZXREYXRhLndpdGhTZXF1ZW5jZU51bWJlcih0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGIuZ2V0VGFyZ2V0Q2FjaGUoKS51cGRhdGVUYXJnZXREYXRhKHR4biwgdXBkYXRlZCk7XG4gICAgfVxuICAgIHVwZGF0ZUxpbWJvRG9jdW1lbnQodHhuLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlU2VudGluZWxLZXkodHhuLCBrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIHByb3ZpZGVkIGZ1bmN0aW9uIGZvciBlYWNoIGRvY3VtZW50IGluIHRoZSBjYWNoZSB0aGF0IGlzICdvcnBoYW5lZCcuIE9ycGhhbmVkXG4gICAgICogbWVhbnMgbm90IGEgcGFydCBvZiBhbnkgdGFyZ2V0LCBzbyB0aGUgb25seSBlbnRyeSBpbiB0aGUgdGFyZ2V0LWRvY3VtZW50IGluZGV4IGZvclxuICAgICAqIHRoYXQgZG9jdW1lbnQgd2lsbCBiZSB0aGUgc2VudGluZWwgcm93ICh0YXJnZXRJZCAwKSwgd2hpY2ggd2lsbCBhbHNvIGhhdmUgdGhlIHNlcXVlbmNlXG4gICAgICogbnVtYmVyIGZvciB0aGUgbGFzdCB0aW1lIHRoZSBkb2N1bWVudCB3YXMgYWNjZXNzZWQuXG4gICAgICovXG4gICAgZm9yRWFjaE9ycGhhbmVkRG9jdW1lbnQodHhuLCBmKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pO1xuICAgICAgICBsZXQgbmV4dFRvUmVwb3J0ID0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRDtcbiAgICAgICAgbGV0IG5leHRQYXRoO1xuICAgICAgICByZXR1cm4gc3RvcmVcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcbiAgICAgICAgICAgIGluZGV4OiBEYlRhcmdldERvY3VtZW50RG9jdW1lbnRUYXJnZXRzSW5kZXhcbiAgICAgICAgfSwgKFt0YXJnZXRJZCwgZG9jS2V5XSwgeyBwYXRoLCBzZXF1ZW5jZU51bWJlciB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0SWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBuZXh0VG9SZXBvcnQgaXMgdmFsaWQsIHJlcG9ydCBpdCwgdGhpcyBpcyBhIG5ldyBrZXkgc28gdGhlXG4gICAgICAgICAgICAgICAgLy8gbGFzdCBvbmUgbXVzdCBub3QgYmUgYSBtZW1iZXIgb2YgYW55IHRhcmdldHMuXG4gICAgICAgICAgICAgICAgaWYgKG5leHRUb1JlcG9ydCAhPT0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCkge1xuICAgICAgICAgICAgICAgICAgICBmKG5ldyBEb2N1bWVudEtleShkZWNvZGVSZXNvdXJjZVBhdGgobmV4dFBhdGgpKSwgbmV4dFRvUmVwb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc2V0IG5leHRUb1JlcG9ydCB0byBiZSB0aGlzIHNlcXVlbmNlIG51bWJlci4gSXQncyB0aGUgbmV4dCBvbmUgd2VcbiAgICAgICAgICAgICAgICAvLyBtaWdodCByZXBvcnQsIGlmIHdlIGRvbid0IGZpbmQgYW55IHRhcmdldHMgZm9yIHRoaXMgZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBzZXF1ZW5jZSBudW1iZXIgbXVzdCBiZSBkZWZpbmVkIHdoZW4gdGhlIHRhcmdldElkXG4gICAgICAgICAgICAgICAgLy8gaXMgMC5cbiAgICAgICAgICAgICAgICBuZXh0VG9SZXBvcnQgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgICAgICBuZXh0UGF0aCA9IHBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgbmV4dFRvUmVwb3J0IHRvIGJlIGludmFsaWQsIHdlIGtub3cgd2UgZG9uJ3QgbmVlZCB0byByZXBvcnRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIG9uZSBzaW5jZSB3ZSBmb3VuZCBhIHRhcmdldCBmb3IgaXQuXG4gICAgICAgICAgICAgICAgbmV4dFRvUmVwb3J0ID0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIHJlcG9ydCBzZXF1ZW5jZSBudW1iZXJzIGFmdGVyIGdldHRpbmcgdG8gdGhlIG5leHQga2V5LCB3ZVxuICAgICAgICAgICAgLy8gbmVlZCB0byBjaGVjayBpZiB0aGUgbGFzdCBrZXkgd2UgaXRlcmF0ZWQgb3ZlciB3YXMgYW4gb3JwaGFuZWRcbiAgICAgICAgICAgIC8vIGRvY3VtZW50IGFuZCByZXBvcnQgaXQuXG4gICAgICAgICAgICBpZiAobmV4dFRvUmVwb3J0ICE9PSBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKSB7XG4gICAgICAgICAgICAgICAgZihuZXcgRG9jdW1lbnRLZXkoZGVjb2RlUmVzb3VyY2VQYXRoKG5leHRQYXRoKSksIG5leHRUb1JlcG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDYWNoZVNpemUodHhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRiLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKS5nZXRTaXplKHR4bik7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VudGluZWxLZXkkMShrZXkpIHtcbiAgICByZXR1cm4gWzAsIGVuY29kZVJlc291cmNlUGF0aChrZXkucGF0aCldO1xufVxuLyoqXG4gKiBAcmV0dXJucyBBIHZhbHVlIHN1aXRhYmxlIGZvciB3cml0aW5nIGEgc2VudGluZWwgcm93IGluIHRoZSB0YXJnZXQtZG9jdW1lbnRcbiAqIHN0b3JlLlxuICovXG5mdW5jdGlvbiBzZW50aW5lbFJvdyhrZXksIHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgcmV0dXJuIHsgdGFyZ2V0SWQ6IDAsIHBhdGg6IGVuY29kZVJlc291cmNlUGF0aChrZXkucGF0aCksIHNlcXVlbmNlTnVtYmVyIH07XG59XG5mdW5jdGlvbiB3cml0ZVNlbnRpbmVsS2V5KHR4biwga2V5KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKS5wdXQoc2VudGluZWxSb3coa2V5LCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGluLW1lbW9yeSBidWZmZXIgb2YgZW50cmllcyB0byBiZSB3cml0dGVuIHRvIGEgUmVtb3RlRG9jdW1lbnRDYWNoZS5cbiAqIEl0IGNhbiBiZSB1c2VkIHRvIGJhdGNoIHVwIGEgc2V0IG9mIGNoYW5nZXMgdG8gYmUgd3JpdHRlbiB0byB0aGUgY2FjaGUsIGJ1dFxuICogYWRkaXRpb25hbGx5IHN1cHBvcnRzIHJlYWRpbmcgZW50cmllcyBiYWNrIHdpdGggdGhlIGBnZXRFbnRyeSgpYCBtZXRob2QsXG4gKiBmYWxsaW5nIGJhY2sgdG8gdGhlIHVuZGVybHlpbmcgUmVtb3RlRG9jdW1lbnRDYWNoZSBpZiBubyBlbnRyeSBpc1xuICogYnVmZmVyZWQuXG4gKlxuICogRW50cmllcyBhZGRlZCB0byB0aGUgY2FjaGUgKm11c3QqIGJlIHJlYWQgZmlyc3QuIFRoaXMgaXMgdG8gZmFjaWxpdGF0ZVxuICogY2FsY3VsYXRpbmcgdGhlIHNpemUgZGVsdGEgb2YgdGhlIHBlbmRpbmcgY2hhbmdlcy5cbiAqXG4gKiBQT1JUSU5HIE5PVEU6IFRoaXMgY2xhc3Mgd2FzIGltcGxlbWVudGVkIHRoZW4gcmVtb3ZlZCBmcm9tIG90aGVyIHBsYXRmb3Jtcy5cbiAqIElmIGJ5dGUtY291bnRpbmcgZW5kcyB1cCBiZWluZyBuZWVkZWQgb24gdGhlIG90aGVyIHBsYXRmb3JtcywgY29uc2lkZXJcbiAqIHBvcnRpbmcgdGhpcyBjbGFzcyBhcyBwYXJ0IG9mIHRoYXQgaW1wbGVtZW50YXRpb24gd29yay5cbiAqL1xuY2xhc3MgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBBIG1hcHBpbmcgb2YgZG9jdW1lbnQga2V5IHRvIHRoZSBuZXcgY2FjaGUgZW50cnkgdGhhdCBzaG91bGQgYmUgd3JpdHRlbi5cbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IE9iamVjdE1hcChrZXkgPT4ga2V5LnRvU3RyaW5nKCksIChsLCByKSA9PiBsLmlzRXF1YWwocikpO1xuICAgICAgICB0aGlzLmNoYW5nZXNBcHBsaWVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1ZmZlcnMgYSBgUmVtb3RlRG9jdW1lbnRDYWNoZS5hZGRFbnRyeSgpYCBjYWxsLlxuICAgICAqXG4gICAgICogWW91IGNhbiBvbmx5IG1vZGlmeSBkb2N1bWVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiByZXRyaWV2ZWQgdmlhXG4gICAgICogYGdldEVudHJ5KCkvZ2V0RW50cmllcygpYCAoZW5mb3JjZWQgdmlhIEluZGV4ZWREYnMgYGFwcGx5KClgKS5cbiAgICAgKi9cbiAgICBhZGRFbnRyeShkb2N1bWVudCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLnNldChkb2N1bWVudC5rZXksIGRvY3VtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVmZmVycyBhIGBSZW1vdGVEb2N1bWVudENhY2hlLnJlbW92ZUVudHJ5KClgIGNhbGwuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG9ubHkgcmVtb3ZlIGRvY3VtZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHJldHJpZXZlZCB2aWFcbiAgICAgKiBgZ2V0RW50cnkoKS9nZXRFbnRyaWVzKClgIChlbmZvcmNlZCB2aWEgSW5kZXhlZERicyBgYXBwbHkoKWApLlxuICAgICAqL1xuICAgIHJlbW92ZUVudHJ5KGtleSwgcmVhZFRpbWUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RBcHBsaWVkKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5zZXQoa2V5LCBNdXRhYmxlRG9jdW1lbnQubmV3SW52YWxpZERvY3VtZW50KGtleSkuc2V0UmVhZFRpbWUocmVhZFRpbWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3MgdXAgYW4gZW50cnkgaW4gdGhlIGNhY2hlLiBUaGUgYnVmZmVyZWQgY2hhbmdlcyB3aWxsIGZpcnN0IGJlIGNoZWNrZWQsXG4gICAgICogYW5kIGlmIG5vIGJ1ZmZlcmVkIGNoYW5nZSBhcHBsaWVzLCB0aGlzIHdpbGwgZm9yd2FyZCB0b1xuICAgICAqIGBSZW1vdGVEb2N1bWVudENhY2hlLmdldEVudHJ5KClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIGluIHdoaWNoIHRvIHBlcmZvcm0gYW55IHBlcnNpc3RlbmNlXG4gICAgICogICAgIG9wZXJhdGlvbnMuXG4gICAgICogQHBhcmFtIGRvY3VtZW50S2V5IC0gVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gbG9vayB1cC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2FjaGVkIGRvY3VtZW50IG9yIGFuIGludmFsaWQgZG9jdW1lbnQgaWYgd2UgaGF2ZSBub3RoaW5nXG4gICAgICogY2FjaGVkLlxuICAgICAqL1xuICAgIGdldEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcbiAgICAgICAgY29uc3QgYnVmZmVyZWRFbnRyeSA9IHRoaXMuY2hhbmdlcy5nZXQoZG9jdW1lbnRLZXkpO1xuICAgICAgICBpZiAoYnVmZmVyZWRFbnRyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoYnVmZmVyZWRFbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rcyB1cCBzZXZlcmFsIGVudHJpZXMgaW4gdGhlIGNhY2hlLCBmb3J3YXJkaW5nIHRvXG4gICAgICogYFJlbW90ZURvY3VtZW50Q2FjaGUuZ2V0RW50cnkoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gaW4gd2hpY2ggdG8gcGVyZm9ybSBhbnkgcGVyc2lzdGVuY2VcbiAgICAgKiAgICAgb3BlcmF0aW9ucy5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRLZXlzIC0gVGhlIGtleXMgb2YgdGhlIGVudHJpZXMgdG8gbG9vayB1cC5cbiAgICAgKiBAcmV0dXJucyBBIG1hcCBvZiBjYWNoZWQgZG9jdW1lbnRzLCBpbmRleGVkIGJ5IGtleS4gSWYgYW4gZW50cnkgY2Fubm90IGJlXG4gICAgICogICAgIGZvdW5kLCB0aGUgY29ycmVzcG9uZGluZyBrZXkgd2lsbCBiZSBtYXBwZWQgdG8gYW4gaW52YWxpZCBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBnZXRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsRnJvbUNhY2hlKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGJ1ZmZlcmVkIGNoYW5nZXMgdG8gdGhlIHVuZGVybHlpbmcgUmVtb3RlRG9jdW1lbnRDYWNoZSwgdXNpbmdcbiAgICAgKiB0aGUgcHJvdmlkZWQgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgYXBwbHkodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5hc3NlcnROb3RBcHBsaWVkKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlc0FwcGxpZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseUNoYW5nZXModHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICAvKiogSGVscGVyIHRvIGFzc2VydCB0aGlzLmNoYW5nZXMgaXMgbm90IG51bGwgICovXG4gICAgYXNzZXJ0Tm90QXBwbGllZCgpIHtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBSZW1vdGVEb2N1bWVudENhY2hlIGZvciBJbmRleGVkRGIuIFRvIGNvbnN0cnVjdCwgaW52b2tlXG4gKiBgbmV3SW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZSgpYC5cbiAqL1xuY2xhc3MgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICB9XG4gICAgc2V0SW5kZXhNYW5hZ2VyKGluZGV4TWFuYWdlcikge1xuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IGluZGV4TWFuYWdlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgc3VwcGxpZWQgZW50cmllcyB0byB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBBbGwgY2FsbHMgb2YgYGFkZEVudHJ5YCBhcmUgcmVxdWlyZWQgdG8gZ28gdGhyb3VnaCB0aGUgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgIHRvIGVuc3VyZSBwcm9wZXIgYWNjb3VudGluZyBvZiBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICBhZGRFbnRyeSh0cmFuc2FjdGlvbiwga2V5LCBkb2MpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRTdG9yZSA9IHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50U3RvcmUucHV0KGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBkb2N1bWVudCBmcm9tIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEFsbCBjYWxscyBvZiBgcmVtb3ZlRW50cnlgICBhcmUgcmVxdWlyZWQgdG8gZ28gdGhyb3VnaCB0aGUgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgIHRvIGVuc3VyZSBwcm9wZXIgYWNjb3VudGluZyBvZiBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICByZW1vdmVFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXksIHJlYWRUaW1lKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gc3RvcmUuZGVsZXRlKGRiUmVhZFRpbWVLZXkoZG9jdW1lbnRLZXksIHJlYWRUaW1lKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgY2FjaGUgc2l6ZS5cbiAgICAgKlxuICAgICAqIENhbGxlcnMgdG8gYGFkZEVudHJ5KClgIGFuZCBgcmVtb3ZlRW50cnkoKWAgKm11c3QqIGNhbGwgdGhpcyBhZnRlcndhcmRzIHRvIHVwZGF0ZSB0aGVcbiAgICAgKiBjYWNoZSdzIG1ldGFkYXRhLlxuICAgICAqL1xuICAgIHVwZGF0ZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBzaXplRGVsdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWV0YWRhdGEodHJhbnNhY3Rpb24pLm5leHQobWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgbWV0YWRhdGEuYnl0ZVNpemUgKz0gc2l6ZURlbHRhO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TWV0YWRhdGEodHJhbnNhY3Rpb24sIG1ldGFkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSkge1xuICAgICAgICBsZXQgZG9jID0gTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSk7XG4gICAgICAgIHJldHVybiByZW1vdGVEb2N1bWVudHNTdG9yZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcbiAgICAgICAgICAgIGluZGV4OiBEYlJlbW90ZURvY3VtZW50RG9jdW1lbnRLZXlJbmRleCxcbiAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KGRiS2V5KGRvY3VtZW50S2V5KSlcbiAgICAgICAgfSwgKF8sIGRiUmVtb3RlRG9jKSA9PiB7XG4gICAgICAgICAgICBkb2MgPSB0aGlzLm1heWJlRGVjb2RlRG9jdW1lbnQoZG9jdW1lbnRLZXksIGRiUmVtb3RlRG9jKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIGFuIGVudHJ5IGluIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb2N1bWVudEtleSAtIFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGxvb2sgdXAuXG4gICAgICogQHJldHVybnMgVGhlIGNhY2hlZCBkb2N1bWVudCBlbnRyeSBhbmQgaXRzIHNpemUuXG4gICAgICovXG4gICAgZ2V0U2l6ZWRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgICBkb2N1bWVudDogTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoe1xuICAgICAgICAgICAgaW5kZXg6IERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4LFxuICAgICAgICAgICAgcmFuZ2U6IElEQktleVJhbmdlLm9ubHkoZGJLZXkoZG9jdW1lbnRLZXkpKVxuICAgICAgICB9LCAoXywgZGJSZW1vdGVEb2MpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudDogdGhpcy5tYXliZURlY29kZURvY3VtZW50KGRvY3VtZW50S2V5LCBkYlJlbW90ZURvYyksXG4gICAgICAgICAgICAgICAgc2l6ZTogZGJEb2N1bWVudFNpemUoZGJSZW1vdGVEb2MpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZvckVhY2hEYkVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMsIChrZXksIGRiUmVtb3RlRG9jKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSB0aGlzLm1heWJlRGVjb2RlRG9jdW1lbnQoa2V5LCBkYlJlbW90ZURvYyk7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoa2V5LCBkb2MpO1xuICAgICAgICB9KS5uZXh0KCgpID0+IHJlc3VsdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rcyB1cCBzZXZlcmFsIGVudHJpZXMgaW4gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50S2V5cyAtIFRoZSBzZXQgb2Yga2V5cyBlbnRyaWVzIHRvIGxvb2sgdXAuXG4gICAgICogQHJldHVybnMgQSBtYXAgb2YgZG9jdW1lbnRzIGluZGV4ZWQgYnkga2V5IGFuZCBhIG1hcCBvZiBzaXplcyBpbmRleGVkIGJ5XG4gICAgICogICAgIGtleSAoemVybyBpZiB0aGUgZG9jdW1lbnQgZG9lcyBub3QgZXhpc3QpLlxuICAgICAqL1xuICAgIGdldFNpemVkRW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIGxldCBzaXplTWFwID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaERiRW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cywgKGtleSwgZGJSZW1vdGVEb2MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IHRoaXMubWF5YmVEZWNvZGVEb2N1bWVudChrZXksIGRiUmVtb3RlRG9jKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChrZXksIGRvYyk7XG4gICAgICAgICAgICBzaXplTWFwID0gc2l6ZU1hcC5pbnNlcnQoa2V5LCBkYkRvY3VtZW50U2l6ZShkYlJlbW90ZURvYykpO1xuICAgICAgICB9KS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGRvY3VtZW50czogcmVzdWx0cywgc2l6ZU1hcCB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yRWFjaERiRW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGRvY3VtZW50S2V5cy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzb3J0ZWRLZXlzID0gbmV3IFNvcnRlZFNldChkYktleUNvbXBhcmF0b3IpO1xuICAgICAgICBkb2N1bWVudEtleXMuZm9yRWFjaChlID0+IChzb3J0ZWRLZXlzID0gc29ydGVkS2V5cy5hZGQoZSkpKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChkYktleShzb3J0ZWRLZXlzLmZpcnN0KCkpLCBkYktleShzb3J0ZWRLZXlzLmxhc3QoKSkpO1xuICAgICAgICBjb25zdCBrZXlJdGVyID0gc29ydGVkS2V5cy5nZXRJdGVyYXRvcigpO1xuICAgICAgICBsZXQgbmV4dEtleSA9IGtleUl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICByZXR1cm4gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IGluZGV4OiBEYlJlbW90ZURvY3VtZW50RG9jdW1lbnRLZXlJbmRleCwgcmFuZ2UgfSwgKF8sIGRiUmVtb3RlRG9jLCBjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3RlbnRpYWxLZXkgPSBEb2N1bWVudEtleS5mcm9tU2VnbWVudHMoW1xuICAgICAgICAgICAgICAgIC4uLmRiUmVtb3RlRG9jLnByZWZpeFBhdGgsXG4gICAgICAgICAgICAgICAgZGJSZW1vdGVEb2MuY29sbGVjdGlvbkdyb3VwLFxuICAgICAgICAgICAgICAgIGRiUmVtb3RlRG9jLmRvY3VtZW50SWRcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBrZXlzIG5vdCBmb3VuZCBpbiBjYWNoZS5cbiAgICAgICAgICAgIHdoaWxlIChuZXh0S2V5ICYmIGRiS2V5Q29tcGFyYXRvcihuZXh0S2V5LCBwb3RlbnRpYWxLZXkpIDwgMCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5leHRLZXksIG51bGwpO1xuICAgICAgICAgICAgICAgIG5leHRLZXkgPSBrZXlJdGVyLmdldE5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0S2V5ICYmIG5leHRLZXkuaXNFcXVhbChwb3RlbnRpYWxLZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gS2V5IGZvdW5kIGluIGNhY2hlLlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5leHRLZXksIGRiUmVtb3RlRG9jKTtcbiAgICAgICAgICAgICAgICBuZXh0S2V5ID0ga2V5SXRlci5oYXNOZXh0KCkgPyBrZXlJdGVyLmdldE5leHQoKSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTa2lwIHRvIHRoZSBuZXh0IGtleSAoaWYgdGhlcmUgaXMgb25lKS5cbiAgICAgICAgICAgIGlmIChuZXh0S2V5KSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5za2lwKGRiS2V5KG5leHRLZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gVGhlIHJlc3Qgb2YgdGhlIGtleXMgYXJlIG5vdCBpbiB0aGUgY2FjaGUuIE9uZSBjYXNlIHdoZXJlIGBpdGVyYXRlYFxuICAgICAgICAgICAgLy8gYWJvdmUgd29uJ3QgZ28gdGhyb3VnaCB0aGVtIGlzIHdoZW4gdGhlIGNhY2hlIGlzIGVtcHR5LlxuICAgICAgICAgICAgd2hpbGUgKG5leHRLZXkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXh0S2V5LCBudWxsKTtcbiAgICAgICAgICAgICAgICBuZXh0S2V5ID0ga2V5SXRlci5oYXNOZXh0KCkgPyBrZXlJdGVyLmdldE5leHQoKSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBtdXRhdGVkRG9jcywgY29udGV4dCkge1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uID0gcXVlcnkucGF0aDtcbiAgICAgICAgY29uc3Qgc3RhcnRLZXkgPSBbXG4gICAgICAgICAgICBjb2xsZWN0aW9uLnBvcExhc3QoKS50b0FycmF5KCksXG4gICAgICAgICAgICBjb2xsZWN0aW9uLmxhc3RTZWdtZW50KCksXG4gICAgICAgICAgICB0b0RiVGltZXN0YW1wS2V5KG9mZnNldC5yZWFkVGltZSksXG4gICAgICAgICAgICBvZmZzZXQuZG9jdW1lbnRLZXkucGF0aC5pc0VtcHR5KClcbiAgICAgICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICAgICAgOiBvZmZzZXQuZG9jdW1lbnRLZXkucGF0aC5sYXN0U2VnbWVudCgpXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGVuZEtleSA9IFtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ucG9wTGFzdCgpLnRvQXJyYXkoKSxcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ubGFzdFNlZ21lbnQoKSxcbiAgICAgICAgICAgIFtOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJdLFxuICAgICAgICAgICAgJydcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLmxvYWRBbGwoSURCS2V5UmFuZ2UuYm91bmQoc3RhcnRLZXksIGVuZEtleSwgdHJ1ZSkpXG4gICAgICAgICAgICAubmV4dChkYlJlbW90ZURvY3MgPT4ge1xuICAgICAgICAgICAgY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LmluY3JlbWVudERvY3VtZW50UmVhZENvdW50KGRiUmVtb3RlRG9jcy5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGJSZW1vdGVEb2Mgb2YgZGJSZW1vdGVEb2NzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSB0aGlzLm1heWJlRGVjb2RlRG9jdW1lbnQoRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKGRiUmVtb3RlRG9jLnByZWZpeFBhdGguY29uY2F0KGRiUmVtb3RlRG9jLmNvbGxlY3Rpb25Hcm91cCwgZGJSZW1vdGVEb2MuZG9jdW1lbnRJZCkpLCBkYlJlbW90ZURvYyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpICYmXG4gICAgICAgICAgICAgICAgICAgIChxdWVyeU1hdGNoZXMocXVlcnksIGRvY3VtZW50KSB8fCBtdXRhdGVkRG9jcy5oYXMoZG9jdW1lbnQua2V5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWl0aGVyIHRoZSBkb2N1bWVudCBtYXRjaGVzIHRoZSBnaXZlbiBxdWVyeSwgb3IgaXQgaXMgbXV0YXRlZC5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuaW5zZXJ0KGRvY3VtZW50LmtleSwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QWxsRnJvbUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQsIGxpbWl0KSB7XG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0S2V5ID0gZGJDb2xsZWN0aW9uR3JvdXBLZXkoY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQpO1xuICAgICAgICBjb25zdCBlbmRLZXkgPSBkYkNvbGxlY3Rpb25Hcm91cEtleShjb2xsZWN0aW9uR3JvdXAsIEluZGV4T2Zmc2V0Lm1heCgpKTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgLml0ZXJhdGUoe1xuICAgICAgICAgICAgaW5kZXg6IERiUmVtb3RlRG9jdW1lbnRDb2xsZWN0aW9uR3JvdXBJbmRleCxcbiAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5ib3VuZChzdGFydEtleSwgZW5kS2V5LCB0cnVlKVxuICAgICAgICB9LCAoXywgZGJSZW1vdGVEb2MsIGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5tYXliZURlY29kZURvY3VtZW50KERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhkYlJlbW90ZURvYy5wcmVmaXhQYXRoLmNvbmNhdChkYlJlbW90ZURvYy5jb2xsZWN0aW9uR3JvdXAsIGRiUmVtb3RlRG9jLmRvY3VtZW50SWQpKSwgZGJSZW1vdGVEb2MpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuaW5zZXJ0KGRvY3VtZW50LmtleSwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdHMuc2l6ZSA9PT0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHJlc3VsdHMpO1xuICAgIH1cbiAgICBuZXdDaGFuZ2VCdWZmZXIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4ZWREYlJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHRoaXMsICEhb3B0aW9ucyAmJiBvcHRpb25zLnRyYWNrUmVtb3ZhbHMpO1xuICAgIH1cbiAgICBnZXRTaXplKHR4bikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNZXRhZGF0YSh0eG4pLm5leHQobWV0YWRhdGEgPT4gbWV0YWRhdGEuYnl0ZVNpemUpO1xuICAgIH1cbiAgICBnZXRNZXRhZGF0YSh0eG4pIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50R2xvYmFsU3RvcmUodHhuKVxuICAgICAgICAgICAgLmdldChEYlJlbW90ZURvY3VtZW50R2xvYmFsS2V5KVxuICAgICAgICAgICAgLm5leHQobWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgaGFyZEFzc2VydCghIW1ldGFkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldE1ldGFkYXRhKHR4biwgbWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50R2xvYmFsU3RvcmUodHhuKS5wdXQoRGJSZW1vdGVEb2N1bWVudEdsb2JhbEtleSwgbWV0YWRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGBkYlJlbW90ZURvY2AgYW5kIHJldHVybnMgdGhlIGRvY3VtZW50IChvciBhbiBpbnZhbGlkIGRvY3VtZW50IGlmXG4gICAgICogdGhlIGRvY3VtZW50IGNvcnJlc3BvbmRzIHRvIHRoZSBmb3JtYXQgdXNlZCBmb3Igc2VudGluZWwgZGVsZXRlcykuXG4gICAgICovXG4gICAgbWF5YmVEZWNvZGVEb2N1bWVudChkb2N1bWVudEtleSwgZGJSZW1vdGVEb2MpIHtcbiAgICAgICAgaWYgKGRiUmVtb3RlRG9jKSB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSBmcm9tRGJSZW1vdGVEb2N1bWVudCh0aGlzLnNlcmlhbGl6ZXIsIGRiUmVtb3RlRG9jKTtcbiAgICAgICAgICAgIC8vIFdoZXRoZXIgdGhlIGRvY3VtZW50IGlzIGEgc2VudGluZWwgcmVtb3ZhbCBhbmQgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiB0aGVcbiAgICAgICAgICAgIC8vIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWBcbiAgICAgICAgICAgIGNvbnN0IGlzU2VudGluZWxSZW1vdmFsID0gZG9jLmlzTm9Eb2N1bWVudCgpICYmIGRvYy52ZXJzaW9uLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKTtcbiAgICAgICAgICAgIGlmICghaXNTZW50aW5lbFJlbW92YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNdXRhYmxlRG9jdW1lbnQubmV3SW52YWxpZERvY3VtZW50KGRvY3VtZW50S2V5KTtcbiAgICB9XG59XG4vKiogQ3JlYXRlcyBhIG5ldyBJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlLiAqL1xuZnVuY3Rpb24gbmV3SW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZShzZXJpYWxpemVyKSB7XG4gICAgcmV0dXJuIG5ldyBJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlSW1wbChzZXJpYWxpemVyKTtcbn1cbi8qKlxuICogSGFuZGxlcyB0aGUgZGV0YWlscyBvZiBhZGRpbmcgYW5kIHVwZGF0aW5nIGRvY3VtZW50cyBpbiB0aGUgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZS5cbiAqXG4gKiBVbmxpa2UgdGhlIE1lbW9yeVJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyLCB0aGUgSW5kZXhlZERiIGltcGxlbWVudGF0aW9uIGNvbXB1dGVzIHRoZSBzaXplXG4gKiBkZWx0YSBmb3IgYWxsIHN1Ym1pdHRlZCBjaGFuZ2VzLiBUaGlzIGF2b2lkcyBoYXZpbmcgdG8gcmUtcmVhZCBhbGwgZG9jdW1lbnRzIGZyb20gSW5kZXhlZERiXG4gKiB3aGVuIHdlIGFwcGx5IHRoZSBjaGFuZ2VzLlxuICovXG5jbGFzcyBJbmRleGVkRGJSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlciBleHRlbmRzIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRDYWNoZSAtIFRoZSBJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlIHRvIGFwcGx5IHRoZSBjaGFuZ2VzIHRvLlxuICAgICAqIEBwYXJhbSB0cmFja1JlbW92YWxzIC0gV2hldGhlciB0byBjcmVhdGUgc2VudGluZWwgZGVsZXRlcyB0aGF0IGNhbiBiZSB0cmFja2VkIGJ5XG4gICAgICogYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudENhY2hlLCB0cmFja1JlbW92YWxzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRDYWNoZSA9IGRvY3VtZW50Q2FjaGU7XG4gICAgICAgIHRoaXMudHJhY2tSZW1vdmFscyA9IHRyYWNrUmVtb3ZhbHM7XG4gICAgICAgIC8vIEEgbWFwIG9mIGRvY3VtZW50IHNpemVzIGFuZCByZWFkIHRpbWVzIHByaW9yIHRvIGFwcGx5aW5nIHRoZSBjaGFuZ2VzIGluXG4gICAgICAgIC8vIHRoaXMgYnVmZmVyLlxuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGVzID0gbmV3IE9iamVjdE1hcChrZXkgPT4ga2V5LnRvU3RyaW5nKCksIChsLCByKSA9PiBsLmlzRXF1YWwocikpO1xuICAgIH1cbiAgICBhcHBseUNoYW5nZXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgbGV0IHNpemVEZWx0YSA9IDA7XG4gICAgICAgIGxldCBjb2xsZWN0aW9uUGFyZW50cyA9IG5ldyBTb3J0ZWRTZXQoKGwsIHIpID0+IHByaW1pdGl2ZUNvbXBhcmF0b3IobC5jYW5vbmljYWxTdHJpbmcoKSwgci5jYW5vbmljYWxTdHJpbmcoKSkpO1xuICAgICAgICB0aGlzLmNoYW5nZXMuZm9yRWFjaCgoa2V5LCBkb2N1bWVudENoYW5nZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNEb2MgPSB0aGlzLmRvY3VtZW50U3RhdGVzLmdldChrZXkpO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvY3VtZW50Q2FjaGUucmVtb3ZlRW50cnkodHJhbnNhY3Rpb24sIGtleSwgcHJldmlvdXNEb2MucmVhZFRpbWUpKTtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudENoYW5nZS5pc1ZhbGlkRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvYyA9IHRvRGJSZW1vdGVEb2N1bWVudCh0aGlzLmRvY3VtZW50Q2FjaGUuc2VyaWFsaXplciwgZG9jdW1lbnRDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25QYXJlbnRzID0gY29sbGVjdGlvblBhcmVudHMuYWRkKGtleS5wYXRoLnBvcExhc3QoKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGRiRG9jdW1lbnRTaXplKGRvYyk7XG4gICAgICAgICAgICAgICAgc2l6ZURlbHRhICs9IHNpemUgLSBwcmV2aW91c0RvYy5zaXplO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudENhY2hlLmFkZEVudHJ5KHRyYW5zYWN0aW9uLCBrZXksIGRvYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2l6ZURlbHRhIC09IHByZXZpb3VzRG9jLnNpemU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tSZW1vdmFscykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBvcmRlciB0byB0cmFjayByZW1vdmFscywgd2Ugc3RvcmUgYSBcInNlbnRpbmVsIGRlbGV0ZVwiIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdGVEb2N1bWVudENhY2hlLiBUaGlzIGVudHJ5IGlzIHJlcHJlc2VudGVkIGJ5IGEgTm9Eb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIGEgdmVyc2lvbiBvZiAwIGFuZCBpZ25vcmVkIGJ5IGBtYXliZURlY29kZURvY3VtZW50KClgIGJ1dFxuICAgICAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZWQgaW4gYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlZERvYyA9IHRvRGJSZW1vdGVEb2N1bWVudCh0aGlzLmRvY3VtZW50Q2FjaGUuc2VyaWFsaXplciwgZG9jdW1lbnRDaGFuZ2UuY29udmVydFRvTm9Eb2N1bWVudChTbmFwc2hvdFZlcnNpb24ubWluKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvY3VtZW50Q2FjaGUuYWRkRW50cnkodHJhbnNhY3Rpb24sIGtleSwgZGVsZXRlZERvYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbGxlY3Rpb25QYXJlbnRzLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudENhY2hlLmluZGV4TWFuYWdlci5hZGRUb0NvbGxlY3Rpb25QYXJlbnRJbmRleCh0cmFuc2FjdGlvbiwgcGFyZW50KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZG9jdW1lbnRDYWNoZS51cGRhdGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgc2l6ZURlbHRhKSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XG4gICAgfVxuICAgIGdldEZyb21DYWNoZSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcbiAgICAgICAgLy8gUmVjb3JkIHRoZSBzaXplIG9mIGV2ZXJ5dGhpbmcgd2UgbG9hZCBmcm9tIHRoZSBjYWNoZSBzbyB3ZSBjYW4gY29tcHV0ZSBhIGRlbHRhIGxhdGVyLlxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudENhY2hlXG4gICAgICAgICAgICAuZ2V0U2l6ZWRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpXG4gICAgICAgICAgICAubmV4dChnZXRSZXN1bHQgPT4ge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlcy5zZXQoZG9jdW1lbnRLZXksIHtcbiAgICAgICAgICAgICAgICBzaXplOiBnZXRSZXN1bHQuc2l6ZSxcbiAgICAgICAgICAgICAgICByZWFkVGltZTogZ2V0UmVzdWx0LmRvY3VtZW50LnJlYWRUaW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBnZXRSZXN1bHQuZG9jdW1lbnQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRBbGxGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xuICAgICAgICAvLyBSZWNvcmQgdGhlIHNpemUgb2YgZXZlcnl0aGluZyB3ZSBsb2FkIGZyb20gdGhlIGNhY2hlIHNvIHdlIGNhbiBjb21wdXRlXG4gICAgICAgIC8vIGEgZGVsdGEgbGF0ZXIuXG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50Q2FjaGVcbiAgICAgICAgICAgIC5nZXRTaXplZEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cylcbiAgICAgICAgICAgIC5uZXh0KCh7IGRvY3VtZW50cywgc2l6ZU1hcCB9KSA9PiB7XG4gICAgICAgICAgICAvLyBOb3RlOiBgZ2V0QWxsRnJvbUNhY2hlYCByZXR1cm5zIHR3byBtYXBzIGluc3RlYWQgb2YgYSBzaW5nbGUgbWFwIGZyb21cbiAgICAgICAgICAgIC8vIGtleXMgdG8gYERvY3VtZW50U2l6ZUVudHJ5YHMuIFRoaXMgaXMgdG8gYWxsb3cgcmV0dXJuaW5nIHRoZVxuICAgICAgICAgICAgLy8gYE11dGFibGVEb2N1bWVudE1hcGAgZGlyZWN0bHksIHdpdGhvdXQgYSBjb252ZXJzaW9uLlxuICAgICAgICAgICAgc2l6ZU1hcC5mb3JFYWNoKChkb2N1bWVudEtleSwgc2l6ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRTdGF0ZXMuc2V0KGRvY3VtZW50S2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRUaW1lOiBkb2N1bWVudHMuZ2V0KGRvY3VtZW50S2V5KS5yZWFkVGltZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRzO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBkb2N1bWVudEdsb2JhbFN0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiUmVtb3RlRG9jdW1lbnRHbG9iYWxTdG9yZSk7XG59XG4vKipcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgcmVtb3RlRG9jdW1lbnRzIG9iamVjdCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHhuKSB7XG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJSZW1vdGVEb2N1bWVudFN0b3JlKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGtleSB0aGF0IGNhbiBiZSB1c2VkIGZvciBkb2N1bWVudCBsb29rdXBzIG9uIHRoZVxuICogYERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4YCBpbmRleC5cbiAqL1xuZnVuY3Rpb24gZGJLZXkoZG9jdW1lbnRLZXkpIHtcbiAgICBjb25zdCBwYXRoID0gZG9jdW1lbnRLZXkucGF0aC50b0FycmF5KCk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgLyogcHJlZml4IHBhdGggKi8gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDIpLFxuICAgICAgICAvKiBjb2xsZWN0aW9uIGlkICovIHBhdGhbcGF0aC5sZW5ndGggLSAyXSxcbiAgICAgICAgLyogZG9jdW1lbnQgaWQgKi8gcGF0aFtwYXRoLmxlbmd0aCAtIDFdXG4gICAgXTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGtleSB0aGF0IGNhbiBiZSB1c2VkIGZvciBkb2N1bWVudCBsb29rdXBzIHZpYSB0aGUgcHJpbWFyeSBrZXkgb2ZcbiAqIHRoZSBEYlJlbW90ZURvY3VtZW50IG9iamVjdCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gZGJSZWFkVGltZUtleShkb2N1bWVudEtleSwgcmVhZFRpbWUpIHtcbiAgICBjb25zdCBwYXRoID0gZG9jdW1lbnRLZXkucGF0aC50b0FycmF5KCk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgLyogcHJlZml4IHBhdGggKi8gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDIpLFxuICAgICAgICAvKiBjb2xsZWN0aW9uIGlkICovIHBhdGhbcGF0aC5sZW5ndGggLSAyXSxcbiAgICAgICAgdG9EYlRpbWVzdGFtcEtleShyZWFkVGltZSksXG4gICAgICAgIC8qIGRvY3VtZW50IGlkICovIHBhdGhbcGF0aC5sZW5ndGggLSAxXVxuICAgIF07XG59XG4vKipcbiAqIFJldHVybnMgYSBrZXkgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZG9jdW1lbnQgbG9va3VwcyBvbiB0aGVcbiAqIGBEYlJlbW90ZURvY3VtZW50RG9jdW1lbnRDb2xsZWN0aW9uR3JvdXBJbmRleGAgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGRiQ29sbGVjdGlvbkdyb3VwS2V5KGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0KSB7XG4gICAgY29uc3QgcGF0aCA9IG9mZnNldC5kb2N1bWVudEtleS5wYXRoLnRvQXJyYXkoKTtcbiAgICByZXR1cm4gW1xuICAgICAgICAvKiBjb2xsZWN0aW9uIGlkICovIGNvbGxlY3Rpb25Hcm91cCxcbiAgICAgICAgdG9EYlRpbWVzdGFtcEtleShvZmZzZXQucmVhZFRpbWUpLFxuICAgICAgICAvKiBwcmVmaXggcGF0aCAqLyBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMiksXG4gICAgICAgIC8qIGRvY3VtZW50IGlkICovIHBhdGgubGVuZ3RoID4gMCA/IHBhdGhbcGF0aC5sZW5ndGggLSAxXSA6ICcnXG4gICAgXTtcbn1cbi8qKlxuICogQ29tcGFyYXRvciB0aGF0IGNvbXBhcmVzIGRvY3VtZW50IGtleXMgYWNjb3JkaW5nIHRvIHRoZSBwcmltYXJ5IGtleSBzb3J0aW5nXG4gKiB1c2VkIGJ5IHRoZSBgRGJSZW1vdGVEb2N1bWVudERvY3VtZW50YCBzdG9yZSAoYnkgcHJlZml4IHBhdGgsIGNvbGxlY3Rpb24gaWRcbiAqIGFuZCB0aGVuIGRvY3VtZW50IElEKS5cbiAqXG4gKiBWaXNpYmxlIGZvciB0ZXN0aW5nLlxuICovXG5mdW5jdGlvbiBkYktleUNvbXBhcmF0b3IobCwgcikge1xuICAgIGNvbnN0IGxlZnQgPSBsLnBhdGgudG9BcnJheSgpO1xuICAgIGNvbnN0IHJpZ2h0ID0gci5wYXRoLnRvQXJyYXkoKTtcbiAgICAvLyBUaGUgb3JkZXJpbmcgaXMgYmFzZWQgb24gaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL2JsaW5rLysvZmU1YzIxZmVmOTRkYWU3MWMxYzMzNDQ3NzViOGQ4YTdmN2U2ZDllYy9Tb3VyY2UvbW9kdWxlcy9pbmRleGVkZGIvSURCS2V5LmNwcCM3NFxuICAgIGxldCBjbXAgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5sZW5ndGggLSAyICYmIGkgPCByaWdodC5sZW5ndGggLSAyOyArK2kpIHtcbiAgICAgICAgY21wID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0W2ldLCByaWdodFtpXSk7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY21wID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0Lmxlbmd0aCwgcmlnaHQubGVuZ3RoKTtcbiAgICBpZiAoY21wKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuICAgIGNtcCA9IHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFtsZWZ0Lmxlbmd0aCAtIDJdLCByaWdodFtyaWdodC5sZW5ndGggLSAyXSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICAvLyBUT0RPKGIvMzI5NDQxNzAyKTogRG9jdW1lbnQgSURzIHNob3VsZCBiZSBzb3J0ZWQgYnkgVVRGLTggZW5jb2RlZCBieXRlXG4gICAgLy8gb3JkZXIsIGJ1dCBJbmRleGVkREIgc29ydHMgc3RyaW5ncyBsZXhpY29ncmFwaGljYWxseS4gRG9jdW1lbnQgSURcbiAgICAvLyBjb21wYXJpc29uIGhlcmUgc3RpbGwgcmVsaWVzIG9uIHByaW1pdGl2ZSBjb21wYXJpc29uIHRvIGF2b2lkIG1pc21hdGNoZXNcbiAgICAvLyBvYnNlcnZlZCBpbiBzbmFwc2hvdCBsaXN0ZW5lcnMgd2l0aCBVbmljb2RlIGNoYXJhY3RlcnMgaW4gZG9jdW1lbnRJZHNcbiAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0W2xlZnQubGVuZ3RoIC0gMV0sIHJpZ2h0W3JpZ2h0Lmxlbmd0aCAtIDFdKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogU2NoZW1hIFZlcnNpb24gZm9yIHRoZSBXZWIgY2xpZW50OlxuICogMS4gIEluaXRpYWwgdmVyc2lvbiBpbmNsdWRpbmcgTXV0YXRpb24gUXVldWUsIFF1ZXJ5IENhY2hlLCBhbmQgUmVtb3RlXG4gKiAgICAgRG9jdW1lbnQgQ2FjaGVcbiAqIDIuICBVc2VkIHRvIGVuc3VyZSBhIHRhcmdldEdsb2JhbCBvYmplY3QgZXhpc3RzIGFuZCBhZGQgdGFyZ2V0Q291bnQgdG8gaXQuIE5vXG4gKiAgICAgbG9uZ2VyIHJlcXVpcmVkIGJlY2F1c2UgbWlncmF0aW9uIDMgdW5jb25kaXRpb25hbGx5IGNsZWFycyBpdC5cbiAqIDMuICBEcm9wcGVkIGFuZCByZS1jcmVhdGVkIFF1ZXJ5IENhY2hlIHRvIGRlYWwgd2l0aCBjYWNoZSBjb3JydXB0aW9uIHJlbGF0ZWRcbiAqICAgICB0byBsaW1ibyByZXNvbHV0aW9uLiBBZGRyZXNzZXNcbiAqICAgICBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtaW9zLXNkay9pc3N1ZXMvMTU0OFxuICogNC4gIE11bHRpLVRhYiBTdXBwb3J0LlxuICogNS4gIFJlbW92YWwgb2YgaGVsZCB3cml0ZSBhY2tzLlxuICogNi4gIENyZWF0ZSBkb2N1bWVudCBnbG9iYWwgZm9yIHRyYWNraW5nIGRvY3VtZW50IGNhY2hlIHNpemUuXG4gKiA3LiAgRW5zdXJlIGV2ZXJ5IGNhY2hlZCBkb2N1bWVudCBoYXMgYSBzZW50aW5lbCByb3cgd2l0aCBhIHNlcXVlbmNlIG51bWJlci5cbiAqIDguICBBZGQgY29sbGVjdGlvbi1wYXJlbnQgaW5kZXggZm9yIENvbGxlY3Rpb24gR3JvdXAgcXVlcmllcy5cbiAqIDkuICBDaGFuZ2UgUmVtb3RlRG9jdW1lbnRDaGFuZ2VzIHN0b3JlIHRvIGJlIGtleWVkIGJ5IHJlYWRUaW1lIHJhdGhlciB0aGFuXG4gKiAgICAgYW4gYXV0by1pbmNyZW1lbnRpbmcgSUQuIFRoaXMgaXMgcmVxdWlyZWQgZm9yIEluZGV4LUZyZWUgcXVlcmllcy5cbiAqIDEwLiBSZXdyaXRlIHRoZSBjYW5vbmljYWwgSURzIHRvIHRoZSBleHBsaWNpdCBQcm90b2J1Zi1iYXNlZCBmb3JtYXQuXG4gKiAxMS4gQWRkIGJ1bmRsZXMgYW5kIG5hbWVkX3F1ZXJpZXMgZm9yIGJ1bmRsZSBzdXBwb3J0LlxuICogMTIuIEFkZCBkb2N1bWVudCBvdmVybGF5cy5cbiAqIDEzLiBSZXdyaXRlIHRoZSBrZXlzIG9mIHRoZSByZW1vdGUgZG9jdW1lbnQgY2FjaGUgdG8gYWxsb3cgZm9yIGVmZmljaWVudFxuICogICAgIGRvY3VtZW50IGxvb2t1cCB2aWEgYGdldEFsbCgpYC5cbiAqIDE0LiBBZGQgb3ZlcmxheXMuXG4gKiAxNS4gQWRkIGluZGV4aW5nIHN1cHBvcnQuXG4gKiAxNi4gUGFyc2UgdGltZXN0YW1wIHN0cmluZ3MgYmVmb3JlIGNyZWF0aW5nIGluZGV4IGVudHJpZXMuXG4gKi9cbmNvbnN0IFNDSEVNQV9WRVJTSU9OID0gMTc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSBsb2NhbCB2aWV3IChvdmVybGF5KSBvZiBhIGRvY3VtZW50LCBhbmQgdGhlIGZpZWxkcyB0aGF0IGFyZVxuICogbG9jYWxseSBtdXRhdGVkLlxuICovXG5jbGFzcyBPdmVybGF5ZWREb2N1bWVudCB7XG4gICAgY29uc3RydWN0b3Iob3ZlcmxheWVkRG9jdW1lbnQsIFxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZHMgdGhhdCBhcmUgbG9jYWxseSBtdXRhdGVkIGJ5IHBhdGNoIG11dGF0aW9ucy5cbiAgICAgKlxuICAgICAqIElmIHRoZSBvdmVybGF5ZWRcdGRvY3VtZW50IGlzIGZyb20gc2V0IG9yIGRlbGV0ZSBtdXRhdGlvbnMsIHRoaXMgaXMgYG51bGxgLlxuICAgICAqIElmIHRoZXJlIGlzIG5vIG92ZXJsYXkgKG11dGF0aW9uKSBmb3IgdGhlIGRvY3VtZW50LCB0aGlzIGlzIGFuIGVtcHR5IGBGaWVsZE1hc2tgLlxuICAgICAqL1xuICAgIG11dGF0ZWRGaWVsZHMpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5ZWREb2N1bWVudCA9IG92ZXJsYXllZERvY3VtZW50O1xuICAgICAgICB0aGlzLm11dGF0ZWRGaWVsZHMgPSBtdXRhdGVkRmllbGRzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSByZWFkb25seSB2aWV3IG9mIHRoZSBsb2NhbCBzdGF0ZSBvZiBhbGwgZG9jdW1lbnRzIHdlJ3JlIHRyYWNraW5nIChpLmUuIHdlXG4gKiBoYXZlIGEgY2FjaGVkIHZlcnNpb24gaW4gcmVtb3RlRG9jdW1lbnRDYWNoZSBvciBsb2NhbCBtdXRhdGlvbnMgZm9yIHRoZVxuICogZG9jdW1lbnQpLiBUaGUgdmlldyBpcyBjb21wdXRlZCBieSBhcHBseWluZyB0aGUgbXV0YXRpb25zIGluIHRoZVxuICogTXV0YXRpb25RdWV1ZSB0byB0aGUgUmVtb3RlRG9jdW1lbnRDYWNoZS5cbiAqL1xuY2xhc3MgTG9jYWxEb2N1bWVudHNWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihyZW1vdGVEb2N1bWVudENhY2hlLCBtdXRhdGlvblF1ZXVlLCBkb2N1bWVudE92ZXJsYXlDYWNoZSwgaW5kZXhNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZSA9IHJlbW90ZURvY3VtZW50Q2FjaGU7XG4gICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZSA9IG11dGF0aW9uUXVldWU7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGUgPSBkb2N1bWVudE92ZXJsYXlDYWNoZTtcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBpbmRleE1hbmFnZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbG9jYWwgdmlldyBvZiB0aGUgZG9jdW1lbnQgaWRlbnRpZmllZCBieSBga2V5YC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIExvY2FsIHZpZXcgb2YgdGhlIGRvY3VtZW50IG9yIG51bGwgaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgY2FjaGVkXG4gICAgICogc3RhdGUgZm9yIGl0LlxuICAgICAqL1xuICAgIGdldERvY3VtZW50KHRyYW5zYWN0aW9uLCBrZXkpIHtcbiAgICAgICAgbGV0IG92ZXJsYXkgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZVxuICAgICAgICAgICAgLmdldE92ZXJsYXkodHJhbnNhY3Rpb24sIGtleSlcbiAgICAgICAgICAgIC5uZXh0KHZhbHVlID0+IHtcbiAgICAgICAgICAgIG92ZXJsYXkgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGUuZ2V0RW50cnkodHJhbnNhY3Rpb24sIGtleSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudCA9PiB7XG4gICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhvdmVybGF5Lm11dGF0aW9uLCBkb2N1bWVudCwgRmllbGRNYXNrLmVtcHR5KCksIFRpbWVzdGFtcC5ub3coKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsb2NhbCB2aWV3IG9mIHRoZSBkb2N1bWVudHMgaWRlbnRpZmllZCBieSBga2V5c2AuXG4gICAgICpcbiAgICAgKiBJZiB3ZSBkb24ndCBoYXZlIGNhY2hlZCBzdGF0ZSBmb3IgYSBkb2N1bWVudCBpbiBga2V5c2AsIGEgTm9Eb2N1bWVudCB3aWxsXG4gICAgICogYmUgc3RvcmVkIGZvciB0aGF0IGtleSBpbiB0aGUgcmVzdWx0aW5nIHNldC5cbiAgICAgKi9cbiAgICBnZXREb2N1bWVudHModHJhbnNhY3Rpb24sIGtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZVxuICAgICAgICAgICAgLmdldEVudHJpZXModHJhbnNhY3Rpb24sIGtleXMpXG4gICAgICAgICAgICAubmV4dChkb2NzID0+IHRoaXMuZ2V0TG9jYWxWaWV3T2ZEb2N1bWVudHModHJhbnNhY3Rpb24sIGRvY3MsIGRvY3VtZW50S2V5U2V0KCkpLm5leHQoKCkgPT4gZG9jcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIGBnZXREb2N1bWVudHNgLCBidXQgY3JlYXRlcyB0aGUgbG9jYWwgdmlldyBmcm9tIHRoZSBnaXZlblxuICAgICAqIGBiYXNlRG9jc2Agd2l0aG91dCByZXRyaWV2aW5nIGRvY3VtZW50cyBmcm9tIHRoZSBsb2NhbCBzdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSB0cmFuc2FjdGlvbiB0aGlzIG9wZXJhdGlvbiBpcyBzY29wZWQgdG8uXG4gICAgICogQHBhcmFtIGRvY3MgLSBUaGUgZG9jdW1lbnRzIHRvIGFwcGx5IGxvY2FsIG11dGF0aW9ucyB0byBnZXQgdGhlIGxvY2FsIHZpZXdzLlxuICAgICAqIEBwYXJhbSBleGlzdGVuY2VTdGF0ZUNoYW5nZWQgLSBUaGUgc2V0IG9mIGRvY3VtZW50IGtleXMgd2hvc2UgZXhpc3RlbmNlIHN0YXRlXG4gICAgICogICBpcyBjaGFuZ2VkLiBUaGlzIGlzIHVzZWZ1bCB0byBkZXRlcm1pbmUgaWYgc29tZSBkb2N1bWVudHMgb3ZlcmxheSBuZWVkc1xuICAgICAqICAgdG8gYmUgcmVjYWxjdWxhdGVkLlxuICAgICAqL1xuICAgIGdldExvY2FsVmlld09mRG9jdW1lbnRzKHRyYW5zYWN0aW9uLCBkb2NzLCBleGlzdGVuY2VTdGF0ZUNoYW5nZWQgPSBkb2N1bWVudEtleVNldCgpKSB7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlzID0gbmV3T3ZlcmxheU1hcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3B1bGF0ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBvdmVybGF5cywgZG9jcykubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVmlld3ModHJhbnNhY3Rpb24sIGRvY3MsIG92ZXJsYXlzLCBleGlzdGVuY2VTdGF0ZUNoYW5nZWQpLm5leHQoY29tcHV0ZVZpZXdzUmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gZG9jdW1lbnRNYXAoKTtcbiAgICAgICAgICAgICAgICBjb21wdXRlVmlld3NSZXN1bHQuZm9yRWFjaCgoZG9jdW1lbnRLZXksIG92ZXJsYXllZERvY3VtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5pbnNlcnQoZG9jdW1lbnRLZXksIG92ZXJsYXllZERvY3VtZW50Lm92ZXJsYXllZERvY3VtZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBvdmVybGF5ZWQgZG9jdW1lbnRzIGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQgbWFwLCB3aGljaCB3aWxsIGluY2x1ZGVcbiAgICAgKiB0aGUgbG9jYWwgdmlldyBvZiB0aG9zZSBkb2N1bWVudHMgYW5kIGEgYEZpZWxkTWFza2AgaW5kaWNhdGluZyB3aGljaCBmaWVsZHNcbiAgICAgKiBhcmUgbXV0YXRlZCBsb2NhbGx5LCBgbnVsbGAgaWYgb3ZlcmxheSBpcyBhIFNldCBvciBEZWxldGUgbXV0YXRpb24uXG4gICAgICovXG4gICAgZ2V0T3ZlcmxheWVkRG9jdW1lbnRzKHRyYW5zYWN0aW9uLCBkb2NzKSB7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlzID0gbmV3T3ZlcmxheU1hcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3B1bGF0ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBvdmVybGF5cywgZG9jcykubmV4dCgoKSA9PiB0aGlzLmNvbXB1dGVWaWV3cyh0cmFuc2FjdGlvbiwgZG9jcywgb3ZlcmxheXMsIGRvY3VtZW50S2V5U2V0KCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgb3ZlcmxheXMgZm9yIHtAY29kZSBkb2NzfSBhbmQgYWRkcyB0aGVtIHRvIHByb3ZpZGVkIG92ZXJsYXkgbWFwXG4gICAgICogaWYgdGhlIG1hcCBkb2VzIG5vdCBhbHJlYWR5IGNvbnRhaW4gYW4gZW50cnkgZm9yIHRoZSBnaXZlbiBkb2N1bWVudCBrZXkuXG4gICAgICovXG4gICAgcG9wdWxhdGVPdmVybGF5cyh0cmFuc2FjdGlvbiwgb3ZlcmxheXMsIGRvY3MpIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ092ZXJsYXlzID0gW107XG4gICAgICAgIGRvY3MuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKCFvdmVybGF5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIG1pc3NpbmdPdmVybGF5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZVxuICAgICAgICAgICAgLmdldE92ZXJsYXlzKHRyYW5zYWN0aW9uLCBtaXNzaW5nT3ZlcmxheXMpXG4gICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKGtleSwgdmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheXMuc2V0KGtleSwgdmFsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGxvY2FsIHZpZXcgZm9yIHRoZSBnaXZlbiBkb2N1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jcyAtIFRoZSBkb2N1bWVudHMgdG8gY29tcHV0ZSB2aWV3cyBmb3IuIEl0IGFsc28gaGFzIHRoZSBiYXNlXG4gICAgICogICB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudHMuXG4gICAgICogQHBhcmFtIG92ZXJsYXlzIC0gVGhlIG92ZXJsYXlzIHRoYXQgbmVlZCB0byBiZSBhcHBsaWVkIHRvIHRoZSBnaXZlbiBiYXNlXG4gICAgICogICB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudHMuXG4gICAgICogQHBhcmFtIGV4aXN0ZW5jZVN0YXRlQ2hhbmdlZCAtIEEgc2V0IG9mIGRvY3VtZW50cyB3aG9zZSBleGlzdGVuY2Ugc3RhdGVzXG4gICAgICogICBtaWdodCBoYXZlIGNoYW5nZWQuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgd2UgbmVlZCB0byByZS1jYWxjdWxhdGVcbiAgICAgKiAgIG92ZXJsYXlzIGZyb20gbXV0YXRpb24gcXVldWVzLlxuICAgICAqIEByZXR1cm4gQSBtYXAgcmVwcmVzZW50cyB0aGUgbG9jYWwgZG9jdW1lbnRzIHZpZXcuXG4gICAgICovXG4gICAgY29tcHV0ZVZpZXdzKHRyYW5zYWN0aW9uLCBkb2NzLCBvdmVybGF5cywgZXhpc3RlbmNlU3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgIGxldCByZWNhbGN1bGF0ZURvY3VtZW50cyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xuICAgICAgICBjb25zdCBtdXRhdGVkRmllbGRzID0gbmV3RG9jdW1lbnRLZXlNYXAoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ld092ZXJsYXllZERvY3VtZW50TWFwKCk7XG4gICAgICAgIGRvY3MuZm9yRWFjaCgoXywgZG9jKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gb3ZlcmxheXMuZ2V0KGRvYy5rZXkpO1xuICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgYW4gb3ZlcmxheSBpZiB0aGUgZG9jdW1lbnQncyBleGlzdGVuY2Ugc3RhdGUgY2hhbmdlZCBkdWUgdG9cbiAgICAgICAgICAgIC8vIGEgcmVtb3RlIGV2ZW50ICphbmQqIHRoZSBvdmVybGF5IGlzIGEgUGF0Y2hNdXRhdGlvbi4gVGhpcyBpcyBiZWNhdXNlXG4gICAgICAgICAgICAvLyBkb2N1bWVudCBleGlzdGVuY2Ugc3RhdGUgY2FuIGNoYW5nZSBpZiBzb21lIHBhdGNoIG11dGF0aW9uJ3NcbiAgICAgICAgICAgIC8vIHByZWNvbmRpdGlvbnMgYXJlIG1ldC5cbiAgICAgICAgICAgIC8vIE5PVEU6IHdlIHJlY2FsY3VsYXRlIHdoZW4gYG92ZXJsYXlgIGlzIHVuZGVmaW5lZCBhcyB3ZWxsLCBiZWNhdXNlIHRoZXJlXG4gICAgICAgICAgICAvLyBtaWdodCBiZSBhIHBhdGNoIG11dGF0aW9uIHdob3NlIHByZWNvbmRpdGlvbiBkb2VzIG5vdCBtYXRjaCBiZWZvcmUgdGhlXG4gICAgICAgICAgICAvLyBjaGFuZ2UgKGhlbmNlIG92ZXJsYXkgaXMgdW5kZWZpbmVkKSwgYnV0IHdvdWxkIG5vdyBtYXRjaC5cbiAgICAgICAgICAgIGlmIChleGlzdGVuY2VTdGF0ZUNoYW5nZWQuaGFzKGRvYy5rZXkpICYmXG4gICAgICAgICAgICAgICAgKG92ZXJsYXkgPT09IHVuZGVmaW5lZCB8fCBvdmVybGF5Lm11dGF0aW9uIGluc3RhbmNlb2YgUGF0Y2hNdXRhdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZWNhbGN1bGF0ZURvY3VtZW50cyA9IHJlY2FsY3VsYXRlRG9jdW1lbnRzLmluc2VydChkb2Mua2V5LCBkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3ZlcmxheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbXV0YXRlZEZpZWxkcy5zZXQoZG9jLmtleSwgb3ZlcmxheS5tdXRhdGlvbi5nZXRGaWVsZE1hc2soKSk7XG4gICAgICAgICAgICAgICAgbXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG92ZXJsYXkubXV0YXRpb24sIGRvYywgb3ZlcmxheS5tdXRhdGlvbi5nZXRGaWVsZE1hc2soKSwgVGltZXN0YW1wLm5vdygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vIG92ZXJsYXkgZXhpc3RzXG4gICAgICAgICAgICAgICAgLy8gVXNpbmcgRU1QVFkgdG8gaW5kaWNhdGUgdGhlcmUgaXMgbm8gb3ZlcmxheSBmb3IgdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgIG11dGF0ZWRGaWVsZHMuc2V0KGRvYy5rZXksIEZpZWxkTWFzay5lbXB0eSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2FsY3VsYXRlQW5kU2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCByZWNhbGN1bGF0ZURvY3VtZW50cykubmV4dChyZWNhbGN1bGF0ZWRGaWVsZHMgPT4ge1xuICAgICAgICAgICAgcmVjYWxjdWxhdGVkRmllbGRzLmZvckVhY2goKGRvY3VtZW50S2V5LCBtYXNrKSA9PiBtdXRhdGVkRmllbGRzLnNldChkb2N1bWVudEtleSwgbWFzaykpO1xuICAgICAgICAgICAgZG9jcy5mb3JFYWNoKChkb2N1bWVudEtleSwgZG9jdW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHMuc2V0KGRvY3VtZW50S2V5LCBuZXcgT3ZlcmxheWVkRG9jdW1lbnQoZG9jdW1lbnQsIChfYSA9IG11dGF0ZWRGaWVsZHMuZ2V0KGRvY3VtZW50S2V5KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlY2FsY3VsYXRlQW5kU2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBkb2NzKSB7XG4gICAgICAgIGNvbnN0IG1hc2tzID0gbmV3RG9jdW1lbnRLZXlNYXAoKTtcbiAgICAgICAgLy8gQSByZXZlcnNlIGxvb2t1cCBtYXAgZnJvbSBiYXRjaCBpZCB0byB0aGUgZG9jdW1lbnRzIHdpdGhpbiB0aGF0IGJhdGNoLlxuICAgICAgICBsZXQgZG9jdW1lbnRzQnlCYXRjaElkID0gbmV3IFNvcnRlZE1hcCgoa2V5MSwga2V5MikgPT4ga2V5MSAtIGtleTIpO1xuICAgICAgICBsZXQgcHJvY2Vzc2VkID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubXV0YXRpb25RdWV1ZVxuICAgICAgICAgICAgLmdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ0RvY3VtZW50S2V5cyh0cmFuc2FjdGlvbiwgZG9jcylcbiAgICAgICAgICAgIC5uZXh0KGJhdGNoZXMgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiBiYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2gua2V5cygpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZURvYyA9IGRvY3MuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlRG9jID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hc2sgPSBtYXNrcy5nZXQoa2V5KSB8fCBGaWVsZE1hc2suZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgbWFzayA9IGJhdGNoLmFwcGx5VG9Mb2NhbFZpZXcoYmFzZURvYywgbWFzayk7XG4gICAgICAgICAgICAgICAgICAgIG1hc2tzLnNldChrZXksIG1hc2spO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdTZXQgPSAoZG9jdW1lbnRzQnlCYXRjaElkLmdldChiYXRjaC5iYXRjaElkKSB8fCBkb2N1bWVudEtleVNldCgpKS5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRzQnlCYXRjaElkID0gZG9jdW1lbnRzQnlCYXRjaElkLmluc2VydChiYXRjaC5iYXRjaElkLCBuZXdTZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgaW4gZGVzY2VuZGluZyBvcmRlciBvZiBiYXRjaCBJRHMsIGFuZCBza2lwIGRvY3VtZW50cyB0aGF0IGFyZVxuICAgICAgICAgICAgLy8gYWxyZWFkeSBzYXZlZC5cbiAgICAgICAgICAgIGNvbnN0IGl0ZXIgPSBkb2N1bWVudHNCeUJhdGNoSWQuZ2V0UmV2ZXJzZUl0ZXJhdG9yKCk7XG4gICAgICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoSWQgPSBlbnRyeS5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IGVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlzID0gbmV3TXV0YXRpb25NYXAoKTtcbiAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9jZXNzZWQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlNdXRhdGlvbiA9IGNhbGN1bGF0ZU92ZXJsYXlNdXRhdGlvbihkb2NzLmdldChrZXkpLCBtYXNrcy5nZXQoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxheU11dGF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheXMuc2V0KGtleSwgb3ZlcmxheU11dGF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZCA9IHByb2Nlc3NlZC5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZS5zYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIGJhdGNoSWQsIG92ZXJsYXlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbWFza3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgb3ZlcmxheXMgYnkgcmVhZGluZyB0aGUgZG9jdW1lbnRzIGZyb20gcmVtb3RlIGRvY3VtZW50IGNhY2hlXG4gICAgICogZmlyc3QsIGFuZCBzYXZlcyB0aGVtIGFmdGVyIHRoZXkgYXJlIGNhbGN1bGF0ZWQuXG4gICAgICovXG4gICAgcmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXNGb3JEb2N1bWVudEtleXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlXG4gICAgICAgICAgICAuZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKVxuICAgICAgICAgICAgLm5leHQoZG9jcyA9PiB0aGlzLnJlY2FsY3VsYXRlQW5kU2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBkb2NzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcXVlcnkgYWdhaW5zdCB0aGUgbG9jYWwgdmlldyBvZiBhbGwgZG9jdW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHBlcnNpc3RlbmNlIHRyYW5zYWN0aW9uLlxuICAgICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0byBtYXRjaCBkb2N1bWVudHMgYWdhaW5zdC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IC0gUmVhZCB0aW1lIGFuZCBrZXkgdG8gc3RhcnQgc2Nhbm5pbmcgYnkgKGV4Y2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBBIG9wdGlvbmFsIHRyYWNrZXIgdG8ga2VlcCBhIHJlY29yZCBvZiBpbXBvcnRhbnQgZGV0YWlsc1xuICAgICAqICAgZHVyaW5nIGRhdGFiYXNlIGxvY2FsIHF1ZXJ5IGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgb2Zmc2V0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChpc0RvY3VtZW50UXVlcnkkMShxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERvY3VtZW50c01hdGNoaW5nRG9jdW1lbnRRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDb2xsZWN0aW9uR3JvdXBRdWVyeShxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERvY3VtZW50c01hdGNoaW5nQ29sbGVjdGlvbkdyb3VwUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdDb2xsZWN0aW9uUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgY29sbGVjdGlvbiBncm91cCwgcmV0dXJucyB0aGUgbmV4dCBkb2N1bWVudHMgdGhhdCBmb2xsb3cgdGhlIHByb3ZpZGVkIG9mZnNldCwgYWxvbmdcbiAgICAgKiB3aXRoIGFuIHVwZGF0ZWQgYmF0Y2ggSUQuXG4gICAgICpcbiAgICAgKiA8cD5UaGUgZG9jdW1lbnRzIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kIGFyZSBvcmRlcmVkIGJ5IHJlbW90ZSB2ZXJzaW9uIGZyb20gdGhlIHByb3ZpZGVkXG4gICAgICogb2Zmc2V0LiBJZiB0aGVyZSBhcmUgbm8gbW9yZSByZW1vdGUgZG9jdW1lbnRzIGFmdGVyIHRoZSBwcm92aWRlZCBvZmZzZXQsIGRvY3VtZW50cyB3aXRoXG4gICAgICogbXV0YXRpb25zIGluIG9yZGVyIG9mIGJhdGNoIGlkIGZyb20gdGhlIG9mZnNldCBhcmUgcmV0dXJuZWQuIFNpbmNlIGFsbCBkb2N1bWVudHMgaW4gYSBiYXRjaCBhcmVcbiAgICAgKiByZXR1cm5lZCB0b2dldGhlciwgdGhlIHRvdGFsIG51bWJlciBvZiBkb2N1bWVudHMgcmV0dXJuZWQgY2FuIGV4Y2VlZCB7QGNvZGUgY291bnR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25Hcm91cCBUaGUgY29sbGVjdGlvbiBncm91cCBmb3IgdGhlIGRvY3VtZW50cy5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgdG8gaW5kZXggaW50by5cbiAgICAgKiBAcGFyYW0gY291bnQgVGhlIG51bWJlciBvZiBkb2N1bWVudHMgdG8gcmV0dXJuXG4gICAgICogQHJldHVybiBBIExvY2FsV3JpdGVSZXN1bHQgd2l0aCB0aGUgZG9jdW1lbnRzIHRoYXQgZm9sbG93IHRoZSBwcm92aWRlZCBvZmZzZXQgYW5kIHRoZSBsYXN0IHByb2Nlc3NlZCBiYXRjaCBpZC5cbiAgICAgKi9cbiAgICBnZXROZXh0RG9jdW1lbnRzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIG9mZnNldCwgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZVxuICAgICAgICAgICAgLmdldEFsbEZyb21Db2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0LCBjb3VudClcbiAgICAgICAgICAgIC5uZXh0KChvcmlnaW5hbERvY3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlzUHJvbWlzZSA9IGNvdW50IC0gb3JpZ2luYWxEb2NzLnNpemUgPiAwXG4gICAgICAgICAgICAgICAgPyB0aGlzLmRvY3VtZW50T3ZlcmxheUNhY2hlLmdldE92ZXJsYXlzRm9yQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIG9mZnNldC5sYXJnZXN0QmF0Y2hJZCwgY291bnQgLSBvcmlnaW5hbERvY3Muc2l6ZSlcbiAgICAgICAgICAgICAgICA6IFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG5ld092ZXJsYXlNYXAoKSk7XG4gICAgICAgICAgICAvLyBUaGUgY2FsbHNpdGUgd2lsbCB1c2UgdGhlIGxhcmdlc3QgYmF0Y2ggSUQgdG9nZXRoZXIgd2l0aCB0aGUgbGF0ZXN0IHJlYWQgdGltZSB0byBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbmV3IGluZGV4IG9mZnNldC4gU2luY2Ugd2Ugb25seSBwcm9jZXNzIGJhdGNoIElEcyBpZiBhbGwgcmVtb3RlIGRvY3VtZW50cyBoYXZlIGJlZW4gcmVhZCxcbiAgICAgICAgICAgIC8vIG5vIG92ZXJsYXkgd2lsbCBpbmNyZWFzZSB0aGUgb3ZlcmFsbCByZWFkIHRpbWUuIFRoaXMgaXMgd2h5IHdlIG9ubHkgbmVlZCB0byBzcGVjaWFsIGNhc2VcbiAgICAgICAgICAgIC8vIHRoZSBiYXRjaCBpZC5cbiAgICAgICAgICAgIGxldCBsYXJnZXN0QmF0Y2hJZCA9IElOSVRJQUxfTEFSR0VTVF9CQVRDSF9JRDtcbiAgICAgICAgICAgIGxldCBtb2RpZmllZERvY3MgPSBvcmlnaW5hbERvY3M7XG4gICAgICAgICAgICByZXR1cm4gb3ZlcmxheXNQcm9taXNlLm5leHQob3ZlcmxheXMgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChvdmVybGF5cywgKGtleSwgb3ZlcmxheSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFyZ2VzdEJhdGNoSWQgPCBvdmVybGF5Lmxhcmdlc3RCYXRjaElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXJnZXN0QmF0Y2hJZCA9IG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsRG9jcy5nZXQoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldEVudHJ5KHRyYW5zYWN0aW9uLCBrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAubmV4dChkb2MgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWREb2NzID0gbW9kaWZpZWREb2NzLmluc2VydChrZXksIGRvYyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMucG9wdWxhdGVPdmVybGF5cyh0cmFuc2FjdGlvbiwgb3ZlcmxheXMsIG9yaWdpbmFsRG9jcykpXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMuY29tcHV0ZVZpZXdzKHRyYW5zYWN0aW9uLCBtb2RpZmllZERvY3MsIG92ZXJsYXlzLCBkb2N1bWVudEtleVNldCgpKSlcbiAgICAgICAgICAgICAgICAgICAgLm5leHQobG9jYWxEb2NzID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoSWQ6IGxhcmdlc3RCYXRjaElkLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiBjb252ZXJ0T3ZlcmxheWVkRG9jdW1lbnRNYXBUb0RvY3VtZW50TWFwKGxvY2FsRG9jcylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldERvY3VtZW50c01hdGNoaW5nRG9jdW1lbnRRdWVyeSh0cmFuc2FjdGlvbiwgZG9jUGF0aCkge1xuICAgICAgICAvLyBKdXN0IGRvIGEgc2ltcGxlIGRvY3VtZW50IGxvb2t1cC5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RG9jdW1lbnQodHJhbnNhY3Rpb24sIG5ldyBEb2N1bWVudEtleShkb2NQYXRoKSkubmV4dChkb2N1bWVudCA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZG9jdW1lbnRNYXAoKTtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5pc0ZvdW5kRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5pbnNlcnQoZG9jdW1lbnQua2V5LCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdDb2xsZWN0aW9uR3JvdXBRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIG9mZnNldCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBxdWVyeS5jb2xsZWN0aW9uR3JvdXA7XG4gICAgICAgIGxldCByZXN1bHRzID0gZG9jdW1lbnRNYXAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYW5hZ2VyXG4gICAgICAgICAgICAuZ2V0Q29sbGVjdGlvblBhcmVudHModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25JZClcbiAgICAgICAgICAgIC5uZXh0KHBhcmVudHMgPT4ge1xuICAgICAgICAgICAgLy8gUGVyZm9ybSBhIGNvbGxlY3Rpb24gcXVlcnkgYWdhaW5zdCBlYWNoIHBhcmVudCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgICAgICAgICAgLy8gY29sbGVjdGlvbklkIGFuZCBhZ2dyZWdhdGUgdGhlIHJlc3VsdHMuXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2gocGFyZW50cywgKHBhcmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25RdWVyeSA9IGFzQ29sbGVjdGlvblF1ZXJ5QXRQYXRoKHF1ZXJ5LCBwYXJlbnQuY2hpbGQoY29sbGVjdGlvbklkKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdDb2xsZWN0aW9uUXVlcnkodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25RdWVyeSwgb2Zmc2V0LCBjb250ZXh0KS5uZXh0KHIgPT4ge1xuICAgICAgICAgICAgICAgICAgICByLmZvckVhY2goKGtleSwgZG9jKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoa2V5LCBkb2MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ0NvbGxlY3Rpb25RdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIG9mZnNldCwgY29udGV4dCkge1xuICAgICAgICAvLyBRdWVyeSB0aGUgcmVtb3RlIGRvY3VtZW50cyBhbmQgb3ZlcmxheSBtdXRhdGlvbnMuXG4gICAgICAgIGxldCBvdmVybGF5cztcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRPdmVybGF5Q2FjaGVcbiAgICAgICAgICAgIC5nZXRPdmVybGF5c0ZvckNvbGxlY3Rpb24odHJhbnNhY3Rpb24sIHF1ZXJ5LnBhdGgsIG9mZnNldC5sYXJnZXN0QmF0Y2hJZClcbiAgICAgICAgICAgIC5uZXh0KHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBvdmVybGF5cyA9IHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGUuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIG9mZnNldCwgb3ZlcmxheXMsIGNvbnRleHQpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQocmVtb3RlRG9jdW1lbnRzID0+IHtcbiAgICAgICAgICAgIC8vIEFzIGRvY3VtZW50cyBtaWdodCBtYXRjaCB0aGUgcXVlcnkgYmVjYXVzZSBvZiB0aGVpciBvdmVybGF5IHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIGluY2x1ZGUgZG9jdW1lbnRzIGZvciBhbGwgb3ZlcmxheXMgaW4gdGhlIGluaXRpYWwgZG9jdW1lbnQgc2V0LlxuICAgICAgICAgICAgb3ZlcmxheXMuZm9yRWFjaCgoXywgb3ZlcmxheSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IG92ZXJsYXkuZ2V0S2V5KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZURvY3VtZW50cy5nZXQoa2V5KSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVEb2N1bWVudHMgPSByZW1vdGVEb2N1bWVudHMuaW5zZXJ0KGtleSwgTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBvdmVybGF5cyBhbmQgbWF0Y2ggYWdhaW5zdCB0aGUgcXVlcnkuXG4gICAgICAgICAgICBsZXQgcmVzdWx0cyA9IGRvY3VtZW50TWFwKCk7XG4gICAgICAgICAgICByZW1vdGVEb2N1bWVudHMuZm9yRWFjaCgoa2V5LCBkb2N1bWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBvdmVybGF5cy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhvdmVybGF5Lm11dGF0aW9uLCBkb2N1bWVudCwgRmllbGRNYXNrLmVtcHR5KCksIFRpbWVzdGFtcC5ub3coKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIGluc2VydCB0aGUgZG9jdW1lbnRzIHRoYXQgc3RpbGwgbWF0Y2ggdGhlIHF1ZXJ5XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZG9jdW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChrZXksIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBNZW1vcnlCdW5kbGVDYWNoZSB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplcikge1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICB0aGlzLmJ1bmRsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubmFtZWRRdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXRCdW5kbGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgYnVuZGxlSWQpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuYnVuZGxlcy5nZXQoYnVuZGxlSWQpKTtcbiAgICB9XG4gICAgc2F2ZUJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmJ1bmRsZXMuc2V0KGJ1bmRsZU1ldGFkYXRhLmlkLCBmcm9tQnVuZGxlTWV0YWRhdGEoYnVuZGxlTWV0YWRhdGEpKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldE5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5TmFtZSkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5uYW1lZFF1ZXJpZXMuZ2V0KHF1ZXJ5TmFtZSkpO1xuICAgIH1cbiAgICBzYXZlTmFtZWRRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkpIHtcbiAgICAgICAgdGhpcy5uYW1lZFF1ZXJpZXMuc2V0KHF1ZXJ5Lm5hbWUsIGZyb21Qcm90b05hbWVkUXVlcnkocXVlcnkpKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBpbi1tZW1vcnkgaW1wbGVtZW50YXRpb24gb2YgRG9jdW1lbnRPdmVybGF5Q2FjaGUuXG4gKi9cbmNsYXNzIE1lbW9yeURvY3VtZW50T3ZlcmxheUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gQSBtYXAgc29ydGVkIGJ5IERvY3VtZW50S2V5LCB3aG9zZSB2YWx1ZSBpcyBhIHBhaXIgb2YgdGhlIGxhcmdlc3QgYmF0Y2ggaWRcbiAgICAgICAgLy8gZm9yIHRoZSBvdmVybGF5IGFuZCB0aGUgb3ZlcmxheSBpdHNlbGYuXG4gICAgICAgIHRoaXMub3ZlcmxheXMgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xuICAgICAgICB0aGlzLm92ZXJsYXlCeUJhdGNoSWQgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGdldE92ZXJsYXkodHJhbnNhY3Rpb24sIGtleSkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5vdmVybGF5cy5nZXQoa2V5KSk7XG4gICAgfVxuICAgIGdldE92ZXJsYXlzKHRyYW5zYWN0aW9uLCBrZXlzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ld092ZXJsYXlNYXAoKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGtleXMsIChrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE92ZXJsYXkodHJhbnNhY3Rpb24sIGtleSkubmV4dChvdmVybGF5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICB9XG4gICAgc2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBsYXJnZXN0QmF0Y2hJZCwgb3ZlcmxheXMpIHtcbiAgICAgICAgb3ZlcmxheXMuZm9yRWFjaCgoXywgbXV0YXRpb24pID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2F2ZU92ZXJsYXkodHJhbnNhY3Rpb24sIGxhcmdlc3RCYXRjaElkLCBtdXRhdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmVtb3ZlT3ZlcmxheXNGb3JCYXRjaElkKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMsIGJhdGNoSWQpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMub3ZlcmxheUJ5QmF0Y2hJZC5nZXQoYmF0Y2hJZCk7XG4gICAgICAgIGlmIChrZXlzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gKHRoaXMub3ZlcmxheXMgPSB0aGlzLm92ZXJsYXlzLnJlbW92ZShrZXkpKSk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlCeUJhdGNoSWQuZGVsZXRlKGJhdGNoSWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBnZXRPdmVybGF5c0ZvckNvbGxlY3Rpb24odHJhbnNhY3Rpb24sIGNvbGxlY3Rpb24sIHNpbmNlQmF0Y2hJZCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXdPdmVybGF5TWFwKCk7XG4gICAgICAgIGNvbnN0IGltbWVkaWF0ZUNoaWxkcmVuUGF0aExlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoICsgMTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gbmV3IERvY3VtZW50S2V5KGNvbGxlY3Rpb24uY2hpbGQoJycpKTtcbiAgICAgICAgY29uc3QgaXRlciA9IHRoaXMub3ZlcmxheXMuZ2V0SXRlcmF0b3JGcm9tKHByZWZpeCk7XG4gICAgICAgIHdoaWxlIChpdGVyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBpdGVyLmdldE5leHQoKTtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IG92ZXJsYXkuZ2V0S2V5KCk7XG4gICAgICAgICAgICBpZiAoIWNvbGxlY3Rpb24uaXNQcmVmaXhPZihrZXkucGF0aCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvY3VtZW50cyBmcm9tIHN1Yi1jb2xsZWN0aW9uc1xuICAgICAgICAgICAgaWYgKGtleS5wYXRoLmxlbmd0aCAhPT0gaW1tZWRpYXRlQ2hpbGRyZW5QYXRoTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCA+IHNpbmNlQmF0Y2hJZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQob3ZlcmxheS5nZXRLZXkoKSwgb3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIGdldE92ZXJsYXlzRm9yQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIHNpbmNlQmF0Y2hJZCwgY291bnQpIHtcbiAgICAgICAgbGV0IGJhdGNoSWRUb092ZXJsYXlzID0gbmV3IFNvcnRlZE1hcCgoa2V5MSwga2V5MikgPT4ga2V5MSAtIGtleTIpO1xuICAgICAgICBjb25zdCBpdGVyID0gdGhpcy5vdmVybGF5cy5nZXRJdGVyYXRvcigpO1xuICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gZW50cnkudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBvdmVybGF5LmdldEtleSgpO1xuICAgICAgICAgICAgaWYgKGtleS5nZXRDb2xsZWN0aW9uR3JvdXAoKSAhPT0gY29sbGVjdGlvbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCA+IHNpbmNlQmF0Y2hJZCkge1xuICAgICAgICAgICAgICAgIGxldCBvdmVybGF5c0ZvckJhdGNoSWQgPSBiYXRjaElkVG9PdmVybGF5cy5nZXQob3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCk7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXlzRm9yQmF0Y2hJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5c0ZvckJhdGNoSWQgPSBuZXdPdmVybGF5TWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoSWRUb092ZXJsYXlzID0gYmF0Y2hJZFRvT3ZlcmxheXMuaW5zZXJ0KG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQsIG92ZXJsYXlzRm9yQmF0Y2hJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG92ZXJsYXlzRm9yQmF0Y2hJZC5zZXQob3ZlcmxheS5nZXRLZXkoKSwgb3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3T3ZlcmxheU1hcCgpO1xuICAgICAgICBjb25zdCBiYXRjaEl0ZXIgPSBiYXRjaElkVG9PdmVybGF5cy5nZXRJdGVyYXRvcigpO1xuICAgICAgICB3aGlsZSAoYmF0Y2hJdGVyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBiYXRjaEl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheXMgPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgIG92ZXJsYXlzLmZvckVhY2goKGtleSwgb3ZlcmxheSkgPT4gcmVzdWx0LnNldChrZXksIG92ZXJsYXkpKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc2l6ZSgpID49IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIHNhdmVPdmVybGF5KHRyYW5zYWN0aW9uLCBsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBhc3NvY2lhdGlvbiBvZiB0aGUgb3ZlcmxheSB0byBpdHMgYmF0Y2ggaWQuXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5vdmVybGF5cy5nZXQobXV0YXRpb24ua2V5KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTZXQgPSB0aGlzLm92ZXJsYXlCeUJhdGNoSWRcbiAgICAgICAgICAgICAgICAuZ2V0KGV4aXN0aW5nLmxhcmdlc3RCYXRjaElkKVxuICAgICAgICAgICAgICAgIC5kZWxldGUobXV0YXRpb24ua2V5KTtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheUJ5QmF0Y2hJZC5zZXQoZXhpc3RpbmcubGFyZ2VzdEJhdGNoSWQsIG5ld1NldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdmVybGF5cyA9IHRoaXMub3ZlcmxheXMuaW5zZXJ0KG11dGF0aW9uLmtleSwgbmV3IE92ZXJsYXkobGFyZ2VzdEJhdGNoSWQsIG11dGF0aW9uKSk7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgYXNzb2NpYXRpb24gb2YgdGhpcyBvdmVybGF5IHRvIHRoZSBnaXZlbiBsYXJnZXN0QmF0Y2hJZC5cbiAgICAgICAgbGV0IGJhdGNoID0gdGhpcy5vdmVybGF5QnlCYXRjaElkLmdldChsYXJnZXN0QmF0Y2hJZCk7XG4gICAgICAgIGlmIChiYXRjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBiYXRjaCA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlCeUJhdGNoSWQuc2V0KGxhcmdlc3RCYXRjaElkLCBiYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdmVybGF5QnlCYXRjaElkLnNldChsYXJnZXN0QmF0Y2hJZCwgYmF0Y2guYWRkKG11dGF0aW9uLmtleSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE1lbW9yeUdsb2JhbHNDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvblRva2VuID0gQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORztcbiAgICB9XG4gICAgZ2V0U2Vzc2lvblRva2VuKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLnNlc3Npb25Ub2tlbik7XG4gICAgfVxuICAgIHNldFNlc3Npb25Ub2tlbih0cmFuc2FjdGlvbiwgc2Vzc2lvblRva2VuKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvblRva2VuID0gc2Vzc2lvblRva2VuO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiByZWZlcmVuY2VzIHRvIGEgZG9jdW1lbnQgZnJvbSBzb21lIGtpbmQgb2YgbnVtYmVyZWQgZW50aXR5XG4gKiAoZWl0aGVyIGEgdGFyZ2V0IElEIG9yIGJhdGNoIElEKS4gQXMgcmVmZXJlbmNlcyBhcmUgYWRkZWQgdG8gb3IgcmVtb3ZlZCBmcm9tXG4gKiB0aGUgc2V0IGNvcnJlc3BvbmRpbmcgZXZlbnRzIGFyZSBlbWl0dGVkIHRvIGEgcmVnaXN0ZXJlZCBnYXJiYWdlIGNvbGxlY3Rvci5cbiAqXG4gKiBFYWNoIHJlZmVyZW5jZSBpcyByZXByZXNlbnRlZCBieSBhIERvY3VtZW50UmVmZXJlbmNlIG9iamVjdC4gRWFjaCBvZiB0aGVtXG4gKiBjb250YWlucyBlbm91Z2ggaW5mb3JtYXRpb24gdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhlIHJlZmVyZW5jZS4gVGhleSBhcmUgYWxsXG4gKiBzdG9yZWQgcHJpbWFyaWx5IGluIGEgc2V0IHNvcnRlZCBieSBrZXkuIEEgZG9jdW1lbnQgaXMgY29uc2lkZXJlZCBnYXJiYWdlIGlmXG4gKiB0aGVyZSdzIG5vIHJlZmVyZW5jZXMgaW4gdGhhdCBzZXQgKHRoaXMgY2FuIGJlIGVmZmljaWVudGx5IGNoZWNrZWQgdGhhbmtzIHRvXG4gKiBzb3J0aW5nIGJ5IGtleSkuXG4gKlxuICogUmVmZXJlbmNlU2V0IGFsc28ga2VlcHMgYSBzZWNvbmRhcnkgc2V0IHRoYXQgY29udGFpbnMgcmVmZXJlbmNlcyBzb3J0ZWQgYnlcbiAqIElEcy4gVGhpcyBvbmUgaXMgdXNlZCB0byBlZmZpY2llbnRseSBpbXBsZW1lbnQgcmVtb3ZhbCBvZiBhbGwgcmVmZXJlbmNlcyBieVxuICogc29tZSB0YXJnZXQgSUQuXG4gKi9cbmNsYXNzIFJlZmVyZW5jZVNldCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIEEgc2V0IG9mIG91dHN0YW5kaW5nIHJlZmVyZW5jZXMgdG8gYSBkb2N1bWVudCBzb3J0ZWQgYnkga2V5LlxuICAgICAgICB0aGlzLnJlZnNCeUtleSA9IG5ldyBTb3J0ZWRTZXQoRG9jUmVmZXJlbmNlLmNvbXBhcmVCeUtleSk7XG4gICAgICAgIC8vIEEgc2V0IG9mIG91dHN0YW5kaW5nIHJlZmVyZW5jZXMgdG8gYSBkb2N1bWVudCBzb3J0ZWQgYnkgdGFyZ2V0IGlkLlxuICAgICAgICB0aGlzLnJlZnNCeVRhcmdldCA9IG5ldyBTb3J0ZWRTZXQoRG9jUmVmZXJlbmNlLmNvbXBhcmVCeVRhcmdldElkKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIHNldCBjb250YWlucyBubyByZWZlcmVuY2VzLiAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZnNCeUtleS5pc0VtcHR5KCk7XG4gICAgfVxuICAgIC8qKiBBZGRzIGEgcmVmZXJlbmNlIHRvIHRoZSBnaXZlbiBkb2N1bWVudCBrZXkgZm9yIHRoZSBnaXZlbiBJRC4gKi9cbiAgICBhZGRSZWZlcmVuY2Uoa2V5LCBpZCkge1xuICAgICAgICBjb25zdCByZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGtleSwgaWQpO1xuICAgICAgICB0aGlzLnJlZnNCeUtleSA9IHRoaXMucmVmc0J5S2V5LmFkZChyZWYpO1xuICAgICAgICB0aGlzLnJlZnNCeVRhcmdldCA9IHRoaXMucmVmc0J5VGFyZ2V0LmFkZChyZWYpO1xuICAgIH1cbiAgICAvKiogQWRkIHJlZmVyZW5jZXMgdG8gdGhlIGdpdmVuIGRvY3VtZW50IGtleXMgZm9yIHRoZSBnaXZlbiBJRC4gKi9cbiAgICBhZGRSZWZlcmVuY2VzKGtleXMsIGlkKSB7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gdGhpcy5hZGRSZWZlcmVuY2Uoa2V5LCBpZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBnaXZlbiBkb2N1bWVudCBrZXkgZm9yIHRoZSBnaXZlblxuICAgICAqIElELlxuICAgICAqL1xuICAgIHJlbW92ZVJlZmVyZW5jZShrZXksIGlkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUmVmKG5ldyBEb2NSZWZlcmVuY2Uoa2V5LCBpZCkpO1xuICAgIH1cbiAgICByZW1vdmVSZWZlcmVuY2VzKGtleXMsIGlkKSB7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gdGhpcy5yZW1vdmVSZWZlcmVuY2Uoa2V5LCBpZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIHJlZmVyZW5jZXMgd2l0aCBhIGdpdmVuIElELiBDYWxscyByZW1vdmVSZWYoKSBmb3IgZWFjaCBrZXlcbiAgICAgKiByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlbW92ZVJlZmVyZW5jZXNGb3JJZChpZCkge1xuICAgICAgICBjb25zdCBlbXB0eUtleSA9IG5ldyBEb2N1bWVudEtleShuZXcgUmVzb3VyY2VQYXRoKFtdKSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0UmVmID0gbmV3IERvY1JlZmVyZW5jZShlbXB0eUtleSwgaWQpO1xuICAgICAgICBjb25zdCBlbmRSZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGVtcHR5S2V5LCBpZCArIDEpO1xuICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgIHRoaXMucmVmc0J5VGFyZ2V0LmZvckVhY2hJblJhbmdlKFtzdGFydFJlZiwgZW5kUmVmXSwgcmVmID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVmKHJlZik7XG4gICAgICAgICAgICBrZXlzLnB1c2gocmVmLmtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgcmVtb3ZlQWxsUmVmZXJlbmNlcygpIHtcbiAgICAgICAgdGhpcy5yZWZzQnlLZXkuZm9yRWFjaChyZWYgPT4gdGhpcy5yZW1vdmVSZWYocmVmKSk7XG4gICAgfVxuICAgIHJlbW92ZVJlZihyZWYpIHtcbiAgICAgICAgdGhpcy5yZWZzQnlLZXkgPSB0aGlzLnJlZnNCeUtleS5kZWxldGUocmVmKTtcbiAgICAgICAgdGhpcy5yZWZzQnlUYXJnZXQgPSB0aGlzLnJlZnNCeVRhcmdldC5kZWxldGUocmVmKTtcbiAgICB9XG4gICAgcmVmZXJlbmNlc0ZvcklkKGlkKSB7XG4gICAgICAgIGNvbnN0IGVtcHR5S2V5ID0gbmV3IERvY3VtZW50S2V5KG5ldyBSZXNvdXJjZVBhdGgoW10pKTtcbiAgICAgICAgY29uc3Qgc3RhcnRSZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGVtcHR5S2V5LCBpZCk7XG4gICAgICAgIGNvbnN0IGVuZFJlZiA9IG5ldyBEb2NSZWZlcmVuY2UoZW1wdHlLZXksIGlkICsgMSk7XG4gICAgICAgIGxldCBrZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgdGhpcy5yZWZzQnlUYXJnZXQuZm9yRWFjaEluUmFuZ2UoW3N0YXJ0UmVmLCBlbmRSZWZdLCByZWYgPT4ge1xuICAgICAgICAgICAga2V5cyA9IGtleXMuYWRkKHJlZi5rZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIGNvbnRhaW5zS2V5KGtleSkge1xuICAgICAgICBjb25zdCByZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGtleSwgMCk7XG4gICAgICAgIGNvbnN0IGZpcnN0UmVmID0gdGhpcy5yZWZzQnlLZXkuZmlyc3RBZnRlck9yRXF1YWwocmVmKTtcbiAgICAgICAgcmV0dXJuIGZpcnN0UmVmICE9PSBudWxsICYmIGtleS5pc0VxdWFsKGZpcnN0UmVmLmtleSk7XG4gICAgfVxufVxuY2xhc3MgRG9jUmVmZXJlbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHRhcmdldE9yQmF0Y2hJZCkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy50YXJnZXRPckJhdGNoSWQgPSB0YXJnZXRPckJhdGNoSWQ7XG4gICAgfVxuICAgIC8qKiBDb21wYXJlIGJ5IGtleSB0aGVuIGJ5IElEICovXG4gICAgc3RhdGljIGNvbXBhcmVCeUtleShsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gKERvY3VtZW50S2V5LmNvbXBhcmF0b3IobGVmdC5rZXksIHJpZ2h0LmtleSkgfHxcbiAgICAgICAgICAgIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC50YXJnZXRPckJhdGNoSWQsIHJpZ2h0LnRhcmdldE9yQmF0Y2hJZCkpO1xuICAgIH1cbiAgICAvKiogQ29tcGFyZSBieSBJRCB0aGVuIGJ5IGtleSAqL1xuICAgIHN0YXRpYyBjb21wYXJlQnlUYXJnZXRJZChsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gKHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdC50YXJnZXRPckJhdGNoSWQsIHJpZ2h0LnRhcmdldE9yQmF0Y2hJZCkgfHxcbiAgICAgICAgICAgIERvY3VtZW50S2V5LmNvbXBhcmF0b3IobGVmdC5rZXksIHJpZ2h0LmtleSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE1lbW9yeU11dGF0aW9uUXVldWUge1xuICAgIGNvbnN0cnVjdG9yKGluZGV4TWFuYWdlciwgcmVmZXJlbmNlRGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBpbmRleE1hbmFnZXI7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUgPSByZWZlcmVuY2VEZWxlZ2F0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZXQgb2YgYWxsIG11dGF0aW9ucyB0aGF0IGhhdmUgYmVlbiBzZW50IGJ1dCBub3QgeWV0IGJlZW4gYXBwbGllZCB0b1xuICAgICAgICAgKiB0aGUgYmFja2VuZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZSA9IFtdO1xuICAgICAgICAvKiogTmV4dCB2YWx1ZSB0byB1c2Ugd2hlbiBhc3NpZ25pbmcgc2VxdWVudGlhbCBJRHMgdG8gZWFjaCBtdXRhdGlvbiBiYXRjaC4gKi9cbiAgICAgICAgdGhpcy5uZXh0QmF0Y2hJZCA9IDE7XG4gICAgICAgIC8qKiBBbiBvcmRlcmVkIG1hcHBpbmcgYmV0d2VlbiBkb2N1bWVudHMgYW5kIHRoZSBtdXRhdGlvbnMgYmF0Y2ggSURzLiAqL1xuICAgICAgICB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5ID0gbmV3IFNvcnRlZFNldChEb2NSZWZlcmVuY2UuY29tcGFyZUJ5S2V5KTtcbiAgICB9XG4gICAgY2hlY2tFbXB0eSh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCA9PT0gMCk7XG4gICAgfVxuICAgIGFkZE11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGxvY2FsV3JpdGVUaW1lLCBiYXNlTXV0YXRpb25zLCBtdXRhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYmF0Y2hJZCA9IHRoaXMubmV4dEJhdGNoSWQ7XG4gICAgICAgIHRoaXMubmV4dEJhdGNoSWQrKztcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uUXVldWVbdGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhdGNoID0gbmV3IE11dGF0aW9uQmF0Y2goYmF0Y2hJZCwgbG9jYWxXcml0ZVRpbWUsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucyk7XG4gICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZS5wdXNoKGJhdGNoKTtcbiAgICAgICAgLy8gVHJhY2sgcmVmZXJlbmNlcyBieSBkb2N1bWVudCBrZXkgYW5kIGluZGV4IGNvbGxlY3Rpb24gcGFyZW50cy5cbiAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkgPSB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5LmFkZChuZXcgRG9jUmVmZXJlbmNlKG11dGF0aW9uLmtleSwgYmF0Y2hJZCkpO1xuICAgICAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIuYWRkVG9Db2xsZWN0aW9uUGFyZW50SW5kZXgodHJhbnNhY3Rpb24sIG11dGF0aW9uLmtleS5wYXRoLnBvcExhc3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGJhdGNoKTtcbiAgICB9XG4gICAgbG9va3VwTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbiwgYmF0Y2hJZCkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5maW5kTXV0YXRpb25CYXRjaChiYXRjaElkKSk7XG4gICAgfVxuICAgIGdldE5leHRNdXRhdGlvbkJhdGNoQWZ0ZXJCYXRjaElkKHRyYW5zYWN0aW9uLCBiYXRjaElkKSB7XG4gICAgICAgIGNvbnN0IG5leHRCYXRjaElkID0gYmF0Y2hJZCArIDE7XG4gICAgICAgIC8vIFRoZSByZXF1ZXN0ZWQgYmF0Y2hJZCBtYXkgc3RpbGwgYmUgb3V0IG9mIHJhbmdlIHNvIG5vcm1hbGl6ZSBpdCB0byB0aGVcbiAgICAgICAgLy8gc3RhcnQgb2YgdGhlIHF1ZXVlLlxuICAgICAgICBjb25zdCByYXdJbmRleCA9IHRoaXMuaW5kZXhPZkJhdGNoSWQobmV4dEJhdGNoSWQpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHJhd0luZGV4IDwgMCA/IDAgOiByYXdJbmRleDtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPiBpbmRleCA/IHRoaXMubXV0YXRpb25RdWV1ZVtpbmRleF0gOiBudWxsKTtcbiAgICB9XG4gICAgZ2V0SGlnaGVzdFVuYWNrbm93bGVkZ2VkQmF0Y2hJZCgpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPT09IDAgPyBCQVRDSElEX1VOS05PV04gOiB0aGlzLm5leHRCYXRjaElkIC0gMSk7XG4gICAgfVxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlcyh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5tdXRhdGlvblF1ZXVlLnNsaWNlKCkpO1xuICAgIH1cbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXNBZmZlY3RpbmdEb2N1bWVudEtleSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRG9jUmVmZXJlbmNlKGRvY3VtZW50S2V5LCAwKTtcbiAgICAgICAgY29uc3QgZW5kID0gbmV3IERvY1JlZmVyZW5jZShkb2N1bWVudEtleSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkuZm9yRWFjaEluUmFuZ2UoW3N0YXJ0LCBlbmRdLCByZWYgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmZpbmRNdXRhdGlvbkJhdGNoKHJlZi50YXJnZXRPckJhdGNoSWQpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYmF0Y2gpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ0RvY3VtZW50S2V5cyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XG4gICAgICAgIGxldCB1bmlxdWVCYXRjaElEcyA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XG4gICAgICAgIGRvY3VtZW50S2V5cy5mb3JFYWNoKGRvY3VtZW50S2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERvY1JlZmVyZW5jZShkb2N1bWVudEtleSwgMCk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBuZXcgRG9jUmVmZXJlbmNlKGRvY3VtZW50S2V5LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICAgICAgdGhpcy5iYXRjaGVzQnlEb2N1bWVudEtleS5mb3JFYWNoSW5SYW5nZShbc3RhcnQsIGVuZF0sIHJlZiA9PiB7XG4gICAgICAgICAgICAgICAgdW5pcXVlQmF0Y2hJRHMgPSB1bmlxdWVCYXRjaElEcy5hZGQocmVmLnRhcmdldE9yQmF0Y2hJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmZpbmRNdXRhdGlvbkJhdGNoZXModW5pcXVlQmF0Y2hJRHMpKTtcbiAgICB9XG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KSB7XG4gICAgICAgIC8vIFVzZSB0aGUgcXVlcnkgcGF0aCBhcyBhIHByZWZpeCBmb3IgdGVzdGluZyBpZiBhIGRvY3VtZW50IG1hdGNoZXMgdGhlXG4gICAgICAgIC8vIHF1ZXJ5LlxuICAgICAgICBjb25zdCBwcmVmaXggPSBxdWVyeS5wYXRoO1xuICAgICAgICBjb25zdCBpbW1lZGlhdGVDaGlsZHJlblBhdGhMZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgMTtcbiAgICAgICAgLy8gQ29uc3RydWN0IGEgZG9jdW1lbnQgcmVmZXJlbmNlIGZvciBhY3R1YWxseSBzY2FubmluZyB0aGUgaW5kZXguIFVubGlrZVxuICAgICAgICAvLyB0aGUgcHJlZml4IHRoZSBkb2N1bWVudCBrZXkgaW4gdGhpcyByZWZlcmVuY2UgbXVzdCBoYXZlIGFuIGV2ZW4gbnVtYmVyIG9mXG4gICAgICAgIC8vIHNlZ21lbnRzLiBUaGUgZW1wdHkgc2VnbWVudCBjYW4gYmUgdXNlZCBhIHN1ZmZpeCBvZiB0aGUgcXVlcnkgcGF0aFxuICAgICAgICAvLyBiZWNhdXNlIGl0IHByZWNlZGVzIGFsbCBvdGhlciBzZWdtZW50cyBpbiBhbiBvcmRlcmVkIHRyYXZlcnNhbC5cbiAgICAgICAgbGV0IHN0YXJ0UGF0aCA9IHByZWZpeDtcbiAgICAgICAgaWYgKCFEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHN0YXJ0UGF0aCkpIHtcbiAgICAgICAgICAgIHN0YXJ0UGF0aCA9IHN0YXJ0UGF0aC5jaGlsZCgnJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRG9jUmVmZXJlbmNlKG5ldyBEb2N1bWVudEtleShzdGFydFBhdGgpLCAwKTtcbiAgICAgICAgLy8gRmluZCB1bmlxdWUgYmF0Y2hJRHMgcmVmZXJlbmNlZCBieSBhbGwgZG9jdW1lbnRzIHBvdGVudGlhbGx5IG1hdGNoaW5nIHRoZVxuICAgICAgICAvLyBxdWVyeS5cbiAgICAgICAgbGV0IHVuaXF1ZUJhdGNoSURzID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICAgICAgdGhpcy5iYXRjaGVzQnlEb2N1bWVudEtleS5mb3JFYWNoV2hpbGUocmVmID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJvd0tleVBhdGggPSByZWYua2V5LnBhdGg7XG4gICAgICAgICAgICBpZiAoIXByZWZpeC5pc1ByZWZpeE9mKHJvd0tleVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUm93cyB3aXRoIGRvY3VtZW50IGtleXMgbW9yZSB0aGFuIG9uZSBzZWdtZW50IGxvbmdlciB0aGFuIHRoZSBxdWVyeVxuICAgICAgICAgICAgICAgIC8vIHBhdGggY2FuJ3QgYmUgbWF0Y2hlcy4gRm9yIGV4YW1wbGUsIGEgcXVlcnkgb24gJ3Jvb21zJyBjYW4ndCBtYXRjaFxuICAgICAgICAgICAgICAgIC8vIHRoZSBkb2N1bWVudCAvcm9vbXMvYWJjL21lc3NhZ2VzL3h5eC5cbiAgICAgICAgICAgICAgICAvLyBUT0RPKG1jZyk6IHdlJ2xsIG5lZWQgYSBkaWZmZXJlbnQgc2Nhbm5lciB3aGVuIHdlIGltcGxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGFuY2VzdG9yIHF1ZXJpZXMuXG4gICAgICAgICAgICAgICAgaWYgKHJvd0tleVBhdGgubGVuZ3RoID09PSBpbW1lZGlhdGVDaGlsZHJlblBhdGhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlQmF0Y2hJRHMgPSB1bmlxdWVCYXRjaElEcy5hZGQocmVmLnRhcmdldE9yQmF0Y2hJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzdGFydCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmZpbmRNdXRhdGlvbkJhdGNoZXModW5pcXVlQmF0Y2hJRHMpKTtcbiAgICB9XG4gICAgZmluZE11dGF0aW9uQmF0Y2hlcyhiYXRjaElEcykge1xuICAgICAgICAvLyBDb25zdHJ1Y3QgYW4gYXJyYXkgb2YgbWF0Y2hpbmcgYmF0Y2hlcywgc29ydGVkIGJ5IGJhdGNoSUQgdG8gZW5zdXJlIHRoYXRcbiAgICAgICAgLy8gbXVsdGlwbGUgbXV0YXRpb25zIGFmZmVjdGluZyB0aGUgc2FtZSBkb2N1bWVudCBrZXkgYXJlIGFwcGxpZWQgaW4gb3JkZXIuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBiYXRjaElEcy5mb3JFYWNoKGJhdGNoSWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmZpbmRNdXRhdGlvbkJhdGNoKGJhdGNoSWQpO1xuICAgICAgICAgICAgaWYgKGJhdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVtb3ZlTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbiwgYmF0Y2gpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGJhdGNoIGZvciByZW1vdmFsLlxuICAgICAgICBjb25zdCBiYXRjaEluZGV4ID0gdGhpcy5pbmRleE9mRXhpc3RpbmdCYXRjaElkKGJhdGNoLmJhdGNoSWQsICdyZW1vdmVkJyk7XG4gICAgICAgIGhhcmRBc3NlcnQoYmF0Y2hJbmRleCA9PT0gMCk7XG4gICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZS5zaGlmdCgpO1xuICAgICAgICBsZXQgcmVmZXJlbmNlcyA9IHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChiYXRjaC5tdXRhdGlvbnMsIChtdXRhdGlvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gbmV3IERvY1JlZmVyZW5jZShtdXRhdGlvbi5rZXksIGJhdGNoLmJhdGNoSWQpO1xuICAgICAgICAgICAgcmVmZXJlbmNlcyA9IHJlZmVyZW5jZXMuZGVsZXRlKHJlZik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZS5tYXJrUG90ZW50aWFsbHlPcnBoYW5lZCh0cmFuc2FjdGlvbiwgbXV0YXRpb24ua2V5KTtcbiAgICAgICAgfSkubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5ID0gcmVmZXJlbmNlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZUNhY2hlZE11dGF0aW9uS2V5cyhiYXRjaElkKSB7XG4gICAgICAgIC8vIE5vLW9wIHNpbmNlIHRoZSBtZW1vcnkgbXV0YXRpb24gcXVldWUgZG9lcyBub3QgbWFpbnRhaW4gYSBzZXBhcmF0ZSBjYWNoZS5cbiAgICB9XG4gICAgY29udGFpbnNLZXkodHhuLCBrZXkpIHtcbiAgICAgICAgY29uc3QgcmVmID0gbmV3IERvY1JlZmVyZW5jZShrZXksIDApO1xuICAgICAgICBjb25zdCBmaXJzdFJlZiA9IHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkuZmlyc3RBZnRlck9yRXF1YWwocmVmKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGtleS5pc0VxdWFsKGZpcnN0UmVmICYmIGZpcnN0UmVmLmtleSkpO1xuICAgIH1cbiAgICBwZXJmb3JtQ29uc2lzdGVuY3lDaGVjayh0eG4pIHtcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPT09IDApIDtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gYmF0Y2hJZCBpbiB0aGUgbXV0YXRpb24gcXVldWUgYW5kIGFzc2VydHMgdGhhdFxuICAgICAqIHRoZSByZXN1bHRpbmcgaW5kZXggaXMgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIHF1ZXVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJhdGNoSWQgLSBUaGUgYmF0Y2hJZCB0byBzZWFyY2ggZm9yXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgY2FsbGVyIGlzIGRvaW5nLCBwaHJhc2VkIGluIHBhc3NpdmVcbiAgICAgKiBmb3JtIChlLmcuIFwiYWNrbm93bGVkZ2VkXCIgaW4gYSByb3V0aW5lIHRoYXQgYWNrbm93bGVkZ2VzIGJhdGNoZXMpLlxuICAgICAqL1xuICAgIGluZGV4T2ZFeGlzdGluZ0JhdGNoSWQoYmF0Y2hJZCwgYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleE9mQmF0Y2hJZChiYXRjaElkKTtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIGJhdGNoSWQgaW4gdGhlIG11dGF0aW9uIHF1ZXVlLiBUaGlzIG9wZXJhdGlvblxuICAgICAqIGlzIE8oMSkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcHV0ZWQgaW5kZXggb2YgdGhlIGJhdGNoIHdpdGggdGhlIGdpdmVuIGJhdGNoSWQsIGJhc2VkIG9uXG4gICAgICogdGhlIHN0YXRlIG9mIHRoZSBxdWV1ZS4gTm90ZSB0aGlzIGluZGV4IGNhbiBiZSBuZWdhdGl2ZSBpZiB0aGUgcmVxdWVzdGVkXG4gICAgICogYmF0Y2hJZCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcXVldWUgb3IgcGFzdCB0aGUgZW5kIG9mIHRoZVxuICAgICAqIHF1ZXVlIGlmIHRoZSBiYXRjaElkIGlzIGxhcmdlciB0aGFuIHRoZSBsYXN0IGFkZGVkIGJhdGNoLlxuICAgICAqL1xuICAgIGluZGV4T2ZCYXRjaElkKGJhdGNoSWQpIHtcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIEFzIGFuIGluZGV4IHRoaXMgaXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhhbWluZSB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlIHRvIGZpZ3VyZSBvdXQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVcbiAgICAgICAgLy8gYmF0Y2hJZCBhbmQgaW5kZXhlcyBpbiB0aGUgYXJyYXkuIE5vdGUgdGhhdCBzaW5jZSB0aGUgcXVldWUgaXMgb3JkZXJlZFxuICAgICAgICAvLyBieSBiYXRjaElkLCBpZiB0aGUgZmlyc3QgYmF0Y2ggaGFzIGEgbGFyZ2VyIGJhdGNoSWQgdGhlbiB0aGUgcmVxdWVzdGVkXG4gICAgICAgIC8vIGJhdGNoSWQgZG9lc24ndCBleGlzdCBpbiB0aGUgcXVldWUuXG4gICAgICAgIGNvbnN0IGZpcnN0QmF0Y2hJZCA9IHRoaXMubXV0YXRpb25RdWV1ZVswXS5iYXRjaElkO1xuICAgICAgICByZXR1cm4gYmF0Y2hJZCAtIGZpcnN0QmF0Y2hJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSB2ZXJzaW9uIG9mIGxvb2t1cE11dGF0aW9uQmF0Y2ggdGhhdCBkb2Vzbid0IHJldHVybiBhIHByb21pc2UsIHRoaXMgbWFrZXNcbiAgICAgKiBvdGhlciBmdW5jdGlvbnMgdGhhdCB1c2VzIHRoaXMgY29kZSBlYXNpZXIgdG8gcmVhZCBhbmQgbW9yZSBlZmZpY2llbnQuXG4gICAgICovXG4gICAgZmluZE11dGF0aW9uQmF0Y2goYmF0Y2hJZCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXhPZkJhdGNoSWQoYmF0Y2hJZCk7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLm11dGF0aW9uUXVldWVbaW5kZXhdO1xuICAgICAgICByZXR1cm4gYmF0Y2g7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgc21hbGxlc3QgdmFsdWUgcmVwcmVzZW50YWJsZSBieSBhIDY0LWJpdCBzaWduZWQgaW50ZWdlciAobG9uZykuXG4gKi9cbmNvbnN0IE1JTl9MT05HX1ZBTFVFID0gJy05MjIzMzcyMDM2ODU0Nzc1ODA4JztcbmZ1bmN0aW9uIGRvY3VtZW50RW50cnlNYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XG59XG4vKipcbiAqIFRoZSBtZW1vcnktb25seSBSZW1vdGVEb2N1bWVudENhY2hlIGZvciBJbmRleGVkRGIuIFRvIGNvbnN0cnVjdCwgaW52b2tlXG4gKiBgbmV3TWVtb3J5UmVtb3RlRG9jdW1lbnRDYWNoZSgpYC5cbiAqL1xuY2xhc3MgTWVtb3J5UmVtb3RlRG9jdW1lbnRDYWNoZUltcGwge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzaXplciAtIFVzZWQgdG8gYXNzZXNzIHRoZSBzaXplIG9mIGEgZG9jdW1lbnQuIEZvciBlYWdlciBHQywgdGhpcyBpc1xuICAgICAqIGV4cGVjdGVkIHRvIGp1c3QgcmV0dXJuIDAgdG8gYXZvaWQgdW5uZWNlc3NhcmlseSBkb2luZyB0aGUgd29yayBvZlxuICAgICAqIGNhbGN1bGF0aW5nIHRoZSBzaXplLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNpemVyKSB7XG4gICAgICAgIHRoaXMuc2l6ZXIgPSBzaXplcjtcbiAgICAgICAgLyoqIFVuZGVybHlpbmcgY2FjaGUgb2YgZG9jdW1lbnRzIGFuZCB0aGVpciByZWFkIHRpbWVzLiAqL1xuICAgICAgICB0aGlzLmRvY3MgPSBkb2N1bWVudEVudHJ5TWFwKCk7XG4gICAgICAgIC8qKiBTaXplIG9mIGFsbCBjYWNoZWQgZG9jdW1lbnRzLiAqL1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cbiAgICBzZXRJbmRleE1hbmFnZXIoaW5kZXhNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gaW5kZXhNYW5hZ2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBzdXBwbGllZCBlbnRyeSB0byB0aGUgY2FjaGUgYW5kIHVwZGF0ZXMgdGhlIGNhY2hlIHNpemUgYXMgYXBwcm9wcmlhdGUuXG4gICAgICpcbiAgICAgKiBBbGwgY2FsbHMgb2YgYGFkZEVudHJ5YCAgYXJlIHJlcXVpcmVkIHRvIGdvIHRocm91Z2ggdGhlIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyXG4gICAgICogcmV0dXJuZWQgYnkgYG5ld0NoYW5nZUJ1ZmZlcigpYC5cbiAgICAgKi9cbiAgICBhZGRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGRvYy5rZXk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5kb2NzLmdldChrZXkpO1xuICAgICAgICBjb25zdCBwcmV2aW91c1NpemUgPSBlbnRyeSA/IGVudHJ5LnNpemUgOiAwO1xuICAgICAgICBjb25zdCBjdXJyZW50U2l6ZSA9IHRoaXMuc2l6ZXIoZG9jKTtcbiAgICAgICAgdGhpcy5kb2NzID0gdGhpcy5kb2NzLmluc2VydChrZXksIHtcbiAgICAgICAgICAgIGRvY3VtZW50OiBkb2MubXV0YWJsZUNvcHkoKSxcbiAgICAgICAgICAgIHNpemU6IGN1cnJlbnRTaXplXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNpemUgKz0gY3VycmVudFNpemUgLSBwcmV2aW91c1NpemU7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFuYWdlci5hZGRUb0NvbGxlY3Rpb25QYXJlbnRJbmRleCh0cmFuc2FjdGlvbiwga2V5LnBhdGgucG9wTGFzdCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGVudHJ5IGZyb20gdGhlIGNhY2hlIGFuZCB1cGRhdGVzIHRoZSBjYWNoZSBzaXplIGFzIGFwcHJvcHJpYXRlLlxuICAgICAqXG4gICAgICogQWxsIGNhbGxzIG9mIGByZW1vdmVFbnRyeWAgYXJlIHJlcXVpcmVkIHRvIGdvIHRocm91Z2ggdGhlIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyXG4gICAgICogcmV0dXJuZWQgYnkgYG5ld0NoYW5nZUJ1ZmZlcigpYC5cbiAgICAgKi9cbiAgICByZW1vdmVFbnRyeShkb2N1bWVudEtleSkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZG9jcy5nZXQoZG9jdW1lbnRLZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jcyA9IHRoaXMuZG9jcy5yZW1vdmUoZG9jdW1lbnRLZXkpO1xuICAgICAgICAgICAgdGhpcy5zaXplIC09IGVudHJ5LnNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5kb2NzLmdldChkb2N1bWVudEtleSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShlbnRyeVxuICAgICAgICAgICAgPyBlbnRyeS5kb2N1bWVudC5tdXRhYmxlQ29weSgpXG4gICAgICAgICAgICA6IE11dGFibGVEb2N1bWVudC5uZXdJbnZhbGlkRG9jdW1lbnQoZG9jdW1lbnRLZXkpKTtcbiAgICB9XG4gICAgZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIGRvY3VtZW50S2V5cy5mb3JFYWNoKGRvY3VtZW50S2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5kb2NzLmdldChkb2N1bWVudEtleSk7XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoZG9jdW1lbnRLZXksIGVudHJ5XG4gICAgICAgICAgICAgICAgPyBlbnRyeS5kb2N1bWVudC5tdXRhYmxlQ29weSgpXG4gICAgICAgICAgICAgICAgOiBNdXRhYmxlRG9jdW1lbnQubmV3SW52YWxpZERvY3VtZW50KGRvY3VtZW50S2V5KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgfVxuICAgIGdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQsIG11dGF0ZWREb2NzKSB7XG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIC8vIERvY3VtZW50cyBhcmUgb3JkZXJlZCBieSBrZXksIHNvIHdlIGNhbiB1c2UgYSBwcmVmaXggc2NhbiB0byBuYXJyb3cgZG93blxuICAgICAgICAvLyB0aGUgZG9jdW1lbnRzIHdlIG5lZWQgdG8gbWF0Y2ggdGhlIHF1ZXJ5IGFnYWluc3QuXG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25QYXRoID0gcXVlcnkucGF0aDtcbiAgICAgICAgLy8gRG9jdW1lbnQga2V5cyBhcmUgb3JkZXJlZCBmaXJzdCBieSBudW1lcmljIHZhbHVlIChcIl9faWQ8TG9uZz5fX1wiKSxcbiAgICAgICAgLy8gdGhlbiBsZXhpY29ncmFwaGljYWxseSBieSBzdHJpbmcgdmFsdWUuIFN0YXJ0IHRoZSBpdGVyYXRvciBhdCB0aGUgbWluaW11bVxuICAgICAgICAvLyBwb3NzaWJsZSBEb2N1bWVudCBrZXkgdmFsdWUuXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG5ldyBEb2N1bWVudEtleShjb2xsZWN0aW9uUGF0aC5jaGlsZCgnX19pZCcgKyBNSU5fTE9OR19WQUxVRSArICdfXycpKTtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLmRvY3MuZ2V0SXRlcmF0b3JGcm9tKHByZWZpeCk7XG4gICAgICAgIHdoaWxlIChpdGVyYXRvci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZTogeyBkb2N1bWVudCB9IH0gPSBpdGVyYXRvci5nZXROZXh0KCk7XG4gICAgICAgICAgICBpZiAoIWNvbGxlY3Rpb25QYXRoLmlzUHJlZml4T2Yoa2V5LnBhdGgpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5LnBhdGgubGVuZ3RoID4gY29sbGVjdGlvblBhdGgubGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgZW50cmllcyBmcm9tIHN1YmNvbGxlY3Rpb25zLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4T2Zmc2V0Q29tcGFyYXRvcihuZXdJbmRleE9mZnNldEZyb21Eb2N1bWVudChkb2N1bWVudCksIG9mZnNldCkgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkb2N1bWVudCBzb3J0cyBiZWZvcmUgdGhlIG9mZnNldC5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbXV0YXRlZERvY3MuaGFzKGRvY3VtZW50LmtleSkgJiYgIXF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZG9jdW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRvY3VtZW50IGNhbm5vdCBwb3NzaWJseSBtYXRjaCB0aGUgcXVlcnkuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoZG9jdW1lbnQua2V5LCBkb2N1bWVudC5tdXRhYmxlQ29weSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgfVxuICAgIGdldEFsbEZyb21Db2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgb2Zmc2V0LCBsaW1pdCkge1xuICAgICAgICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSB0aGUgSW5kZXhCYWNrZmlsbGVyIGlmIHBlcnNpc3RlbmNlXG4gICAgICAgIC8vIGlzIGVuYWJsZWQuXG4gICAgICAgIGZhaWwoKTtcbiAgICB9XG4gICAgZm9yRWFjaERvY3VtZW50S2V5KHRyYW5zYWN0aW9uLCBmKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh0aGlzLmRvY3MsIChrZXkpID0+IGYoa2V5KSk7XG4gICAgfVxuICAgIG5ld0NoYW5nZUJ1ZmZlcihvcHRpb25zKSB7XG4gICAgICAgIC8vIGB0cmFja1JlbW92YWxzYCBpcyBpZ25vcmVzIHNpbmNlIHRoZSBNZW1vcnlSZW1vdGVEb2N1bWVudENhY2hlIGtlZXBzXG4gICAgICAgIC8vIGEgc2VwYXJhdGUgY2hhbmdlbG9nIGFuZCBkb2VzIG5vdCBuZWVkIHNwZWNpYWwgaGFuZGxpbmcgZm9yIHJlbW92YWxzLlxuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHRoaXMpO1xuICAgIH1cbiAgICBnZXRTaXplKHR4bikge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5zaXplKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVtb3J5LW9ubHkgUmVtb3RlRG9jdW1lbnRDYWNoZS5cbiAqXG4gKiBAcGFyYW0gc2l6ZXIgLSBVc2VkIHRvIGFzc2VzcyB0aGUgc2l6ZSBvZiBhIGRvY3VtZW50LiBGb3IgZWFnZXIgR0MsIHRoaXMgaXNcbiAqIGV4cGVjdGVkIHRvIGp1c3QgcmV0dXJuIDAgdG8gYXZvaWQgdW5uZWNlc3NhcmlseSBkb2luZyB0aGUgd29yayBvZlxuICogY2FsY3VsYXRpbmcgdGhlIHNpemUuXG4gKi9cbmZ1bmN0aW9uIG5ld01lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGUoc2l6ZXIpIHtcbiAgICByZXR1cm4gbmV3IE1lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGVJbXBsKHNpemVyKTtcbn1cbi8qKlxuICogSGFuZGxlcyB0aGUgZGV0YWlscyBvZiBhZGRpbmcgYW5kIHVwZGF0aW5nIGRvY3VtZW50cyBpbiB0aGUgTWVtb3J5UmVtb3RlRG9jdW1lbnRDYWNoZS5cbiAqL1xuY2xhc3MgTWVtb3J5UmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIgZXh0ZW5kcyBSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnRDYWNoZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRvY3VtZW50Q2FjaGUgPSBkb2N1bWVudENhY2hlO1xuICAgIH1cbiAgICBhcHBseUNoYW5nZXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmZvckVhY2goKGtleSwgZG9jKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9jLmlzVmFsaWREb2N1bWVudCgpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvY3VtZW50Q2FjaGUuYWRkRW50cnkodHJhbnNhY3Rpb24sIGRvYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudENhY2hlLnJlbW92ZUVudHJ5KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xuICAgIH1cbiAgICBnZXRGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50Q2FjaGUuZ2V0RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KTtcbiAgICB9XG4gICAgZ2V0QWxsRnJvbUNhY2hlKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRDYWNoZS5nZXRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE1lbW9yeVRhcmdldENhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwZXJzaXN0ZW5jZSkge1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gcGVyc2lzdGVuY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXBzIGEgdGFyZ2V0IHRvIHRoZSBkYXRhIGFib3V0IHRoYXQgdGFyZ2V0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhcmdldHMgPSBuZXcgT2JqZWN0TWFwKHQgPT4gY2Fub25pZnlUYXJnZXQodCksIHRhcmdldEVxdWFscyk7XG4gICAgICAgIC8qKiBUaGUgbGFzdCByZWNlaXZlZCBzbmFwc2hvdCB2ZXJzaW9uLiAqL1xuICAgICAgICB0aGlzLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPSBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgICAgIC8qKiBUaGUgaGlnaGVzdCBudW1iZXJlZCB0YXJnZXQgSUQgZW5jb3VudGVyZWQuICovXG4gICAgICAgIHRoaXMuaGlnaGVzdFRhcmdldElkID0gMDtcbiAgICAgICAgLyoqIFRoZSBoaWdoZXN0IHNlcXVlbmNlIG51bWJlciBlbmNvdW50ZXJlZC4gKi9cbiAgICAgICAgdGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBvcmRlcmVkIGJpZGlyZWN0aW9uYWwgbWFwcGluZyBiZXR3ZWVuIGRvY3VtZW50cyBhbmQgdGhlIHJlbW90ZSB0YXJnZXRcbiAgICAgICAgICogSURzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gbmV3IFJlZmVyZW5jZVNldCgpO1xuICAgICAgICB0aGlzLnRhcmdldENvdW50ID0gMDtcbiAgICAgICAgdGhpcy50YXJnZXRJZEdlbmVyYXRvciA9IFRhcmdldElkR2VuZXJhdG9yLmZvclRhcmdldENhY2hlKCk7XG4gICAgfVxuICAgIGZvckVhY2hUYXJnZXQodHhuLCBmKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0cy5mb3JFYWNoKChfLCB0YXJnZXREYXRhKSA9PiBmKHRhcmdldERhdGEpKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbik7XG4gICAgfVxuICAgIGdldEhpZ2hlc3RTZXF1ZW5jZU51bWJlcih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIpO1xuICAgIH1cbiAgICBhbGxvY2F0ZVRhcmdldElkKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuaGlnaGVzdFRhcmdldElkID0gdGhpcy50YXJnZXRJZEdlbmVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmhpZ2hlc3RUYXJnZXRJZCk7XG4gICAgfVxuICAgIHNldFRhcmdldHNNZXRhZGF0YSh0cmFuc2FjdGlvbiwgaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyLCBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgIGlmIChsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPSBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPiB0aGlzLmhpZ2hlc3RTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICAgICAgdGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIgPSBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHNhdmVUYXJnZXREYXRhKHRhcmdldERhdGEpIHtcbiAgICAgICAgdGhpcy50YXJnZXRzLnNldCh0YXJnZXREYXRhLnRhcmdldCwgdGFyZ2V0RGF0YSk7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gdGFyZ2V0RGF0YS50YXJnZXRJZDtcbiAgICAgICAgaWYgKHRhcmdldElkID4gdGhpcy5oaWdoZXN0VGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0SWRHZW5lcmF0b3IgPSBuZXcgVGFyZ2V0SWRHZW5lcmF0b3IodGFyZ2V0SWQpO1xuICAgICAgICAgICAgdGhpcy5oaWdoZXN0VGFyZ2V0SWQgPSB0YXJnZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlciA+IHRoaXMuaGlnaGVzdFNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLmhpZ2hlc3RTZXF1ZW5jZU51bWJlciA9IHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSkge1xuICAgICAgICB0aGlzLnNhdmVUYXJnZXREYXRhKHRhcmdldERhdGEpO1xuICAgICAgICB0aGlzLnRhcmdldENvdW50ICs9IDE7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIHRoaXMuc2F2ZVRhcmdldERhdGEodGFyZ2V0RGF0YSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0cy5kZWxldGUodGFyZ2V0RGF0YS50YXJnZXQpO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMucmVtb3ZlUmVmZXJlbmNlc0ZvcklkKHRhcmdldERhdGEudGFyZ2V0SWQpO1xuICAgICAgICB0aGlzLnRhcmdldENvdW50IC09IDE7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXRzKHRyYW5zYWN0aW9uLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgY29uc3QgcmVtb3ZhbHMgPSBbXTtcbiAgICAgICAgdGhpcy50YXJnZXRzLmZvckVhY2goKGtleSwgdGFyZ2V0RGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIgPD0gdXBwZXJCb3VuZCAmJlxuICAgICAgICAgICAgICAgIGFjdGl2ZVRhcmdldElkcy5nZXQodGFyZ2V0RGF0YS50YXJnZXRJZCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgcmVtb3ZhbHMucHVzaCh0aGlzLnJlbW92ZU1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhLnRhcmdldElkKSk7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihyZW1vdmFscykubmV4dCgoKSA9PiBjb3VudCk7XG4gICAgfVxuICAgIGdldFRhcmdldENvdW50KHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLnRhcmdldENvdW50KTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSB0aGlzLnRhcmdldHMuZ2V0KHRhcmdldCkgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRhcmdldERhdGEpO1xuICAgIH1cbiAgICBhZGRNYXRjaGluZ0tleXModHhuLCBrZXlzLCB0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMuYWRkUmVmZXJlbmNlcyhrZXlzLCB0YXJnZXRJZCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZW1vdmVNYXRjaGluZ0tleXModHhuLCBrZXlzLCB0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMucmVtb3ZlUmVmZXJlbmNlcyhrZXlzLCB0YXJnZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZURlbGVnYXRlID0gdGhpcy5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgaWYgKHJlZmVyZW5jZURlbGVnYXRlKSB7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHJlZmVyZW5jZURlbGVnYXRlLm1hcmtQb3RlbnRpYWxseU9ycGhhbmVkKHR4biwga2V5KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xuICAgIH1cbiAgICByZW1vdmVNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0eG4sIHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcy5yZW1vdmVSZWZlcmVuY2VzRm9ySWQodGFyZ2V0SWQpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0TWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHhuLCB0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0tleXMgPSB0aGlzLnJlZmVyZW5jZXMucmVmZXJlbmNlc0ZvcklkKHRhcmdldElkKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG1hdGNoaW5nS2V5cyk7XG4gICAgfVxuICAgIGNvbnRhaW5zS2V5KHR4biwga2V5KSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLnJlZmVyZW5jZXMuY29udGFpbnNLZXkoa2V5KSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyRkID0gJ01lbW9yeVBlcnNpc3RlbmNlJztcbi8qKlxuICogQSBtZW1vcnktYmFja2VkIGluc3RhbmNlIG9mIFBlcnNpc3RlbmNlLiBEYXRhIGlzIHN0b3JlZCBvbmx5IGluIFJBTSBhbmRcbiAqIG5vdCBwZXJzaXN0ZWQgYWNyb3NzIHNlc3Npb25zLlxuICovXG5jbGFzcyBNZW1vcnlQZXJzaXN0ZW5jZSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIGFjY2VwdHMgYSBmYWN0b3J5IGZvciBjcmVhdGluZyBhIHJlZmVyZW5jZSBkZWxlZ2F0ZS4gVGhpc1xuICAgICAqIGFsbG93cyBib3RoIHRoZSBkZWxlZ2F0ZSBhbmQgdGhpcyBpbnN0YW5jZSB0byBoYXZlIHN0cm9uZyByZWZlcmVuY2VzIHRvXG4gICAgICogZWFjaCBvdGhlciB3aXRob3V0IGhhdmluZyBudWxsYWJsZSBmaWVsZHMgdGhhdCB3b3VsZCB0aGVuIG5lZWQgdG8gYmVcbiAgICAgKiBjaGVja2VkIG9yIGFzc2VydGVkIG9uIGV2ZXJ5IGFjY2Vzcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZWZlcmVuY2VEZWxlZ2F0ZUZhY3RvcnksIHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5tdXRhdGlvblF1ZXVlcyA9IHt9O1xuICAgICAgICB0aGlzLm92ZXJsYXlzID0ge307XG4gICAgICAgIHRoaXMubGlzdGVuU2VxdWVuY2UgPSBuZXcgTGlzdGVuU2VxdWVuY2UoMCk7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZ2xvYmFsc0NhY2hlID0gbmV3IE1lbW9yeUdsb2JhbHNDYWNoZSgpO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlID0gcmVmZXJlbmNlRGVsZWdhdGVGYWN0b3J5KHRoaXMpO1xuICAgICAgICB0aGlzLnRhcmdldENhY2hlID0gbmV3IE1lbW9yeVRhcmdldENhY2hlKHRoaXMpO1xuICAgICAgICBjb25zdCBzaXplciA9IChkb2MpID0+IHRoaXMucmVmZXJlbmNlRGVsZWdhdGUuZG9jdW1lbnRTaXplKGRvYyk7XG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gbmV3IE1lbW9yeUluZGV4TWFuYWdlcigpO1xuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGUgPSBuZXdNZW1vcnlSZW1vdGVEb2N1bWVudENhY2hlKHNpemVyKTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gbmV3IExvY2FsU2VyaWFsaXplcihzZXJpYWxpemVyKTtcbiAgICAgICAgdGhpcy5idW5kbGVDYWNoZSA9IG5ldyBNZW1vcnlCdW5kbGVDYWNoZSh0aGlzLnNlcmlhbGl6ZXIpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgLy8gTm8gZHVyYWJsZSBzdGF0ZSB0byBlbnN1cmUgaXMgY2xvc2VkIG9uIHNodXRkb3duLlxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFydGVkO1xuICAgIH1cbiAgICBzZXREYXRhYmFzZURlbGV0ZWRMaXN0ZW5lcigpIHtcbiAgICAgICAgLy8gTm8gb3AuXG4gICAgfVxuICAgIHNldE5ldHdvcmtFbmFibGVkKCkge1xuICAgICAgICAvLyBObyBvcC5cbiAgICB9XG4gICAgZ2V0SW5kZXhNYW5hZ2VyKHVzZXIpIHtcbiAgICAgICAgLy8gV2UgZG8gbm90IGN1cnJlbnRseSBzdXBwb3J0IGluZGljZXMgZm9yIG1lbW9yeSBwZXJzaXN0ZW5jZSwgc28gd2UgY2FuXG4gICAgICAgIC8vIHJldHVybiB0aGUgc2FtZSBzaGFyZWQgaW5zdGFuY2Ugb2YgdGhlIG1lbW9yeSBpbmRleCBtYW5hZ2VyLlxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXI7XG4gICAgfVxuICAgIGdldERvY3VtZW50T3ZlcmxheUNhY2hlKHVzZXIpIHtcbiAgICAgICAgbGV0IG92ZXJsYXkgPSB0aGlzLm92ZXJsYXlzW3VzZXIudG9LZXkoKV07XG4gICAgICAgIGlmICghb3ZlcmxheSkge1xuICAgICAgICAgICAgb3ZlcmxheSA9IG5ldyBNZW1vcnlEb2N1bWVudE92ZXJsYXlDYWNoZSgpO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5c1t1c2VyLnRvS2V5KCldID0gb3ZlcmxheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3ZlcmxheTtcbiAgICB9XG4gICAgZ2V0TXV0YXRpb25RdWV1ZSh1c2VyLCBpbmRleE1hbmFnZXIpIHtcbiAgICAgICAgbGV0IHF1ZXVlID0gdGhpcy5tdXRhdGlvblF1ZXVlc1t1c2VyLnRvS2V5KCldO1xuICAgICAgICBpZiAoIXF1ZXVlKSB7XG4gICAgICAgICAgICBxdWV1ZSA9IG5ldyBNZW1vcnlNdXRhdGlvblF1ZXVlKGluZGV4TWFuYWdlciwgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZSk7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uUXVldWVzW3VzZXIudG9LZXkoKV0gPSBxdWV1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVldWU7XG4gICAgfVxuICAgIGdldEdsb2JhbHNDYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsc0NhY2hlO1xuICAgIH1cbiAgICBnZXRUYXJnZXRDYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0Q2FjaGU7XG4gICAgfVxuICAgIGdldFJlbW90ZURvY3VtZW50Q2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGU7XG4gICAgfVxuICAgIGdldEJ1bmRsZUNhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idW5kbGVDYWNoZTtcbiAgICB9XG4gICAgcnVuVHJhbnNhY3Rpb24oYWN0aW9uLCBtb2RlLCB0cmFuc2FjdGlvbk9wZXJhdGlvbikge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGQsICdTdGFydGluZyB0cmFuc2FjdGlvbjonLCBhY3Rpb24pO1xuICAgICAgICBjb25zdCB0eG4gPSBuZXcgTWVtb3J5VHJhbnNhY3Rpb24odGhpcy5saXN0ZW5TZXF1ZW5jZS5uZXh0KCkpO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlLm9uVHJhbnNhY3Rpb25TdGFydGVkKCk7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbk9wZXJhdGlvbih0eG4pXG4gICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlRGVsZWdhdGVcbiAgICAgICAgICAgICAgICAub25UcmFuc2FjdGlvbkNvbW1pdHRlZCh0eG4pXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50b1Byb21pc2UoKVxuICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHR4bi5yYWlzZU9uQ29tbWl0dGVkRXZlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHJhbnNhY3Rpb24sIGtleSkge1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLm9yKE9iamVjdC52YWx1ZXModGhpcy5tdXRhdGlvblF1ZXVlcykubWFwKHF1ZXVlID0+ICgpID0+IHF1ZXVlLmNvbnRhaW5zS2V5KHRyYW5zYWN0aW9uLCBrZXkpKSk7XG4gICAgfVxufVxuLyoqXG4gKiBNZW1vcnkgcGVyc2lzdGVuY2UgaXMgbm90IGFjdHVhbGx5IHRyYW5zYWN0aW9uYWwsIGJ1dCBmdXR1cmUgaW1wbGVtZW50YXRpb25zXG4gKiBtYXkgaGF2ZSB0cmFuc2FjdGlvbi1zY29wZWQgc3RhdGUuXG4gKi9cbmNsYXNzIE1lbW9yeVRyYW5zYWN0aW9uIGV4dGVuZHMgUGVyc2lzdGVuY2VUcmFuc2FjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY3VycmVudFNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFNlcXVlbmNlTnVtYmVyID0gY3VycmVudFNlcXVlbmNlTnVtYmVyO1xuICAgIH1cbn1cbmNsYXNzIE1lbW9yeUVhZ2VyRGVsZWdhdGUge1xuICAgIGNvbnN0cnVjdG9yKHBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICAgICAgLyoqIFRyYWNrcyBhbGwgZG9jdW1lbnRzIHRoYXQgYXJlIGFjdGl2ZSBpbiBRdWVyeSB2aWV3cy4gKi9cbiAgICAgICAgdGhpcy5sb2NhbFZpZXdSZWZlcmVuY2VzID0gbmV3IFJlZmVyZW5jZVNldCgpO1xuICAgICAgICAvKiogVGhlIGxpc3Qgb2YgZG9jdW1lbnRzIHRoYXQgYXJlIHBvdGVudGlhbGx5IEdDZWQgYWZ0ZXIgZWFjaCB0cmFuc2FjdGlvbi4gKi9cbiAgICAgICAgdGhpcy5fb3JwaGFuZWREb2N1bWVudHMgPSBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZmFjdG9yeShwZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeUVhZ2VyRGVsZWdhdGUocGVyc2lzdGVuY2UpO1xuICAgIH1cbiAgICBnZXQgb3JwaGFuZWREb2N1bWVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3JwaGFuZWREb2N1bWVudHMpIHtcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcnBoYW5lZERvY3VtZW50cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRSZWZlcmVuY2UodHhuLCB0YXJnZXRJZCwga2V5KSB7XG4gICAgICAgIHRoaXMubG9jYWxWaWV3UmVmZXJlbmNlcy5hZGRSZWZlcmVuY2Uoa2V5LCB0YXJnZXRJZCk7XG4gICAgICAgIHRoaXMub3JwaGFuZWREb2N1bWVudHMuZGVsZXRlKGtleS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJlbW92ZVJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpIHtcbiAgICAgICAgdGhpcy5sb2NhbFZpZXdSZWZlcmVuY2VzLnJlbW92ZVJlZmVyZW5jZShrZXksIHRhcmdldElkKTtcbiAgICAgICAgdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgbWFya1BvdGVudGlhbGx5T3JwaGFuZWQodHhuLCBrZXkpIHtcbiAgICAgICAgdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmVtb3ZlVGFyZ2V0KHR4biwgdGFyZ2V0RGF0YSkge1xuICAgICAgICBjb25zdCBvcnBoYW5lZCA9IHRoaXMubG9jYWxWaWV3UmVmZXJlbmNlcy5yZW1vdmVSZWZlcmVuY2VzRm9ySWQodGFyZ2V0RGF0YS50YXJnZXRJZCk7XG4gICAgICAgIG9ycGhhbmVkLmZvckVhY2goa2V5ID0+IHRoaXMub3JwaGFuZWREb2N1bWVudHMuYWRkKGtleS50b1N0cmluZygpKSk7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5wZXJzaXN0ZW5jZS5nZXRUYXJnZXRDYWNoZSgpO1xuICAgICAgICByZXR1cm4gY2FjaGVcbiAgICAgICAgICAgIC5nZXRNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0eG4sIHRhcmdldERhdGEudGFyZ2V0SWQpXG4gICAgICAgICAgICAubmV4dChrZXlzID0+IHtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNhY2hlLnJlbW92ZVRhcmdldERhdGEodHhuLCB0YXJnZXREYXRhKSk7XG4gICAgfVxuICAgIG9uVHJhbnNhY3Rpb25TdGFydGVkKCkge1xuICAgICAgICB0aGlzLl9vcnBoYW5lZERvY3VtZW50cyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgb25UcmFuc2FjdGlvbkNvbW1pdHRlZCh0eG4pIHtcbiAgICAgICAgLy8gUmVtb3ZlIG5ld2x5IG9ycGhhbmVkIGRvY3VtZW50cy5cbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnBlcnNpc3RlbmNlLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKTtcbiAgICAgICAgY29uc3QgY2hhbmdlQnVmZmVyID0gY2FjaGUubmV3Q2hhbmdlQnVmZmVyKCk7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh0aGlzLm9ycGhhbmVkRG9jdW1lbnRzLCAocGF0aCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gRG9jdW1lbnRLZXkuZnJvbVBhdGgocGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1JlZmVyZW5jZWQodHhuLCBrZXkpLm5leHQoaXNSZWZlcmVuY2VkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmVmZXJlbmNlZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VCdWZmZXIucmVtb3ZlRW50cnkoa2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX29ycGhhbmVkRG9jdW1lbnRzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VCdWZmZXIuYXBwbHkodHhuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZUxpbWJvRG9jdW1lbnQodHhuLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNSZWZlcmVuY2VkKHR4biwga2V5KS5uZXh0KGlzUmVmZXJlbmNlZCA9PiB7XG4gICAgICAgICAgICBpZiAoaXNSZWZlcmVuY2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcnBoYW5lZERvY3VtZW50cy5kZWxldGUoa2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZG9jdW1lbnRTaXplKGRvYykge1xuICAgICAgICAvLyBGb3IgZWFnZXIgR0MsIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIGRvY3VtZW50IHNpemUsIHRoZXJlIGFyZSBubyBzaXplIHRocmVzaG9sZHMuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpc1JlZmVyZW5jZWQodHhuLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5vcihbXG4gICAgICAgICAgICAoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmxvY2FsVmlld1JlZmVyZW5jZXMuY29udGFpbnNLZXkoa2V5KSksXG4gICAgICAgICAgICAoKSA9PiB0aGlzLnBlcnNpc3RlbmNlLmdldFRhcmdldENhY2hlKCkuY29udGFpbnNLZXkodHhuLCBrZXkpLFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5wZXJzaXN0ZW5jZS5tdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHhuLCBrZXkpXG4gICAgICAgIF0pO1xuICAgIH1cbn1cbmNsYXNzIE1lbW9yeUxydURlbGVnYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihwZXJzaXN0ZW5jZSwgbHJ1UGFyYW1zKSB7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycyA9IG5ldyBPYmplY3RNYXAoayA9PiBlbmNvZGVSZXNvdXJjZVBhdGgoay5wYXRoKSwgKGwsIHIpID0+IGwuaXNFcXVhbChyKSk7XG4gICAgICAgIHRoaXMuZ2FyYmFnZUNvbGxlY3RvciA9IG5ld0xydUdhcmJhZ2VDb2xsZWN0b3IodGhpcywgbHJ1UGFyYW1zKTtcbiAgICB9XG4gICAgc3RhdGljIGZhY3RvcnkocGVyc2lzdGVuY2UsIGxydVBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeUxydURlbGVnYXRlKHBlcnNpc3RlbmNlLCBscnVQYXJhbXMpO1xuICAgIH1cbiAgICAvLyBOby1vcHMsIHByZXNlbnQgc28gbWVtb3J5IHBlcnNpc3RlbmNlIGRvZXNuJ3QgaGF2ZSB0byBjYXJlIHdoaWNoIGRlbGVnYXRlXG4gICAgLy8gaXQgaGFzLlxuICAgIG9uVHJhbnNhY3Rpb25TdGFydGVkKCkgeyB9XG4gICAgb25UcmFuc2FjdGlvbkNvbW1pdHRlZCh0eG4pIHtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGZvckVhY2hUYXJnZXQodHhuLCBmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLmdldFRhcmdldENhY2hlKCkuZm9yRWFjaFRhcmdldCh0eG4sIGYpO1xuICAgIH1cbiAgICBnZXRTZXF1ZW5jZU51bWJlckNvdW50KHR4bikge1xuICAgICAgICBjb25zdCBkb2NDb3VudFByb21pc2UgPSB0aGlzLm9ycGhhbmVkRG9jdW1lbnRDb3VudCh0eG4pO1xuICAgICAgICBjb25zdCB0YXJnZXRDb3VudFByb21pc2UgPSB0aGlzLnBlcnNpc3RlbmNlXG4gICAgICAgICAgICAuZ2V0VGFyZ2V0Q2FjaGUoKVxuICAgICAgICAgICAgLmdldFRhcmdldENvdW50KHR4bik7XG4gICAgICAgIHJldHVybiB0YXJnZXRDb3VudFByb21pc2UubmV4dCh0YXJnZXRDb3VudCA9PiBkb2NDb3VudFByb21pc2UubmV4dChkb2NDb3VudCA9PiB0YXJnZXRDb3VudCArIGRvY0NvdW50KSk7XG4gICAgfVxuICAgIG9ycGhhbmVkRG9jdW1lbnRDb3VudCh0eG4pIHtcbiAgICAgICAgbGV0IG9ycGhhbmVkQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoT3JwaGFuZWREb2N1bWVudFNlcXVlbmNlTnVtYmVyKHR4biwgXyA9PiB7XG4gICAgICAgICAgICBvcnBoYW5lZENvdW50Kys7XG4gICAgICAgIH0pLm5leHQoKCkgPT4gb3JwaGFuZWRDb3VudCk7XG4gICAgfVxuICAgIGZvckVhY2hPcnBoYW5lZERvY3VtZW50U2VxdWVuY2VOdW1iZXIodHhuLCBmKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh0aGlzLm9ycGhhbmVkU2VxdWVuY2VOdW1iZXJzLCAoa2V5LCBzZXF1ZW5jZU51bWJlcikgPT4ge1xuICAgICAgICAgICAgLy8gUGFzcyBpbiB0aGUgZXhhY3Qgc2VxdWVuY2UgbnVtYmVyIGFzIHRoZSB1cHBlciBib3VuZCBzbyB3ZSBrbm93IGl0IHdvbid0IGJlIHBpbm5lZCBieVxuICAgICAgICAgICAgLy8gYmVpbmcgdG9vIHJlY2VudC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUGlubmVkKHR4biwga2V5LCBzZXF1ZW5jZU51bWJlcikubmV4dChpc1Bpbm5lZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Bpbm5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZihzZXF1ZW5jZU51bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kLCBhY3RpdmVUYXJnZXRJZHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2VcbiAgICAgICAgICAgIC5nZXRUYXJnZXRDYWNoZSgpXG4gICAgICAgICAgICAucmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcyk7XG4gICAgfVxuICAgIHJlbW92ZU9ycGhhbmVkRG9jdW1lbnRzKHR4biwgdXBwZXJCb3VuZCkge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMucGVyc2lzdGVuY2UuZ2V0UmVtb3RlRG9jdW1lbnRDYWNoZSgpO1xuICAgICAgICBjb25zdCBjaGFuZ2VCdWZmZXIgPSBjYWNoZS5uZXdDaGFuZ2VCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgcCA9IGNhY2hlLmZvckVhY2hEb2N1bWVudEtleSh0eG4sIGtleSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1Bpbm5lZCh0eG4sIGtleSwgdXBwZXJCb3VuZCkubmV4dChpc1Bpbm5lZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Bpbm5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VCdWZmZXIucmVtb3ZlRW50cnkoa2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHAubmV4dCgoKSA9PiBjaGFuZ2VCdWZmZXIuYXBwbHkodHhuKSkubmV4dCgoKSA9PiBjb3VudCk7XG4gICAgfVxuICAgIG1hcmtQb3RlbnRpYWxseU9ycGhhbmVkKHR4biwga2V5KSB7XG4gICAgICAgIHRoaXMub3JwaGFuZWRTZXF1ZW5jZU51bWJlcnMuc2V0KGtleSwgdHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlcik7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZW1vdmVUYXJnZXQodHhuLCB0YXJnZXREYXRhKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWQgPSB0YXJnZXREYXRhLndpdGhTZXF1ZW5jZU51bWJlcih0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuZ2V0VGFyZ2V0Q2FjaGUoKS51cGRhdGVUYXJnZXREYXRhKHR4biwgdXBkYXRlZCk7XG4gICAgfVxuICAgIGFkZFJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpIHtcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5zZXQoa2V5LCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJlbW92ZVJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpIHtcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5zZXQoa2V5LCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHVwZGF0ZUxpbWJvRG9jdW1lbnQodHhuLCBrZXkpIHtcbiAgICAgICAgdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5zZXQoa2V5LCB0eG4uY3VycmVudFNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGRvY3VtZW50U2l6ZShkb2N1bWVudCkge1xuICAgICAgICBsZXQgZG9jdW1lbnRTaXplID0gZG9jdW1lbnQua2V5LnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICBpZiAoZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgIGRvY3VtZW50U2l6ZSArPSBlc3RpbWF0ZUJ5dGVTaXplKGRvY3VtZW50LmRhdGEudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2N1bWVudFNpemU7XG4gICAgfVxuICAgIGlzUGlubmVkKHR4biwga2V5LCB1cHBlckJvdW5kKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uub3IoW1xuICAgICAgICAgICAgKCkgPT4gdGhpcy5wZXJzaXN0ZW5jZS5tdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHhuLCBrZXkpLFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5wZXJzaXN0ZW5jZS5nZXRUYXJnZXRDYWNoZSgpLmNvbnRhaW5zS2V5KHR4biwga2V5KSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcnBoYW5lZEF0ID0gdGhpcy5vcnBoYW5lZFNlcXVlbmNlTnVtYmVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUob3JwaGFuZWRBdCAhPT0gdW5kZWZpbmVkICYmIG9ycGhhbmVkQXQgPiB1cHBlckJvdW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGdldENhY2hlU2l6ZSh0eG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuZ2V0UmVtb3RlRG9jdW1lbnRDYWNoZSgpLmdldFNpemUodHhuKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogUGVyZm9ybXMgZGF0YWJhc2UgY3JlYXRpb24gYW5kIHNjaGVtYSB1cGdyYWRlcy4gKi9cbmNsYXNzIFNjaGVtYUNvbnZlcnRlciB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplcikge1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBkYXRhYmFzZSBjcmVhdGlvbiBhbmQgc2NoZW1hIHVwZ3JhZGVzLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGluIHByb2R1Y3Rpb24sIHRoaXMgbWV0aG9kIGlzIG9ubHkgZXZlciB1c2VkIHRvIHVwZ3JhZGUgdGhlIHNjaGVtYVxuICAgICAqIHRvIFNDSEVNQV9WRVJTSU9OLiBEaWZmZXJlbnQgdmFsdWVzIG9mIHRvVmVyc2lvbiBhcmUgb25seSB1c2VkIGZvciB0ZXN0aW5nXG4gICAgICogYW5kIGxvY2FsIGZlYXR1cmUgZGV2ZWxvcG1lbnQuXG4gICAgICovXG4gICAgY3JlYXRlT3JVcGdyYWRlKGRiLCB0eG4sIGZyb21WZXJzaW9uLCB0b1ZlcnNpb24pIHtcbiAgICAgICAgY29uc3Qgc2ltcGxlRGJUcmFuc2FjdGlvbiA9IG5ldyBTaW1wbGVEYlRyYW5zYWN0aW9uKCdjcmVhdGVPclVwZ3JhZGUnLCB0eG4pO1xuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxICYmIHRvVmVyc2lvbiA+PSAxKSB7XG4gICAgICAgICAgICBjcmVhdGVQcmltYXJ5Q2xpZW50U3RvcmUoZGIpO1xuICAgICAgICAgICAgY3JlYXRlTXV0YXRpb25RdWV1ZShkYik7XG4gICAgICAgICAgICBjcmVhdGVRdWVyeUNhY2hlKGRiKTtcbiAgICAgICAgICAgIGNyZWF0ZUxlZ2FjeVJlbW90ZURvY3VtZW50Q2FjaGUoZGIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1pZ3JhdGlvbiAyIHRvIHBvcHVsYXRlIHRoZSB0YXJnZXRHbG9iYWwgb2JqZWN0IG5vIGxvbmdlciBuZWVkZWQgc2luY2VcbiAgICAgICAgLy8gbWlncmF0aW9uIDMgdW5jb25kaXRpb25hbGx5IGNsZWFycyBpdC5cbiAgICAgICAgbGV0IHAgPSBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAzICYmIHRvVmVyc2lvbiA+PSAzKSB7XG4gICAgICAgICAgICAvLyBCcmFuZCBuZXcgY2xpZW50cyBkb24ndCBuZWVkIHRvIGRyb3AgYW5kIHJlY3JlYXRlLS1vbmx5IGNsaWVudHMgdGhhdFxuICAgICAgICAgICAgLy8gcG90ZW50aWFsbHkgaGF2ZSBjb3JydXB0IGRhdGEuXG4gICAgICAgICAgICBpZiAoZnJvbVZlcnNpb24gIT09IDApIHtcbiAgICAgICAgICAgICAgICBkcm9wUXVlcnlDYWNoZShkYik7XG4gICAgICAgICAgICAgICAgY3JlYXRlUXVlcnlDYWNoZShkYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHdyaXRlRW1wdHlUYXJnZXRHbG9iYWxFbnRyeShzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgNCAmJiB0b1ZlcnNpb24gPj0gNCkge1xuICAgICAgICAgICAgaWYgKGZyb21WZXJzaW9uICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NoZW1hIHZlcnNpb24gMyB1c2VzIGF1dG8tZ2VuZXJhdGVkIGtleXMgdG8gZ2VuZXJhdGUgZ2xvYmFsbHkgdW5pcXVlXG4gICAgICAgICAgICAgICAgLy8gbXV0YXRpb24gYmF0Y2ggSURzICh0aGlzIHdhcyBwcmV2aW91c2x5IGVuc3VyZWQgaW50ZXJuYWxseSBieSB0aGVcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQpLiBUbyBtaWdyYXRlIHRvIHRoZSBuZXcgc2NoZW1hLCB3ZSBoYXZlIHRvIHJlYWQgYWxsIG11dGF0aW9uc1xuICAgICAgICAgICAgICAgIC8vIGFuZCB3cml0ZSB0aGVtIGJhY2sgb3V0LiBXZSBwcmVzZXJ2ZSB0aGUgZXhpc3RpbmcgYmF0Y2ggSURzIHRvIGd1YXJhbnRlZVxuICAgICAgICAgICAgICAgIC8vIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgb2JqZWN0IHN0b3Jlcy4gQW55IGZ1cnRoZXIgbXV0YXRpb24gYmF0Y2ggSURzIHdpbGxcbiAgICAgICAgICAgICAgICAvLyBiZSBhdXRvLWdlbmVyYXRlZC5cbiAgICAgICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHVwZ3JhZGVNdXRhdGlvbkJhdGNoU2NoZW1hQW5kTWlncmF0ZURhdGEoZGIsIHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUNsaWVudE1ldGFkYXRhU3RvcmUoZGIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgNSAmJiB0b1ZlcnNpb24gPj0gNSkge1xuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB0aGlzLnJlbW92ZUFja25vd2xlZGdlZE11dGF0aW9ucyhzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgNiAmJiB0b1ZlcnNpb24gPj0gNikge1xuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3JlYXRlRG9jdW1lbnRHbG9iYWxTdG9yZShkYik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkRG9jdW1lbnRHbG9iYWwoc2ltcGxlRGJUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA3ICYmIHRvVmVyc2lvbiA+PSA3KSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHRoaXMuZW5zdXJlU2VxdWVuY2VOdW1iZXJzKHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA4ICYmIHRvVmVyc2lvbiA+PSA4KSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHRoaXMuY3JlYXRlQ29sbGVjdGlvblBhcmVudEluZGV4KGRiLCBzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgOSAmJiB0b1ZlcnNpb24gPj0gOSkge1xuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTXVsdGktVGFiIHVzZWQgdG8gbWFuYWdlIGl0cyBvd24gY2hhbmdlbG9nLCBidXQgdGhpcyBoYXMgYmVlbiBtb3ZlZFxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBEYlJlbW90ZURvY3VtZW50IG9iamVjdCBzdG9yZSBpdHNlbGYuIFNpbmNlIHRoZSBwcmV2aW91cyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAvLyBsb2cgb25seSBjb250YWluZWQgdHJhbnNpZW50IGRhdGEsIHdlIGNhbiBkcm9wIGl0cyBvYmplY3Qgc3RvcmUuXG4gICAgICAgICAgICAgICAgZHJvcFJlbW90ZURvY3VtZW50Q2hhbmdlc1N0b3JlKGRiKTtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBTY2hlbWEgdmVyc2lvbiA5IHVzZWQgdG8gY3JlYXRlIGEgcmVhZCB0aW1lIGluZGV4IGZvciB0aGVcbiAgICAgICAgICAgICAgICAvLyBSZW1vdGVEb2N1bWVudENhY2hlLiBUaGlzIGlzIG5vdyBkb25lIHdpdGggc2NoZW1hIHZlcnNpb24gMTMuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxMCAmJiB0b1ZlcnNpb24gPj0gMTApIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdGhpcy5yZXdyaXRlQ2Fub25pY2FsSWRzKHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxMSAmJiB0b1ZlcnNpb24gPj0gMTEpIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUJ1bmRsZXNTdG9yZShkYik7XG4gICAgICAgICAgICAgICAgY3JlYXRlTmFtZWRRdWVyaWVzU3RvcmUoZGIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgMTIgJiYgdG9WZXJzaW9uID49IDEyKSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjcmVhdGVEb2N1bWVudE92ZXJsYXlTdG9yZShkYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxMyAmJiB0b1ZlcnNpb24gPj0gMTMpIHtcbiAgICAgICAgICAgIHAgPSBwXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gY3JlYXRlUmVtb3RlRG9jdW1lbnRDYWNoZShkYikpXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gdGhpcy5yZXdyaXRlUmVtb3RlRG9jdW1lbnRDYWNoZShkYiwgc2ltcGxlRGJUcmFuc2FjdGlvbikpXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gZGIuZGVsZXRlT2JqZWN0U3RvcmUoRGJSZW1vdGVEb2N1bWVudFN0b3JlJDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxNCAmJiB0b1ZlcnNpb24gPj0gMTQpIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdGhpcy5ydW5PdmVybGF5TWlncmF0aW9uKGRiLCBzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgMTUgJiYgdG9WZXJzaW9uID49IDE1KSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IGNyZWF0ZUZpZWxkSW5kZXgoZGIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxNiAmJiB0b1ZlcnNpb24gPj0gMTYpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBvYmplY3Qgc3RvcmVzIHRvIHJlbW92ZSBwb3NzaWJseSBjb3JydXB0ZWQgaW5kZXggZW50cmllc1xuICAgICAgICAgICAgcCA9IHBcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhTdGF0ZVN0b3JlID0gdHhuLm9iamVjdFN0b3JlKERiSW5kZXhTdGF0ZVN0b3JlKTtcbiAgICAgICAgICAgICAgICBpbmRleFN0YXRlU3RvcmUuY2xlYXIoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4RW50cnlTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShEYkluZGV4RW50cnlTdG9yZSk7XG4gICAgICAgICAgICAgICAgaW5kZXhFbnRyeVN0b3JlLmNsZWFyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxNyAmJiB0b1ZlcnNpb24gPj0gMTcpIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUdsb2JhbHNTdG9yZShkYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgYWRkRG9jdW1lbnRHbG9iYWwodHhuKSB7XG4gICAgICAgIGxldCBieXRlU2l6ZSA9IDA7XG4gICAgICAgIHJldHVybiB0eG5cbiAgICAgICAgICAgIC5zdG9yZShEYlJlbW90ZURvY3VtZW50U3RvcmUkMSlcbiAgICAgICAgICAgIC5pdGVyYXRlKChfLCBkb2MpID0+IHtcbiAgICAgICAgICAgIGJ5dGVTaXplICs9IGRiRG9jdW1lbnRTaXplKGRvYyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHsgYnl0ZVNpemUgfTtcbiAgICAgICAgICAgIHJldHVybiB0eG5cbiAgICAgICAgICAgICAgICAuc3RvcmUoRGJSZW1vdGVEb2N1bWVudEdsb2JhbFN0b3JlKVxuICAgICAgICAgICAgICAgIC5wdXQoRGJSZW1vdGVEb2N1bWVudEdsb2JhbEtleSwgbWV0YWRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlQWNrbm93bGVkZ2VkTXV0YXRpb25zKHR4bikge1xuICAgICAgICBjb25zdCBxdWV1ZXNTdG9yZSA9IHR4bi5zdG9yZShEYk11dGF0aW9uUXVldWVTdG9yZSk7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uc1N0b3JlID0gdHhuLnN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcbiAgICAgICAgcmV0dXJuIHF1ZXVlc1N0b3JlLmxvYWRBbGwoKS5uZXh0KHF1ZXVlcyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2gocXVldWVzLCAocXVldWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFtxdWV1ZS51c2VySWQsIEJBVENISURfVU5LTk9XTl0sIFtxdWV1ZS51c2VySWQsIHF1ZXVlLmxhc3RBY2tub3dsZWRnZWRCYXRjaElkXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlXG4gICAgICAgICAgICAgICAgICAgIC5sb2FkQWxsKERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNJbmRleCwgcmFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KGRiQmF0Y2hlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChkYkJhdGNoZXMsIChkYkJhdGNoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KGRiQmF0Y2gudXNlcklkID09PSBxdWV1ZS51c2VySWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgZGJCYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlTXV0YXRpb25CYXRjaCh0eG4sIHF1ZXVlLnVzZXJJZCwgYmF0Y2gpLm5leHQoKCkgPT4geyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCBldmVyeSBkb2N1bWVudCBpbiB0aGUgcmVtb3RlIGRvY3VtZW50IGNhY2hlIGhhcyBhIGNvcnJlc3BvbmRpbmcgc2VudGluZWwgcm93XG4gICAgICogd2l0aCBhIHNlcXVlbmNlIG51bWJlci4gTWlzc2luZyByb3dzIGFyZSBnaXZlbiB0aGUgbW9zdCByZWNlbnRseSB1c2VkIHNlcXVlbmNlIG51bWJlci5cbiAgICAgKi9cbiAgICBlbnN1cmVTZXF1ZW5jZU51bWJlcnModHhuKSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50VGFyZ2V0U3RvcmUgPSB0eG4uc3RvcmUoRGJUYXJnZXREb2N1bWVudFN0b3JlKTtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRzU3RvcmUgPSB0eG4uc3RvcmUoRGJSZW1vdGVEb2N1bWVudFN0b3JlJDEpO1xuICAgICAgICBjb25zdCBnbG9iYWxUYXJnZXRTdG9yZSA9IHR4bi5zdG9yZShEYlRhcmdldEdsb2JhbFN0b3JlKTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRhcmdldFN0b3JlLmdldChEYlRhcmdldEdsb2JhbEtleSkubmV4dChtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3cml0ZVNlbnRpbmVsS2V5ID0gKHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRUYXJnZXRTdG9yZS5wdXQoe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRJZDogMCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogZW5jb2RlUmVzb3VyY2VQYXRoKHBhdGgpLFxuICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZU51bWJlcjogbWV0YWRhdGEuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudHNTdG9yZVxuICAgICAgICAgICAgICAgIC5pdGVyYXRlKChrZXksIGRvYykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBuZXcgUmVzb3VyY2VQYXRoKGtleSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jU2VudGluZWxLZXkgPSBzZW50aW5lbEtleShwYXRoKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRvY3VtZW50VGFyZ2V0U3RvcmUuZ2V0KGRvY1NlbnRpbmVsS2V5KS5uZXh0KG1heWJlU2VudGluZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heWJlU2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZVNlbnRpbmVsS2V5KHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVDb2xsZWN0aW9uUGFyZW50SW5kZXgoZGIsIHR4bikge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGluZGV4LlxuICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkNvbGxlY3Rpb25QYXJlbnRTdG9yZSwge1xuICAgICAgICAgICAga2V5UGF0aDogRGJDb2xsZWN0aW9uUGFyZW50S2V5UGF0aFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvblBhcmVudHNTdG9yZSA9IHR4bi5zdG9yZShEYkNvbGxlY3Rpb25QYXJlbnRTdG9yZSk7XG4gICAgICAgIC8vIEhlbHBlciB0byBhZGQgYW4gaW5kZXggZW50cnkgaWZmIHdlIGhhdmVuJ3QgYWxyZWFkeSB3cml0dGVuIGl0LlxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBNZW1vcnlDb2xsZWN0aW9uUGFyZW50SW5kZXgoKTtcbiAgICAgICAgY29uc3QgYWRkRW50cnkgPSAoY29sbGVjdGlvblBhdGgpID0+IHtcbiAgICAgICAgICAgIGlmIChjYWNoZS5hZGQoY29sbGVjdGlvblBhdGgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gY29sbGVjdGlvblBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gY29sbGVjdGlvblBhdGgucG9wTGFzdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uUGFyZW50c1N0b3JlLnB1dCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBlbmNvZGVSZXNvdXJjZVBhdGgocGFyZW50UGF0aClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gSW5kZXggZXhpc3RpbmcgcmVtb3RlIGRvY3VtZW50cy5cbiAgICAgICAgcmV0dXJuIHR4blxuICAgICAgICAgICAgLnN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSQxKVxuICAgICAgICAgICAgLml0ZXJhdGUoeyBrZXlzT25seTogdHJ1ZSB9LCAocGF0aFNlZ21lbnRzLCBfKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gbmV3IFJlc291cmNlUGF0aChwYXRoU2VnbWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZEVudHJ5KHBhdGgucG9wTGFzdCgpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIEluZGV4IGV4aXN0aW5nIG11dGF0aW9ucy5cbiAgICAgICAgICAgIHJldHVybiB0eG5cbiAgICAgICAgICAgICAgICAuc3RvcmUoRGJEb2N1bWVudE11dGF0aW9uU3RvcmUpXG4gICAgICAgICAgICAgICAgLml0ZXJhdGUoeyBrZXlzT25seTogdHJ1ZSB9LCAoW3VzZXJJRCwgZW5jb2RlZFBhdGgsIGJhdGNoSWRdLCBfKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRlY29kZVJlc291cmNlUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZEVudHJ5KHBhdGgucG9wTGFzdCgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV3cml0ZUNhbm9uaWNhbElkcyh0eG4pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0U3RvcmUgPSB0eG4uc3RvcmUoRGJUYXJnZXRTdG9yZSk7XG4gICAgICAgIHJldHVybiB0YXJnZXRTdG9yZS5pdGVyYXRlKChrZXksIG9yaWdpbmFsRGJUYXJnZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsVGFyZ2V0RGF0YSA9IGZyb21EYlRhcmdldChvcmlnaW5hbERiVGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWREYlRhcmdldCA9IHRvRGJUYXJnZXQodGhpcy5zZXJpYWxpemVyLCBvcmlnaW5hbFRhcmdldERhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFN0b3JlLnB1dCh1cGRhdGVkRGJUYXJnZXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV3cml0ZVJlbW90ZURvY3VtZW50Q2FjaGUoZGIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGxlZ2FjeVJlbW90ZURvY3VtZW50U3RvcmUgPSB0cmFuc2FjdGlvbi5zdG9yZShEYlJlbW90ZURvY3VtZW50U3RvcmUkMSk7XG4gICAgICAgIGNvbnN0IHdyaXRlcyA9IFtdO1xuICAgICAgICByZXR1cm4gbGVnYWN5UmVtb3RlRG9jdW1lbnRTdG9yZVxuICAgICAgICAgICAgLml0ZXJhdGUoKF8sIGxlZ2FjeURvY3VtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVEb2N1bWVudFN0b3JlID0gdHJhbnNhY3Rpb24uc3RvcmUoRGJSZW1vdGVEb2N1bWVudFN0b3JlKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBleHRyYWN0S2V5KGxlZ2FjeURvY3VtZW50KS5wYXRoLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIGNvbnN0IGRiUmVtb3RlRG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgcHJlZml4UGF0aDogcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDIpLFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25Hcm91cDogcGF0aFtwYXRoLmxlbmd0aCAtIDJdLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50SWQ6IHBhdGhbcGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICByZWFkVGltZTogbGVnYWN5RG9jdW1lbnQucmVhZFRpbWUgfHwgWzAsIDBdLFxuICAgICAgICAgICAgICAgIHVua25vd25Eb2N1bWVudDogbGVnYWN5RG9jdW1lbnQudW5rbm93bkRvY3VtZW50LFxuICAgICAgICAgICAgICAgIG5vRG9jdW1lbnQ6IGxlZ2FjeURvY3VtZW50Lm5vRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQ6IGxlZ2FjeURvY3VtZW50LmRvY3VtZW50LFxuICAgICAgICAgICAgICAgIGhhc0NvbW1pdHRlZE11dGF0aW9uczogISFsZWdhY3lEb2N1bWVudC5oYXNDb21taXR0ZWRNdXRhdGlvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3cml0ZXMucHVzaChyZW1vdGVEb2N1bWVudFN0b3JlLnB1dChkYlJlbW90ZURvY3VtZW50KSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcih3cml0ZXMpKTtcbiAgICB9XG4gICAgcnVuT3ZlcmxheU1pZ3JhdGlvbihkYiwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgbXV0YXRpb25zU3RvcmUgPSB0cmFuc2FjdGlvbi5zdG9yZShEYk11dGF0aW9uQmF0Y2hTdG9yZSk7XG4gICAgICAgIGNvbnN0IHJlbW90ZURvY3VtZW50Q2FjaGUgPSBuZXdJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlKHRoaXMuc2VyaWFsaXplcik7XG4gICAgICAgIGNvbnN0IG1lbW9yeVBlcnNpc3RlbmNlID0gbmV3IE1lbW9yeVBlcnNpc3RlbmNlKE1lbW9yeUVhZ2VyRGVsZWdhdGUuZmFjdG9yeSwgdGhpcy5zZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIpO1xuICAgICAgICByZXR1cm4gbXV0YXRpb25zU3RvcmUubG9hZEFsbCgpLm5leHQoZGJCYXRjaGVzID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJUb0RvY3VtZW50U2V0ID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZGJCYXRjaGVzLmZvckVhY2goZGJCYXRjaCA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGxldCBkb2N1bWVudFNldCA9IChfYSA9IHVzZXJUb0RvY3VtZW50U2V0LmdldChkYkJhdGNoLnVzZXJJZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgZGJCYXRjaCk7XG4gICAgICAgICAgICAgICAgYmF0Y2gua2V5cygpLmZvckVhY2goa2V5ID0+IChkb2N1bWVudFNldCA9IGRvY3VtZW50U2V0LmFkZChrZXkpKSk7XG4gICAgICAgICAgICAgICAgdXNlclRvRG9jdW1lbnRTZXQuc2V0KGRiQmF0Y2gudXNlcklkLCBkb2N1bWVudFNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh1c2VyVG9Eb2N1bWVudFNldCwgKGFsbERvY3VtZW50S2V5c0ZvclVzZXIsIHVzZXJJZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlcih1c2VySWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50T3ZlcmxheUNhY2hlID0gSW5kZXhlZERiRG9jdW1lbnRPdmVybGF5Q2FjaGUuZm9yVXNlcih0aGlzLnNlcmlhbGl6ZXIsIHVzZXIpO1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IFRoZSBpbmRleCBtYW5hZ2VyIGFuZCB0aGUgcmVmZXJlbmNlIGRlbGVnYXRlIGFyZVxuICAgICAgICAgICAgICAgIC8vIGlycmVsZXZhbnQgZm9yIHRoZSBwdXJwb3NlIG9mIHJlY2FsY3VsYXRpbmcgYW5kIHNhdmluZ1xuICAgICAgICAgICAgICAgIC8vIG92ZXJsYXlzLiBXZSBjYW4gdGhlcmVmb3JlIHNpbXBseSB1c2UgdGhlIG1lbW9yeVxuICAgICAgICAgICAgICAgIC8vIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4TWFuYWdlciA9IG1lbW9yeVBlcnNpc3RlbmNlLmdldEluZGV4TWFuYWdlcih1c2VyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtdXRhdGlvblF1ZXVlID0gSW5kZXhlZERiTXV0YXRpb25RdWV1ZS5mb3JVc2VyKHVzZXIsIHRoaXMuc2VyaWFsaXplciwgaW5kZXhNYW5hZ2VyLCBtZW1vcnlQZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxEb2N1bWVudHNWaWV3ID0gbmV3IExvY2FsRG9jdW1lbnRzVmlldyhyZW1vdGVEb2N1bWVudENhY2hlLCBtdXRhdGlvblF1ZXVlLCBkb2N1bWVudE92ZXJsYXlDYWNoZSwgaW5kZXhNYW5hZ2VyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxEb2N1bWVudHNWaWV3XG4gICAgICAgICAgICAgICAgICAgIC5yZWNhbGN1bGF0ZUFuZFNhdmVPdmVybGF5c0ZvckRvY3VtZW50S2V5cyhuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIExpc3RlblNlcXVlbmNlLklOVkFMSUQpLCBhbGxEb2N1bWVudEtleXNGb3JVc2VyKVxuICAgICAgICAgICAgICAgICAgICAubmV4dCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbnRpbmVsS2V5KHBhdGgpIHtcbiAgICByZXR1cm4gWzAsIGVuY29kZVJlc291cmNlUGF0aChwYXRoKV07XG59XG5mdW5jdGlvbiBjcmVhdGVQcmltYXJ5Q2xpZW50U3RvcmUoZGIpIHtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYlByaW1hcnlDbGllbnRTdG9yZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVNdXRhdGlvblF1ZXVlKGRiKSB7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJNdXRhdGlvblF1ZXVlU3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJNdXRhdGlvblF1ZXVlS2V5UGF0aFxuICAgIH0pO1xuICAgIGNvbnN0IG11dGF0aW9uQmF0Y2hlc1N0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJNdXRhdGlvbkJhdGNoU3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJNdXRhdGlvbkJhdGNoS2V5UGF0aCxcbiAgICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxuICAgIH0pO1xuICAgIG11dGF0aW9uQmF0Y2hlc1N0b3JlLmNyZWF0ZUluZGV4KERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNJbmRleCwgRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0tleVBhdGgsIHsgdW5pcXVlOiB0cnVlIH0pO1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiRG9jdW1lbnRNdXRhdGlvblN0b3JlKTtcbn1cbi8qKlxuICogVXBncmFkZSBmdW5jdGlvbiB0byBtaWdyYXRlIHRoZSAnbXV0YXRpb25zJyBzdG9yZSBmcm9tIFYxIHRvIFYzLiBMb2Fkc1xuICogYW5kIHJld3JpdGVzIGFsbCBkYXRhLlxuICovXG5mdW5jdGlvbiB1cGdyYWRlTXV0YXRpb25CYXRjaFNjaGVtYUFuZE1pZ3JhdGVEYXRhKGRiLCB0eG4pIHtcbiAgICBjb25zdCB2MU11dGF0aW9uc1N0b3JlID0gdHhuLnN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcbiAgICByZXR1cm4gdjFNdXRhdGlvbnNTdG9yZS5sb2FkQWxsKCkubmV4dChleGlzdGluZ011dGF0aW9ucyA9PiB7XG4gICAgICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcbiAgICAgICAgY29uc3QgbXV0YXRpb25zU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYk11dGF0aW9uQmF0Y2hTdG9yZSwge1xuICAgICAgICAgICAga2V5UGF0aDogRGJNdXRhdGlvbkJhdGNoS2V5UGF0aCxcbiAgICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIG11dGF0aW9uc1N0b3JlLmNyZWF0ZUluZGV4KERiTXV0YXRpb25CYXRjaFVzZXJNdXRhdGlvbnNJbmRleCwgRGJNdXRhdGlvbkJhdGNoVXNlck11dGF0aW9uc0tleVBhdGgsIHsgdW5pcXVlOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCB2M011dGF0aW9uc1N0b3JlID0gdHhuLnN0b3JlKERiTXV0YXRpb25CYXRjaFN0b3JlKTtcbiAgICAgICAgY29uc3Qgd3JpdGVBbGwgPSBleGlzdGluZ011dGF0aW9ucy5tYXAobXV0YXRpb24gPT4gdjNNdXRhdGlvbnNTdG9yZS5wdXQobXV0YXRpb24pKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHdyaXRlQWxsKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxlZ2FjeVJlbW90ZURvY3VtZW50Q2FjaGUoZGIpIHtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYlJlbW90ZURvY3VtZW50U3RvcmUkMSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZW1vdGVEb2N1bWVudENhY2hlKGRiKSB7XG4gICAgY29uc3QgcmVtb3RlRG9jdW1lbnRTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiUmVtb3RlRG9jdW1lbnRTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYlJlbW90ZURvY3VtZW50S2V5UGF0aFxuICAgIH0pO1xuICAgIHJlbW90ZURvY3VtZW50U3RvcmUuY3JlYXRlSW5kZXgoRGJSZW1vdGVEb2N1bWVudERvY3VtZW50S2V5SW5kZXgsIERiUmVtb3RlRG9jdW1lbnREb2N1bWVudEtleUluZGV4UGF0aCk7XG4gICAgcmVtb3RlRG9jdW1lbnRTdG9yZS5jcmVhdGVJbmRleChEYlJlbW90ZURvY3VtZW50Q29sbGVjdGlvbkdyb3VwSW5kZXgsIERiUmVtb3RlRG9jdW1lbnRDb2xsZWN0aW9uR3JvdXBJbmRleFBhdGgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnRHbG9iYWxTdG9yZShkYikge1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiUmVtb3RlRG9jdW1lbnRHbG9iYWxTdG9yZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVRdWVyeUNhY2hlKGRiKSB7XG4gICAgY29uc3QgdGFyZ2V0RG9jdW1lbnRzU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYlRhcmdldERvY3VtZW50U3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJUYXJnZXREb2N1bWVudEtleVBhdGhcbiAgICB9KTtcbiAgICB0YXJnZXREb2N1bWVudHNTdG9yZS5jcmVhdGVJbmRleChEYlRhcmdldERvY3VtZW50RG9jdW1lbnRUYXJnZXRzSW5kZXgsIERiVGFyZ2V0RG9jdW1lbnREb2N1bWVudFRhcmdldHNLZXlQYXRoLCB7IHVuaXF1ZTogdHJ1ZSB9KTtcbiAgICBjb25zdCB0YXJnZXRTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiVGFyZ2V0U3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJUYXJnZXRLZXlQYXRoXG4gICAgfSk7XG4gICAgLy8gTk9URTogVGhpcyBpcyB1bmlxdWUgb25seSBiZWNhdXNlIHRoZSBUYXJnZXRJZCBpcyB0aGUgc3VmZml4LlxuICAgIHRhcmdldFN0b3JlLmNyZWF0ZUluZGV4KERiVGFyZ2V0UXVlcnlUYXJnZXRzSW5kZXhOYW1lLCBEYlRhcmdldFF1ZXJ5VGFyZ2V0c0tleVBhdGgsIHsgdW5pcXVlOiB0cnVlIH0pO1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiVGFyZ2V0R2xvYmFsU3RvcmUpO1xufVxuZnVuY3Rpb24gZHJvcFF1ZXJ5Q2FjaGUoZGIpIHtcbiAgICBkYi5kZWxldGVPYmplY3RTdG9yZShEYlRhcmdldERvY3VtZW50U3RvcmUpO1xuICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiVGFyZ2V0U3RvcmUpO1xuICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiVGFyZ2V0R2xvYmFsU3RvcmUpO1xufVxuZnVuY3Rpb24gZHJvcFJlbW90ZURvY3VtZW50Q2hhbmdlc1N0b3JlKGRiKSB7XG4gICAgaWYgKGRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJ3JlbW90ZURvY3VtZW50Q2hhbmdlcycpKSB7XG4gICAgICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKCdyZW1vdGVEb2N1bWVudENoYW5nZXMnKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgdGhlIHRhcmdldCBnbG9iYWwgc2luZ2xldG9uIHJvdy5cbiAqXG4gKiBAcGFyYW0gdHhuIC0gVGhlIHZlcnNpb24gdXBncmFkZSB0cmFuc2FjdGlvbiBmb3IgaW5kZXhlZGRiXG4gKi9cbmZ1bmN0aW9uIHdyaXRlRW1wdHlUYXJnZXRHbG9iYWxFbnRyeSh0eG4pIHtcbiAgICBjb25zdCBnbG9iYWxTdG9yZSA9IHR4bi5zdG9yZShEYlRhcmdldEdsb2JhbFN0b3JlKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgICAgaGlnaGVzdFRhcmdldElkOiAwLFxuICAgICAgICBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICAgIGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb246IFNuYXBzaG90VmVyc2lvbi5taW4oKS50b1RpbWVzdGFtcCgpLFxuICAgICAgICB0YXJnZXRDb3VudDogMFxuICAgIH07XG4gICAgcmV0dXJuIGdsb2JhbFN0b3JlLnB1dChEYlRhcmdldEdsb2JhbEtleSwgbWV0YWRhdGEpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50TWV0YWRhdGFTdG9yZShkYikge1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiQ2xpZW50TWV0YWRhdGFTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYkNsaWVudE1ldGFkYXRhS2V5UGF0aFxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQnVuZGxlc1N0b3JlKGRiKSB7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJCdW5kbGVTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYkJ1bmRsZUtleVBhdGhcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5hbWVkUXVlcmllc1N0b3JlKGRiKSB7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJOYW1lZFF1ZXJ5U3RvcmUsIHtcbiAgICAgICAga2V5UGF0aDogRGJOYW1lZFF1ZXJ5S2V5UGF0aFxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRmllbGRJbmRleChkYikge1xuICAgIGNvbnN0IGluZGV4Q29uZmlndXJhdGlvblN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJJbmRleENvbmZpZ3VyYXRpb25TdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYkluZGV4Q29uZmlndXJhdGlvbktleVBhdGgsXG4gICAgICAgIGF1dG9JbmNyZW1lbnQ6IHRydWVcbiAgICB9KTtcbiAgICBpbmRleENvbmZpZ3VyYXRpb25TdG9yZS5jcmVhdGVJbmRleChEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4LCBEYkluZGV4Q29uZmlndXJhdGlvbkNvbGxlY3Rpb25Hcm91cEluZGV4UGF0aCwgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgIGNvbnN0IGluZGV4U3RhdGVTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiSW5kZXhTdGF0ZVN0b3JlLCB7XG4gICAgICAgIGtleVBhdGg6IERiSW5kZXhTdGF0ZUtleVBhdGhcbiAgICB9KTtcbiAgICBpbmRleFN0YXRlU3RvcmUuY3JlYXRlSW5kZXgoRGJJbmRleFN0YXRlU2VxdWVuY2VOdW1iZXJJbmRleCwgRGJJbmRleFN0YXRlU2VxdWVuY2VOdW1iZXJJbmRleFBhdGgsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbiAgICBjb25zdCBpbmRleEVudHJ5U3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkluZGV4RW50cnlTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYkluZGV4RW50cnlLZXlQYXRoXG4gICAgfSk7XG4gICAgaW5kZXhFbnRyeVN0b3JlLmNyZWF0ZUluZGV4KERiSW5kZXhFbnRyeURvY3VtZW50S2V5SW5kZXgsIERiSW5kZXhFbnRyeURvY3VtZW50S2V5SW5kZXhQYXRoLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEb2N1bWVudE92ZXJsYXlTdG9yZShkYikge1xuICAgIGNvbnN0IGRvY3VtZW50T3ZlcmxheVN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJEb2N1bWVudE92ZXJsYXlTdG9yZSwge1xuICAgICAgICBrZXlQYXRoOiBEYkRvY3VtZW50T3ZlcmxheUtleVBhdGhcbiAgICB9KTtcbiAgICBkb2N1bWVudE92ZXJsYXlTdG9yZS5jcmVhdGVJbmRleChEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4LCBEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4UGF0aCwgeyB1bmlxdWU6IGZhbHNlIH0pO1xuICAgIGRvY3VtZW50T3ZlcmxheVN0b3JlLmNyZWF0ZUluZGV4KERiRG9jdW1lbnRPdmVybGF5Q29sbGVjdGlvbkdyb3VwT3ZlcmxheUluZGV4LCBEYkRvY3VtZW50T3ZlcmxheUNvbGxlY3Rpb25Hcm91cE92ZXJsYXlJbmRleFBhdGgsIHsgdW5pcXVlOiBmYWxzZSB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdsb2JhbHNTdG9yZShkYikge1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiR2xvYmFsc1N0b3JlLCB7XG4gICAgICAgIGtleVBhdGg6IERiR2xvYmFsc0tleVBhdGhcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RLZXkocmVtb3RlRG9jKSB7XG4gICAgaWYgKHJlbW90ZURvYy5kb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKHJlbW90ZURvYy5kb2N1bWVudC5uYW1lKS5wb3BGaXJzdCg1KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlbW90ZURvYy5ub0RvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBEb2N1bWVudEtleS5mcm9tU2VnbWVudHMocmVtb3RlRG9jLm5vRG9jdW1lbnQucGF0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlbW90ZURvYy51bmtub3duRG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhyZW1vdGVEb2MudW5rbm93bkRvY3VtZW50LnBhdGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJGMgPSAnSW5kZXhlZERiUGVyc2lzdGVuY2UnO1xuLyoqXG4gKiBPbGRlc3QgYWNjZXB0YWJsZSBhZ2UgaW4gbWlsbGlzZWNvbmRzIGZvciBjbGllbnQgbWV0YWRhdGEgYmVmb3JlIHRoZSBjbGllbnRcbiAqIGlzIGNvbnNpZGVyZWQgaW5hY3RpdmUgYW5kIGl0cyBhc3NvY2lhdGVkIGRhdGEgaXMgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gKi9cbmNvbnN0IE1BWF9DTElFTlRfQUdFX01TID0gMzAgKiA2MCAqIDEwMDA7IC8vIDMwIG1pbnV0ZXNcbi8qKlxuICogT2xkZXN0IGFjY2VwdGFibGUgbWV0YWRhdGEgYWdlIGZvciBjbGllbnRzIHRoYXQgbWF5IHBhcnRpY2lwYXRlIGluIHRoZVxuICogcHJpbWFyeSBsZWFzZSBlbGVjdGlvbi4gQ2xpZW50cyB0aGF0IGhhdmUgbm90IHVwZGF0ZWQgdGhlaXIgY2xpZW50IG1ldGFkYXRhXG4gKiB3aXRoaW4gNSBzZWNvbmRzIGFyZSBub3QgZWxpZ2libGUgdG8gcmVjZWl2ZSBhIHByaW1hcnkgbGVhc2UuXG4gKi9cbmNvbnN0IE1BWF9QUklNQVJZX0VMSUdJQkxFX0FHRV9NUyA9IDUwMDA7XG4vKipcbiAqIFRoZSBpbnRlcnZhbCBhdCB3aGljaCBjbGllbnRzIHdpbGwgdXBkYXRlIHRoZWlyIG1ldGFkYXRhLCBpbmNsdWRpbmdcbiAqIHJlZnJlc2hpbmcgdGhlaXIgcHJpbWFyeSBsZWFzZSBpZiBoZWxkIG9yIHBvdGVudGlhbGx5IHRyeWluZyB0byBhY3F1aXJlIGl0IGlmXG4gKiBub3QgaGVsZC5cbiAqXG4gKiBQcmltYXJ5IGNsaWVudHMgbWF5IG9wcG9ydHVuaXN0aWNhbGx5IHJlZnJlc2ggdGhlaXIgbWV0YWRhdGEgZWFybGllclxuICogaWYgdGhleSdyZSBhbHJlYWR5IHBlcmZvcm1pbmcgYW4gSW5kZXhlZERCIG9wZXJhdGlvbi5cbiAqL1xuY29uc3QgQ0xJRU5UX01FVEFEQVRBX1JFRlJFU0hfSU5URVJWQUxfTVMgPSA0MDAwO1xuLyoqIFVzZXItZmFjaW5nIGVycm9yIHdoZW4gdGhlIHByaW1hcnkgbGVhc2UgaXMgcmVxdWlyZWQgYnV0IG5vdCBhdmFpbGFibGUuICovXG5jb25zdCBQUklNQVJZX0xFQVNFX0VYQ0xVU0lWRV9FUlJPUl9NU0cgPSAnRmFpbGVkIHRvIG9idGFpbiBleGNsdXNpdmUgYWNjZXNzIHRvIHRoZSBwZXJzaXN0ZW5jZSBsYXllci4gVG8gYWxsb3cgJyArXG4gICAgJ3NoYXJlZCBhY2Nlc3MsIG11bHRpLXRhYiBzeW5jaHJvbml6YXRpb24gaGFzIHRvIGJlIGVuYWJsZWQgaW4gYWxsIHRhYnMuICcgK1xuICAgICdJZiB5b3UgYXJlIHVzaW5nIGBleHBlcmltZW50YWxGb3JjZU93bmluZ1RhYjp0cnVlYCwgbWFrZSBzdXJlIHRoYXQgb25seSAnICtcbiAgICAnb25lIHRhYiBoYXMgcGVyc2lzdGVuY2UgZW5hYmxlZCBhdCBhbnkgZ2l2ZW4gdGltZS4nO1xuY29uc3QgVU5TVVBQT1JURURfUExBVEZPUk1fRVJST1JfTVNHID0gJ1RoaXMgcGxhdGZvcm0gaXMgZWl0aGVyIG1pc3NpbmcgSW5kZXhlZERCIG9yIGlzIGtub3duIHRvIGhhdmUgJyArXG4gICAgJ2FuIGluY29tcGxldGUgaW1wbGVtZW50YXRpb24uIE9mZmxpbmUgcGVyc2lzdGVuY2UgaGFzIGJlZW4gZGlzYWJsZWQuJztcbi8vIFRoZSBmb3JtYXQgb2YgdGhlIExvY2FsU3RvcmFnZSBrZXkgdGhhdCBzdG9yZXMgem9tYmllZCBjbGllbnQgaXM6XG4vLyAgICAgZmlyZXN0b3JlX3pvbWJpZV88cGVyc2lzdGVuY2VfcHJlZml4Pl88aW5zdGFuY2Vfa2V5PlxuY29uc3QgWk9NQklFRF9DTElFTlRTX0tFWV9QUkVGSVggPSAnZmlyZXN0b3JlX3pvbWJpZSc7XG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBtYWluIChhbmQgY3VycmVudGx5IG9ubHkpIEluZGV4ZWREQiBkYXRhYmFzZS4gVGhpcyBuYW1lIGlzXG4gKiBhcHBlbmRlZCB0byB0aGUgcHJlZml4IHByb3ZpZGVkIHRvIHRoZSBJbmRleGVkRGJQZXJzaXN0ZW5jZSBjb25zdHJ1Y3Rvci5cbiAqL1xuY29uc3QgTUFJTl9EQVRBQkFTRSA9ICdtYWluJztcbi8qKlxuICogQW4gSW5kZXhlZERCLWJhY2tlZCBpbnN0YW5jZSBvZiBQZXJzaXN0ZW5jZS4gRGF0YSBpcyBzdG9yZWQgcGVyc2lzdGVudGx5XG4gKiBhY3Jvc3Mgc2Vzc2lvbnMuXG4gKlxuICogT24gV2ViIG9ubHksIHRoZSBGaXJlc3RvcmUgU0RLcyBzdXBwb3J0IHNoYXJlZCBhY2Nlc3MgdG8gaXRzIHBlcnNpc3RlbmNlXG4gKiBsYXllci4gVGhpcyBhbGxvd3MgbXVsdGlwbGUgYnJvd3NlciB0YWJzIHRvIHJlYWQgYW5kIHdyaXRlIHRvIEluZGV4ZWREYiBhbmRcbiAqIHRvIHN5bmNocm9uaXplIHN0YXRlIGV2ZW4gd2l0aG91dCBuZXR3b3JrIGNvbm5lY3Rpdml0eS4gU2hhcmVkIGFjY2VzcyBpc1xuICogY3VycmVudGx5IG9wdGlvbmFsIGFuZCBub3QgZW5hYmxlZCB1bmxlc3MgYWxsIGNsaWVudHMgaW52b2tlXG4gKiBgZW5hYmxlUGVyc2lzdGVuY2UoKWAgd2l0aCBge3N5bmNocm9uaXplVGFiczp0cnVlfWAuXG4gKlxuICogSW4gbXVsdGktdGFiIG1vZGUsIGlmIG11bHRpcGxlIGNsaWVudHMgYXJlIGFjdGl2ZSBhdCB0aGUgc2FtZSB0aW1lLCB0aGUgU0RLXG4gKiB3aWxsIGRlc2lnbmF0ZSBvbmUgY2xpZW50IGFzIHRoZSDigJxwcmltYXJ5IGNsaWVudOKAnS4gQW4gZWZmb3J0IGlzIG1hZGUgdG8gcGlja1xuICogYSB2aXNpYmxlLCBuZXR3b3JrLWNvbm5lY3RlZCBhbmQgYWN0aXZlIGNsaWVudCwgYW5kIHRoaXMgY2xpZW50IGlzXG4gKiByZXNwb25zaWJsZSBmb3IgbGV0dGluZyBvdGhlciBjbGllbnRzIGtub3cgYWJvdXQgaXRzIHByZXNlbmNlLiBUaGUgcHJpbWFyeVxuICogY2xpZW50IHdyaXRlcyBhIHVuaXF1ZSBjbGllbnQtZ2VuZXJhdGVkIGlkZW50aWZpZXIgKHRoZSBjbGllbnQgSUQpIHRvXG4gKiBJbmRleGVkRGLigJlzIOKAnG93bmVy4oCdIHN0b3JlIGV2ZXJ5IDQgc2Vjb25kcy4gSWYgdGhlIHByaW1hcnkgY2xpZW50IGZhaWxzIHRvXG4gKiB1cGRhdGUgdGhpcyBlbnRyeSwgYW5vdGhlciBjbGllbnQgY2FuIGFjcXVpcmUgdGhlIGxlYXNlIGFuZCB0YWtlIG92ZXIgYXNcbiAqIHByaW1hcnkuXG4gKlxuICogU29tZSBwZXJzaXN0ZW5jZSBvcGVyYXRpb25zIGluIHRoZSBTREsgYXJlIGRlc2lnbmF0ZWQgYXMgcHJpbWFyeS1jbGllbnQgb25seVxuICogb3BlcmF0aW9ucy4gVGhpcyBpbmNsdWRlcyB0aGUgYWNrbm93bGVkZ21lbnQgb2YgbXV0YXRpb25zIGFuZCBhbGwgdXBkYXRlcyBvZlxuICogcmVtb3RlIGRvY3VtZW50cy4gVGhlIGVmZmVjdHMgb2YgdGhlc2Ugb3BlcmF0aW9ucyBhcmUgd3JpdHRlbiB0byBwZXJzaXN0ZW5jZVxuICogYW5kIHRoZW4gYnJvYWRjYXN0IHRvIG90aGVyIHRhYnMgdmlhIExvY2FsU3RvcmFnZSAoc2VlXG4gKiBgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlYCksIHdoaWNoIHRoZW4gcmVmcmVzaCB0aGVpciBzdGF0ZSBmcm9tXG4gKiBwZXJzaXN0ZW5jZS5cbiAqXG4gKiBTaW1pbGFybHksIHRoZSBwcmltYXJ5IGNsaWVudCBsaXN0ZW5zIHRvIG5vdGlmaWNhdGlvbnMgc2VudCBieSBzZWNvbmRhcnlcbiAqIGNsaWVudHMgdG8gZGlzY292ZXIgcGVyc2lzdGVuY2UgY2hhbmdlcyB3cml0dGVuIGJ5IHNlY29uZGFyeSBjbGllbnRzLCBzdWNoIGFzXG4gKiB0aGUgYWRkaXRpb24gb2YgbmV3IG11dGF0aW9ucyBhbmQgcXVlcnkgdGFyZ2V0cy5cbiAqXG4gKiBJZiBtdWx0aS10YWIgaXMgbm90IGVuYWJsZWQgYW5kIGFub3RoZXIgdGFiIGFscmVhZHkgb2J0YWluZWQgdGhlIHByaW1hcnlcbiAqIGxlYXNlLCBJbmRleGVkRGJQZXJzaXN0ZW5jZSBlbnRlcnMgYSBmYWlsZWQgc3RhdGUgYW5kIGFsbCBzdWJzZXF1ZW50XG4gKiBvcGVyYXRpb25zIHdpbGwgYXV0b21hdGljYWxseSBmYWlsLlxuICpcbiAqIEFkZGl0aW9uYWxseSwgdGhlcmUgaXMgYW4gb3B0aW1pemF0aW9uIHNvIHRoYXQgd2hlbiBhIHRhYiBpcyBjbG9zZWQsIHRoZVxuICogcHJpbWFyeSBsZWFzZSBpcyByZWxlYXNlZCBpbW1lZGlhdGVseSAodGhpcyBpcyBlc3BlY2lhbGx5IGltcG9ydGFudCB0byBtYWtlXG4gKiBzdXJlIHRoYXQgYSByZWZyZXNoZWQgdGFiIGlzIGFibGUgdG8gaW1tZWRpYXRlbHkgcmUtYWNxdWlyZSB0aGUgcHJpbWFyeVxuICogbGVhc2UpLiBVbmZvcnR1bmF0ZWx5LCBJbmRleGVkREIgY2Fubm90IGJlIHJlbGlhYmx5IHVzZWQgaW4gd2luZG93LnVubG9hZFxuICogc2luY2UgaXQgaXMgYW4gYXN5bmNocm9ub3VzIEFQSS4gU28gaW4gYWRkaXRpb24gdG8gYXR0ZW1wdGluZyB0byBnaXZlIHVwIHRoZVxuICogbGVhc2UsIHRoZSBsZWFzZWhvbGRlciB3cml0ZXMgaXRzIGNsaWVudCBJRCB0byBhIFwiem9tYmllZENsaWVudFwiIGVudHJ5IGluXG4gKiBMb2NhbFN0b3JhZ2Ugd2hpY2ggYWN0cyBhcyBhbiBpbmRpY2F0b3IgdGhhdCBhbm90aGVyIHRhYiBzaG91bGQgZ28gYWhlYWQgYW5kXG4gKiB0YWtlIHRoZSBwcmltYXJ5IGxlYXNlIGltbWVkaWF0ZWx5IHJlZ2FyZGxlc3Mgb2YgdGhlIGN1cnJlbnQgbGVhc2UgdGltZXN0YW1wLlxuICpcbiAqIFRPRE8oYi8xMTQyMjYyMzQpOiBSZW1vdmUgYHN5bmNocm9uaXplVGFic2Agc2VjdGlvbiB3aGVuIG11bHRpLXRhYiBpcyBub1xuICogbG9uZ2VyIG9wdGlvbmFsLlxuICovXG5jbGFzcyBJbmRleGVkRGJQZXJzaXN0ZW5jZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzeW5jaHJvbml6ZSB0aGUgaW4tbWVtb3J5IHN0YXRlIG9mIG11bHRpcGxlIHRhYnMgYW5kIHNoYXJlXG4gICAgICogYWNjZXNzIHRvIGxvY2FsIHBlcnNpc3RlbmNlLlxuICAgICAqL1xuICAgIGFsbG93VGFiU3luY2hyb25pemF0aW9uLCBwZXJzaXN0ZW5jZUtleSwgY2xpZW50SWQsIGxydVBhcmFtcywgcXVldWUsIHdpbmRvdywgZG9jdW1lbnQsIHNlcmlhbGl6ZXIsIHNlcXVlbmNlTnVtYmVyU3luY2VyLCBcbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgZm9yY2VmdWxseSBvYnRhaW5zIGRhdGFiYXNlIGFjY2Vzcy4gRXhpc3RpbmcgdGFicyB3aWxsXG4gICAgICogbm8gbG9uZ2VyIGJlIGFibGUgdG8gYWNjZXNzIEluZGV4ZWREQi5cbiAgICAgKi9cbiAgICBmb3JjZU93bmluZ1RhYiwgc2NoZW1hVmVyc2lvbiA9IFNDSEVNQV9WRVJTSU9OKSB7XG4gICAgICAgIHRoaXMuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24gPSBhbGxvd1RhYlN5bmNocm9uaXphdGlvbjtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5O1xuICAgICAgICB0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICAgICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZU51bWJlclN5bmNlciA9IHNlcXVlbmNlTnVtYmVyU3luY2VyO1xuICAgICAgICB0aGlzLmZvcmNlT3duaW5nVGFiID0gZm9yY2VPd25pbmdUYWI7XG4gICAgICAgIHRoaXMuc2NoZW1hVmVyc2lvbiA9IHNjaGVtYVZlcnNpb247XG4gICAgICAgIHRoaXMubGlzdGVuU2VxdWVuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNQcmltYXJ5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV0d29ya0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAvKiogT3VyIHdpbmRvdy51bmxvYWQgaGFuZGxlciwgaWYgcmVnaXN0ZXJlZC4gKi9cbiAgICAgICAgdGhpcy53aW5kb3dVbmxvYWRIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbkZvcmVncm91bmQgPSBmYWxzZTtcbiAgICAgICAgLyoqIE91ciAndmlzaWJpbGl0eWNoYW5nZScgbGlzdGVuZXIgaWYgcmVnaXN0ZXJlZC4gKi9cbiAgICAgICAgdGhpcy5kb2N1bWVudFZpc2liaWxpdHlIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgLyoqIFRoZSBjbGllbnQgbWV0YWRhdGEgcmVmcmVzaCB0YXNrLiAqL1xuICAgICAgICB0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyID0gbnVsbDtcbiAgICAgICAgLyoqIFRoZSBsYXN0IHRpbWUgd2UgZ2FyYmFnZSBjb2xsZWN0ZWQgdGhlIGNsaWVudCBtZXRhZGF0YSBvYmplY3Qgc3RvcmUuICovXG4gICAgICAgIHRoaXMubGFzdEdhcmJhZ2VDb2xsZWN0aW9uVGltZSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgLyoqIEEgbGlzdGVuZXIgdG8gbm90aWZ5IG9uIHByaW1hcnkgc3RhdGUgY2hhbmdlcy4gKi9cbiAgICAgICAgdGhpcy5wcmltYXJ5U3RhdGVMaXN0ZW5lciA9IF8gPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIGlmICghSW5kZXhlZERiUGVyc2lzdGVuY2UuaXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5JTVBMRU1FTlRFRCwgVU5TVVBQT1JURURfUExBVEZPUk1fRVJST1JfTVNHKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlID0gbmV3IEluZGV4ZWREYkxydURlbGVnYXRlSW1wbCh0aGlzLCBscnVQYXJhbXMpO1xuICAgICAgICB0aGlzLmRiTmFtZSA9IHBlcnNpc3RlbmNlS2V5ICsgTUFJTl9EQVRBQkFTRTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gbmV3IExvY2FsU2VyaWFsaXplcihzZXJpYWxpemVyKTtcbiAgICAgICAgdGhpcy5zaW1wbGVEYiA9IG5ldyBTaW1wbGVEYih0aGlzLmRiTmFtZSwgdGhpcy5zY2hlbWFWZXJzaW9uLCBuZXcgU2NoZW1hQ29udmVydGVyKHRoaXMuc2VyaWFsaXplcikpO1xuICAgICAgICB0aGlzLmdsb2JhbHNDYWNoZSA9IG5ldyBJbmRleGVkRGJHbG9iYWxzQ2FjaGUoKTtcbiAgICAgICAgdGhpcy50YXJnZXRDYWNoZSA9IG5ldyBJbmRleGVkRGJUYXJnZXRDYWNoZSh0aGlzLnJlZmVyZW5jZURlbGVnYXRlLCB0aGlzLnNlcmlhbGl6ZXIpO1xuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGUgPSBuZXdJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlKHRoaXMuc2VyaWFsaXplcik7XG4gICAgICAgIHRoaXMuYnVuZGxlQ2FjaGUgPSBuZXcgSW5kZXhlZERiQnVuZGxlQ2FjaGUoKTtcbiAgICAgICAgaWYgKHRoaXMud2luZG93ICYmIHRoaXMud2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgdGhpcy53ZWJTdG9yYWdlID0gdGhpcy53aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53ZWJTdG9yYWdlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChmb3JjZU93bmluZ1RhYiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBsb2dFcnJvcihMT0dfVEFHJGMsICdMb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGUuIEFzIGEgcmVzdWx0LCBwZXJzaXN0ZW5jZSBtYXkgbm90IHdvcmsgJyArXG4gICAgICAgICAgICAgICAgICAgICdyZWxpYWJseS4gSW4gcGFydGljdWxhciBlbmFibGVQZXJzaXN0ZW5jZSgpIGNvdWxkIGZhaWwgaW1tZWRpYXRlbHkgJyArXG4gICAgICAgICAgICAgICAgICAgICdhZnRlciByZWZyZXNoaW5nIHRoZSBwYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gc3RhcnQgSW5kZXhlZERiIHBlcnNpc3RlbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgV2hldGhlciBwZXJzaXN0ZW5jZSB3YXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBleHBlY3RlZCB0byBmYWlsIHNvbWV0aW1lcyAoaW4gdGhlIGNhc2Ugb2YgYW5vdGhlciB0YWJcbiAgICAgICAgLy8gYWxyZWFkeSBoYXZpbmcgdGhlIHBlcnNpc3RlbmNlIGxvY2spLCBzbyBpdCdzIHRoZSBmaXJzdCB0aGluZyB3ZSBzaG91bGRcbiAgICAgICAgLy8gZG8uXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeSgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNQcmltYXJ5ICYmICF0aGlzLmFsbG93VGFiU3luY2hyb25pemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gRmFpbCBgc3RhcnQoKWAgaWYgYHN5bmNocm9uaXplVGFic2AgaXMgZGlzYWJsZWQgYW5kIHdlIGNhbm5vdFxuICAgICAgICAgICAgICAgIC8vIG9idGFpbiB0aGUgcHJpbWFyeSBsZWFzZS5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCBQUklNQVJZX0xFQVNFX0VYQ0xVU0lWRV9FUlJPUl9NU0cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hdHRhY2hWaXNpYmlsaXR5SGFuZGxlcigpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hXaW5kb3dVbmxvYWRIb29rKCk7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ2xpZW50TWV0YWRhdGFBbmRQcmltYXJ5TGVhc2VSZWZyZXNoZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1blRyYW5zYWN0aW9uKCdnZXRIaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXInLCAncmVhZG9ubHknLCB0eG4gPT4gdGhpcy50YXJnZXRDYWNoZS5nZXRIaWdoZXN0U2VxdWVuY2VOdW1iZXIodHhuKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPT4ge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5TZXF1ZW5jZSA9IG5ldyBMaXN0ZW5TZXF1ZW5jZShoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIsIHRoaXMuc2VxdWVuY2VOdW1iZXJTeW5jZXIpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2ltcGxlRGIgJiYgdGhpcy5zaW1wbGVEYi5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIHByaW1hcnkgc3RhdGUgb2YgdGhlXG4gICAgICogaW5zdGFuY2UgY2hhbmdlcy4gVXBvbiByZWdpc3RlcmluZywgdGhpcyBsaXN0ZW5lciBpcyBpbnZva2VkIGltbWVkaWF0ZWx5XG4gICAgICogd2l0aCB0aGUgY3VycmVudCBwcmltYXJ5IHN0YXRlLlxuICAgICAqXG4gICAgICogUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgV2ViIG11bHRpLXRhYi5cbiAgICAgKi9cbiAgICBzZXRQcmltYXJ5U3RhdGVMaXN0ZW5lcihwcmltYXJ5U3RhdGVMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnByaW1hcnlTdGF0ZUxpc3RlbmVyID0gYXN5bmMgKHByaW1hcnlTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmltYXJ5U3RhdGVMaXN0ZW5lcihwcmltYXJ5U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJpbWFyeVN0YXRlTGlzdGVuZXIodGhpcy5pc1ByaW1hcnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIGRhdGFiYXNlIHJlY2VpdmVzIGFcbiAgICAgKiB2ZXJzaW9uIGNoYW5nZSBldmVudCBpbmRpY2F0aW5nIHRoYXQgaXQgaGFzIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBQT1JUSU5HIE5PVEU6IFRoaXMgaXMgb25seSB1c2VkIGZvciBXZWIgbXVsdGktdGFiLlxuICAgICAqL1xuICAgIHNldERhdGFiYXNlRGVsZXRlZExpc3RlbmVyKGRhdGFiYXNlRGVsZXRlZExpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc2ltcGxlRGIuc2V0VmVyc2lvbkNoYW5nZUxpc3RlbmVyKGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW4gYXR0ZW1wdCBpcyBtYWRlIHRvIGRlbGV0ZSBJbmRleGVkREIuXG4gICAgICAgICAgICBpZiAoZXZlbnQubmV3VmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGRhdGFiYXNlRGVsZXRlZExpc3RlbmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIHRoZSBjdXJyZW50IG5ldHdvcmsgc3RhdGUgaW4gdGhlIGNsaWVudCdzIG1ldGFkYXRhLCBwb3RlbnRpYWxseVxuICAgICAqIGFmZmVjdGluZyB0aGUgcHJpbWFyeSBsZWFzZS5cbiAgICAgKlxuICAgICAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgZm9yIFdlYiBtdWx0aS10YWIuXG4gICAgICovXG4gICAgc2V0TmV0d29ya0VuYWJsZWQobmV0d29ya0VuYWJsZWQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV0d29ya0VuYWJsZWQgIT09IG5ldHdvcmtFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5ldHdvcmtFbmFibGVkID0gbmV0d29ya0VuYWJsZWQ7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIHByaW1hcnkgbGVhc2UgcmVmcmVzaCBmb3IgaW1tZWRpYXRlIGV4ZWN1dGlvbi4gVGhlIGV2ZW50dWFsXG4gICAgICAgICAgICAvLyBsZWFzZSB1cGRhdGUgd2lsbCBiZSBwcm9wYWdhdGVkIHZpYSBgcHJpbWFyeVN0YXRlTGlzdGVuZXJgLlxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlQ2xpZW50TWV0YWRhdGFBbmRUcnlCZWNvbWVQcmltYXJ5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY2xpZW50IG1ldGFkYXRhIGluIEluZGV4ZWREYiBhbmQgYXR0ZW1wdHMgdG8gZWl0aGVyIG9idGFpbiBvclxuICAgICAqIGV4dGVuZCB0aGUgcHJpbWFyeSBsZWFzZSBmb3IgdGhlIGxvY2FsIGNsaWVudC4gQXN5bmNocm9ub3VzbHkgbm90aWZpZXMgdGhlXG4gICAgICogcHJpbWFyeSBzdGF0ZSBsaXN0ZW5lciBpZiB0aGUgY2xpZW50IGVpdGhlciBuZXdseSBvYnRhaW5lZCBvciByZWxlYXNlZCBpdHNcbiAgICAgKiBwcmltYXJ5IGxlYXNlLlxuICAgICAqL1xuICAgIHVwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuVHJhbnNhY3Rpb24oJ3VwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeScsICdyZWFkd3JpdGUnLCB0eG4gPT4ge1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFTdG9yZSA9IGNsaWVudE1ldGFkYXRhU3RvcmUodHhuKTtcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YVN0b3JlXG4gICAgICAgICAgICAgICAgLnB1dCh7XG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgdXBkYXRlVGltZU1zOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtFbmFibGVkOiB0aGlzLm5ldHdvcmtFbmFibGVkLFxuICAgICAgICAgICAgICAgIGluRm9yZWdyb3VuZDogdGhpcy5pbkZvcmVncm91bmRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlQcmltYXJ5TGVhc2UodHhuKS5uZXh0KHN1Y2Nlc3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gdGhpcy5wcmltYXJ5U3RhdGVMaXN0ZW5lcihmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMuY2FuQWN0QXNQcmltYXJ5KHR4bikpXG4gICAgICAgICAgICAgICAgLm5leHQoY2FuQWN0QXNQcmltYXJ5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnkgJiYgIWNhbkFjdEFzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxlYXNlUHJpbWFyeUxlYXNlSWZIZWxkKHR4bikubmV4dCgoKSA9PiBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhbkFjdEFzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3F1aXJlT3JFeHRlbmRQcmltYXJ5TGVhc2UodHhuKS5uZXh0KCgpID0+IHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8qIGNhbkFjdEFzUHJpbWFyeT0gKi8gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRjLCAnRmFpbGVkIHRvIGV4dGVuZCBvd25lciBsZWFzZTogJywgZSk7XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VlZCB3aXRoIHRoZSBleGlzdGluZyBzdGF0ZS4gQW55IHN1YnNlcXVlbnQgYWNjZXNzIHRvXG4gICAgICAgICAgICAgICAgLy8gSW5kZXhlZERCIHdpbGwgdmVyaWZ5IHRoZSBsZWFzZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ByaW1hcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRjLCAnUmVsZWFzaW5nIG93bmVyIGxlYXNlIGFmdGVyIGVycm9yIGR1cmluZyBsZWFzZSByZWZyZXNoJywgZSk7XG4gICAgICAgICAgICByZXR1cm4gLyogaXNQcmltYXJ5PSAqLyBmYWxzZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGlzUHJpbWFyeSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnkgIT09IGlzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiB0aGlzLnByaW1hcnlTdGF0ZUxpc3RlbmVyKGlzUHJpbWFyeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSBpc1ByaW1hcnk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2ZXJpZnlQcmltYXJ5TGVhc2UodHhuKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gcHJpbWFyeUNsaWVudFN0b3JlKHR4bik7XG4gICAgICAgIHJldHVybiBzdG9yZS5nZXQoRGJQcmltYXJ5Q2xpZW50S2V5KS5uZXh0KHByaW1hcnlDbGllbnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuaXNMb2NhbENsaWVudChwcmltYXJ5Q2xpZW50KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVDbGllbnRNZXRhZGF0YSh0eG4pIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGFTdG9yZSA9IGNsaWVudE1ldGFkYXRhU3RvcmUodHhuKTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhU3RvcmUuZGVsZXRlKHRoaXMuY2xpZW50SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZ2FyYmFnZSBjb2xsZWN0aW9uIHRocmVzaG9sZCBoYXMgcGFzc2VkLCBwcnVuZXMgdGhlXG4gICAgICogUmVtb3RlRG9jdW1lbnRDaGFuZ2VzIGFuZCB0aGUgQ2xpZW50TWV0YWRhdGEgc3RvcmUgYmFzZWQgb24gdGhlIGxhc3QgdXBkYXRlXG4gICAgICogdGltZSBvZiBhbGwgY2xpZW50cy5cbiAgICAgKi9cbiAgICBhc3luYyBtYXliZUdhcmJhZ2VDb2xsZWN0TXVsdGlDbGllbnRTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNQcmltYXJ5ICYmXG4gICAgICAgICAgICAhdGhpcy5pc1dpdGhpbkFnZSh0aGlzLmxhc3RHYXJiYWdlQ29sbGVjdGlvblRpbWUsIE1BWF9DTElFTlRfQUdFX01TKSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0R2FyYmFnZUNvbGxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IGluYWN0aXZlQ2xpZW50cyA9IGF3YWl0IHRoaXMucnVuVHJhbnNhY3Rpb24oJ21heWJlR2FyYmFnZUNvbGxlY3RNdWx0aUNsaWVudFN0YXRlJywgJ3JlYWR3cml0ZS1wcmltYXJ5JywgdHhuID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YVN0b3JlID0gZ2V0U3RvcmUodHhuLCBEYkNsaWVudE1ldGFkYXRhU3RvcmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YVN0b3JlLmxvYWRBbGwoKS5uZXh0KGV4aXN0aW5nQ2xpZW50cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuZmlsdGVyQWN0aXZlQ2xpZW50cyhleGlzdGluZ0NsaWVudHMsIE1BWF9DTElFTlRfQUdFX01TKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5hY3RpdmUgPSBleGlzdGluZ0NsaWVudHMuZmlsdGVyKGNsaWVudCA9PiBhY3RpdmUuaW5kZXhPZihjbGllbnQpID09PSAtMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBtZXRhZGF0YSBmb3IgY2xpZW50cyB0aGF0IGFyZSBubyBsb25nZXIgY29uc2lkZXJlZCBhY3RpdmUuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChpbmFjdGl2ZSwgKGluYWN0aXZlQ2xpZW50KSA9PiBtZXRhZGF0YVN0b3JlLmRlbGV0ZShpbmFjdGl2ZUNsaWVudC5jbGllbnRJZCkpLm5leHQoKCkgPT4gaW5hY3RpdmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBwcmltYXJ5IGxlYXNlIHZpb2xhdGlvbnMgb3IgYW55IG90aGVyIHR5cGUgb2YgZXJyb3IuIFRoZSBuZXh0XG4gICAgICAgICAgICAgICAgLy8gcHJpbWFyeSB3aWxsIHJ1biBgbWF5YmVHYXJiYWdlQ29sbGVjdE11bHRpQ2xpZW50U3RhdGUoKWAgYWdhaW4uXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXNlIGBpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MoKWAgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0byBkZXBlbmRcbiAgICAgICAgICAgICAgICAvLyBvbiBMb2NhbFN0b3JlLlxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRGVsZXRlIHBvdGVudGlhbCBsZWZ0b3ZlciBlbnRyaWVzIHRoYXQgbWF5IGNvbnRpbnVlIHRvIG1hcmsgdGhlXG4gICAgICAgICAgICAvLyBpbmFjdGl2ZSBjbGllbnRzIGFzIHpvbWJpZWQgaW4gTG9jYWxTdG9yYWdlLlxuICAgICAgICAgICAgLy8gSWRlYWxseSB3ZSdkIGRlbGV0ZSB0aGUgSW5kZXhlZERiIGFuZCBMb2NhbFN0b3JhZ2Ugem9tYmllIGVudHJpZXMgZm9yXG4gICAgICAgICAgICAvLyB0aGUgY2xpZW50IGF0b21pY2FsbHksIGJ1dCB3ZSBjYW4ndC4gU28gd2Ugb3B0IHRvIGRlbGV0ZSB0aGUgSW5kZXhlZERiXG4gICAgICAgICAgICAvLyBlbnRyaWVzIGZpcnN0IHRvIGF2b2lkIHBvdGVudGlhbGx5IHJldml2aW5nIGEgem9tYmllZCBjbGllbnQuXG4gICAgICAgICAgICBpZiAodGhpcy53ZWJTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbmFjdGl2ZUNsaWVudCBvZiBpbmFjdGl2ZUNsaWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWJTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy56b21iaWVkQ2xpZW50TG9jYWxTdG9yYWdlS2V5KGluYWN0aXZlQ2xpZW50LmNsaWVudElkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhIHJlY3VycmluZyB0aW1lciB0byB1cGRhdGUgdGhlIGNsaWVudCBtZXRhZGF0YSBhbmQgdG8gZWl0aGVyXG4gICAgICogZXh0ZW5kIG9yIGFjcXVpcmUgdGhlIHByaW1hcnkgbGVhc2UgaWYgdGhlIGNsaWVudCBpcyBlbGlnaWJsZS5cbiAgICAgKi9cbiAgICBzY2hlZHVsZUNsaWVudE1ldGFkYXRhQW5kUHJpbWFyeUxlYXNlUmVmcmVzaGVzKCkge1xuICAgICAgICB0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyID0gdGhpcy5xdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheShcImNsaWVudF9tZXRhZGF0YV9yZWZyZXNoXCIgLyogVGltZXJJZC5DbGllbnRNZXRhZGF0YVJlZnJlc2ggKi8sIENMSUVOVF9NRVRBREFUQV9SRUZSRVNIX0lOVEVSVkFMX01TLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVDbGllbnRNZXRhZGF0YUFuZFRyeUJlY29tZVByaW1hcnkoKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMubWF5YmVHYXJiYWdlQ29sbGVjdE11bHRpQ2xpZW50U3RhdGUoKSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLnNjaGVkdWxlQ2xpZW50TWV0YWRhdGFBbmRQcmltYXJ5TGVhc2VSZWZyZXNoZXMoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQ2hlY2tzIHdoZXRoZXIgYGNsaWVudGAgaXMgdGhlIGxvY2FsIGNsaWVudC4gKi9cbiAgICBpc0xvY2FsQ2xpZW50KGNsaWVudCkge1xuICAgICAgICByZXR1cm4gY2xpZW50ID8gY2xpZW50Lm93bmVySWQgPT09IHRoaXMuY2xpZW50SWQgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgdGhlIHN0YXRlIG9mIGFsbCBhY3RpdmUgY2xpZW50cyBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGxvY2FsXG4gICAgICogY2xpZW50IGlzIG9yIGNhbiBhY3QgYXMgdGhlIGhvbGRlciBvZiB0aGUgcHJpbWFyeSBsZWFzZS4gUmV0dXJucyB3aGV0aGVyXG4gICAgICogdGhlIGNsaWVudCBpcyBlbGlnaWJsZSBmb3IgdGhlIGxlYXNlLCBidXQgZG9lcyBub3QgYWN0dWFsbHkgYWNxdWlyZSBpdC5cbiAgICAgKiBNYXkgcmV0dXJuICdmYWxzZScgZXZlbiBpZiB0aGVyZSBpcyBubyBhY3RpdmUgbGVhc2Vob2xkZXIgYW5kIGFub3RoZXJcbiAgICAgKiAoZm9yZWdyb3VuZCkgY2xpZW50IHNob3VsZCBiZWNvbWUgbGVhc2Vob2xkZXIgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBjYW5BY3RBc1ByaW1hcnkodHhuKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcmNlT3duaW5nVGFiKSB7XG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RvcmUgPSBwcmltYXJ5Q2xpZW50U3RvcmUodHhuKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlXG4gICAgICAgICAgICAuZ2V0KERiUHJpbWFyeUNsaWVudEtleSlcbiAgICAgICAgICAgIC5uZXh0KGN1cnJlbnRQcmltYXJ5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMZWFzZUlzVmFsaWQgPSBjdXJyZW50UHJpbWFyeSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaXNXaXRoaW5BZ2UoY3VycmVudFByaW1hcnkubGVhc2VUaW1lc3RhbXBNcywgTUFYX1BSSU1BUllfRUxJR0lCTEVfQUdFX01TKSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmlzQ2xpZW50Wm9tYmllZChjdXJyZW50UHJpbWFyeS5vd25lcklkKTtcbiAgICAgICAgICAgIC8vIEEgY2xpZW50IGlzIGVsaWdpYmxlIGZvciB0aGUgcHJpbWFyeSBsZWFzZSBpZjpcbiAgICAgICAgICAgIC8vIC0gaXRzIG5ldHdvcmsgaXMgZW5hYmxlZCBhbmQgdGhlIGNsaWVudCdzIHRhYiBpcyBpbiB0aGUgZm9yZWdyb3VuZC5cbiAgICAgICAgICAgIC8vIC0gaXRzIG5ldHdvcmsgaXMgZW5hYmxlZCBhbmQgbm8gb3RoZXIgY2xpZW50J3MgdGFiIGlzIGluIHRoZVxuICAgICAgICAgICAgLy8gICBmb3JlZ3JvdW5kLlxuICAgICAgICAgICAgLy8gLSBldmVyeSBjbGllbnRzIG5ldHdvcmsgaXMgZGlzYWJsZWQgYW5kIHRoZSBjbGllbnQncyB0YWIgaXMgaW4gdGhlXG4gICAgICAgICAgICAvLyAgIGZvcmVncm91bmQuXG4gICAgICAgICAgICAvLyAtIGV2ZXJ5IGNsaWVudHMgbmV0d29yayBpcyBkaXNhYmxlZCBhbmQgbm8gb3RoZXIgY2xpZW50J3MgdGFiIGlzIGluXG4gICAgICAgICAgICAvLyAgIHRoZSBmb3JlZ3JvdW5kLlxuICAgICAgICAgICAgLy8gLSB0aGUgYGZvcmNlT3duaW5nVGFiYCBzZXR0aW5nIHdhcyBwYXNzZWQgaW4uXG4gICAgICAgICAgICBpZiAoY3VycmVudExlYXNlSXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTG9jYWxDbGllbnQoY3VycmVudFByaW1hcnkpICYmIHRoaXMubmV0d29ya0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0xvY2FsQ2xpZW50KGN1cnJlbnRQcmltYXJ5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcmltYXJ5LmFsbG93VGFiU3luY2hyb25pemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWlsIHRoZSBgY2FuQWN0QXNQcmltYXJ5YCBjaGVjayBpZiB0aGUgY3VycmVudCBsZWFzZWhvbGRlciBoYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBvcHRlZCBpbnRvIG11bHRpLXRhYiBzeW5jaHJvbml6YXRpb24uIElmIHRoaXMgaGFwcGVucyBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50IHN0YXJ0dXAsIHdlIHJlamVjdCB0aGUgUHJvbWlzZSByZXR1cm5lZCBieVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGVuYWJsZVBlcnNpc3RlbmNlKClgIGFuZCB0aGUgdXNlciBjYW4gY29udGludWUgdG8gdXNlIEZpcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCBpbi1tZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGZhaWxzIGR1cmluZyBhIGxlYXNlIHJlZnJlc2gsIHdlIHdpbGwgaW5zdGVhZCBibG9jayB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzeW5jUXVldWUgZnJvbSBleGVjdXRpbmcgZnVydGhlciBvcGVyYXRpb25zLiBOb3RlIHRoYXQgdGhpcyBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXB0YWJsZSBzaW5jZSBtaXhpbmcgJiBtYXRjaGluZyBkaWZmZXJlbnQgYHN5bmNocm9uaXplVGFic2BcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmdzIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhiLzExNDIyNjIzNCk6IFJlbW92ZSB0aGlzIGNoZWNrIHdoZW4gYHN5bmNocm9uaXplVGFic2AgY2FuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgYmUgdHVybmVkIG9mZi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sIFBSSU1BUllfTEVBU0VfRVhDTFVTSVZFX0VSUk9SX01TRyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm5ldHdvcmtFbmFibGVkICYmIHRoaXMuaW5Gb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50TWV0YWRhdGFTdG9yZSh0eG4pXG4gICAgICAgICAgICAgICAgLmxvYWRBbGwoKVxuICAgICAgICAgICAgICAgIC5uZXh0KGV4aXN0aW5nQ2xpZW50cyA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBhbGwgZXhpc3RpbmcgY2xpZW50cyBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgYXQgbGVhc3Qgb25lIG9mXG4gICAgICAgICAgICAgICAgLy8gdGhlbSBpcyBiZXR0ZXIgc3VpdGVkIHRvIG9idGFpbiB0aGUgcHJpbWFyeSBsZWFzZS5cbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmZXJyZWRDYW5kaWRhdGUgPSB0aGlzLmZpbHRlckFjdGl2ZUNsaWVudHMoZXhpc3RpbmdDbGllbnRzLCBNQVhfUFJJTUFSWV9FTElHSUJMRV9BR0VfTVMpLmZpbmQob3RoZXJDbGllbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jbGllbnRJZCAhPT0gb3RoZXJDbGllbnQuY2xpZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyQ2xpZW50SGFzQmV0dGVyTmV0d29ya1N0YXRlID0gIXRoaXMubmV0d29ya0VuYWJsZWQgJiYgb3RoZXJDbGllbnQubmV0d29ya0VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNsaWVudEhhc0JldHRlclZpc2liaWxpdHkgPSAhdGhpcy5pbkZvcmVncm91bmQgJiYgb3RoZXJDbGllbnQuaW5Gb3JlZ3JvdW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJDbGllbnRIYXNTYW1lTmV0d29ya1N0YXRlID0gdGhpcy5uZXR3b3JrRW5hYmxlZCA9PT0gb3RoZXJDbGllbnQubmV0d29ya0VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJDbGllbnRIYXNCZXR0ZXJOZXR3b3JrU3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3RoZXJDbGllbnRIYXNCZXR0ZXJWaXNpYmlsaXR5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyQ2xpZW50SGFzU2FtZU5ldHdvcmtTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZlcnJlZENhbmRpZGF0ZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChjYW5BY3RBc1ByaW1hcnkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNQcmltYXJ5ICE9PSBjYW5BY3RBc1ByaW1hcnkpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsIGBDbGllbnQgJHtjYW5BY3RBc1ByaW1hcnkgPyAnaXMnIDogJ2lzIG5vdCd9IGVsaWdpYmxlIGZvciBhIHByaW1hcnkgbGVhc2UuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FuQWN0QXNQcmltYXJ5O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2h1dGRvd24oKSB7XG4gICAgICAgIC8vIFRoZSBzaHV0ZG93bigpIG9wZXJhdGlvbnMgYXJlIGlkZW1wb3RlbnQgYW5kIGNhbiBiZSBjYWxsZWQgZXZlbiB3aGVuXG4gICAgICAgIC8vIHN0YXJ0KCkgYWJvcnRlZCAoZS5nLiBiZWNhdXNlIGl0IGNvdWxkbid0IGFjcXVpcmUgdGhlIHBlcnNpc3RlbmNlIGxlYXNlKS5cbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hcmtDbGllbnRab21iaWVkKCk7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy5jbGllbnRNZXRhZGF0YVJlZnJlc2hlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXRhY2hWaXNpYmlsaXR5SGFuZGxlcigpO1xuICAgICAgICB0aGlzLmRldGFjaFdpbmRvd1VubG9hZEhvb2soKTtcbiAgICAgICAgLy8gVXNlIGBTaW1wbGVEYi5ydW5UcmFuc2FjdGlvbmAgZGlyZWN0bHkgdG8gYXZvaWQgZmFpbGluZyBpZiBhbm90aGVyIHRhYlxuICAgICAgICAvLyBoYXMgb2J0YWluZWQgdGhlIHByaW1hcnkgbGVhc2UuXG4gICAgICAgIGF3YWl0IHRoaXMuc2ltcGxlRGIucnVuVHJhbnNhY3Rpb24oJ3NodXRkb3duJywgJ3JlYWR3cml0ZScsIFtEYlByaW1hcnlDbGllbnRTdG9yZSwgRGJDbGllbnRNZXRhZGF0YVN0b3JlXSwgc2ltcGxlRGJUeG4gPT4ge1xuICAgICAgICAgICAgY29uc3QgcGVyc2lzdGVuY2VUcmFuc2FjdGlvbiA9IG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbihzaW1wbGVEYlR4biwgTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxlYXNlUHJpbWFyeUxlYXNlSWZIZWxkKHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24pLm5leHQoKCkgPT4gdGhpcy5yZW1vdmVDbGllbnRNZXRhZGF0YShwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNpbXBsZURiLmNsb3NlKCk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZW50cnkgbWFya2luZyB0aGUgY2xpZW50IGFzIHpvbWJpZWQgZnJvbSBMb2NhbFN0b3JhZ2Ugc2luY2VcbiAgICAgICAgLy8gd2Ugc3VjY2Vzc2Z1bGx5IGRlbGV0ZWQgaXRzIG1ldGFkYXRhIGZyb20gSW5kZXhlZERiLlxuICAgICAgICB0aGlzLnJlbW92ZUNsaWVudFpvbWJpZWRFbnRyeSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNsaWVudHMgdGhhdCBhcmUgbm90IHpvbWJpZWQgYW5kIGhhdmUgYW4gdXBkYXRlVGltZSB3aXRoaW4gdGhlXG4gICAgICogcHJvdmlkZWQgdGhyZXNob2xkLlxuICAgICAqL1xuICAgIGZpbHRlckFjdGl2ZUNsaWVudHMoY2xpZW50cywgYWN0aXZpdHlUaHJlc2hvbGRNcykge1xuICAgICAgICByZXR1cm4gY2xpZW50cy5maWx0ZXIoY2xpZW50ID0+IHRoaXMuaXNXaXRoaW5BZ2UoY2xpZW50LnVwZGF0ZVRpbWVNcywgYWN0aXZpdHlUaHJlc2hvbGRNcykgJiZcbiAgICAgICAgICAgICF0aGlzLmlzQ2xpZW50Wm9tYmllZChjbGllbnQuY2xpZW50SWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSURzIG9mIHRoZSBjbGllbnRzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUuIElmIG11bHRpLXRhYlxuICAgICAqIGlzIG5vdCBzdXBwb3J0ZWQsIHJldHVybnMgYW4gYXJyYXkgdGhhdCBvbmx5IGNvbnRhaW5zIHRoZSBsb2NhbCBjbGllbnQnc1xuICAgICAqIElELlxuICAgICAqXG4gICAgICogUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgV2ViIG11bHRpLXRhYi5cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVDbGllbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5UcmFuc2FjdGlvbignZ2V0QWN0aXZlQ2xpZW50cycsICdyZWFkb25seScsIHR4biA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50TWV0YWRhdGFTdG9yZSh0eG4pXG4gICAgICAgICAgICAgICAgLmxvYWRBbGwoKVxuICAgICAgICAgICAgICAgIC5uZXh0KGNsaWVudHMgPT4gdGhpcy5maWx0ZXJBY3RpdmVDbGllbnRzKGNsaWVudHMsIE1BWF9DTElFTlRfQUdFX01TKS5tYXAoY2xpZW50TWV0YWRhdGEgPT4gY2xpZW50TWV0YWRhdGEuY2xpZW50SWQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBzdGFydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnRlZDtcbiAgICB9XG4gICAgZ2V0R2xvYmFsc0NhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxzQ2FjaGU7XG4gICAgfVxuICAgIGdldE11dGF0aW9uUXVldWUodXNlciwgaW5kZXhNYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiBJbmRleGVkRGJNdXRhdGlvblF1ZXVlLmZvclVzZXIodXNlciwgdGhpcy5zZXJpYWxpemVyLCBpbmRleE1hbmFnZXIsIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUpO1xuICAgIH1cbiAgICBnZXRUYXJnZXRDYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0Q2FjaGU7XG4gICAgfVxuICAgIGdldFJlbW90ZURvY3VtZW50Q2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGU7XG4gICAgfVxuICAgIGdldEluZGV4TWFuYWdlcih1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiSW5kZXhNYW5hZ2VyKHVzZXIsIHRoaXMuc2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLmRhdGFiYXNlSWQpO1xuICAgIH1cbiAgICBnZXREb2N1bWVudE92ZXJsYXlDYWNoZSh1c2VyKSB7XG4gICAgICAgIHJldHVybiBJbmRleGVkRGJEb2N1bWVudE92ZXJsYXlDYWNoZS5mb3JVc2VyKHRoaXMuc2VyaWFsaXplciwgdXNlcik7XG4gICAgfVxuICAgIGdldEJ1bmRsZUNhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idW5kbGVDYWNoZTtcbiAgICB9XG4gICAgcnVuVHJhbnNhY3Rpb24oYWN0aW9uLCBtb2RlLCB0cmFuc2FjdGlvbk9wZXJhdGlvbikge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsICdTdGFydGluZyB0cmFuc2FjdGlvbjonLCBhY3Rpb24pO1xuICAgICAgICBjb25zdCBzaW1wbGVEYk1vZGUgPSBtb2RlID09PSAncmVhZG9ubHknID8gJ3JlYWRvbmx5JyA6ICdyZWFkd3JpdGUnO1xuICAgICAgICBjb25zdCBvYmplY3RTdG9yZXMgPSBnZXRPYmplY3RTdG9yZXModGhpcy5zY2hlbWFWZXJzaW9uKTtcbiAgICAgICAgbGV0IHBlcnNpc3RlbmNlVHJhbnNhY3Rpb247XG4gICAgICAgIC8vIERvIGFsbCB0cmFuc2FjdGlvbnMgYXMgcmVhZHdyaXRlIGFnYWluc3QgYWxsIG9iamVjdCBzdG9yZXMsIHNpbmNlIHdlXG4gICAgICAgIC8vIGFyZSB0aGUgb25seSByZWFkZXIvd3JpdGVyLlxuICAgICAgICByZXR1cm4gdGhpcy5zaW1wbGVEYlxuICAgICAgICAgICAgLnJ1blRyYW5zYWN0aW9uKGFjdGlvbiwgc2ltcGxlRGJNb2RlLCBvYmplY3RTdG9yZXMsIHNpbXBsZURiVHhuID0+IHtcbiAgICAgICAgICAgIHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24gPSBuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb24oc2ltcGxlRGJUeG4sIHRoaXMubGlzdGVuU2VxdWVuY2VcbiAgICAgICAgICAgICAgICA/IHRoaXMubGlzdGVuU2VxdWVuY2UubmV4dCgpXG4gICAgICAgICAgICAgICAgOiBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKTtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlLXByaW1hcnknKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgd2UgbWVyZWx5IHZlcmlmeSB0aGF0IHdlIGhhdmUgKG9yIGNhbiBhY3F1aXJlKSB0aGUgbGVhc2VcbiAgICAgICAgICAgICAgICAvLyBpbW1lZGlhdGVseSwgd2Ugd2FpdCB0byBleHRlbmQgdGhlIHByaW1hcnkgbGVhc2UgdW50aWwgYWZ0ZXJcbiAgICAgICAgICAgICAgICAvLyBleGVjdXRpbmcgdHJhbnNhY3Rpb25PcGVyYXRpb24oKS4gVGhpcyBlbnN1cmVzIHRoYXQgZXZlbiBpZiB0aGVcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbk9wZXJhdGlvbiB0YWtlcyBhIGxvbmcgdGltZSwgd2UnbGwgdXNlIGEgcmVjZW50XG4gICAgICAgICAgICAgICAgLy8gbGVhc2VUaW1lc3RhbXBNcyBpbiB0aGUgZXh0ZW5kZWQgKG9yIG5ld2x5IGFjcXVpcmVkKSBsZWFzZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlQcmltYXJ5TGVhc2UocGVyc2lzdGVuY2VUcmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoaG9sZHNQcmltYXJ5TGVhc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZHNQcmltYXJ5TGVhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAvKiBob2xkc1ByaW1hcnlMZWFzZT0gKi8gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYW5BY3RBc1ByaW1hcnkocGVyc2lzdGVuY2VUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm5leHQoaG9sZHNQcmltYXJ5TGVhc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhvbGRzUHJpbWFyeUxlYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFcnJvcihgRmFpbGVkIHRvIG9idGFpbiBwcmltYXJ5IGxlYXNlIGZvciBhY3Rpb24gJyR7YWN0aW9ufScuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IHRoaXMucHJpbWFyeVN0YXRlTGlzdGVuZXIoZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sIFBSSU1BUllfTEVBU0VfTE9TVF9FUlJPUl9NU0cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbk9wZXJhdGlvbihwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3F1aXJlT3JFeHRlbmRQcmltYXJ5TGVhc2UocGVyc2lzdGVuY2VUcmFuc2FjdGlvbikubmV4dCgoKSA9PiByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5QWxsb3dUYWJTeW5jaHJvbml6YXRpb24ocGVyc2lzdGVuY2VUcmFuc2FjdGlvbikubmV4dCgoKSA9PiB0cmFuc2FjdGlvbk9wZXJhdGlvbihwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcGVyc2lzdGVuY2VUcmFuc2FjdGlvbi5yYWlzZU9uQ29tbWl0dGVkRXZlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGF0IHRoZSBjdXJyZW50IHRhYiBpcyB0aGUgcHJpbWFyeSBsZWFzZWhvbGRlciBvciBhbHRlcm5hdGl2ZWx5XG4gICAgICogdGhhdCB0aGUgbGVhc2Vob2xkZXIgaGFzIG9wdGVkIGludG8gbXVsdGktdGFiIHN5bmNocm9uaXphdGlvbi5cbiAgICAgKi9cbiAgICAvLyBUT0RPKGIvMTE0MjI2MjM0KTogUmVtb3ZlIHRoaXMgY2hlY2sgd2hlbiBgc3luY2hyb25pemVUYWJzYCBjYW4gbm8gbG9uZ2VyXG4gICAgLy8gYmUgdHVybmVkIG9mZi5cbiAgICB2ZXJpZnlBbGxvd1RhYlN5bmNocm9uaXphdGlvbih0eG4pIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBwcmltYXJ5Q2xpZW50U3RvcmUodHhuKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlLmdldChEYlByaW1hcnlDbGllbnRLZXkpLm5leHQoY3VycmVudFByaW1hcnkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudExlYXNlSXNWYWxpZCA9IGN1cnJlbnRQcmltYXJ5ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5pc1dpdGhpbkFnZShjdXJyZW50UHJpbWFyeS5sZWFzZVRpbWVzdGFtcE1zLCBNQVhfUFJJTUFSWV9FTElHSUJMRV9BR0VfTVMpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaXNDbGllbnRab21iaWVkKGN1cnJlbnRQcmltYXJ5Lm93bmVySWQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZWFzZUlzVmFsaWQgJiYgIXRoaXMuaXNMb2NhbENsaWVudChjdXJyZW50UHJpbWFyeSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZm9yY2VPd25pbmdUYWIgJiZcbiAgICAgICAgICAgICAgICAgICAgKCF0aGlzLmFsbG93VGFiU3luY2hyb25pemF0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhY3VycmVudFByaW1hcnkuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sIFBSSU1BUllfTEVBU0VfRVhDTFVTSVZFX0VSUk9SX01TRyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT2J0YWlucyBvciBleHRlbmRzIHRoZSBuZXcgcHJpbWFyeSBsZWFzZSBmb3IgdGhlIGxvY2FsIGNsaWVudC4gVGhpc1xuICAgICAqIG1ldGhvZCBkb2VzIG5vdCB2ZXJpZnkgdGhhdCB0aGUgY2xpZW50IGlzIGVsaWdpYmxlIGZvciB0aGlzIGxlYXNlLlxuICAgICAqL1xuICAgIGFjcXVpcmVPckV4dGVuZFByaW1hcnlMZWFzZSh0eG4pIHtcbiAgICAgICAgY29uc3QgbmV3UHJpbWFyeSA9IHtcbiAgICAgICAgICAgIG93bmVySWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICBhbGxvd1RhYlN5bmNocm9uaXphdGlvbjogdGhpcy5hbGxvd1RhYlN5bmNocm9uaXphdGlvbixcbiAgICAgICAgICAgIGxlYXNlVGltZXN0YW1wTXM6IERhdGUubm93KClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByaW1hcnlDbGllbnRTdG9yZSh0eG4pLnB1dChEYlByaW1hcnlDbGllbnRLZXksIG5ld1ByaW1hcnkpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNBdmFpbGFibGUoKSB7XG4gICAgICAgIHJldHVybiBTaW1wbGVEYi5pc0F2YWlsYWJsZSgpO1xuICAgIH1cbiAgICAvKiogQ2hlY2tzIHRoZSBwcmltYXJ5IGxlYXNlIGFuZCByZW1vdmVzIGl0IGlmIHdlIGFyZSB0aGUgY3VycmVudCBwcmltYXJ5LiAqL1xuICAgIHJlbGVhc2VQcmltYXJ5TGVhc2VJZkhlbGQodHhuKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gcHJpbWFyeUNsaWVudFN0b3JlKHR4bik7XG4gICAgICAgIHJldHVybiBzdG9yZS5nZXQoRGJQcmltYXJ5Q2xpZW50S2V5KS5uZXh0KHByaW1hcnlDbGllbnQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2NhbENsaWVudChwcmltYXJ5Q2xpZW50KSkge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckYywgJ1JlbGVhc2luZyBwcmltYXJ5IGxlYXNlLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5kZWxldGUoRGJQcmltYXJ5Q2xpZW50S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIFZlcmlmaWVzIHRoYXQgYHVwZGF0ZVRpbWVNc2AgaXMgd2l0aGluIGBtYXhBZ2VNc2AuICovXG4gICAgaXNXaXRoaW5BZ2UodXBkYXRlVGltZU1zLCBtYXhBZ2VNcykge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBtaW5BY2NlcHRhYmxlID0gbm93IC0gbWF4QWdlTXM7XG4gICAgICAgIGNvbnN0IG1heEFjY2VwdGFibGUgPSBub3c7XG4gICAgICAgIGlmICh1cGRhdGVUaW1lTXMgPCBtaW5BY2NlcHRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXBkYXRlVGltZU1zID4gbWF4QWNjZXB0YWJsZSkge1xuICAgICAgICAgICAgbG9nRXJyb3IoYERldGVjdGVkIGFuIHVwZGF0ZSB0aW1lIHRoYXQgaXMgaW4gdGhlIGZ1dHVyZTogJHt1cGRhdGVUaW1lTXN9ID4gJHttYXhBY2NlcHRhYmxlfWApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhdHRhY2hWaXNpYmlsaXR5SGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnQgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluRm9yZWdyb3VuZCA9IHRoaXMuZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZSc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5SGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLmluRm9yZWdyb3VuZCA9IHRoaXMuZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGV0YWNoVmlzaWJpbGl0eUhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50VmlzaWJpbGl0eUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5SGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50VmlzaWJpbGl0eUhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGEgd2luZG93LnVubG9hZCBoYW5kbGVyIHRoYXQgd2lsbCBzeW5jaHJvbm91c2x5IHdyaXRlIG91clxuICAgICAqIGNsaWVudElkIHRvIGEgXCJ6b21iaWUgY2xpZW50IGlkXCIgbG9jYXRpb24gaW4gTG9jYWxTdG9yYWdlLiBUaGlzIGNhbiBiZSB1c2VkXG4gICAgICogYnkgdGFicyB0cnlpbmcgdG8gYWNxdWlyZSB0aGUgcHJpbWFyeSBsZWFzZSB0byBkZXRlcm1pbmUgdGhhdCB0aGUgbGVhc2VcbiAgICAgKiBpcyBubyBsb25nZXIgdmFsaWQgZXZlbiBpZiB0aGUgdGltZXN0YW1wIGlzIHJlY2VudC4gVGhpcyBpcyBwYXJ0aWN1bGFybHlcbiAgICAgKiBpbXBvcnRhbnQgZm9yIHRoZSByZWZyZXNoIGNhc2UgKHNvIHRoZSB0YWIgY29ycmVjdGx5IHJlLWFjcXVpcmVzIHRoZVxuICAgICAqIHByaW1hcnkgbGVhc2UpLiBMb2NhbFN0b3JhZ2UgaXMgdXNlZCBmb3IgdGhpcyByYXRoZXIgdGhhbiBJbmRleGVkRGIgYmVjYXVzZVxuICAgICAqIGl0IGlzIGEgc3luY2hyb25vdXMgQVBJIGFuZCBzbyBjYW4gYmUgdXNlZCByZWxpYWJseSBmcm9tICBhbiB1bmxvYWRcbiAgICAgKiBoYW5kbGVyLlxuICAgICAqL1xuICAgIGF0dGFjaFdpbmRvd1VubG9hZEhvb2soKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHR5cGVvZiAoKF9hID0gdGhpcy53aW5kb3cpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRFdmVudExpc3RlbmVyKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy53aW5kb3dVbmxvYWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IEluIHRoZW9yeSwgdGhpcyBzaG91bGQgYmUgc2NoZWR1bGVkIG9uIHRoZSBBc3luY1F1ZXVlIHNpbmNlIGl0XG4gICAgICAgICAgICAgICAgLy8gYWNjZXNzZXMgaW50ZXJuYWwgc3RhdGUuIFdlIGV4ZWN1dGUgdGhpcyBjb2RlIGRpcmVjdGx5IGR1cmluZyBzaHV0ZG93blxuICAgICAgICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBpdCBnZXRzIGEgY2hhbmNlIHRvIHJ1bi5cbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtDbGllbnRab21iaWVkKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FmYXJpSW5kZXhkYkJ1Z1ZlcnNpb25SZWdleCA9IC8oPzpWZXJzaW9ufE1vYmlsZSlcXC8xWzQ1Nl0vO1xuICAgICAgICAgICAgICAgIGlmIChpc1NhZmFyaSgpICYmXG4gICAgICAgICAgICAgICAgICAgIChuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaChzYWZhcmlJbmRleGRiQnVnVmVyc2lvblJlZ2V4KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChzYWZhcmlJbmRleGRiQnVnVmVyc2lvblJlZ2V4KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT24gU2FmYXJpIDE0LCAxNSwgYW5kIDE2LCB3ZSBkbyBub3QgcnVuIGFueSBjbGVhbnVwIGFjdGlvbnMgYXMgaXQgbWlnaHRcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBhIGJ1ZyB0aGF0IHByZXZlbnRzIFNhZmFyaSBmcm9tIHJlLW9wZW5pbmcgSW5kZXhlZERCIGR1cmluZ1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmV4dCBwYWdlIGxvYWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjI2NTQ3XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW50ZXJSZXN0cmljdGVkTW9kZSgvKiBwdXJnZUV4aXN0aW5nVGFza3M9ICovIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IGdyYWNlZnVsIHNodXRkb3duIChpbmNsdWRpbmcgcmVsZWFzaW5nIG91ciBwcmltYXJ5IGxlYXNlKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHRoZXJlJ3Mgbm8gZ3VhcmFudGVlIGl0IHdpbGwgY29tcGxldGUuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNodXRkb3duKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLndpbmRvd1VubG9hZEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRldGFjaFdpbmRvd1VubG9hZEhvb2soKSB7XG4gICAgICAgIGlmICh0aGlzLndpbmRvd1VubG9hZEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy53aW5kb3dVbmxvYWRIYW5kbGVyKTtcbiAgICAgICAgICAgIHRoaXMud2luZG93VW5sb2FkSGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGEgY2xpZW50IGlzIFwiem9tYmllZFwiIGJhc2VkIG9uIGl0cyBMb2NhbFN0b3JhZ2UgZW50cnkuXG4gICAgICogQ2xpZW50cyBiZWNvbWUgem9tYmllZCB3aGVuIHRoZWlyIHRhYiBjbG9zZXMgd2l0aG91dCBydW5uaW5nIGFsbCBvZiB0aGVcbiAgICAgKiBjbGVhbnVwIGxvZ2ljIGluIGBzaHV0ZG93bigpYC5cbiAgICAgKi9cbiAgICBpc0NsaWVudFpvbWJpZWQoY2xpZW50SWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXNab21iaWVkID0gKChfYSA9IHRoaXMud2ViU3RvcmFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEl0ZW0odGhpcy56b21iaWVkQ2xpZW50TG9jYWxTdG9yYWdlS2V5KGNsaWVudElkKSkpICE9PSBudWxsO1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRjLCBgQ2xpZW50ICcke2NsaWVudElkfScgJHtpc1pvbWJpZWQgPyAnaXMnIDogJ2lzIG5vdCd9IHpvbWJpZWQgaW4gTG9jYWxTdG9yYWdlYCk7XG4gICAgICAgICAgICByZXR1cm4gaXNab21iaWVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBHcmFjZWZ1bGx5IGhhbmRsZSBpZiBMb2NhbFN0b3JhZ2UgaXNuJ3Qgd29ya2luZy5cbiAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYywgJ0ZhaWxlZCB0byBnZXQgem9tYmllZCBjbGllbnQgaWQuJywgZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3JkIGNsaWVudCBhcyB6b21iaWVkIChhIGNsaWVudCB0aGF0IGhhZCBpdHMgdGFiIGNsb3NlZCkuIFpvbWJpZWRcbiAgICAgKiBjbGllbnRzIGFyZSBpZ25vcmVkIGR1cmluZyBwcmltYXJ5IHRhYiBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgbWFya0NsaWVudFpvbWJpZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy53ZWJTdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMud2ViU3RvcmFnZS5zZXRJdGVtKHRoaXMuem9tYmllZENsaWVudExvY2FsU3RvcmFnZUtleSh0aGlzLmNsaWVudElkKSwgU3RyaW5nKERhdGUubm93KCkpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gR3JhY2VmdWxseSBoYW5kbGUgaWYgTG9jYWxTdG9yYWdlIGlzbid0IGF2YWlsYWJsZSAvIHdvcmtpbmcuXG4gICAgICAgICAgICBsb2dFcnJvcignRmFpbGVkIHRvIHNldCB6b21iaWUgY2xpZW50IGlkLicsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBSZW1vdmVzIHRoZSB6b21iaWVkIGNsaWVudCBlbnRyeSBpZiBpdCBleGlzdHMuICovXG4gICAgcmVtb3ZlQ2xpZW50Wm9tYmllZEVudHJ5KCkge1xuICAgICAgICBpZiAoIXRoaXMud2ViU3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLndlYlN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnpvbWJpZWRDbGllbnRMb2NhbFN0b3JhZ2VLZXkodGhpcy5jbGllbnRJZCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmVcbiAgICAgICAgfVxuICAgIH1cbiAgICB6b21iaWVkQ2xpZW50TG9jYWxTdG9yYWdlS2V5KGNsaWVudElkKSB7XG4gICAgICAgIHJldHVybiBgJHtaT01CSUVEX0NMSUVOVFNfS0VZX1BSRUZJWH1fJHt0aGlzLnBlcnNpc3RlbmNlS2V5fV8ke2NsaWVudElkfWA7XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIHByaW1hcnkgY2xpZW50IG9iamVjdCBzdG9yZS5cbiAqL1xuZnVuY3Rpb24gcHJpbWFyeUNsaWVudFN0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiUHJpbWFyeUNsaWVudFN0b3JlKTtcbn1cbi8qKlxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBjbGllbnQgbWV0YWRhdGEgb2JqZWN0IHN0b3JlLlxuICovXG5mdW5jdGlvbiBjbGllbnRNZXRhZGF0YVN0b3JlKHR4bikge1xuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiQ2xpZW50TWV0YWRhdGFTdG9yZSk7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHN0cmluZyB1c2VkIGFzIGEgcHJlZml4IHdoZW4gc3RvcmluZyBkYXRhIGluIEluZGV4ZWREQiBhbmRcbiAqIExvY2FsU3RvcmFnZS5cbiAqL1xuZnVuY3Rpb24gaW5kZXhlZERiU3RvcmFnZVByZWZpeChkYXRhYmFzZUlkLCBwZXJzaXN0ZW5jZUtleSkge1xuICAgIC8vIFVzZSB0d28gZGlmZmVyZW50IHByZWZpeCBmb3JtYXRzOlxuICAgIC8vXG4gICAgLy8gICAqIGZpcmVzdG9yZSAvIHBlcnNpc3RlbmNlS2V5IC8gcHJvamVjdElEIC4gZGF0YWJhc2VJRCAvIC4uLlxuICAgIC8vICAgKiBmaXJlc3RvcmUgLyBwZXJzaXN0ZW5jZUtleSAvIHByb2plY3RJRCAvIC4uLlxuICAgIC8vXG4gICAgLy8gcHJvamVjdElEcyBhcmUgRE5TLWNvbXBhdGlibGUgbmFtZXMgYW5kIGNhbm5vdCBjb250YWluIGRvdHNcbiAgICAvLyBzbyB0aGVyZSdzIG5vIGRhbmdlciBvZiBjb2xsaXNpb25zLlxuICAgIGxldCBkYXRhYmFzZSA9IGRhdGFiYXNlSWQucHJvamVjdElkO1xuICAgIGlmICghZGF0YWJhc2VJZC5pc0RlZmF1bHREYXRhYmFzZSkge1xuICAgICAgICBkYXRhYmFzZSArPSAnLicgKyBkYXRhYmFzZUlkLmRhdGFiYXNlO1xuICAgIH1cbiAgICByZXR1cm4gJ2ZpcmVzdG9yZS8nICsgcGVyc2lzdGVuY2VLZXkgKyAnLycgKyBkYXRhYmFzZSArICcvJztcbn1cbmFzeW5jIGZ1bmN0aW9uIGluZGV4ZWREYkNsZWFyUGVyc2lzdGVuY2UocGVyc2lzdGVuY2VLZXkpIHtcbiAgICBpZiAoIVNpbXBsZURiLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBkYk5hbWUgPSBwZXJzaXN0ZW5jZUtleSArIE1BSU5fREFUQUJBU0U7XG4gICAgYXdhaXQgU2ltcGxlRGIuZGVsZXRlKGRiTmFtZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENvbXBhcmVzIHR3byBhcnJheSBmb3IgZXF1YWxpdHkgdXNpbmcgY29tcGFyYXRvci4gVGhlIG1ldGhvZCBjb21wdXRlcyB0aGVcbiAqIGludGVyc2VjdGlvbiBhbmQgaW52b2tlcyBgb25BZGRgIGZvciBldmVyeSBlbGVtZW50IHRoYXQgaXMgaW4gYGFmdGVyYCBidXQgbm90XG4gKiBgYmVmb3JlYC4gYG9uUmVtb3ZlYCBpcyBpbnZva2VkIGZvciBldmVyeSBlbGVtZW50IGluIGBiZWZvcmVgIGJ1dCBtaXNzaW5nXG4gKiBmcm9tIGBhZnRlcmAuXG4gKlxuICogVGhlIG1ldGhvZCBjcmVhdGVzIGEgY29weSBvZiBib3RoIGBiZWZvcmVgIGFuZCBgYWZ0ZXJgIGFuZCBydW5zIGluIE8obiBsb2dcbiAqIG4pLCB3aGVyZSBuIGlzIHRoZSBzaXplIG9mIHRoZSB0d28gbGlzdHMuXG4gKlxuICogQHBhcmFtIGJlZm9yZSAtIFRoZSBlbGVtZW50cyB0aGF0IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBhcnJheS5cbiAqIEBwYXJhbSBhZnRlciAtIFRoZSBlbGVtZW50cyB0byBkaWZmIGFnYWluc3QgdGhlIG9yaWdpbmFsIGFycmF5LlxuICogQHBhcmFtIGNvbXBhcmF0b3IgLSBUaGUgY29tcGFyYXRvciBmb3IgdGhlIGVsZW1lbnRzIGluIGJlZm9yZSBhbmQgYWZ0ZXIuXG4gKiBAcGFyYW0gb25BZGQgLSBBIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZXZlcnkgZWxlbWVudCB0aGF0IGlzIHBhcnQgb2YgYFxuICogYWZ0ZXJgIGJ1dCBub3QgYGJlZm9yZWAuXG4gKiBAcGFyYW0gb25SZW1vdmUgLSBBIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZXZlcnkgZWxlbWVudCB0aGF0IGlzIHBhcnQgb2ZcbiAqIGBiZWZvcmVgIGJ1dCBub3QgYGFmdGVyYC5cbiAqL1xuZnVuY3Rpb24gZGlmZkFycmF5cyhiZWZvcmUsIGFmdGVyLCBjb21wYXJhdG9yLCBvbkFkZCwgb25SZW1vdmUpIHtcbiAgICBiZWZvcmUgPSBbLi4uYmVmb3JlXTtcbiAgICBhZnRlciA9IFsuLi5hZnRlcl07XG4gICAgYmVmb3JlLnNvcnQoY29tcGFyYXRvcik7XG4gICAgYWZ0ZXIuc29ydChjb21wYXJhdG9yKTtcbiAgICBjb25zdCBiTGVuID0gYmVmb3JlLmxlbmd0aDtcbiAgICBjb25zdCBhTGVuID0gYWZ0ZXIubGVuZ3RoO1xuICAgIGxldCBhID0gMDtcbiAgICBsZXQgYiA9IDA7XG4gICAgd2hpbGUgKGEgPCBhTGVuICYmIGIgPCBiTGVuKSB7XG4gICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmF0b3IoYmVmb3JlW2JdLCBhZnRlclthXSk7XG4gICAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCB3YXMgcmVtb3ZlZCBpZiB0aGUgbmV4dCBlbGVtZW50IGluIG91ciBvcmRlcmVkXG4gICAgICAgICAgICAvLyB3YWxrdGhyb3VnaCBpcyBvbmx5IGluIGBiZWZvcmVgLlxuICAgICAgICAgICAgb25SZW1vdmUoYmVmb3JlW2IrK10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IHdhcyBhZGRlZCBpZiB0aGUgbmV4dCBlbGVtZW50IGluIG91ciBvcmRlcmVkIHdhbGt0aHJvdWdoXG4gICAgICAgICAgICAvLyBpcyBvbmx5IGluIGBhZnRlcmAuXG4gICAgICAgICAgICBvbkFkZChhZnRlclthKytdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGErKztcbiAgICAgICAgICAgIGIrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoYSA8IGFMZW4pIHtcbiAgICAgICAgb25BZGQoYWZ0ZXJbYSsrXSk7XG4gICAgfVxuICAgIHdoaWxlIChiIDwgYkxlbikge1xuICAgICAgICBvblJlbW92ZShiZWZvcmVbYisrXSk7XG4gICAgfVxufVxuLyoqXG4gKiBWZXJpZmllcyBlcXVhbGl0eSBmb3IgYW4gYXJyYXkgb2YgcHJpbWl0aXZlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGludGVybmFsXG4gKiBAcGFyYW0gbGVmdCBBcnJheSBvZiBwcmltaXRpdmVzLlxuICogQHBhcmFtIHJpZ2h0IEFycmF5IG9mIHByaW1pdGl2ZXMuXG4gKiBAcmV0dXJuIFRydWUgaWYgYXJyYXlzIGFyZSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmVBcnJheUVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQubGVuZ3RoICE9PSByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGxlZnRbaV0gIT09IHJpZ2h0W2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJGIgPSAnTG9jYWxTdG9yZSc7XG4vKipcbiAqIFRoZSBtYXhpbXVtIHRpbWUgdG8gbGVhdmUgYSByZXN1bWUgdG9rZW4gYnVmZmVyZWQgd2l0aG91dCB3cml0aW5nIGl0IG91dC5cbiAqIFRoaXMgdmFsdWUgaXMgYXJiaXRyYXJ5OiBpdCdzIGxvbmcgZW5vdWdoIHRvIGF2b2lkIHNldmVyYWwgd3JpdGVzXG4gKiAocG9zc2libHkgaW5kZWZpbml0ZWx5IGlmIHVwZGF0ZXMgY29tZSBtb3JlIGZyZXF1ZW50bHkgdGhhbiB0aGlzKSBidXRcbiAqIHNob3J0IGVub3VnaCB0aGF0IHJlc3RhcnRpbmcgYWZ0ZXIgY3Jhc2hpbmcgd2lsbCBzdGlsbCBoYXZlIGEgcHJldHR5XG4gKiByZWNlbnQgcmVzdW1lIHRva2VuLlxuICovXG5jb25zdCBSRVNVTUVfVE9LRU5fTUFYX0FHRV9NSUNST1MgPSA1ICogNjAgKiAxZTY7XG4vKipcbiAqIEltcGxlbWVudHMgYExvY2FsU3RvcmVgIGludGVyZmFjZS5cbiAqXG4gKiBOb3RlOiBzb21lIGZpZWxkIGRlZmluZWQgaW4gdGhpcyBjbGFzcyBtaWdodCBoYXZlIHB1YmxpYyBhY2Nlc3MgbGV2ZWwsIGJ1dFxuICogdGhlIGNsYXNzIGlzIG5vdCBleHBvcnRlZCBzbyB0aGV5IGFyZSBvbmx5IGFjY2Vzc2libGUgZnJvbSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgdXNlZnVsIHRvIGltcGxlbWVudCBvcHRpb25hbCBmZWF0dXJlcyAobGlrZSBidW5kbGVzKSBpbiBmcmVlXG4gKiBmdW5jdGlvbnMsIHN1Y2ggdGhhdCB0aGV5IGFyZSB0cmVlLXNoYWtlYWJsZS5cbiAqL1xuY2xhc3MgTG9jYWxTdG9yZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBNYW5hZ2VzIG91ciBpbi1tZW1vcnkgb3IgZHVyYWJsZSBwZXJzaXN0ZW5jZS4gKi9cbiAgICBwZXJzaXN0ZW5jZSwgcXVlcnlFbmdpbmUsIGluaXRpYWxVc2VyLCBzZXJpYWxpemVyKSB7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICAgICAgdGhpcy5xdWVyeUVuZ2luZSA9IHF1ZXJ5RW5naW5lO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwcyBhIHRhcmdldElEIHRvIGRhdGEgYWJvdXQgaXRzIHRhcmdldC5cbiAgICAgICAgICpcbiAgICAgICAgICogUE9SVElORyBOT1RFOiBXZSBhcmUgdXNpbmcgYW4gaW1tdXRhYmxlIGRhdGEgc3RydWN0dXJlIG9uIFdlYiB0byBtYWtlIHJlLXJ1bnNcbiAgICAgICAgICogb2YgYGFwcGx5UmVtb3RlRXZlbnQoKWAgaWRlbXBvdGVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFyZ2V0RGF0YUJ5VGFyZ2V0ID0gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICAgICAgLyoqIE1hcHMgYSB0YXJnZXQgdG8gaXRzIHRhcmdldElELiAqL1xuICAgICAgICAvLyBUT0RPKHd1YW5keSk6IEV2YWx1YXRlIGlmIFRhcmdldElkIGNhbiBiZSBwYXJ0IG9mIFRhcmdldC5cbiAgICAgICAgdGhpcy50YXJnZXRJZEJ5VGFyZ2V0ID0gbmV3IE9iamVjdE1hcCh0ID0+IGNhbm9uaWZ5VGFyZ2V0KHQpLCB0YXJnZXRFcXVhbHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBwZXIgY29sbGVjdGlvbiBncm91cCBpbmRleCBvZiB0aGUgbGFzdCByZWFkIHRpbWUgcHJvY2Vzc2VkIGJ5XG4gICAgICAgICAqIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgZm9yIG11bHRpLXRhYiBzeW5jaHJvbml6YXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25Hcm91cFJlYWRUaW1lID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50cyA9IHBlcnNpc3RlbmNlLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKTtcbiAgICAgICAgdGhpcy50YXJnZXRDYWNoZSA9IHBlcnNpc3RlbmNlLmdldFRhcmdldENhY2hlKCk7XG4gICAgICAgIHRoaXMuYnVuZGxlQ2FjaGUgPSBwZXJzaXN0ZW5jZS5nZXRCdW5kbGVDYWNoZSgpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVVc2VyQ29tcG9uZW50cyhpbml0aWFsVXNlcik7XG4gICAgfVxuICAgIGluaXRpYWxpemVVc2VyQ29tcG9uZW50cyh1c2VyKSB7XG4gICAgICAgIC8vIFRPRE8oaW5kZXhpbmcpOiBBZGQgc3BlYyB0ZXN0cyB0aGF0IHRlc3QgdGhlc2UgY29tcG9uZW50cyBjaGFuZ2UgYWZ0ZXIgYVxuICAgICAgICAvLyB1c2VyIGNoYW5nZVxuICAgICAgICB0aGlzLmRvY3VtZW50T3ZlcmxheUNhY2hlID0gdGhpcy5wZXJzaXN0ZW5jZS5nZXREb2N1bWVudE92ZXJsYXlDYWNoZSh1c2VyKTtcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSB0aGlzLnBlcnNpc3RlbmNlLmdldEluZGV4TWFuYWdlcih1c2VyKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvblF1ZXVlID0gdGhpcy5wZXJzaXN0ZW5jZS5nZXRNdXRhdGlvblF1ZXVlKHVzZXIsIHRoaXMuaW5kZXhNYW5hZ2VyKTtcbiAgICAgICAgdGhpcy5sb2NhbERvY3VtZW50cyA9IG5ldyBMb2NhbERvY3VtZW50c1ZpZXcodGhpcy5yZW1vdGVEb2N1bWVudHMsIHRoaXMubXV0YXRpb25RdWV1ZSwgdGhpcy5kb2N1bWVudE92ZXJsYXlDYWNoZSwgdGhpcy5pbmRleE1hbmFnZXIpO1xuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50cy5zZXRJbmRleE1hbmFnZXIodGhpcy5pbmRleE1hbmFnZXIpO1xuICAgICAgICB0aGlzLnF1ZXJ5RW5naW5lLmluaXRpYWxpemUodGhpcy5sb2NhbERvY3VtZW50cywgdGhpcy5pbmRleE1hbmFnZXIpO1xuICAgIH1cbiAgICBjb2xsZWN0R2FyYmFnZShnYXJiYWdlQ29sbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdDb2xsZWN0IGdhcmJhZ2UnLCAncmVhZHdyaXRlLXByaW1hcnknLCB0eG4gPT4gZ2FyYmFnZUNvbGxlY3Rvci5jb2xsZWN0KHR4biwgdGhpcy50YXJnZXREYXRhQnlUYXJnZXQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdMb2NhbFN0b3JlKFxuLyoqIE1hbmFnZXMgb3VyIGluLW1lbW9yeSBvciBkdXJhYmxlIHBlcnNpc3RlbmNlLiAqL1xucGVyc2lzdGVuY2UsIHF1ZXJ5RW5naW5lLCBpbml0aWFsVXNlciwgc2VyaWFsaXplcikge1xuICAgIHJldHVybiBuZXcgTG9jYWxTdG9yZUltcGwocGVyc2lzdGVuY2UsIHF1ZXJ5RW5naW5lLCBpbml0aWFsVXNlciwgc2VyaWFsaXplcik7XG59XG4vKipcbiAqIFRlbGxzIHRoZSBMb2NhbFN0b3JlIHRoYXQgdGhlIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHVzZXIgaGFzIGNoYW5nZWQuXG4gKlxuICogSW4gcmVzcG9uc2UgdGhlIGxvY2FsIHN0b3JlIHN3aXRjaGVzIHRoZSBtdXRhdGlvbiBxdWV1ZSB0byB0aGUgbmV3IHVzZXIgYW5kXG4gKiByZXR1cm5zIGFueSByZXN1bHRpbmcgZG9jdW1lbnQgY2hhbmdlcy5cbiAqL1xuLy8gUE9SVElORyBOT1RFOiBBbmRyb2lkIGFuZCBpT1Mgb25seSByZXR1cm4gdGhlIGRvY3VtZW50cyBhZmZlY3RlZCBieSB0aGVcbi8vIGNoYW5nZS5cbmFzeW5jIGZ1bmN0aW9uIGxvY2FsU3RvcmVIYW5kbGVVc2VyQ2hhbmdlKGxvY2FsU3RvcmUsIHVzZXIpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignSGFuZGxlIHVzZXIgY2hhbmdlJywgJ3JlYWRvbmx5JywgdHhuID0+IHtcbiAgICAgICAgLy8gU3dhcCBvdXQgdGhlIG11dGF0aW9uIHF1ZXVlLCBncmFiYmluZyB0aGUgcGVuZGluZyBtdXRhdGlvbiBiYXRjaGVzXG4gICAgICAgIC8vIGJlZm9yZSBhbmQgYWZ0ZXIuXG4gICAgICAgIGxldCBvbGRCYXRjaGVzO1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZVxuICAgICAgICAgICAgLmdldEFsbE11dGF0aW9uQmF0Y2hlcyh0eG4pXG4gICAgICAgICAgICAubmV4dChwcm9taXNlZE9sZEJhdGNoZXMgPT4ge1xuICAgICAgICAgICAgb2xkQmF0Y2hlcyA9IHByb21pc2VkT2xkQmF0Y2hlcztcbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLmluaXRpYWxpemVVc2VyQ29tcG9uZW50cyh1c2VyKTtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLmdldEFsbE11dGF0aW9uQmF0Y2hlcyh0eG4pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQobmV3QmF0Y2hlcyA9PiB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkQmF0Y2hJZHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkQmF0Y2hJZHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFVuaW9uIHRoZSBvbGQvbmV3IGNoYW5nZWQga2V5cy5cbiAgICAgICAgICAgIGxldCBjaGFuZ2VkS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIG9sZEJhdGNoZXMpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkQmF0Y2hJZHMucHVzaChiYXRjaC5iYXRjaElkKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIGJhdGNoLm11dGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkS2V5cyA9IGNoYW5nZWRLZXlzLmFkZChtdXRhdGlvbi5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgYmF0Y2ggb2YgbmV3QmF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGFkZGVkQmF0Y2hJZHMucHVzaChiYXRjaC5iYXRjaElkKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIGJhdGNoLm11dGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkS2V5cyA9IGNoYW5nZWRLZXlzLmFkZChtdXRhdGlvbi5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgc2V0IG9mIGFsbCAocG90ZW50aWFsbHkpIGNoYW5nZWQgZG9jdW1lbnRzIGFuZCB0aGUgbGlzdFxuICAgICAgICAgICAgLy8gb2YgbXV0YXRpb24gYmF0Y2ggSURzIHRoYXQgd2VyZSBhZmZlY3RlZCBieSBjaGFuZ2UuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHNcbiAgICAgICAgICAgICAgICAuZ2V0RG9jdW1lbnRzKHR4biwgY2hhbmdlZEtleXMpXG4gICAgICAgICAgICAgICAgLm5leHQoYWZmZWN0ZWREb2N1bWVudHMgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRG9jdW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkQmF0Y2hJZHMsXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkQmF0Y2hJZHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiBBY2NlcHRzIGxvY2FsbHkgZ2VuZXJhdGVkIE11dGF0aW9ucyBhbmQgY29tbWl0IHRoZW0gdG8gc3RvcmFnZS4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVXcml0ZUxvY2FsbHkobG9jYWxTdG9yZSwgbXV0YXRpb25zKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgbG9jYWxXcml0ZVRpbWUgPSBUaW1lc3RhbXAubm93KCk7XG4gICAgY29uc3Qga2V5cyA9IG11dGF0aW9ucy5yZWR1Y2UoKGtleXMsIG0pID0+IGtleXMuYWRkKG0ua2V5KSwgZG9jdW1lbnRLZXlTZXQoKSk7XG4gICAgbGV0IG92ZXJsYXllZERvY3VtZW50cztcbiAgICBsZXQgbXV0YXRpb25CYXRjaDtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2VcbiAgICAgICAgLnJ1blRyYW5zYWN0aW9uKCdMb2NhbGx5IHdyaXRlIG11dGF0aW9ucycsICdyZWFkd3JpdGUnLCB0eG4gPT4ge1xuICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIGtleXMgZG8gbm90IGhhdmUgYSByZW1vdGUgdmVyc2lvbiBpbiB0aGUgY2FjaGUsIHRoaXNcbiAgICAgICAgLy8gaXMgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgcmlnaHQgb3ZlcmxheSBtdXRhdGlvbjogaWYgbm8gcmVtb3RlIHZlcnNpb25cbiAgICAgICAgLy8gcHJlc2VudHMsIHdlIGRvIG5vdCBuZWVkIHRvIGNyZWF0ZSBvdmVybGF5cyBhcyBwYXRjaCBtdXRhdGlvbnMuXG4gICAgICAgIC8vIFRPRE8oT3ZlcmxheSk6IElzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBkZXRlcm1pbmUgdGhpcz8gVXNpbmcgdGhlXG4gICAgICAgIC8vICBkb2N1bWVudCB2ZXJzaW9uIGRvZXMgbm90IHdvcmsgYmVjYXVzZSBsb2NhbCBtdXRhdGlvbnMgc2V0IHRoZW0gYmFja1xuICAgICAgICAvLyAgdG8gMC5cbiAgICAgICAgbGV0IHJlbW90ZURvY3MgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgbGV0IGRvY3NXaXRob3V0UmVtb3RlVmVyc2lvbiA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5yZW1vdGVEb2N1bWVudHNcbiAgICAgICAgICAgIC5nZXRFbnRyaWVzKHR4biwga2V5cylcbiAgICAgICAgICAgIC5uZXh0KGRvY3MgPT4ge1xuICAgICAgICAgICAgcmVtb3RlRG9jcyA9IGRvY3M7XG4gICAgICAgICAgICByZW1vdGVEb2NzLmZvckVhY2goKGtleSwgZG9jKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFkb2MuaXNWYWxpZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jc1dpdGhvdXRSZW1vdGVWZXJzaW9uID0gZG9jc1dpdGhvdXRSZW1vdGVWZXJzaW9uLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gTG9hZCBhbmQgYXBwbHkgYWxsIGV4aXN0aW5nIG11dGF0aW9ucy4gVGhpcyBsZXRzIHVzIGNvbXB1dGUgdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IGJhc2Ugc3RhdGUgZm9yIGFsbCBub24taWRlbXBvdGVudCB0cmFuc2Zvcm1zIGJlZm9yZSBhcHBseWluZ1xuICAgICAgICAgICAgLy8gYW55IGFkZGl0aW9uYWwgdXNlci1wcm92aWRlZCB3cml0ZXMuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0T3ZlcmxheWVkRG9jdW1lbnRzKHR4biwgcmVtb3RlRG9jcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoZG9jcykgPT4ge1xuICAgICAgICAgICAgb3ZlcmxheWVkRG9jdW1lbnRzID0gZG9jcztcbiAgICAgICAgICAgIC8vIEZvciBub24taWRlbXBvdGVudCBtdXRhdGlvbnMgKHN1Y2ggYXMgYEZpZWxkVmFsdWUuaW5jcmVtZW50KClgKSxcbiAgICAgICAgICAgIC8vIHdlIHJlY29yZCB0aGUgYmFzZSBzdGF0ZSBpbiBhIHNlcGFyYXRlIHBhdGNoIG11dGF0aW9uLiBUaGlzIGlzXG4gICAgICAgICAgICAvLyBsYXRlciB1c2VkIHRvIGd1YXJhbnRlZSBjb25zaXN0ZW50IHZhbHVlcyBhbmQgcHJldmVudHMgZmxpY2tlclxuICAgICAgICAgICAgLy8gZXZlbiBpZiB0aGUgYmFja2VuZCBzZW5kcyB1cyBhbiB1cGRhdGUgdGhhdCBhbHJlYWR5IGluY2x1ZGVzIG91clxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtLlxuICAgICAgICAgICAgY29uc3QgYmFzZU11dGF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlVmFsdWUgPSBtdXRhdGlvbkV4dHJhY3RCYXNlVmFsdWUobXV0YXRpb24sIG92ZXJsYXllZERvY3VtZW50cy5nZXQobXV0YXRpb24ua2V5KS5vdmVybGF5ZWREb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFRoZSBiYXNlIHN0YXRlIHNob3VsZCBvbmx5IGJlIGFwcGxpZWQgaWYgdGhlcmUncyBzb21lXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4aXN0aW5nIGRvY3VtZW50IHRvIG92ZXJyaWRlLCBzbyB1c2UgYSBQcmVjb25kaXRpb24gb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhpc3RzPXRydWVcbiAgICAgICAgICAgICAgICAgICAgYmFzZU11dGF0aW9ucy5wdXNoKG5ldyBQYXRjaE11dGF0aW9uKG11dGF0aW9uLmtleSwgYmFzZVZhbHVlLCBleHRyYWN0RmllbGRNYXNrKGJhc2VWYWx1ZS52YWx1ZS5tYXBWYWx1ZSksIFByZWNvbmRpdGlvbi5leGlzdHModHJ1ZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZS5hZGRNdXRhdGlvbkJhdGNoKHR4biwgbG9jYWxXcml0ZVRpbWUsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChiYXRjaCA9PiB7XG4gICAgICAgICAgICBtdXRhdGlvbkJhdGNoID0gYmF0Y2g7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5cyA9IGJhdGNoLmFwcGx5VG9Mb2NhbERvY3VtZW50U2V0KG92ZXJsYXllZERvY3VtZW50cywgZG9jc1dpdGhvdXRSZW1vdGVWZXJzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5kb2N1bWVudE92ZXJsYXlDYWNoZS5zYXZlT3ZlcmxheXModHhuLCBiYXRjaC5iYXRjaElkLCBvdmVybGF5cyk7XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgICAgIC50aGVuKCgpID0+ICh7XG4gICAgICAgIGJhdGNoSWQ6IG11dGF0aW9uQmF0Y2guYmF0Y2hJZCxcbiAgICAgICAgY2hhbmdlczogY29udmVydE92ZXJsYXllZERvY3VtZW50TWFwVG9Eb2N1bWVudE1hcChvdmVybGF5ZWREb2N1bWVudHMpXG4gICAgfSkpO1xufVxuLyoqXG4gKiBBY2tub3dsZWRnZXMgdGhlIGdpdmVuIGJhdGNoLlxuICpcbiAqIE9uIHRoZSBoYXBweSBwYXRoIHdoZW4gYSBiYXRjaCBpcyBhY2tub3dsZWRnZWQsIHRoZSBsb2NhbCBzdG9yZSB3aWxsXG4gKlxuICogICsgcmVtb3ZlIHRoZSBiYXRjaCBmcm9tIHRoZSBtdXRhdGlvbiBxdWV1ZTtcbiAqICArIGFwcGx5IHRoZSBjaGFuZ2VzIHRvIHRoZSByZW1vdGUgZG9jdW1lbnQgY2FjaGU7XG4gKiAgKyByZWNhbGN1bGF0ZSB0aGUgbGF0ZW5jeSBjb21wZW5zYXRlZCB2aWV3IGltcGxpZWQgYnkgdGhvc2UgY2hhbmdlcyAodGhlcmVcbiAqICAgIG1heSBiZSBtdXRhdGlvbnMgaW4gdGhlIHF1ZXVlIHRoYXQgYWZmZWN0IHRoZSBkb2N1bWVudHMgYnV0IGhhdmVuJ3QgYmVlblxuICogICAgYWNrbm93bGVkZ2VkIHlldCk7IGFuZFxuICogICsgZ2l2ZSB0aGUgY2hhbmdlZCBkb2N1bWVudHMgYmFjayB0aGUgc3luYyBlbmdpbmVcbiAqXG4gKiBAcmV0dXJucyBUaGUgcmVzdWx0aW5nIChtb2RpZmllZCkgZG9jdW1lbnRzLlxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlQWNrbm93bGVkZ2VCYXRjaChsb2NhbFN0b3JlLCBiYXRjaFJlc3VsdCkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignQWNrbm93bGVkZ2UgYmF0Y2gnLCAncmVhZHdyaXRlLXByaW1hcnknLCB0eG4gPT4ge1xuICAgICAgICBjb25zdCBhZmZlY3RlZCA9IGJhdGNoUmVzdWx0LmJhdGNoLmtleXMoKTtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRCdWZmZXIgPSBsb2NhbFN0b3JlSW1wbC5yZW1vdGVEb2N1bWVudHMubmV3Q2hhbmdlQnVmZmVyKHtcbiAgICAgICAgICAgIHRyYWNrUmVtb3ZhbHM6IHRydWUgLy8gTWFrZSBzdXJlIGRvY3VtZW50IHJlbW92YWxzIHNob3cgdXAgaW4gYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFwcGx5V3JpdGVUb1JlbW90ZURvY3VtZW50cyhsb2NhbFN0b3JlSW1wbCwgdHhuLCBiYXRjaFJlc3VsdCwgZG9jdW1lbnRCdWZmZXIpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBkb2N1bWVudEJ1ZmZlci5hcHBseSh0eG4pKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZS5wZXJmb3JtQ29uc2lzdGVuY3lDaGVjayh0eG4pKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwuZG9jdW1lbnRPdmVybGF5Q2FjaGUucmVtb3ZlT3ZlcmxheXNGb3JCYXRjaElkKHR4biwgYWZmZWN0ZWQsIGJhdGNoUmVzdWx0LmJhdGNoLmJhdGNoSWQpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXNGb3JEb2N1bWVudEtleXModHhuLCBnZXRLZXlzV2l0aFRyYW5zZm9ybVJlc3VsdHMoYmF0Y2hSZXN1bHQpKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLmxvY2FsRG9jdW1lbnRzLmdldERvY3VtZW50cyh0eG4sIGFmZmVjdGVkKSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRLZXlzV2l0aFRyYW5zZm9ybVJlc3VsdHMoYmF0Y2hSZXN1bHQpIHtcbiAgICBsZXQgcmVzdWx0ID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoUmVzdWx0Lm11dGF0aW9uUmVzdWx0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBtdXRhdGlvblJlc3VsdCA9IGJhdGNoUmVzdWx0Lm11dGF0aW9uUmVzdWx0c1tpXTtcbiAgICAgICAgaWYgKG11dGF0aW9uUmVzdWx0LnRyYW5zZm9ybVJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChiYXRjaFJlc3VsdC5iYXRjaC5tdXRhdGlvbnNbaV0ua2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBSZW1vdmVzIG11dGF0aW9ucyBmcm9tIHRoZSBNdXRhdGlvblF1ZXVlIGZvciB0aGUgc3BlY2lmaWVkIGJhdGNoO1xuICogTG9jYWxEb2N1bWVudHMgd2lsbCBiZSByZWNhbGN1bGF0ZWQuXG4gKlxuICogQHJldHVybnMgVGhlIHJlc3VsdGluZyBtb2RpZmllZCBkb2N1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVSZWplY3RCYXRjaChsb2NhbFN0b3JlLCBiYXRjaElkKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdSZWplY3QgYmF0Y2gnLCAncmVhZHdyaXRlLXByaW1hcnknLCB0eG4gPT4ge1xuICAgICAgICBsZXQgYWZmZWN0ZWRLZXlzO1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZVxuICAgICAgICAgICAgLmxvb2t1cE11dGF0aW9uQmF0Y2godHhuLCBiYXRjaElkKVxuICAgICAgICAgICAgLm5leHQoKGJhdGNoKSA9PiB7XG4gICAgICAgICAgICBoYXJkQXNzZXJ0KGJhdGNoICE9PSBudWxsKTtcbiAgICAgICAgICAgIGFmZmVjdGVkS2V5cyA9IGJhdGNoLmtleXMoKTtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLnJlbW92ZU11dGF0aW9uQmF0Y2godHhuLCBiYXRjaCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLnBlcmZvcm1Db25zaXN0ZW5jeUNoZWNrKHR4bikpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5kb2N1bWVudE92ZXJsYXlDYWNoZS5yZW1vdmVPdmVybGF5c0ZvckJhdGNoSWQodHhuLCBhZmZlY3RlZEtleXMsIGJhdGNoSWQpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMucmVjYWxjdWxhdGVBbmRTYXZlT3ZlcmxheXNGb3JEb2N1bWVudEtleXModHhuLCBhZmZlY3RlZEtleXMpKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0RG9jdW1lbnRzKHR4biwgYWZmZWN0ZWRLZXlzKSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGxhcmdlc3QgKGxhdGVzdCkgYmF0Y2ggaWQgaW4gbXV0YXRpb24gcXVldWUgdGhhdCBpcyBwZW5kaW5nXG4gKiBzZXJ2ZXIgcmVzcG9uc2UuXG4gKlxuICogUmV0dXJucyBgQkFUQ0hJRF9VTktOT1dOYCBpZiB0aGUgcXVldWUgaXMgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXRIaWdoZXN0VW5hY2tub3dsZWRnZWRCYXRjaElkKGxvY2FsU3RvcmUpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCBoaWdoZXN0IHVuYWNrbm93bGVkZ2VkIGJhdGNoIGlkJywgJ3JlYWRvbmx5JywgdHhuID0+IGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUuZ2V0SGlnaGVzdFVuYWNrbm93bGVkZ2VkQmF0Y2hJZCh0eG4pKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBjb25zaXN0ZW50IHNuYXBzaG90IHByb2Nlc3NlZCAodXNlZCBieSB0aGUgUmVtb3RlU3RvcmUgdG9cbiAqIGRldGVybWluZSB3aGV0aGVyIHRvIGJ1ZmZlciBpbmNvbWluZyBzbmFwc2hvdHMgZnJvbSB0aGUgYmFja2VuZCkuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKGxvY2FsU3RvcmUpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCBsYXN0IHJlbW90ZSBzbmFwc2hvdCB2ZXJzaW9uJywgJ3JlYWRvbmx5JywgdHhuID0+IGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlLmdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24odHhuKSk7XG59XG4vKipcbiAqIFVwZGF0ZXMgdGhlIFwiZ3JvdW5kLXN0YXRlXCIgKHJlbW90ZSkgZG9jdW1lbnRzLiBXZSBhc3N1bWUgdGhhdCB0aGUgcmVtb3RlXG4gKiBldmVudCByZWZsZWN0cyBhbnkgd3JpdGUgYmF0Y2hlcyB0aGF0IGhhdmUgYmVlbiBhY2tub3dsZWRnZWQgb3IgcmVqZWN0ZWRcbiAqIChpLmUuIHdlIGRvIG5vdCByZS1hcHBseSBsb2NhbCBtdXRhdGlvbnMgdG8gdXBkYXRlcyBmcm9tIHRoaXMgZXZlbnQpLlxuICpcbiAqIExvY2FsRG9jdW1lbnRzIGFyZSByZS1jYWxjdWxhdGVkIGlmIHRoZXJlIGFyZSByZW1haW5pbmcgbXV0YXRpb25zIGluIHRoZVxuICogcXVldWUuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVBcHBseVJlbW90ZUV2ZW50VG9Mb2NhbENhY2hlKGxvY2FsU3RvcmUsIHJlbW90ZUV2ZW50KSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgcmVtb3RlVmVyc2lvbiA9IHJlbW90ZUV2ZW50LnNuYXBzaG90VmVyc2lvbjtcbiAgICBsZXQgbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0O1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZVxuICAgICAgICAucnVuVHJhbnNhY3Rpb24oJ0FwcGx5IHJlbW90ZSBldmVudCcsICdyZWFkd3JpdGUtcHJpbWFyeScsIHR4biA9PiB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50QnVmZmVyID0gbG9jYWxTdG9yZUltcGwucmVtb3RlRG9jdW1lbnRzLm5ld0NoYW5nZUJ1ZmZlcih7XG4gICAgICAgICAgICB0cmFja1JlbW92YWxzOiB0cnVlIC8vIE1ha2Ugc3VyZSBkb2N1bWVudCByZW1vdmFscyBzaG93IHVwIGluIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlc2V0IG5ld1RhcmdldERhdGFCeVRhcmdldE1hcCBpbiBjYXNlIHRoaXMgdHJhbnNhY3Rpb24gZ2V0cyByZS1ydW4uXG4gICAgICAgIG5ld1RhcmdldERhdGFCeVRhcmdldE1hcCA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldDtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgcmVtb3RlRXZlbnQudGFyZ2V0Q2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UsIHRhcmdldElkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRUYXJnZXREYXRhID0gbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwLmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICBpZiAoIW9sZFRhcmdldERhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgcmVtb3RlIGtleXMgaWYgdGhlIHRhcmdldCBpcyBzdGlsbCBhY3RpdmUuIFRoaXNcbiAgICAgICAgICAgIC8vIGVuc3VyZXMgdGhhdCB3ZSBjYW4gcGVyc2lzdCB0aGUgdXBkYXRlZCB0YXJnZXQgZGF0YSBhbG9uZyB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgdXBkYXRlZCBhc3NpZ25tZW50LlxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxuICAgICAgICAgICAgICAgIC5yZW1vdmVNYXRjaGluZ0tleXModHhuLCBjaGFuZ2UucmVtb3ZlZERvY3VtZW50cywgdGFyZ2V0SWQpXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5hZGRNYXRjaGluZ0tleXModHhuLCBjaGFuZ2UuYWRkZWREb2N1bWVudHMsIHRhcmdldElkKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGxldCBuZXdUYXJnZXREYXRhID0gb2xkVGFyZ2V0RGF0YS53aXRoU2VxdWVuY2VOdW1iZXIodHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlcik7XG4gICAgICAgICAgICBpZiAocmVtb3RlRXZlbnQudGFyZ2V0TWlzbWF0Y2hlcy5nZXQodGFyZ2V0SWQpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3VGFyZ2V0RGF0YSA9IG5ld1RhcmdldERhdGFcbiAgICAgICAgICAgICAgICAgICAgLndpdGhSZXN1bWVUb2tlbihCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HLCBTbmFwc2hvdFZlcnNpb24ubWluKCkpXG4gICAgICAgICAgICAgICAgICAgIC53aXRoTGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbihTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnJlc3VtZVRva2VuLmFwcHJveGltYXRlQnl0ZVNpemUoKSA+IDApIHtcbiAgICAgICAgICAgICAgICBuZXdUYXJnZXREYXRhID0gbmV3VGFyZ2V0RGF0YS53aXRoUmVzdW1lVG9rZW4oY2hhbmdlLnJlc3VtZVRva2VuLCByZW1vdGVWZXJzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1RhcmdldERhdGFCeVRhcmdldE1hcCA9IG5ld1RhcmdldERhdGFCeVRhcmdldE1hcC5pbnNlcnQodGFyZ2V0SWQsIG5ld1RhcmdldERhdGEpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0YXJnZXQgZGF0YSBpZiB0aGVyZSBhcmUgdGFyZ2V0IGNoYW5nZXMgKG9yIGlmXG4gICAgICAgICAgICAvLyBzdWZmaWNpZW50IHRpbWUgaGFzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGUpLlxuICAgICAgICAgICAgaWYgKHNob3VsZFBlcnNpc3RUYXJnZXREYXRhKG9sZFRhcmdldERhdGEsIG5ld1RhcmdldERhdGEsIGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlLnVwZGF0ZVRhcmdldERhdGEodHhuLCBuZXdUYXJnZXREYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgY2hhbmdlZERvY3MgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICAgICAgbGV0IGV4aXN0ZW5jZUNoYW5nZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgcmVtb3RlRXZlbnQuZG9jdW1lbnRVcGRhdGVzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChyZW1vdGVFdmVudC5yZXNvbHZlZExpbWJvRG9jdW1lbnRzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZS51cGRhdGVMaW1ib0RvY3VtZW50KHR4biwga2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBFYWNoIGxvb3AgaXRlcmF0aW9uIG9ubHkgYWZmZWN0cyBpdHMgXCJvd25cIiBkb2MsIHNvIGl0J3Mgc2FmZSB0byBnZXQgYWxsXG4gICAgICAgIC8vIHRoZSByZW1vdGUgZG9jdW1lbnRzIGluIGFkdmFuY2UgaW4gYSBzaW5nbGUgY2FsbC5cbiAgICAgICAgcHJvbWlzZXMucHVzaChwb3B1bGF0ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHR4biwgZG9jdW1lbnRCdWZmZXIsIHJlbW90ZUV2ZW50LmRvY3VtZW50VXBkYXRlcykubmV4dChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgY2hhbmdlZERvY3MgPSByZXN1bHQuY2hhbmdlZERvY3VtZW50cztcbiAgICAgICAgICAgIGV4aXN0ZW5jZUNoYW5nZWRLZXlzID0gcmVzdWx0LmV4aXN0ZW5jZUNoYW5nZWRLZXlzO1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIEhBQ0s6IFRoZSBvbmx5IHJlYXNvbiB3ZSBhbGxvdyBhIG51bGwgc25hcHNob3QgdmVyc2lvbiBpcyBzbyB0aGF0IHdlXG4gICAgICAgIC8vIGNhbiBzeW50aGVzaXplIHJlbW90ZSBldmVudHMgd2hlbiB3ZSBnZXQgcGVybWlzc2lvbiBkZW5pZWQgZXJyb3JzIHdoaWxlXG4gICAgICAgIC8vIHRyeWluZyB0byByZXNvbHZlIHRoZSBzdGF0ZSBvZiBhIGxvY2FsbHkgY2FjaGVkIGRvY3VtZW50IHRoYXQgaXMgaW5cbiAgICAgICAgLy8gbGltYm8uXG4gICAgICAgIGlmICghcmVtb3RlVmVyc2lvbi5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVJlbW90ZVZlcnNpb24gPSBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxuICAgICAgICAgICAgICAgIC5nZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKHR4bilcbiAgICAgICAgICAgICAgICAubmV4dChsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuc2V0VGFyZ2V0c01ldGFkYXRhKHR4biwgdHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlciwgcmVtb3RlVmVyc2lvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godXBkYXRlUmVtb3RlVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jdW1lbnRCdWZmZXIuYXBwbHkodHhuKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLmxvY2FsRG9jdW1lbnRzLmdldExvY2FsVmlld09mRG9jdW1lbnRzKHR4biwgY2hhbmdlZERvY3MsIGV4aXN0ZW5jZUNoYW5nZWRLZXlzKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNoYW5nZWREb2NzKTtcbiAgICB9KVxuICAgICAgICAudGhlbihjaGFuZ2VkRG9jcyA9PiB7XG4gICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9IG5ld1RhcmdldERhdGFCeVRhcmdldE1hcDtcbiAgICAgICAgcmV0dXJuIGNoYW5nZWREb2NzO1xuICAgIH0pO1xufVxuLyoqXG4gKiBQb3B1bGF0ZXMgZG9jdW1lbnQgY2hhbmdlIGJ1ZmZlciB3aXRoIGRvY3VtZW50cyBmcm9tIGJhY2tlbmQgb3IgYSBidW5kbGUuXG4gKiBSZXR1cm5zIHRoZSBkb2N1bWVudCBjaGFuZ2VzIHJlc3VsdGluZyBmcm9tIGFwcGx5aW5nIHRob3NlIGRvY3VtZW50cywgYW5kXG4gKiBhbHNvIGEgc2V0IG9mIGRvY3VtZW50cyB3aG9zZSBleGlzdGVuY2Ugc3RhdGUgYXJlIGNoYW5nZWQgYXMgYSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHR4biAtIFRyYW5zYWN0aW9uIHRvIHVzZSB0byByZWFkIGV4aXN0aW5nIGRvY3VtZW50cyBmcm9tIHN0b3JhZ2UuXG4gKiBAcGFyYW0gZG9jdW1lbnRCdWZmZXIgLSBEb2N1bWVudCBidWZmZXIgdG8gY29sbGVjdCB0aGUgcmVzdWx0ZWQgY2hhbmdlcyB0byBiZVxuICogICAgICAgIGFwcGxpZWQgdG8gc3RvcmFnZS5cbiAqIEBwYXJhbSBkb2N1bWVudHMgLSBEb2N1bWVudHMgdG8gYmUgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gcG9wdWxhdGVEb2N1bWVudENoYW5nZUJ1ZmZlcih0eG4sIGRvY3VtZW50QnVmZmVyLCBkb2N1bWVudHMpIHtcbiAgICBsZXQgdXBkYXRlZEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgIGxldCBleGlzdGVuY2VDaGFuZ2VkS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgZG9jdW1lbnRzLmZvckVhY2goayA9PiAodXBkYXRlZEtleXMgPSB1cGRhdGVkS2V5cy5hZGQoaykpKTtcbiAgICByZXR1cm4gZG9jdW1lbnRCdWZmZXIuZ2V0RW50cmllcyh0eG4sIHVwZGF0ZWRLZXlzKS5uZXh0KGV4aXN0aW5nRG9jcyA9PiB7XG4gICAgICAgIGxldCBjaGFuZ2VkRG9jdW1lbnRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XG4gICAgICAgIGRvY3VtZW50cy5mb3JFYWNoKChrZXksIGRvYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdEb2MgPSBleGlzdGluZ0RvY3MuZ2V0KGtleSk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBzZWUgaWYgdGhlcmUgaXMgYSBleGlzdGVuY2Ugc3RhdGUgY2hhbmdlIGZvciB0aGlzIGRvY3VtZW50LlxuICAgICAgICAgICAgaWYgKGRvYy5pc0ZvdW5kRG9jdW1lbnQoKSAhPT0gZXhpc3RpbmdEb2MuaXNGb3VuZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgICAgICBleGlzdGVuY2VDaGFuZ2VkS2V5cyA9IGV4aXN0ZW5jZUNoYW5nZWRLZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm90ZTogVGhlIG9yZGVyIG9mIHRoZSBzdGVwcyBiZWxvdyBpcyBpbXBvcnRhbnQsIHNpbmNlIHdlIHdhbnRcbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSB0aGF0IHJlamVjdGVkIGxpbWJvIHJlc29sdXRpb25zICh3aGljaCBmYWJyaWNhdGVcbiAgICAgICAgICAgIC8vIE5vRG9jdW1lbnRzIHdpdGggU25hcHNob3RWZXJzaW9uLm1pbigpKSBuZXZlciBhZGQgZG9jdW1lbnRzIHRvXG4gICAgICAgICAgICAvLyBjYWNoZS5cbiAgICAgICAgICAgIGlmIChkb2MuaXNOb0RvY3VtZW50KCkgJiYgZG9jLnZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XG4gICAgICAgICAgICAgICAgLy8gTm9Eb2N1bWVudHMgd2l0aCBTbmFwc2hvdFZlcnNpb24ubWluKCkgYXJlIHVzZWQgaW4gbWFudWZhY3R1cmVkXG4gICAgICAgICAgICAgICAgLy8gZXZlbnRzLiBXZSByZW1vdmUgdGhlc2UgZG9jdW1lbnRzIGZyb20gY2FjaGUgc2luY2Ugd2UgbG9zdFxuICAgICAgICAgICAgICAgIC8vIGFjY2Vzcy5cbiAgICAgICAgICAgICAgICBkb2N1bWVudEJ1ZmZlci5yZW1vdmVFbnRyeShrZXksIGRvYy5yZWFkVGltZSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZERvY3VtZW50cyA9IGNoYW5nZWREb2N1bWVudHMuaW5zZXJ0KGtleSwgZG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFleGlzdGluZ0RvYy5pc1ZhbGlkRG9jdW1lbnQoKSB8fFxuICAgICAgICAgICAgICAgIGRvYy52ZXJzaW9uLmNvbXBhcmVUbyhleGlzdGluZ0RvYy52ZXJzaW9uKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAoZG9jLnZlcnNpb24uY29tcGFyZVRvKGV4aXN0aW5nRG9jLnZlcnNpb24pID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nRG9jLmhhc1BlbmRpbmdXcml0ZXMpKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRCdWZmZXIuYWRkRW50cnkoZG9jKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkRG9jdW1lbnRzID0gY2hhbmdlZERvY3VtZW50cy5pbnNlcnQoa2V5LCBkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRiLCAnSWdub3Jpbmcgb3V0ZGF0ZWQgd2F0Y2ggdXBkYXRlIGZvciAnLCBrZXksICcuIEN1cnJlbnQgdmVyc2lvbjonLCBleGlzdGluZ0RvYy52ZXJzaW9uLCAnIFdhdGNoIHZlcnNpb246JywgZG9jLnZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlZERvY3VtZW50cywgZXhpc3RlbmNlQ2hhbmdlZEtleXMgfTtcbiAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBuZXdUYXJnZXREYXRhIHNob3VsZCBiZSBwZXJzaXN0ZWQgZHVyaW5nIGFuIHVwZGF0ZSBvZlxuICogYW4gYWN0aXZlIHRhcmdldC4gVGFyZ2V0RGF0YSBzaG91bGQgYWx3YXlzIGJlIHBlcnNpc3RlZCB3aGVuIGEgdGFyZ2V0IGlzXG4gKiBiZWluZyByZWxlYXNlZCBhbmQgc2hvdWxkIG5vdCBjYWxsIHRoaXMgZnVuY3Rpb24uXG4gKlxuICogV2hpbGUgdGhlIHRhcmdldCBpcyBhY3RpdmUsIFRhcmdldERhdGEgdXBkYXRlcyBjYW4gYmUgb21pdHRlZCB3aGVuIG5vdGhpbmdcbiAqIGFib3V0IHRoZSB0YXJnZXQgaGFzIGNoYW5nZWQgZXhjZXB0IG1ldGFkYXRhIGxpa2UgdGhlIHJlc3VtZSB0b2tlbiBvclxuICogc25hcHNob3QgdmVyc2lvbi4gT2NjYXNpb25hbGx5IGl0J3Mgd29ydGggdGhlIGV4dHJhIHdyaXRlIHRvIHByZXZlbnQgdGhlc2VcbiAqIHZhbHVlcyBmcm9tIGdldHRpbmcgdG9vIHN0YWxlIGFmdGVyIGEgY3Jhc2gsIGJ1dCB0aGlzIGRvZXNuJ3QgaGF2ZSB0byBiZVxuICogdG9vIGZyZXF1ZW50LlxuICovXG5mdW5jdGlvbiBzaG91bGRQZXJzaXN0VGFyZ2V0RGF0YShvbGRUYXJnZXREYXRhLCBuZXdUYXJnZXREYXRhLCBjaGFuZ2UpIHtcbiAgICAvLyBBbHdheXMgcGVyc2lzdCB0YXJnZXQgZGF0YSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYSByZXN1bWUgdG9rZW4uXG4gICAgaWYgKG9sZFRhcmdldERhdGEucmVzdW1lVG9rZW4uYXBwcm94aW1hdGVCeXRlU2l6ZSgpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBEb24ndCBhbGxvdyByZXN1bWUgdG9rZW4gY2hhbmdlcyB0byBiZSBidWZmZXJlZCBpbmRlZmluaXRlbHkuIFRoaXNcbiAgICAvLyBhbGxvd3MgdXMgdG8gYmUgcmVhc29uYWJseSB1cC10by1kYXRlIGFmdGVyIGEgY3Jhc2ggYW5kIGF2b2lkcyBuZWVkaW5nXG4gICAgLy8gdG8gbG9vcCBvdmVyIGFsbCBhY3RpdmUgcXVlcmllcyBvbiBzaHV0ZG93bi4gRXNwZWNpYWxseSBpbiB0aGUgYnJvd3NlclxuICAgIC8vIHdlIG1heSBub3QgZ2V0IHRpbWUgdG8gZG8gYW55dGhpbmcgaW50ZXJlc3Rpbmcgd2hpbGUgdGhlIGN1cnJlbnQgdGFiIGlzXG4gICAgLy8gY2xvc2luZy5cbiAgICBjb25zdCB0aW1lRGVsdGEgPSBuZXdUYXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbi50b01pY3Jvc2Vjb25kcygpIC1cbiAgICAgICAgb2xkVGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24udG9NaWNyb3NlY29uZHMoKTtcbiAgICBpZiAodGltZURlbHRhID49IFJFU1VNRV9UT0tFTl9NQVhfQUdFX01JQ1JPUykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlIGlmIHRoZSBvbmx5IHRoaW5nIHRoYXQgaGFzIGNoYW5nZWQgYWJvdXQgYSB0YXJnZXQgaXMgaXRzIHJlc3VtZVxuICAgIC8vIHRva2VuIGl0J3Mgbm90IHdvcnRoIHBlcnNpc3RpbmcuIE5vdGUgdGhhdCB0aGUgUmVtb3RlU3RvcmUga2VlcHMgYW5cbiAgICAvLyBpbi1tZW1vcnkgdmlldyBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSB0YXJnZXRzIHdoaWNoIGluY2x1ZGVzIHRoZSBjdXJyZW50XG4gICAgLy8gcmVzdW1lIHRva2VuLCBzbyBzdHJlYW0gZmFpbHVyZSBvciB1c2VyIGNoYW5nZXMgd2lsbCBzdGlsbCB1c2UgYW5cbiAgICAvLyB1cC10by1kYXRlIHJlc3VtZSB0b2tlbiByZWdhcmRsZXNzIG9mIHdoYXQgd2UgZG8gaGVyZS5cbiAgICBjb25zdCBjaGFuZ2VzID0gY2hhbmdlLmFkZGVkRG9jdW1lbnRzLnNpemUgK1xuICAgICAgICBjaGFuZ2UubW9kaWZpZWREb2N1bWVudHMuc2l6ZSArXG4gICAgICAgIGNoYW5nZS5yZW1vdmVkRG9jdW1lbnRzLnNpemU7XG4gICAgcmV0dXJuIGNoYW5nZXMgPiAwO1xufVxuLyoqXG4gKiBOb3RpZmllcyBsb2NhbCBzdG9yZSBvZiB0aGUgY2hhbmdlZCB2aWV3cyB0byBsb2NhbGx5IHBpbiBkb2N1bWVudHMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvY2FsU3RvcmVOb3RpZnlMb2NhbFZpZXdDaGFuZ2VzKGxvY2FsU3RvcmUsIHZpZXdDaGFuZ2VzKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ25vdGlmeUxvY2FsVmlld0NoYW5nZXMnLCAncmVhZHdyaXRlJywgdHhuID0+IHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh2aWV3Q2hhbmdlcywgKHZpZXdDaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godmlld0NoYW5nZS5hZGRlZEtleXMsIChrZXkpID0+IGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlLmFkZFJlZmVyZW5jZSh0eG4sIHZpZXdDaGFuZ2UudGFyZ2V0SWQsIGtleSkpLm5leHQoKCkgPT4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2godmlld0NoYW5nZS5yZW1vdmVkS2V5cywgKGtleSkgPT4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGUucmVtb3ZlUmVmZXJlbmNlKHR4biwgdmlld0NoYW5nZS50YXJnZXRJZCwga2V5KSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XG4gICAgICAgICAgICAvLyBJZiBgbm90aWZ5TG9jYWxWaWV3Q2hhbmdlc2AgZmFpbHMsIHdlIGRpZCBub3QgYWR2YW5jZSB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIC8vIG51bWJlciBmb3IgdGhlIGRvY3VtZW50cyB0aGF0IHdlcmUgaW5jbHVkZWQgaW4gdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgIC8vIFRoaXMgbWlnaHQgdHJpZ2dlciB0aGVtIHRvIGJlIGRlbGV0ZWQgZWFybGllciB0aGFuIHRoZXkgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyB3b3VsZCBoYXZlLCBidXQgaXQgc2hvdWxkIG5vdCBpbnZhbGlkYXRlIHRoZSBpbnRlZ3JpdHkgb2YgdGhlIGRhdGEuXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGIsICdGYWlsZWQgdG8gdXBkYXRlIHNlcXVlbmNlIG51bWJlcnM6ICcgKyBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB2aWV3Q2hhbmdlIG9mIHZpZXdDaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gdmlld0NoYW5nZS50YXJnZXRJZDtcbiAgICAgICAgaWYgKCF2aWV3Q2hhbmdlLmZyb21DYWNoZSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgbGFzdCBsaW1ibyBmcmVlIHNuYXBzaG90IHZlcnNpb25cbiAgICAgICAgICAgIGNvbnN0IGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gPSB0YXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUYXJnZXREYXRhID0gdGFyZ2V0RGF0YS53aXRoTGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbihsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0Lmluc2VydCh0YXJnZXRJZCwgdXBkYXRlZFRhcmdldERhdGEpO1xuICAgICAgICAgICAgLy8gVE9ETyhiLzI3MjU2NDMxNik6IEFwcGx5IHRoZSBvcHRpbWl6YXRpb24gZG9uZSBvbiBvdGhlciBwbGF0Zm9ybXMuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgcHJvYmxlbSBmb3Igd2ViIGJlY2F1c2Ugc2F2aW5nIHRoZSB1cGRhdGVkIHRhcmdldERhdGEgZnJvbVxuICAgICAgICAgICAgLy8gbm9uLXByaW1hcnkgY2xpZW50IGNvbmZsaWN0cyB3aXRoIHdoYXQgcHJpbWFyeSBjbGllbnQgc2F2ZWQuXG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEdldHMgdGhlIG11dGF0aW9uIGJhdGNoIGFmdGVyIHRoZSBwYXNzZWQgaW4gYmF0Y2hJZCBpbiB0aGUgbXV0YXRpb24gcXVldWVcbiAqIG9yIG51bGwgaWYgZW1wdHkuXG4gKiBAcGFyYW0gYWZ0ZXJCYXRjaElkIC0gSWYgcHJvdmlkZWQsIHRoZSBiYXRjaCB0byBzZWFyY2ggYWZ0ZXIuXG4gKiBAcmV0dXJucyBUaGUgbmV4dCBtdXRhdGlvbiBvciBudWxsIGlmIHRoZXJlIHdhc24ndCBvbmUuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXROZXh0TXV0YXRpb25CYXRjaChsb2NhbFN0b3JlLCBhZnRlckJhdGNoSWQpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCBuZXh0IG11dGF0aW9uIGJhdGNoJywgJ3JlYWRvbmx5JywgdHhuID0+IHtcbiAgICAgICAgaWYgKGFmdGVyQmF0Y2hJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhZnRlckJhdGNoSWQgPSBCQVRDSElEX1VOS05PV047XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUuZ2V0TmV4dE11dGF0aW9uQmF0Y2hBZnRlckJhdGNoSWQodHhuLCBhZnRlckJhdGNoSWQpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZWFkcyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIERvY3VtZW50IHdpdGggYSBnaXZlbiBrZXkgb3IgbnVsbCBpZiBub3RcbiAqIGZvdW5kIC0gdXNlZCBmb3IgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yZVJlYWREb2N1bWVudChsb2NhbFN0b3JlLCBrZXkpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ3JlYWQgZG9jdW1lbnQnLCAncmVhZG9ubHknLCB0eG4gPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0RG9jdW1lbnQodHhuLCBrZXkpKTtcbn1cbi8qKlxuICogQXNzaWducyB0aGUgZ2l2ZW4gdGFyZ2V0IGFuIGludGVybmFsIElEIHNvIHRoYXQgaXRzIHJlc3VsdHMgY2FuIGJlIHBpbm5lZCBzb1xuICogdGhleSBkb24ndCBnZXQgR0MnZC4gQSB0YXJnZXQgbXVzdCBiZSBhbGxvY2F0ZWQgaW4gdGhlIGxvY2FsIHN0b3JlIGJlZm9yZVxuICogdGhlIHN0b3JlIGNhbiBiZSB1c2VkIHRvIG1hbmFnZSBpdHMgdmlldy5cbiAqXG4gKiBBbGxvY2F0aW5nIGFuIGFscmVhZHkgYWxsb2NhdGVkIGBUYXJnZXRgIHdpbGwgcmV0dXJuIHRoZSBleGlzdGluZyBgVGFyZ2V0RGF0YWBcbiAqIGZvciB0aGF0IGBUYXJnZXRgLlxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlQWxsb2NhdGVUYXJnZXQobG9jYWxTdG9yZSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlXG4gICAgICAgIC5ydW5UcmFuc2FjdGlvbignQWxsb2NhdGUgdGFyZ2V0JywgJ3JlYWR3cml0ZScsIHR4biA9PiB7XG4gICAgICAgIGxldCB0YXJnZXREYXRhO1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcbiAgICAgICAgICAgIC5nZXRUYXJnZXREYXRhKHR4biwgdGFyZ2V0KVxuICAgICAgICAgICAgLm5leHQoKGNhY2hlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgdGFyZ2V0IGhhcyBiZWVuIGxpc3RlbmVkIHRvIHByZXZpb3VzbHksIHNvIHJldXNlIHRoZVxuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIHRhcmdldElELlxuICAgICAgICAgICAgICAgIC8vIFRPRE8obWNnKTogZnJlc2hlbiBsYXN0IGFjY2Vzc2VkIGRhdGU/XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGF0YSA9IGNhY2hlZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGFyZ2V0RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgLmFsbG9jYXRlVGFyZ2V0SWQodHhuKVxuICAgICAgICAgICAgICAgICAgICAubmV4dCh0YXJnZXRJZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldERhdGEgPSBuZXcgVGFyZ2V0RGF0YSh0YXJnZXQsIHRhcmdldElkLCBcIlRhcmdldFB1cnBvc2VMaXN0ZW5cIiAvKiBUYXJnZXRQdXJwb3NlLkxpc3RlbiAqLywgdHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZFRhcmdldERhdGEodHhuLCB0YXJnZXREYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gdGFyZ2V0RGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgICAgIC50aGVuKHRhcmdldERhdGEgPT4ge1xuICAgICAgICAvLyBJZiBNdWx0aS1UYWIgaXMgZW5hYmxlZCwgdGhlIGV4aXN0aW5nIHRhcmdldCBkYXRhIG1heSBiZSBuZXdlciB0aGFuXG4gICAgICAgIC8vIHRoZSBpbi1tZW1vcnkgZGF0YVxuICAgICAgICBjb25zdCBjYWNoZWRUYXJnZXREYXRhID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0LmdldCh0YXJnZXREYXRhLnRhcmdldElkKTtcbiAgICAgICAgaWYgKGNhY2hlZFRhcmdldERhdGEgPT09IG51bGwgfHxcbiAgICAgICAgICAgIHRhcmdldERhdGEuc25hcHNob3RWZXJzaW9uLmNvbXBhcmVUbyhjYWNoZWRUYXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbikgPlxuICAgICAgICAgICAgICAgIDApIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0Lmluc2VydCh0YXJnZXREYXRhLnRhcmdldElkLCB0YXJnZXREYXRhKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldElkQnlUYXJnZXQuc2V0KHRhcmdldCwgdGFyZ2V0RGF0YS50YXJnZXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldERhdGE7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIFRhcmdldERhdGEgYXMgc2VlbiBieSB0aGUgTG9jYWxTdG9yZSwgaW5jbHVkaW5nIHVwZGF0ZXMgdGhhdCBtYXlcbiAqIGhhdmUgbm90IHlldCBiZWVuIHBlcnNpc3RlZCB0byB0aGUgVGFyZ2V0Q2FjaGUuXG4gKi9cbi8vIFZpc2libGUgZm9yIHRlc3RpbmcuXG5mdW5jdGlvbiBsb2NhbFN0b3JlR2V0VGFyZ2V0RGF0YShsb2NhbFN0b3JlLCB0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgdGFyZ2V0SWQgPSBsb2NhbFN0b3JlSW1wbC50YXJnZXRJZEJ5VGFyZ2V0LmdldCh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuZ2V0KHRhcmdldElkKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuZ2V0VGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0KTtcbiAgICB9XG59XG4vKipcbiAqIFVucGlucyBhbGwgdGhlIGRvY3VtZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHRhcmdldC4gSWZcbiAqIGBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YWAgaXMgc2V0IHRvIGZhbHNlIGFuZCBFYWdlciBHQyBlbmFibGVkLCB0aGUgbWV0aG9kXG4gKiBkaXJlY3RseSByZW1vdmVzIHRoZSBhc3NvY2lhdGVkIHRhcmdldCBkYXRhIGZyb20gdGhlIHRhcmdldCBjYWNoZS5cbiAqXG4gKiBSZWxlYXNpbmcgYSBub24tZXhpc3RpbmcgYFRhcmdldGAgaXMgYSBuby1vcC5cbiAqL1xuLy8gUE9SVElORyBOT1RFOiBga2VlcFBlcnNpc3RlZFRhcmdldERhdGFgIGlzIG11bHRpLXRhYiBvbmx5LlxuYXN5bmMgZnVuY3Rpb24gbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQobG9jYWxTdG9yZSwgdGFyZ2V0SWQsIGtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgdGFyZ2V0RGF0YSA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xuICAgIGNvbnN0IG1vZGUgPSBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YSA/ICdyZWFkd3JpdGUnIDogJ3JlYWR3cml0ZS1wcmltYXJ5JztcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhKSB7XG4gICAgICAgICAgICBhd2FpdCBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignUmVsZWFzZSB0YXJnZXQnLCBtb2RlLCB0eG4gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZS5yZW1vdmVUYXJnZXQodHhuLCB0YXJnZXREYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcbiAgICAgICAgICAgIC8vIEFsbCBgcmVsZWFzZVRhcmdldGAgZG9lcyBpcyByZWNvcmQgdGhlIGZpbmFsIG1ldGFkYXRhIHN0YXRlIGZvciB0aGVcbiAgICAgICAgICAgIC8vIHRhcmdldCwgYnV0IHdlJ3ZlIGJlZW4gcmVjb3JkaW5nIHRoaXMgcGVyaW9kaWNhbGx5IGR1cmluZyB0YXJnZXRcbiAgICAgICAgICAgIC8vIGFjdGl2aXR5LiBJZiB3ZSBsb3NlIHRoaXMgd3JpdGUgdGhpcyBjb3VsZCBjYXVzZSBhIHZlcnkgc2xpZ2h0XG4gICAgICAgICAgICAvLyBkaWZmZXJlbmNlIGluIHRoZSBvcmRlciBvZiB0YXJnZXQgZGVsZXRpb24gZHVyaW5nIEdDLCBidXQgd2VcbiAgICAgICAgICAgIC8vIGRvbid0IGRlZmluZSBleGFjdCBMUlUgc2VtYW50aWNzIHNvIHRoaXMgaXMgYWNjZXB0YWJsZS5cbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckYiwgYEZhaWxlZCB0byB1cGRhdGUgc2VxdWVuY2UgbnVtYmVycyBmb3IgdGFyZ2V0ICR7dGFyZ2V0SWR9OiAke2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9XG4gICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5yZW1vdmUodGFyZ2V0SWQpO1xuICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldElkQnlUYXJnZXQuZGVsZXRlKHRhcmdldERhdGEudGFyZ2V0KTtcbn1cbi8qKlxuICogUnVucyB0aGUgc3BlY2lmaWVkIHF1ZXJ5IGFnYWluc3QgdGhlIGxvY2FsIHN0b3JlIGFuZCByZXR1cm5zIHRoZSByZXN1bHRzLFxuICogcG90ZW50aWFsbHkgdGFraW5nIGFkdmFudGFnZSBvZiBxdWVyeSBkYXRhIGZyb20gcHJldmlvdXMgZXhlY3V0aW9ucyAoc3VjaFxuICogYXMgdGhlIHNldCBvZiByZW1vdGUga2V5cykuXG4gKlxuICogQHBhcmFtIHVzZVByZXZpb3VzUmVzdWx0cyAtIFdoZXRoZXIgcmVzdWx0cyBmcm9tIHByZXZpb3VzIGV4ZWN1dGlvbnMgY2FuXG4gKiBiZSB1c2VkIHRvIG9wdGltaXplIHRoaXMgcXVlcnkgZXhlY3V0aW9uLlxuICovXG5mdW5jdGlvbiBsb2NhbFN0b3JlRXhlY3V0ZVF1ZXJ5KGxvY2FsU3RvcmUsIHF1ZXJ5LCB1c2VQcmV2aW91c1Jlc3VsdHMpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBsZXQgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiA9IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICBsZXQgcmVtb3RlS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdFeGVjdXRlIHF1ZXJ5JywgJ3JlYWR3cml0ZScsIC8vIFVzZSByZWFkd3JpdGUgaW5zdGVhZCBvZiByZWFkb25seSBzbyBpbmRleGVzIGNhbiBiZSBjcmVhdGVkXG4gICAgLy8gVXNlIHJlYWR3cml0ZSBpbnN0ZWFkIG9mIHJlYWRvbmx5IHNvIGluZGV4ZXMgY2FuIGJlIGNyZWF0ZWRcbiAgICB0eG4gPT4ge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUdldFRhcmdldERhdGEobG9jYWxTdG9yZUltcGwsIHR4biwgcXVlcnlUb1RhcmdldChxdWVyeSkpXG4gICAgICAgICAgICAubmV4dCh0YXJnZXREYXRhID0+IHtcbiAgICAgICAgICAgIGlmICh0YXJnZXREYXRhKSB7XG4gICAgICAgICAgICAgICAgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiA9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldERhdGEubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgLmdldE1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0RGF0YS50YXJnZXRJZClcbiAgICAgICAgICAgICAgICAgICAgLm5leHQocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlS2V5cyA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLnF1ZXJ5RW5naW5lLmdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHhuLCBxdWVyeSwgdXNlUHJldmlvdXNSZXN1bHRzXG4gICAgICAgICAgICA/IGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb25cbiAgICAgICAgICAgIDogU25hcHNob3RWZXJzaW9uLm1pbigpLCB1c2VQcmV2aW91c1Jlc3VsdHMgPyByZW1vdGVLZXlzIDogZG9jdW1lbnRLZXlTZXQoKSkpXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudHMgPT4ge1xuICAgICAgICAgICAgc2V0TWF4UmVhZFRpbWUobG9jYWxTdG9yZUltcGwsIHF1ZXJ5Q29sbGVjdGlvbkdyb3VwKHF1ZXJ5KSwgZG9jdW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRvY3VtZW50cywgcmVtb3RlS2V5cyB9O1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFwcGx5V3JpdGVUb1JlbW90ZURvY3VtZW50cyhsb2NhbFN0b3JlSW1wbCwgdHhuLCBiYXRjaFJlc3VsdCwgZG9jdW1lbnRCdWZmZXIpIHtcbiAgICBjb25zdCBiYXRjaCA9IGJhdGNoUmVzdWx0LmJhdGNoO1xuICAgIGNvbnN0IGRvY0tleXMgPSBiYXRjaC5rZXlzKCk7XG4gICAgbGV0IHByb21pc2VDaGFpbiA9IFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgZG9jS2V5cy5mb3JFYWNoKGRvY0tleSA9PiB7XG4gICAgICAgIHByb21pc2VDaGFpbiA9IHByb21pc2VDaGFpblxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZG9jdW1lbnRCdWZmZXIuZ2V0RW50cnkodHhuLCBkb2NLZXkpKVxuICAgICAgICAgICAgLm5leHQoZG9jID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFja1ZlcnNpb24gPSBiYXRjaFJlc3VsdC5kb2NWZXJzaW9ucy5nZXQoZG9jS2V5KTtcbiAgICAgICAgICAgIGhhcmRBc3NlcnQoYWNrVmVyc2lvbiAhPT0gbnVsbCk7XG4gICAgICAgICAgICBpZiAoZG9jLnZlcnNpb24uY29tcGFyZVRvKGFja1ZlcnNpb24pIDwgMCkge1xuICAgICAgICAgICAgICAgIGJhdGNoLmFwcGx5VG9SZW1vdGVEb2N1bWVudChkb2MsIGJhdGNoUmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAoZG9jLmlzVmFsaWREb2N1bWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgY29tbWl0VmVyc2lvbiBhcyB0aGUgcmVhZFRpbWUgcmF0aGVyIHRoYW4gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvY3VtZW50J3MgdXBkYXRlVGltZSBzaW5jZSB0aGUgdXBkYXRlVGltZSBpcyBub3QgYWR2YW5jZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHVwZGF0ZXMgdGhhdCBkbyBub3QgbW9kaWZ5IHRoZSB1bmRlcmx5aW5nIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgICAgICBkb2Muc2V0UmVhZFRpbWUoYmF0Y2hSZXN1bHQuY29tbWl0VmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50QnVmZmVyLmFkZEVudHJ5KGRvYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZUNoYWluLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZS5yZW1vdmVNdXRhdGlvbkJhdGNoKHR4biwgYmF0Y2gpKTtcbn1cbi8qKiBSZXR1cm5zIHRoZSBsb2NhbCB2aWV3IG9mIHRoZSBkb2N1bWVudHMgYWZmZWN0ZWQgYnkgYSBtdXRhdGlvbiBiYXRjaC4gKi9cbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXG5mdW5jdGlvbiBsb2NhbFN0b3JlTG9va3VwTXV0YXRpb25Eb2N1bWVudHMobG9jYWxTdG9yZSwgYmF0Y2hJZCkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIGNvbnN0IG11dGF0aW9uUXVldWVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignTG9va3VwIG11dGF0aW9uIGRvY3VtZW50cycsICdyZWFkb25seScsIHR4biA9PiB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvblF1ZXVlSW1wbC5sb29rdXBNdXRhdGlvbktleXModHhuLCBiYXRjaElkKS5uZXh0KGtleXMgPT4ge1xuICAgICAgICAgICAgaWYgKGtleXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0RG9jdW1lbnRzKHR4biwga2V5cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmZ1bmN0aW9uIGxvY2FsU3RvcmVSZW1vdmVDYWNoZWRNdXRhdGlvbkJhdGNoTWV0YWRhdGEobG9jYWxTdG9yZSwgYmF0Y2hJZCkge1xuICAgIGNvbnN0IG11dGF0aW9uUXVldWVJbXBsID0gZGVidWdDYXN0KGRlYnVnQ2FzdChsb2NhbFN0b3JlLCBMb2NhbFN0b3JlSW1wbCkubXV0YXRpb25RdWV1ZSk7XG4gICAgbXV0YXRpb25RdWV1ZUltcGwucmVtb3ZlQ2FjaGVkTXV0YXRpb25LZXlzKGJhdGNoSWQpO1xufVxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXRBY3RpdmVDbGllbnRzKGxvY2FsU3RvcmUpIHtcbiAgICBjb25zdCBwZXJzaXN0ZW5jZUltcGwgPSBkZWJ1Z0Nhc3QoZGVidWdDYXN0KGxvY2FsU3RvcmUsIExvY2FsU3RvcmVJbXBsKS5wZXJzaXN0ZW5jZSk7XG4gICAgcmV0dXJuIHBlcnNpc3RlbmNlSW1wbC5nZXRBY3RpdmVDbGllbnRzKCk7XG59XG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuZnVuY3Rpb24gbG9jYWxTdG9yZUdldENhY2hlZFRhcmdldChsb2NhbFN0b3JlLCB0YXJnZXRJZCkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIGNvbnN0IHRhcmdldENhY2hlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZSk7XG4gICAgY29uc3QgY2FjaGVkVGFyZ2V0RGF0YSA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xuICAgIGlmIChjYWNoZWRUYXJnZXREYXRhKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVkVGFyZ2V0RGF0YS50YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdHZXQgdGFyZ2V0IGRhdGEnLCAncmVhZG9ubHknLCB0eG4gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldENhY2hlSW1wbFxuICAgICAgICAgICAgICAgIC5nZXRUYXJnZXREYXRhRm9yVGFyZ2V0KHR4biwgdGFyZ2V0SWQpXG4gICAgICAgICAgICAgICAgLm5leHQodGFyZ2V0RGF0YSA9PiAodGFyZ2V0RGF0YSA/IHRhcmdldERhdGEudGFyZ2V0IDogbnVsbCkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHNldCBvZiBkb2N1bWVudHMgdGhhdCBoYXZlIGJlZW4gdXBkYXRlZCBzaW5jZSB0aGUgbGFzdCBjYWxsLlxuICogSWYgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgcmV0dXJucyB0aGUgc2V0IG9mIGNoYW5nZXMgc2luY2UgY2xpZW50XG4gKiBpbml0aWFsaXphdGlvbi4gRnVydGhlciBpbnZvY2F0aW9ucyB3aWxsIHJldHVybiBkb2N1bWVudCB0aGF0IGhhdmUgY2hhbmdlZFxuICogc2luY2UgdGhlIHByaW9yIGNhbGwuXG4gKi9cbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXG5mdW5jdGlvbiBsb2NhbFN0b3JlR2V0TmV3RG9jdW1lbnRDaGFuZ2VzKGxvY2FsU3RvcmUsIGNvbGxlY3Rpb25Hcm91cCkge1xuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xuICAgIC8vIEdldCB0aGUgY3VycmVudCBtYXhpbXVtIHJlYWQgdGltZSBmb3IgdGhlIGNvbGxlY3Rpb24uIFRoaXMgc2hvdWxkIGFsd2F5c1xuICAgIC8vIGV4aXN0LCBidXQgdG8gcmVkdWNlIHRoZSBjaGFuY2UgZm9yIHJlZ3Jlc3Npb25zIHdlIGRlZmF1bHQgdG9cbiAgICAvLyBTbmFwc2hvdFZlcnNpb24uTWluKClcbiAgICAvLyBUT0RPKGluZGV4aW5nKTogQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgY29uc3QgcmVhZFRpbWUgPSBsb2NhbFN0b3JlSW1wbC5jb2xsZWN0aW9uR3JvdXBSZWFkVGltZS5nZXQoY29sbGVjdGlvbkdyb3VwKSB8fFxuICAgICAgICBTbmFwc2hvdFZlcnNpb24ubWluKCk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlXG4gICAgICAgIC5ydW5UcmFuc2FjdGlvbignR2V0IG5ldyBkb2N1bWVudCBjaGFuZ2VzJywgJ3JlYWRvbmx5JywgdHhuID0+IGxvY2FsU3RvcmVJbXBsLnJlbW90ZURvY3VtZW50cy5nZXRBbGxGcm9tQ29sbGVjdGlvbkdyb3VwKHR4biwgY29sbGVjdGlvbkdyb3VwLCBuZXdJbmRleE9mZnNldFN1Y2Nlc3NvckZyb21SZWFkVGltZShyZWFkVGltZSwgSU5JVElBTF9MQVJHRVNUX0JBVENIX0lEKSwgXG4gICAgLyogbGltaXQ9ICovIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSlcbiAgICAgICAgLnRoZW4oY2hhbmdlZERvY3MgPT4ge1xuICAgICAgICBzZXRNYXhSZWFkVGltZShsb2NhbFN0b3JlSW1wbCwgY29sbGVjdGlvbkdyb3VwLCBjaGFuZ2VkRG9jcyk7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkRG9jcztcbiAgICB9KTtcbn1cbi8qKiBTZXRzIHRoZSBjb2xsZWN0aW9uIGdyb3VwJ3MgbWF4aW11bSByZWFkIHRpbWUgZnJvbSB0aGUgZ2l2ZW4gZG9jdW1lbnRzLiAqL1xuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmZ1bmN0aW9uIHNldE1heFJlYWRUaW1lKGxvY2FsU3RvcmVJbXBsLCBjb2xsZWN0aW9uR3JvdXAsIGNoYW5nZWREb2NzKSB7XG4gICAgbGV0IHJlYWRUaW1lID0gbG9jYWxTdG9yZUltcGwuY29sbGVjdGlvbkdyb3VwUmVhZFRpbWUuZ2V0KGNvbGxlY3Rpb25Hcm91cCkgfHxcbiAgICAgICAgU25hcHNob3RWZXJzaW9uLm1pbigpO1xuICAgIGNoYW5nZWREb2NzLmZvckVhY2goKF8sIGRvYykgPT4ge1xuICAgICAgICBpZiAoZG9jLnJlYWRUaW1lLmNvbXBhcmVUbyhyZWFkVGltZSkgPiAwKSB7XG4gICAgICAgICAgICByZWFkVGltZSA9IGRvYy5yZWFkVGltZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxvY2FsU3RvcmVJbXBsLmNvbGxlY3Rpb25Hcm91cFJlYWRUaW1lLnNldChjb2xsZWN0aW9uR3JvdXAsIHJlYWRUaW1lKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0YXJnZXQgdXNpbmcgdGhlIGdpdmVuIGJ1bmRsZSBuYW1lLCB3aGljaCB3aWxsIGJlIHVzZWQgdG9cbiAqIGhvbGQgdGhlIGtleXMgb2YgYWxsIGRvY3VtZW50cyBmcm9tIHRoZSBidW5kbGUgaW4gcXVlcnktZG9jdW1lbnQgbWFwcGluZ3MuXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgbG9hZGVkIGRvY3VtZW50cyBkbyBub3QgZ2V0IGdhcmJhZ2UgY29sbGVjdGVkXG4gKiByaWdodCBhd2F5LlxuICovXG5mdW5jdGlvbiB1bWJyZWxsYVRhcmdldChidW5kbGVOYW1lKSB7XG4gICAgLy8gSXQgaXMgT0sgdGhhdCB0aGUgcGF0aCB1c2VkIGZvciB0aGUgcXVlcnkgaXMgbm90IHZhbGlkLCBiZWNhdXNlIHRoaXMgd2lsbFxuICAgIC8vIG5vdCBiZSByZWFkIGFuZCBxdWVyaWVkLlxuICAgIHJldHVybiBxdWVyeVRvVGFyZ2V0KG5ld1F1ZXJ5Rm9yUGF0aChSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhgX19idW5kbGVfXy9kb2NzLyR7YnVuZGxlTmFtZX1gKSkpO1xufVxuLyoqXG4gKiBBcHBsaWVzIHRoZSBkb2N1bWVudHMgZnJvbSBhIGJ1bmRsZSB0byB0aGUgXCJncm91bmQtc3RhdGVcIiAocmVtb3RlKVxuICogZG9jdW1lbnRzLlxuICpcbiAqIExvY2FsRG9jdW1lbnRzIGFyZSByZS1jYWxjdWxhdGVkIGlmIHRoZXJlIGFyZSByZW1haW5pbmcgbXV0YXRpb25zIGluIHRoZVxuICogcXVldWUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvY2FsU3RvcmVBcHBseUJ1bmRsZWREb2N1bWVudHMobG9jYWxTdG9yZSwgYnVuZGxlQ29udmVydGVyLCBkb2N1bWVudHMsIGJ1bmRsZU5hbWUpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBsZXQgZG9jdW1lbnRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICBsZXQgZG9jdW1lbnRNYXAgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGJ1bmRsZURvYyBvZiBkb2N1bWVudHMpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRLZXkgPSBidW5kbGVDb252ZXJ0ZXIudG9Eb2N1bWVudEtleShidW5kbGVEb2MubWV0YWRhdGEubmFtZSk7XG4gICAgICAgIGlmIChidW5kbGVEb2MuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50S2V5cyA9IGRvY3VtZW50S2V5cy5hZGQoZG9jdW1lbnRLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvYyA9IGJ1bmRsZUNvbnZlcnRlci50b011dGFibGVEb2N1bWVudChidW5kbGVEb2MpO1xuICAgICAgICBkb2Muc2V0UmVhZFRpbWUoYnVuZGxlQ29udmVydGVyLnRvU25hcHNob3RWZXJzaW9uKGJ1bmRsZURvYy5tZXRhZGF0YS5yZWFkVGltZSkpO1xuICAgICAgICBkb2N1bWVudE1hcCA9IGRvY3VtZW50TWFwLmluc2VydChkb2N1bWVudEtleSwgZG9jKTtcbiAgICB9XG4gICAgY29uc3QgZG9jdW1lbnRCdWZmZXIgPSBsb2NhbFN0b3JlSW1wbC5yZW1vdGVEb2N1bWVudHMubmV3Q2hhbmdlQnVmZmVyKHtcbiAgICAgICAgdHJhY2tSZW1vdmFsczogdHJ1ZSAvLyBNYWtlIHN1cmUgZG9jdW1lbnQgcmVtb3ZhbHMgc2hvdyB1cCBpbiBgZ2V0TmV3RG9jdW1lbnRDaGFuZ2VzKClgXG4gICAgfSk7XG4gICAgLy8gQWxsb2NhdGVzIGEgdGFyZ2V0IHRvIGhvbGQgYWxsIGRvY3VtZW50IGtleXMgZnJvbSB0aGUgYnVuZGxlLCBzdWNoIHRoYXRcbiAgICAvLyB0aGV5IHdpbGwgbm90IGdldCBnYXJiYWdlIGNvbGxlY3RlZCByaWdodCBhd2F5LlxuICAgIGNvbnN0IHVtYnJlbGxhVGFyZ2V0RGF0YSA9IGF3YWl0IGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChsb2NhbFN0b3JlSW1wbCwgdW1icmVsbGFUYXJnZXQoYnVuZGxlTmFtZSkpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignQXBwbHkgYnVuZGxlIGRvY3VtZW50cycsICdyZWFkd3JpdGUnLCB0eG4gPT4ge1xuICAgICAgICByZXR1cm4gcG9wdWxhdGVEb2N1bWVudENoYW5nZUJ1ZmZlcih0eG4sIGRvY3VtZW50QnVmZmVyLCBkb2N1bWVudE1hcClcbiAgICAgICAgICAgIC5uZXh0KGRvY3VtZW50Q2hhbmdlUmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50QnVmZmVyLmFwcGx5KHR4bik7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRDaGFuZ2VSZXN1bHQ7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dChkb2N1bWVudENoYW5nZVJlc3VsdCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcbiAgICAgICAgICAgICAgICAucmVtb3ZlTWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHhuLCB1bWJyZWxsYVRhcmdldERhdGEudGFyZ2V0SWQpXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuYWRkTWF0Y2hpbmdLZXlzKHR4biwgZG9jdW1lbnRLZXlzLCB1bWJyZWxsYVRhcmdldERhdGEudGFyZ2V0SWQpKVxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLmxvY2FsRG9jdW1lbnRzLmdldExvY2FsVmlld09mRG9jdW1lbnRzKHR4biwgZG9jdW1lbnRDaGFuZ2VSZXN1bHQuY2hhbmdlZERvY3VtZW50cywgZG9jdW1lbnRDaGFuZ2VSZXN1bHQuZXhpc3RlbmNlQ2hhbmdlZEtleXMpKVxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IGRvY3VtZW50Q2hhbmdlUmVzdWx0LmNoYW5nZWREb2N1bWVudHMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2Ugb2YgYSBib29sZWFuIHRvIGluZGljYXRlIGlmIHRoZSBnaXZlbiBidW5kbGUgaGFzIGFscmVhZHlcbiAqIGJlZW4gbG9hZGVkIGFuZCB0aGUgY3JlYXRlIHRpbWUgaXMgbmV3ZXIgdGhhbiB0aGUgY3VycmVudCBsb2FkaW5nIGJ1bmRsZS5cbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yZUhhc05ld2VyQnVuZGxlKGxvY2FsU3RvcmUsIGJ1bmRsZU1ldGFkYXRhKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgY3VycmVudFJlYWRUaW1lID0gZnJvbVZlcnNpb24oYnVuZGxlTWV0YWRhdGEuY3JlYXRlVGltZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlXG4gICAgICAgIC5ydW5UcmFuc2FjdGlvbignaGFzTmV3ZXJCdW5kbGUnLCAncmVhZG9ubHknLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5idW5kbGVDYWNoZS5nZXRCdW5kbGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgYnVuZGxlTWV0YWRhdGEuaWQpO1xuICAgIH0pXG4gICAgICAgIC50aGVuKGNhY2hlZCA9PiB7XG4gICAgICAgIHJldHVybiAhIWNhY2hlZCAmJiBjYWNoZWQuY3JlYXRlVGltZS5jb21wYXJlVG8oY3VycmVudFJlYWRUaW1lKSA+PSAwO1xuICAgIH0pO1xufVxuLyoqXG4gKiBTYXZlcyB0aGUgZ2l2ZW4gYEJ1bmRsZU1ldGFkYXRhYCB0byBsb2NhbCBwZXJzaXN0ZW5jZS5cbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yZVNhdmVCdW5kbGUobG9jYWxTdG9yZSwgYnVuZGxlTWV0YWRhdGEpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ1NhdmUgYnVuZGxlJywgJ3JlYWR3cml0ZScsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLmJ1bmRsZUNhY2hlLnNhdmVCdW5kbGVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgYnVuZGxlTWV0YWRhdGEpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBvZiBhIGBOYW1lZFF1ZXJ5YCBhc3NvY2lhdGVkIHdpdGggZ2l2ZW4gcXVlcnkgbmFtZS4gUHJvbWlzZVxuICogcmVzb2x2ZXMgdG8gdW5kZWZpbmVkIGlmIG5vIHBlcnNpc3RlZCBkYXRhIGNhbiBiZSBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yZUdldE5hbWVkUXVlcnkobG9jYWxTdG9yZSwgcXVlcnlOYW1lKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdHZXQgbmFtZWQgcXVlcnknLCAncmVhZG9ubHknLCB0cmFuc2FjdGlvbiA9PiBsb2NhbFN0b3JlSW1wbC5idW5kbGVDYWNoZS5nZXROYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeU5hbWUpKTtcbn1cbi8qKlxuICogU2F2ZXMgdGhlIGdpdmVuIGBOYW1lZFF1ZXJ5YCB0byBsb2NhbCBwZXJzaXN0ZW5jZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9jYWxTdG9yZVNhdmVOYW1lZFF1ZXJ5KGxvY2FsU3RvcmUsIHF1ZXJ5LCBkb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpKSB7XG4gICAgLy8gQWxsb2NhdGUgYSB0YXJnZXQgZm9yIHRoZSBuYW1lZCBxdWVyeSBzdWNoIHRoYXQgaXQgY2FuIGJlIHJlc3VtZWRcbiAgICAvLyBmcm9tIGFzc29jaWF0ZWQgcmVhZCB0aW1lIGlmIHVzZXJzIHVzZSBpdCB0byBsaXN0ZW4uXG4gICAgLy8gTk9URTogdGhpcyBhbHNvIG1lYW5zIGlmIG5vIGNvcnJlc3BvbmRpbmcgdGFyZ2V0IGV4aXN0cywgdGhlIG5ldyB0YXJnZXRcbiAgICAvLyB3aWxsIHJlbWFpbiBhY3RpdmUgYW5kIHdpbGwgbm90IGdldCBjb2xsZWN0ZWQsIHVubGVzcyB1c2VycyBoYXBwZW4gdG9cbiAgICAvLyB1bmxpc3RlbiB0aGUgcXVlcnkgc29tZWhvdy5cbiAgICBjb25zdCBhbGxvY2F0ZWQgPSBhd2FpdCBsb2NhbFN0b3JlQWxsb2NhdGVUYXJnZXQobG9jYWxTdG9yZSwgcXVlcnlUb1RhcmdldChmcm9tQnVuZGxlZFF1ZXJ5KHF1ZXJ5LmJ1bmRsZWRRdWVyeSkpKTtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ1NhdmUgbmFtZWQgcXVlcnknLCAncmVhZHdyaXRlJywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCByZWFkVGltZSA9IGZyb21WZXJzaW9uKHF1ZXJ5LnJlYWRUaW1lKTtcbiAgICAgICAgLy8gU2ltcGx5IHNhdmUgdGhlIHF1ZXJ5IGl0c2VsZiBpZiBpdCBpcyBvbGRlciB0aGFuIHdoYXQgdGhlIFNESyBhbHJlYWR5XG4gICAgICAgIC8vIGhhcy5cbiAgICAgICAgaWYgKGFsbG9jYXRlZC5zbmFwc2hvdFZlcnNpb24uY29tcGFyZVRvKHJlYWRUaW1lKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwuYnVuZGxlQ2FjaGUuc2F2ZU5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgdGFyZ2V0IGRhdGEgYmVjYXVzZSB0aGUgcXVlcnkgZnJvbSB0aGUgYnVuZGxlIGlzIG5ld2VyLlxuICAgICAgICBjb25zdCBuZXdUYXJnZXREYXRhID0gYWxsb2NhdGVkLndpdGhSZXN1bWVUb2tlbihCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HLCByZWFkVGltZSk7XG4gICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9XG4gICAgICAgICAgICBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuaW5zZXJ0KG5ld1RhcmdldERhdGEudGFyZ2V0SWQsIG5ld1RhcmdldERhdGEpO1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcbiAgICAgICAgICAgIC51cGRhdGVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCBuZXdUYXJnZXREYXRhKVxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUucmVtb3ZlTWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHJhbnNhY3Rpb24sIGFsbG9jYXRlZC50YXJnZXRJZCkpXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5hZGRNYXRjaGluZ0tleXModHJhbnNhY3Rpb24sIGRvY3VtZW50cywgYWxsb2NhdGVkLnRhcmdldElkKSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLmJ1bmRsZUNhY2hlLnNhdmVOYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSkpO1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9jYWxTdG9yZUNvbmZpZ3VyZUZpZWxkSW5kZXhlcyhsb2NhbFN0b3JlLCBuZXdGaWVsZEluZGV4ZXMpIHtcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcbiAgICBjb25zdCBpbmRleE1hbmFnZXIgPSBsb2NhbFN0b3JlSW1wbC5pbmRleE1hbmFnZXI7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0NvbmZpZ3VyZSBpbmRleGVzJywgJ3JlYWR3cml0ZScsIHRyYW5zYWN0aW9uID0+IGluZGV4TWFuYWdlclxuICAgICAgICAuZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uKVxuICAgICAgICAubmV4dChvbGRGaWVsZEluZGV4ZXMgPT4gZGlmZkFycmF5cyhvbGRGaWVsZEluZGV4ZXMsIG5ld0ZpZWxkSW5kZXhlcywgZmllbGRJbmRleFNlbWFudGljQ29tcGFyYXRvciwgZmllbGRJbmRleCA9PiB7XG4gICAgICAgIHByb21pc2VzLnB1c2goaW5kZXhNYW5hZ2VyLmFkZEZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIGZpZWxkSW5kZXgpKTtcbiAgICB9LCBmaWVsZEluZGV4ID0+IHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChpbmRleE1hbmFnZXIuZGVsZXRlRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgZmllbGRJbmRleCkpO1xuICAgIH0pKVxuICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykpKTtcbn1cbmZ1bmN0aW9uIGxvY2FsU3RvcmVTZXRJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQobG9jYWxTdG9yZSwgaXNFbmFibGVkKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgbG9jYWxTdG9yZUltcGwucXVlcnlFbmdpbmUuaW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkID0gaXNFbmFibGVkO1xufVxuZnVuY3Rpb24gbG9jYWxTdG9yZURlbGV0ZUFsbEZpZWxkSW5kZXhlcyhsb2NhbFN0b3JlKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XG4gICAgY29uc3QgaW5kZXhNYW5hZ2VyID0gbG9jYWxTdG9yZUltcGwuaW5kZXhNYW5hZ2VyO1xuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignRGVsZXRlIEFsbCBJbmRleGVzJywgJ3JlYWR3cml0ZScsIHRyYW5zYWN0aW9uID0+IGluZGV4TWFuYWdlci5kZWxldGVBbGxGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24pKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSB0cmFja2VyIHRvIGtlZXAgYSByZWNvcmQgb2YgaW1wb3J0YW50IGRldGFpbHMgZHVyaW5nIGRhdGFiYXNlIGxvY2FsIHF1ZXJ5XG4gKiBleGVjdXRpb24uXG4gKi9cbmNsYXNzIFF1ZXJ5Q29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgcGFzc2VkIHRocm91Z2ggZHVyaW5nIGxvY2FsIHF1ZXJ5IGV4ZWN1dGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2RvY3VtZW50UmVhZENvdW50ID0gMDtcbiAgICB9XG4gICAgZ2V0IGRvY3VtZW50UmVhZENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG9jdW1lbnRSZWFkQ291bnQ7XG4gICAgfVxuICAgIGluY3JlbWVudERvY3VtZW50UmVhZENvdW50KGFtb3VudCkge1xuICAgICAgICB0aGlzLl9kb2N1bWVudFJlYWRDb3VudCArPSBhbW91bnQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgREVGQVVMVF9JTkRFWF9BVVRPX0NSRUFUSU9OX01JTl9DT0xMRUNUSU9OX1NJWkUgPSAxMDA7XG4vKipcbiAqIFRoaXMgY29zdCByZXByZXNlbnRzIHRoZSBldmFsdWF0aW9uIHJlc3VsdCBvZlxuICogKChbaW5kZXgsIGRvY0tleV0gKyBbZG9jS2V5LCBkb2NDb250ZW50XSkgcGVyIGRvY3VtZW50IGluIHRoZSByZXN1bHQgc2V0KVxuICogLyAoW2RvY0tleSwgZG9jQ29udGVudF0gcGVyIGRvY3VtZW50cyBpbiBmdWxsIGNvbGxlY3Rpb24gc2NhbikgY29taW5nIGZyb21cbiAqIGV4cGVyaW1lbnQgW2VudGVyIFBSIGV4cGVyaW1lbnQgVVJMIGhlcmVdLlxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0UmVsYXRpdmVJbmRleFJlYWRDb3N0UGVyRG9jdW1lbnQoKSB7XG4gICAgLy8gVGhlc2UgdmFsdWVzIHdlcmUgZGVyaXZlZCBmcm9tIGFuIGV4cGVyaW1lbnQgd2hlcmUgc2V2ZXJhbCBtZW1iZXJzIG9mIHRoZVxuICAgIC8vIEZpcmVzdG9yZSBTREsgdGVhbSByYW4gYSBwZXJmb3JtYW5jZSB0ZXN0IGluIHZhcmlvdXMgZW52aXJvbm1lbnRzLlxuICAgIC8vIEdvb2dsZXJzIGNhbiBzZWUgYi8yOTkyODQyODcgZm9yIGRldGFpbHMuXG4gICAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGdldEFuZHJvaWRWZXJzaW9uKGdldFVBKCkpID4gMCkge1xuICAgICAgICByZXR1cm4gNjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbn1cbi8qKlxuICogVGhlIEZpcmVzdG9yZSBxdWVyeSBlbmdpbmUuXG4gKlxuICogRmlyZXN0b3JlIHF1ZXJpZXMgY2FuIGJlIGV4ZWN1dGVkIGluIHRocmVlIG1vZGVzLiBUaGUgUXVlcnkgRW5naW5lIGRldGVybWluZXNcbiAqIHdoYXQgbW9kZSB0byB1c2UgYmFzZWQgb24gd2hhdCBkYXRhIGlzIHBlcnNpc3RlZC4gVGhlIG1vZGUgb25seSBkZXRlcm1pbmVzXG4gKiB0aGUgcnVudGltZSBjb21wbGV4aXR5IG9mIHRoZSBxdWVyeSAtIHRoZSByZXN1bHQgc2V0IGlzIGVxdWl2YWxlbnQgYWNyb3NzIGFsbFxuICogaW1wbGVtZW50YXRpb25zLlxuICpcbiAqIFRoZSBRdWVyeSBlbmdpbmUgd2lsbCB1c2UgaW5kZXhlZC1iYXNlZCBleGVjdXRpb24gaWYgYSB1c2VyIGhhcyBjb25maWd1cmVkXG4gKiBhbnkgaW5kZXggdGhhdCBjYW4gYmUgdXNlZCB0byBleGVjdXRlIHF1ZXJ5ICh2aWEgYHNldEluZGV4Q29uZmlndXJhdGlvbigpYCkuXG4gKiBPdGhlcndpc2UsIHRoZSBlbmdpbmUgd2lsbCB0cnkgdG8gb3B0aW1pemUgdGhlIHF1ZXJ5IGJ5IHJlLXVzaW5nIGEgcHJldmlvdXNseVxuICogcGVyc2lzdGVkIHF1ZXJ5IHJlc3VsdC4gSWYgdGhhdCBpcyBub3QgcG9zc2libGUsIHRoZSBxdWVyeSB3aWxsIGJlIGV4ZWN1dGVkXG4gKiB2aWEgYSBmdWxsIGNvbGxlY3Rpb24gc2Nhbi5cbiAqXG4gKiBJbmRleC1iYXNlZCBleGVjdXRpb24gaXMgdGhlIGRlZmF1bHQgd2hlbiBhdmFpbGFibGUuIFRoZSBxdWVyeSBlbmdpbmVcbiAqIHN1cHBvcnRzIHBhcnRpYWwgaW5kZXhlZCBleGVjdXRpb24gYW5kIG1lcmdlcyB0aGUgcmVzdWx0IGZyb20gdGhlIGluZGV4XG4gKiBsb29rdXAgd2l0aCBkb2N1bWVudHMgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiBpbmRleGVkLiBUaGUgaW5kZXggZXZhbHVhdGlvblxuICogbWF0Y2hlcyB0aGUgYmFja2VuZCdzIGZvcm1hdCBhbmQgYXMgc3VjaCwgdGhlIFNESyBjYW4gdXNlIGluZGV4aW5nIGZvciBhbGxcbiAqIHF1ZXJpZXMgdGhhdCB0aGUgYmFja2VuZCBzdXBwb3J0cy5cbiAqXG4gKiBJZiBubyBpbmRleCBleGlzdHMsIHRoZSBxdWVyeSBlbmdpbmUgdHJpZXMgdG8gdGFrZSBhZHZhbnRhZ2Ugb2YgdGhlIHRhcmdldFxuICogZG9jdW1lbnQgbWFwcGluZyBpbiB0aGUgVGFyZ2V0Q2FjaGUuIFRoZXNlIG1hcHBpbmdzIGV4aXN0cyBmb3IgYWxsIHF1ZXJpZXNcbiAqIHRoYXQgaGF2ZSBiZWVuIHN5bmNlZCB3aXRoIHRoZSBiYWNrZW5kIGF0IGxlYXN0IG9uY2UgYW5kIGFsbG93IHRoZSBxdWVyeVxuICogZW5naW5lIHRvIG9ubHkgcmVhZCBkb2N1bWVudHMgdGhhdCBwcmV2aW91c2x5IG1hdGNoZWQgYSBxdWVyeSBwbHVzIGFueVxuICogZG9jdW1lbnRzIHRoYXQgd2VyZSBlZGl0ZWQgYWZ0ZXIgdGhlIHF1ZXJ5IHdhcyBsYXN0IGxpc3RlbmVkIHRvLlxuICpcbiAqIFRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZW4gdGhpcyBvcHRpbWl6YXRpb24gaXMgbm90IGd1YXJhbnRlZWQgdG8gcHJvZHVjZVxuICogdGhlIHNhbWUgcmVzdWx0cyBhcyBmdWxsIGNvbGxlY3Rpb24gc2NhbnMuIEluIHRoZXNlIGNhc2VzLCBxdWVyeVxuICogcHJvY2Vzc2luZyBmYWxscyBiYWNrIHRvIGZ1bGwgc2NhbnMuIFRoZXNlIGNhc2VzIGFyZTpcbiAqXG4gKiAtIExpbWl0IHF1ZXJpZXMgd2hlcmUgYSBkb2N1bWVudCB0aGF0IG1hdGNoZWQgdGhlIHF1ZXJ5IHByZXZpb3VzbHkgbm8gbG9uZ2VyXG4gKiAgIG1hdGNoZXMgdGhlIHF1ZXJ5LlxuICpcbiAqIC0gTGltaXQgcXVlcmllcyB3aGVyZSBhIGRvY3VtZW50IGVkaXQgbWF5IGNhdXNlIHRoZSBkb2N1bWVudCB0byBzb3J0IGJlbG93XG4gKiAgIGFub3RoZXIgZG9jdW1lbnQgdGhhdCBpcyBpbiB0aGUgbG9jYWwgY2FjaGUuXG4gKlxuICogLSBRdWVyaWVzIHRoYXQgaGF2ZSBuZXZlciBiZWVuIENVUlJFTlQgb3IgZnJlZSBvZiBsaW1ibyBkb2N1bWVudHMuXG4gKi9cbmNsYXNzIFF1ZXJ5RW5naW5lIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU0RLIG9ubHkgZGVjaWRlcyB3aGV0aGVyIGl0IHNob3VsZCBjcmVhdGUgaW5kZXggd2hlbiBjb2xsZWN0aW9uIHNpemUgaXNcbiAgICAgICAgICogbGFyZ2VyIHRoYW4gdGhpcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXhBdXRvQ3JlYXRpb25NaW5Db2xsZWN0aW9uU2l6ZSA9IERFRkFVTFRfSU5ERVhfQVVUT19DUkVBVElPTl9NSU5fQ09MTEVDVElPTl9TSVpFO1xuICAgICAgICB0aGlzLnJlbGF0aXZlSW5kZXhSZWFkQ29zdFBlckRvY3VtZW50ID0gZ2V0RGVmYXVsdFJlbGF0aXZlSW5kZXhSZWFkQ29zdFBlckRvY3VtZW50KCk7XG4gICAgfVxuICAgIC8qKiBTZXRzIHRoZSBkb2N1bWVudCB2aWV3IHRvIHF1ZXJ5IGFnYWluc3QuICovXG4gICAgaW5pdGlhbGl6ZShsb2NhbERvY3VtZW50cywgaW5kZXhNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMubG9jYWxEb2N1bWVudHNWaWV3ID0gbG9jYWxEb2N1bWVudHM7XG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gaW5kZXhNYW5hZ2VyO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYWxsIGxvY2FsIGRvY3VtZW50cyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIHF1ZXJ5LiAqL1xuICAgIGdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLCByZW1vdGVLZXlzKSB7XG4gICAgICAgIC8vIFN0b3JlcyB0aGUgcmVzdWx0IGZyb20gZXhlY3V0aW5nIHRoZSBxdWVyeTsgdXNpbmcgdGhpcyBvYmplY3QgaXMgbW9yZVxuICAgICAgICAvLyBjb252ZW5pZW50IHRoYW4gcGFzc2luZyB0aGUgcmVzdWx0IGJldHdlZW4gc3RlcHMgb2YgdGhlIHBlcnNpc3RlbmNlXG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIGFuZCBpbXByb3ZlcyByZWFkYWJpbGl0eSBjb21wYXJhdGl2ZWx5LlxuICAgICAgICBjb25zdCBxdWVyeVJlc3VsdCA9IHsgcmVzdWx0OiBudWxsIH07XG4gICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1RdWVyeVVzaW5nSW5kZXgodHJhbnNhY3Rpb24sIHF1ZXJ5KVxuICAgICAgICAgICAgLm5leHQocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHF1ZXJ5UmVzdWx0LnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChxdWVyeVJlc3VsdC5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJmb3JtUXVlcnlVc2luZ1JlbW90ZUtleXModHJhbnNhY3Rpb24sIHF1ZXJ5LCByZW1vdGVLZXlzLCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKS5uZXh0KHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgcXVlcnlSZXN1bHQucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAocXVlcnlSZXN1bHQucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IG5ldyBRdWVyeUNvbnRleHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVGdWxsQ29sbGVjdGlvblNjYW4odHJhbnNhY3Rpb24sIHF1ZXJ5LCBjb250ZXh0KS5uZXh0KHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgcXVlcnlSZXN1bHQucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDYWNoZUluZGV4ZXModHJhbnNhY3Rpb24sIHF1ZXJ5LCBjb250ZXh0LCByZXN1bHQuc2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBxdWVyeVJlc3VsdC5yZXN1bHQpO1xuICAgIH1cbiAgICBjcmVhdGVDYWNoZUluZGV4ZXModHJhbnNhY3Rpb24sIHF1ZXJ5LCBjb250ZXh0LCByZXN1bHRTaXplKSB7XG4gICAgICAgIGlmIChjb250ZXh0LmRvY3VtZW50UmVhZENvdW50IDwgdGhpcy5pbmRleEF1dG9DcmVhdGlvbk1pbkNvbGxlY3Rpb25TaXplKSB7XG4gICAgICAgICAgICBpZiAoZ2V0TG9nTGV2ZWwoKSA8PSBMb2dMZXZlbC5ERUJVRykge1xuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdRdWVyeUVuZ2luZScsICdTREsgd2lsbCBub3QgY3JlYXRlIGNhY2hlIGluZGV4ZXMgZm9yIHF1ZXJ5OicsIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSwgJ3NpbmNlIGl0IG9ubHkgY3JlYXRlcyBjYWNoZSBpbmRleGVzIGZvciBjb2xsZWN0aW9uIGNvbnRhaW5zJywgJ21vcmUgdGhhbiBvciBlcXVhbCB0bycsIHRoaXMuaW5kZXhBdXRvQ3JlYXRpb25NaW5Db2xsZWN0aW9uU2l6ZSwgJ2RvY3VtZW50cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPD0gTG9nTGV2ZWwuREVCVUcpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdRdWVyeUVuZ2luZScsICdRdWVyeTonLCBzdHJpbmdpZnlRdWVyeShxdWVyeSksICdzY2FucycsIGNvbnRleHQuZG9jdW1lbnRSZWFkQ291bnQsICdsb2NhbCBkb2N1bWVudHMgYW5kIHJldHVybnMnLCByZXN1bHRTaXplLCAnZG9jdW1lbnRzIGFzIHJlc3VsdHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQuZG9jdW1lbnRSZWFkQ291bnQgPlxuICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZUluZGV4UmVhZENvc3RQZXJEb2N1bWVudCAqIHJlc3VsdFNpemUpIHtcbiAgICAgICAgICAgIGlmIChnZXRMb2dMZXZlbCgpIDw9IExvZ0xldmVsLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1RoZSBTREsgZGVjaWRlcyB0byBjcmVhdGUgY2FjaGUgaW5kZXhlcyBmb3IgcXVlcnk6Jywgc3RyaW5naWZ5UXVlcnkocXVlcnkpLCAnYXMgdXNpbmcgY2FjaGUgaW5kZXhlcyBtYXkgaGVscCBpbXByb3ZlIHBlcmZvcm1hbmNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYW5hZ2VyLmNyZWF0ZVRhcmdldEluZGV4ZXModHJhbnNhY3Rpb24sIHF1ZXJ5VG9UYXJnZXQocXVlcnkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYW4gaW5kZXhlZCBxdWVyeSB0aGF0IGV2YWx1YXRlcyB0aGUgcXVlcnkgYmFzZWQgb24gYSBjb2xsZWN0aW9uJ3NcbiAgICAgKiBwZXJzaXN0ZWQgaW5kZXggdmFsdWVzLiBSZXR1cm5zIGBudWxsYCBpZiBhbiBpbmRleCBpcyBub3QgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIHBlcmZvcm1RdWVyeVVzaW5nSW5kZXgodHJhbnNhY3Rpb24sIHF1ZXJ5KSB7XG4gICAgICAgIGlmIChxdWVyeU1hdGNoZXNBbGxEb2N1bWVudHMocXVlcnkpKSB7XG4gICAgICAgICAgICAvLyBRdWVyaWVzIHRoYXQgbWF0Y2ggYWxsIGRvY3VtZW50cyBkb24ndCBiZW5lZml0IGZyb20gdXNpbmdcbiAgICAgICAgICAgIC8vIGtleS1iYXNlZCBsb29rdXBzLiBJdCBpcyBtb3JlIGVmZmljaWVudCB0byBzY2FuIGFsbCBkb2N1bWVudHMgaW4gYVxuICAgICAgICAgICAgLy8gY29sbGVjdGlvbiwgcmF0aGVyIHRoYW4gdG8gcGVyZm9ybSBpbmRpdmlkdWFsIGxvb2t1cHMuXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhcmdldCA9IHF1ZXJ5VG9UYXJnZXQocXVlcnkpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXJcbiAgICAgICAgICAgIC5nZXRJbmRleFR5cGUodHJhbnNhY3Rpb24sIHRhcmdldClcbiAgICAgICAgICAgIC5uZXh0KGluZGV4VHlwZSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5kZXhUeXBlID09PSAwIC8qIEluZGV4VHlwZS5OT05FICovKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHRhcmdldCBjYW5ub3QgYmUgc2VydmVkIGZyb20gYW55IGluZGV4LlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHF1ZXJ5LmxpbWl0ICE9PSBudWxsICYmIGluZGV4VHlwZSA9PT0gMSAvKiBJbmRleFR5cGUuUEFSVElBTCAqLykge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbm5vdCBhcHBseSBhIGxpbWl0IGZvciB0YXJnZXRzIHRoYXQgYXJlIHNlcnZlZCB1c2luZyBhIHBhcnRpYWxcbiAgICAgICAgICAgICAgICAvLyBpbmRleC4gSWYgYSBwYXJ0aWFsIGluZGV4IHdpbGwgYmUgdXNlZCB0byBzZXJ2ZSB0aGUgdGFyZ2V0LCB0aGVcbiAgICAgICAgICAgICAgICAvLyBxdWVyeSBtYXkgcmV0dXJuIGEgc3VwZXJzZXQgb2YgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggdGhlIHRhcmdldFxuICAgICAgICAgICAgICAgIC8vIChlLmcuIGlmIHRoZSBpbmRleCBkb2Vzbid0IGluY2x1ZGUgYWxsIHRoZSB0YXJnZXQncyBmaWx0ZXJzKSwgb3JcbiAgICAgICAgICAgICAgICAvLyBtYXkgcmV0dXJuIHRoZSBjb3JyZWN0IHNldCBvZiBkb2N1bWVudHMgaW4gdGhlIHdyb25nIG9yZGVyIChlLmcuIGlmXG4gICAgICAgICAgICAgICAgLy8gdGhlIGluZGV4IGRvZXNuJ3QgaW5jbHVkZSBhIHNlZ21lbnQgZm9yIG9uZSBvZiB0aGUgb3JkZXJCeXMpLlxuICAgICAgICAgICAgICAgIC8vIFRoZXJlZm9yZSwgYSBsaW1pdCBzaG91bGQgbm90IGJlIGFwcGxpZWQgaW4gc3VjaCBjYXNlcy5cbiAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5V2l0aExpbWl0KHF1ZXJ5LCBudWxsLCBcIkZcIiAvKiBMaW1pdFR5cGUuRmlyc3QgKi8pO1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHF1ZXJ5VG9UYXJnZXQocXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYW5hZ2VyXG4gICAgICAgICAgICAgICAgLmdldERvY3VtZW50c01hdGNoaW5nVGFyZ2V0KHRyYW5zYWN0aW9uLCB0YXJnZXQpXG4gICAgICAgICAgICAgICAgLm5leHQoa2V5cyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkS2V5cyA9IGRvY3VtZW50S2V5U2V0KC4uLmtleXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsRG9jdW1lbnRzVmlld1xuICAgICAgICAgICAgICAgICAgICAuZ2V0RG9jdW1lbnRzKHRyYW5zYWN0aW9uLCBzb3J0ZWRLZXlzKVxuICAgICAgICAgICAgICAgICAgICAubmV4dChpbmRleGVkRG9jdW1lbnRzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYW5hZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0TWluT2Zmc2V0KHRyYW5zYWN0aW9uLCB0YXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAubmV4dChvZmZzZXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNSZXN1bHRzID0gdGhpcy5hcHBseVF1ZXJ5KHF1ZXJ5LCBpbmRleGVkRG9jdW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5lZWRzUmVmaWxsKHF1ZXJ5LCBwcmV2aW91c1Jlc3VsdHMsIHNvcnRlZEtleXMsIG9mZnNldC5yZWFkVGltZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGxpbWl0IHF1ZXJ5IHdob3NlIGJvdW5kYXJpZXMgY2hhbmdlIGR1ZSB0byBsb2NhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVkaXRzIGNhbiBiZSByZS1ydW4gYWdhaW5zdCB0aGUgY2FjaGUgYnkgZXhjbHVkaW5nIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxpbWl0LiBUaGlzIGVuc3VyZXMgdGhhdCBhbGwgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcXVlcnkncyBmaWx0ZXJzIGFyZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IHNldC4gVGhlIFNES1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiB0aGVuIGFwcGx5IHRoZSBsaW1pdCBvbmNlIGFsbCBsb2NhbCBlZGl0cyBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmNvcnBvcmF0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVF1ZXJ5VXNpbmdJbmRleCh0cmFuc2FjdGlvbiwgcXVlcnlXaXRoTGltaXQocXVlcnksIG51bGwsIFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqLykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kUmVtYWluaW5nUmVzdWx0cyh0cmFuc2FjdGlvbiwgcHJldmlvdXNSZXN1bHRzLCBxdWVyeSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcXVlcnkgYmFzZWQgb24gdGhlIHRhcmdldCdzIHBlcnNpc3RlZCBxdWVyeSBtYXBwaW5nLiBSZXR1cm5zXG4gICAgICogYG51bGxgIGlmIHRoZSBtYXBwaW5nIGlzIG5vdCBhdmFpbGFibGUgb3IgY2Fubm90IGJlIHVzZWQuXG4gICAgICovXG4gICAgcGVyZm9ybVF1ZXJ5VXNpbmdSZW1vdGVLZXlzKHRyYW5zYWN0aW9uLCBxdWVyeSwgcmVtb3RlS2V5cywgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikge1xuICAgICAgICBpZiAocXVlcnlNYXRjaGVzQWxsRG9jdW1lbnRzKHF1ZXJ5KSkge1xuICAgICAgICAgICAgLy8gUXVlcmllcyB0aGF0IG1hdGNoIGFsbCBkb2N1bWVudHMgZG9uJ3QgYmVuZWZpdCBmcm9tIHVzaW5nXG4gICAgICAgICAgICAvLyBrZXktYmFzZWQgbG9va3Vwcy4gSXQgaXMgbW9yZSBlZmZpY2llbnQgdG8gc2NhbiBhbGwgZG9jdW1lbnRzIGluIGFcbiAgICAgICAgICAgIC8vIGNvbGxlY3Rpb24sIHJhdGhlciB0aGFuIHRvIHBlcmZvcm0gaW5kaXZpZHVhbCBsb29rdXBzLlxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFF1ZXJpZXMgdGhhdCBoYXZlIG5ldmVyIHNlZW4gYSBzbmFwc2hvdCB3aXRob3V0IGxpbWJvIGZyZWUgZG9jdW1lbnRzXG4gICAgICAgIC8vIHNob3VsZCBhbHNvIGJlIHJ1biBhcyBhIGZ1bGwgY29sbGVjdGlvbiBzY2FuLlxuICAgICAgICBpZiAobGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbi5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbERvY3VtZW50c1ZpZXcuZ2V0RG9jdW1lbnRzKHRyYW5zYWN0aW9uLCByZW1vdGVLZXlzKS5uZXh0KGRvY3VtZW50cyA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1Jlc3VsdHMgPSB0aGlzLmFwcGx5UXVlcnkocXVlcnksIGRvY3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5uZWVkc1JlZmlsbChxdWVyeSwgcHJldmlvdXNSZXN1bHRzLCByZW1vdGVLZXlzLCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRMb2dMZXZlbCgpIDw9IExvZ0xldmVsLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1JlLXVzaW5nIHByZXZpb3VzIHJlc3VsdCBmcm9tICVzIHRvIGV4ZWN1dGUgcXVlcnk6ICVzJywgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbi50b1N0cmluZygpLCBzdHJpbmdpZnlRdWVyeShxdWVyeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0cmlldmUgYWxsIHJlc3VsdHMgZm9yIGRvY3VtZW50cyB0aGF0IHdlcmUgdXBkYXRlZCBzaW5jZSB0aGUgbGFzdFxuICAgICAgICAgICAgLy8gbGltYm8tZG9jdW1lbnQgZnJlZSByZW1vdGUgc25hcHNob3QuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmRSZW1haW5pbmdSZXN1bHRzKHRyYW5zYWN0aW9uLCBwcmV2aW91c1Jlc3VsdHMsIHF1ZXJ5LCBuZXdJbmRleE9mZnNldFN1Y2Nlc3NvckZyb21SZWFkVGltZShsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLCBJTklUSUFMX0xBUkdFU1RfQkFUQ0hfSUQpKS5uZXh0KHJlc3VsdHMgPT4gcmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQXBwbGllcyB0aGUgcXVlcnkgZmlsdGVyIGFuZCBzb3J0aW5nIHRvIHRoZSBwcm92aWRlZCBkb2N1bWVudHMuICAqL1xuICAgIGFwcGx5UXVlcnkocXVlcnksIGRvY3VtZW50cykge1xuICAgICAgICAvLyBTb3J0IHRoZSBkb2N1bWVudHMgYW5kIHJlLWFwcGx5IHRoZSBxdWVyeSBmaWx0ZXIgc2luY2UgcHJldmlvdXNseVxuICAgICAgICAvLyBtYXRjaGluZyBkb2N1bWVudHMgZG8gbm90IG5lY2Vzc2FyaWx5IHN0aWxsIG1hdGNoIHRoZSBxdWVyeS5cbiAgICAgICAgbGV0IHF1ZXJ5UmVzdWx0cyA9IG5ldyBTb3J0ZWRTZXQobmV3UXVlcnlDb21wYXJhdG9yKHF1ZXJ5KSk7XG4gICAgICAgIGRvY3VtZW50cy5mb3JFYWNoKChfLCBtYXliZURvYykgPT4ge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgbWF5YmVEb2MpKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlSZXN1bHRzID0gcXVlcnlSZXN1bHRzLmFkZChtYXliZURvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcXVlcnlSZXN1bHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgbGltaXQgcXVlcnkgbmVlZHMgdG8gYmUgcmVmaWxsZWQgZnJvbSBjYWNoZSwgbWFraW5nIGl0XG4gICAgICogaW5lbGlnaWJsZSBmb3IgaW5kZXgtZnJlZSBleGVjdXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkuXG4gICAgICogQHBhcmFtIHNvcnRlZFByZXZpb3VzUmVzdWx0cyAtIFRoZSBkb2N1bWVudHMgdGhhdCBtYXRjaGVkIHRoZSBxdWVyeSB3aGVuIGl0XG4gICAgICogd2FzIGxhc3Qgc3luY2hyb25pemVkLCBzb3J0ZWQgYnkgdGhlIHF1ZXJ5J3MgY29tcGFyYXRvci5cbiAgICAgKiBAcGFyYW0gcmVtb3RlS2V5cyAtIFRoZSBkb2N1bWVudCBrZXlzIHRoYXQgbWF0Y2hlZCB0aGUgcXVlcnkgYXQgdGhlIGxhc3RcbiAgICAgKiBzbmFwc2hvdC5cbiAgICAgKiBAcGFyYW0gbGltYm9GcmVlU25hcHNob3RWZXJzaW9uIC0gVGhlIHZlcnNpb24gb2YgdGhlIHNuYXBzaG90IHdoZW4gdGhlXG4gICAgICogcXVlcnkgd2FzIGxhc3Qgc3luY2hyb25pemVkLlxuICAgICAqL1xuICAgIG5lZWRzUmVmaWxsKHF1ZXJ5LCBzb3J0ZWRQcmV2aW91c1Jlc3VsdHMsIHJlbW90ZUtleXMsIGxpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikge1xuICAgICAgICBpZiAocXVlcnkubGltaXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFF1ZXJpZXMgd2l0aG91dCBsaW1pdHMgZG8gbm90IG5lZWQgdG8gYmUgcmVmaWxsZWQuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW90ZUtleXMuc2l6ZSAhPT0gc29ydGVkUHJldmlvdXNSZXN1bHRzLnNpemUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBxdWVyeSBuZWVkcyB0byBiZSByZWZpbGxlZCBpZiBhIHByZXZpb3VzbHkgbWF0Y2hpbmcgZG9jdW1lbnQgbm9cbiAgICAgICAgICAgIC8vIGxvbmdlciBtYXRjaGVzLlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGltaXQgcXVlcmllcyBhcmUgbm90IGVsaWdpYmxlIGZvciBpbmRleC1mcmVlIHF1ZXJ5IGV4ZWN1dGlvbiBpZiB0aGVyZSBpc1xuICAgICAgICAvLyBhIHBvdGVudGlhbCB0aGF0IGFuIG9sZGVyIGRvY3VtZW50IGZyb20gY2FjaGUgbm93IHNvcnRzIGJlZm9yZSBhIGRvY3VtZW50XG4gICAgICAgIC8vIHRoYXQgd2FzIHByZXZpb3VzbHkgcGFydCBvZiB0aGUgbGltaXQuIFRoaXMsIGhvd2V2ZXIsIGNhbiBvbmx5IGhhcHBlbiBpZlxuICAgICAgICAvLyB0aGUgZG9jdW1lbnQgYXQgdGhlIGVkZ2Ugb2YgdGhlIGxpbWl0IGdvZXMgb3V0IG9mIGxpbWl0LlxuICAgICAgICAvLyBJZiBhIGRvY3VtZW50IHRoYXQgaXMgbm90IHRoZSBsaW1pdCBib3VuZGFyeSBzb3J0cyBkaWZmZXJlbnRseSxcbiAgICAgICAgLy8gdGhlIGJvdW5kYXJ5IG9mIHRoZSBsaW1pdCBpdHNlbGYgZGlkIG5vdCBjaGFuZ2UgYW5kIGRvY3VtZW50cyBmcm9tIGNhY2hlXG4gICAgICAgIC8vIHdpbGwgY29udGludWUgdG8gYmUgXCJyZWplY3RlZFwiIGJ5IHRoaXMgYm91bmRhcnkuIFRoZXJlZm9yZSwgd2UgY2FuIGlnbm9yZVxuICAgICAgICAvLyBhbnkgbW9kaWZpY2F0aW9ucyB0aGF0IGRvbid0IGFmZmVjdCB0aGUgbGFzdCBkb2N1bWVudC5cbiAgICAgICAgY29uc3QgZG9jQXRMaW1pdEVkZ2UgPSBxdWVyeS5saW1pdFR5cGUgPT09IFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqL1xuICAgICAgICAgICAgPyBzb3J0ZWRQcmV2aW91c1Jlc3VsdHMubGFzdCgpXG4gICAgICAgICAgICA6IHNvcnRlZFByZXZpb3VzUmVzdWx0cy5maXJzdCgpO1xuICAgICAgICBpZiAoIWRvY0F0TGltaXRFZGdlKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlZmlsbCB0aGUgcXVlcnkgaWYgdGhlcmUgd2VyZSBhbHJlYWR5IG5vIGRvY3VtZW50cy5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGRvY0F0TGltaXRFZGdlLmhhc1BlbmRpbmdXcml0ZXMgfHxcbiAgICAgICAgICAgIGRvY0F0TGltaXRFZGdlLnZlcnNpb24uY29tcGFyZVRvKGxpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikgPiAwKTtcbiAgICB9XG4gICAgZXhlY3V0ZUZ1bGxDb2xsZWN0aW9uU2Nhbih0cmFuc2FjdGlvbiwgcXVlcnksIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPD0gTG9nTGV2ZWwuREVCVUcpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdRdWVyeUVuZ2luZScsICdVc2luZyBmdWxsIGNvbGxlY3Rpb24gc2NhbiB0byBleGVjdXRlIHF1ZXJ5OicsIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxEb2N1bWVudHNWaWV3LmdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBJbmRleE9mZnNldC5taW4oKSwgY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbWJpbmVzIHRoZSByZXN1bHRzIGZyb20gYW4gaW5kZXhlZCBleGVjdXRpb24gd2l0aCB0aGUgcmVtYWluaW5nIGRvY3VtZW50c1xuICAgICAqIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW4gaW5kZXhlZC5cbiAgICAgKi9cbiAgICBhcHBlbmRSZW1haW5pbmdSZXN1bHRzKHRyYW5zYWN0aW9uLCBpbmRleGVkUmVzdWx0cywgcXVlcnksIG9mZnNldCkge1xuICAgICAgICAvLyBSZXRyaWV2ZSBhbGwgcmVzdWx0cyBmb3IgZG9jdW1lbnRzIHRoYXQgd2VyZSB1cGRhdGVkIHNpbmNlIHRoZSBvZmZzZXQuXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsRG9jdW1lbnRzVmlld1xuICAgICAgICAgICAgLmdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBvZmZzZXQpXG4gICAgICAgICAgICAubmV4dChyZW1haW5pbmdSZXN1bHRzID0+IHtcbiAgICAgICAgICAgIC8vIE1lcmdlIHdpdGggZXhpc3RpbmcgcmVzdWx0c1xuICAgICAgICAgICAgaW5kZXhlZFJlc3VsdHMuZm9yRWFjaChkID0+IHtcbiAgICAgICAgICAgICAgICByZW1haW5pbmdSZXN1bHRzID0gcmVtYWluaW5nUmVzdWx0cy5pbnNlcnQoZC5rZXksIGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVtYWluaW5nUmVzdWx0cztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gVGhlIGZvcm1hdCBvZiB0aGUgTG9jYWxTdG9yYWdlIGtleSB0aGF0IHN0b3JlcyB0aGUgY2xpZW50IHN0YXRlIGlzOlxuLy8gICAgIGZpcmVzdG9yZV9jbGllbnRzXzxwZXJzaXN0ZW5jZV9wcmVmaXg+XzxpbnN0YW5jZV9rZXk+XG5jb25zdCBDTElFTlRfU1RBVEVfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfY2xpZW50cyc7XG4vKiogQXNzZW1ibGVzIHRoZSBrZXkgZm9yIGEgY2xpZW50IHN0YXRlIGluIFdlYlN0b3JhZ2UgKi9cbmZ1bmN0aW9uIGNyZWF0ZVdlYlN0b3JhZ2VDbGllbnRTdGF0ZUtleShwZXJzaXN0ZW5jZUtleSwgY2xpZW50SWQpIHtcbiAgICByZXR1cm4gYCR7Q0xJRU5UX1NUQVRFX0tFWV9QUkVGSVh9XyR7cGVyc2lzdGVuY2VLZXl9XyR7Y2xpZW50SWR9YDtcbn1cbi8vIFRoZSBmb3JtYXQgb2YgdGhlIFdlYlN0b3JhZ2Uga2V5IHRoYXQgc3RvcmVzIHRoZSBtdXRhdGlvbiBzdGF0ZSBpczpcbi8vICAgICBmaXJlc3RvcmVfbXV0YXRpb25zXzxwZXJzaXN0ZW5jZV9wcmVmaXg+XzxiYXRjaF9pZD5cbi8vICAgICAoZm9yIHVuYXV0aGVudGljYXRlZCB1c2Vycylcbi8vIG9yOiBmaXJlc3RvcmVfbXV0YXRpb25zXzxwZXJzaXN0ZW5jZV9wcmVmaXg+XzxiYXRjaF9pZD5fPHVzZXJfdWlkPlxuLy9cbi8vICd1c2VyX3VpZCcgaXMgbGFzdCB0byBhdm9pZCBuZWVkaW5nIHRvIGVzY2FwZSAnXycgY2hhcmFjdGVycyB0aGF0IGl0IG1pZ2h0XG4vLyBjb250YWluLlxuY29uc3QgTVVUQVRJT05fQkFUQ0hfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfbXV0YXRpb25zJztcbi8qKiBBc3NlbWJsZXMgdGhlIGtleSBmb3IgYSBtdXRhdGlvbiBiYXRjaCBpbiBXZWJTdG9yYWdlICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTdG9yYWdlTXV0YXRpb25CYXRjaEtleShwZXJzaXN0ZW5jZUtleSwgdXNlciwgYmF0Y2hJZCkge1xuICAgIGxldCBtdXRhdGlvbktleSA9IGAke01VVEFUSU9OX0JBVENIX0tFWV9QUkVGSVh9XyR7cGVyc2lzdGVuY2VLZXl9XyR7YmF0Y2hJZH1gO1xuICAgIGlmICh1c2VyLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICAgIG11dGF0aW9uS2V5ICs9IGBfJHt1c2VyLnVpZH1gO1xuICAgIH1cbiAgICByZXR1cm4gbXV0YXRpb25LZXk7XG59XG4vLyBUaGUgZm9ybWF0IG9mIHRoZSBXZWJTdG9yYWdlIGtleSB0aGF0IHN0b3JlcyBhIHF1ZXJ5IHRhcmdldCdzIG1ldGFkYXRhIGlzOlxuLy8gICAgIGZpcmVzdG9yZV90YXJnZXRzXzxwZXJzaXN0ZW5jZV9wcmVmaXg+Xzx0YXJnZXRfaWQ+XG5jb25zdCBRVUVSWV9UQVJHRVRfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfdGFyZ2V0cyc7XG4vKiogQXNzZW1ibGVzIHRoZSBrZXkgZm9yIGEgcXVlcnkgc3RhdGUgaW4gV2ViU3RvcmFnZSAqL1xuZnVuY3Rpb24gY3JlYXRlV2ViU3RvcmFnZVF1ZXJ5VGFyZ2V0TWV0YWRhdGFLZXkocGVyc2lzdGVuY2VLZXksIHRhcmdldElkKSB7XG4gICAgcmV0dXJuIGAke1FVRVJZX1RBUkdFVF9LRVlfUFJFRklYfV8ke3BlcnNpc3RlbmNlS2V5fV8ke3RhcmdldElkfWA7XG59XG4vLyBUaGUgV2ViU3RvcmFnZSBwcmVmaXggdGhhdCBzdG9yZXMgdGhlIHByaW1hcnkgdGFiJ3Mgb25saW5lIHN0YXRlLiBUaGVcbi8vIGZvcm1hdCBvZiB0aGUga2V5IGlzOlxuLy8gICAgIGZpcmVzdG9yZV9vbmxpbmVfc3RhdGVfPHBlcnNpc3RlbmNlX3ByZWZpeD5cbmNvbnN0IE9OTElORV9TVEFURV9LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV9vbmxpbmVfc3RhdGUnO1xuLyoqIEFzc2VtYmxlcyB0aGUga2V5IGZvciB0aGUgb25saW5lIHN0YXRlIG9mIHRoZSBwcmltYXJ5IHRhYi4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVdlYlN0b3JhZ2VPbmxpbmVTdGF0ZUtleShwZXJzaXN0ZW5jZUtleSkge1xuICAgIHJldHVybiBgJHtPTkxJTkVfU1RBVEVfS0VZX1BSRUZJWH1fJHtwZXJzaXN0ZW5jZUtleX1gO1xufVxuLy8gVGhlIFdlYlN0b3JhZ2UgcHJlZml4IHRoYXQgcGxheXMgYXMgYSBldmVudCB0byBpbmRpY2F0ZSB0aGUgcmVtb3RlIGRvY3VtZW50c1xuLy8gbWlnaHQgaGF2ZSBjaGFuZ2VkIGR1ZSB0byBzb21lIHNlY29uZGFyeSB0YWJzIGxvYWRpbmcgYSBidW5kbGUuXG4vLyBmb3JtYXQgb2YgdGhlIGtleSBpczpcbi8vICAgICBmaXJlc3RvcmVfYnVuZGxlX2xvYWRlZF92Ml88cGVyc2lzdGVuY2VLZXk+XG4vLyBUaGUgdmVyc2lvbiBlbmRpbmcgd2l0aCBcInYyXCIgc3RvcmVzIHRoZSBsaXN0IG9mIG1vZGlmaWVkIGNvbGxlY3Rpb24gZ3JvdXBzLlxuY29uc3QgQlVORExFX0xPQURFRF9LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV9idW5kbGVfbG9hZGVkX3YyJztcbmZ1bmN0aW9uIGNyZWF0ZUJ1bmRsZUxvYWRlZEtleShwZXJzaXN0ZW5jZUtleSkge1xuICAgIHJldHVybiBgJHtCVU5ETEVfTE9BREVEX0tFWV9QUkVGSVh9XyR7cGVyc2lzdGVuY2VLZXl9YDtcbn1cbi8vIFRoZSBXZWJTdG9yYWdlIGtleSBwcmVmaXggZm9yIHRoZSBrZXkgdGhhdCBzdG9yZXMgdGhlIGxhc3Qgc2VxdWVuY2UgbnVtYmVyIGFsbG9jYXRlZC4gVGhlIGtleVxuLy8gbG9va3MgbGlrZSAnZmlyZXN0b3JlX3NlcXVlbmNlX251bWJlcl88cGVyc2lzdGVuY2VfcHJlZml4PicuXG5jb25zdCBTRVFVRU5DRV9OVU1CRVJfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfc2VxdWVuY2VfbnVtYmVyJztcbi8qKiBBc3NlbWJsZXMgdGhlIGtleSBmb3IgdGhlIGN1cnJlbnQgc2VxdWVuY2UgbnVtYmVyLiAqL1xuZnVuY3Rpb24gY3JlYXRlV2ViU3RvcmFnZVNlcXVlbmNlTnVtYmVyS2V5KHBlcnNpc3RlbmNlS2V5KSB7XG4gICAgcmV0dXJuIGAke1NFUVVFTkNFX05VTUJFUl9LRVlfUFJFRklYfV8ke3BlcnNpc3RlbmNlS2V5fWA7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJGEgPSAnU2hhcmVkQ2xpZW50U3RhdGUnO1xuLyoqXG4gKiBIb2xkcyB0aGUgc3RhdGUgb2YgYSBtdXRhdGlvbiBiYXRjaCwgaW5jbHVkaW5nIGl0cyB1c2VyIElELCBiYXRjaCBJRCBhbmRcbiAqIHdoZXRoZXIgdGhlIGJhdGNoIGlzICdwZW5kaW5nJywgJ2Fja25vd2xlZGdlZCcgb3IgJ3JlamVjdGVkJy5cbiAqL1xuLy8gVmlzaWJsZSBmb3IgdGVzdGluZ1xuY2xhc3MgTXV0YXRpb25NZXRhZGF0YSB7XG4gICAgY29uc3RydWN0b3IodXNlciwgYmF0Y2hJZCwgc3RhdGUsIGVycm9yKSB7XG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgICAgIHRoaXMuYmF0Y2hJZCA9IGJhdGNoSWQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBNdXRhdGlvbk1ldGFkYXRhIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gaW4gV2ViU3RvcmFnZS5cbiAgICAgKiBMb2dzIGEgd2FybmluZyBhbmQgcmV0dXJucyBudWxsIGlmIHRoZSBmb3JtYXQgb2YgdGhlIGRhdGEgaXMgbm90IHZhbGlkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tV2ViU3RvcmFnZUVudHJ5KHVzZXIsIGJhdGNoSWQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uQmF0Y2ggPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgbGV0IHZhbGlkRGF0YSA9IHR5cGVvZiBtdXRhdGlvbkJhdGNoID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgWydwZW5kaW5nJywgJ2Fja25vd2xlZGdlZCcsICdyZWplY3RlZCddLmluZGV4T2YobXV0YXRpb25CYXRjaC5zdGF0ZSkgIT09XG4gICAgICAgICAgICAgICAgLTEgJiZcbiAgICAgICAgICAgIChtdXRhdGlvbkJhdGNoLmVycm9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgbXV0YXRpb25CYXRjaC5lcnJvciA9PT0gJ29iamVjdCcpO1xuICAgICAgICBsZXQgZmlyZXN0b3JlRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh2YWxpZERhdGEgJiYgbXV0YXRpb25CYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgdmFsaWREYXRhID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgbXV0YXRpb25CYXRjaC5lcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbXV0YXRpb25CYXRjaC5lcnJvci5jb2RlID09PSAnc3RyaW5nJztcbiAgICAgICAgICAgIGlmICh2YWxpZERhdGEpIHtcbiAgICAgICAgICAgICAgICBmaXJlc3RvcmVFcnJvciA9IG5ldyBGaXJlc3RvcmVFcnJvcihtdXRhdGlvbkJhdGNoLmVycm9yLmNvZGUsIG11dGF0aW9uQmF0Y2guZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNdXRhdGlvbk1ldGFkYXRhKHVzZXIsIGJhdGNoSWQsIG11dGF0aW9uQmF0Y2guc3RhdGUsIGZpcmVzdG9yZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYSwgYEZhaWxlZCB0byBwYXJzZSBtdXRhdGlvbiBzdGF0ZSBmb3IgSUQgJyR7YmF0Y2hJZH0nOiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9XZWJTdG9yYWdlSlNPTigpIHtcbiAgICAgICAgY29uc3QgYmF0Y2hNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgdXBkYXRlVGltZU1zOiBEYXRlLm5vdygpIC8vIE1vZGlmeSB0aGUgZXhpc3RpbmcgdmFsdWUgdG8gdHJpZ2dlciB1cGRhdGUuXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICBiYXRjaE1ldGFkYXRhLmVycm9yID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IHRoaXMuZXJyb3IuY29kZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0aGlzLmVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGJhdGNoTWV0YWRhdGEpO1xuICAgIH1cbn1cbi8qKlxuICogSG9sZHMgdGhlIHN0YXRlIG9mIGEgcXVlcnkgdGFyZ2V0LCBpbmNsdWRpbmcgaXRzIHRhcmdldCBJRCBhbmQgd2hldGhlciB0aGVcbiAqIHRhcmdldCBpcyAnbm90LWN1cnJlbnQnLCAnY3VycmVudCcgb3IgJ3JlamVjdGVkJy5cbiAqL1xuLy8gVmlzaWJsZSBmb3IgdGVzdGluZ1xuY2xhc3MgUXVlcnlUYXJnZXRNZXRhZGF0YSB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0SWQsIHN0YXRlLCBlcnJvcikge1xuICAgICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBRdWVyeVRhcmdldE1ldGFkYXRhIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gaW4gV2ViU3RvcmFnZS5cbiAgICAgKiBMb2dzIGEgd2FybmluZyBhbmQgcmV0dXJucyBudWxsIGlmIHRoZSBmb3JtYXQgb2YgdGhlIGRhdGEgaXMgbm90IHZhbGlkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tV2ViU3RvcmFnZUVudHJ5KHRhcmdldElkLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICBsZXQgdmFsaWREYXRhID0gdHlwZW9mIHRhcmdldFN0YXRlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgWydub3QtY3VycmVudCcsICdjdXJyZW50JywgJ3JlamVjdGVkJ10uaW5kZXhPZih0YXJnZXRTdGF0ZS5zdGF0ZSkgIT09XG4gICAgICAgICAgICAgICAgLTEgJiZcbiAgICAgICAgICAgICh0YXJnZXRTdGF0ZS5lcnJvciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFN0YXRlLmVycm9yID09PSAnb2JqZWN0Jyk7XG4gICAgICAgIGxldCBmaXJlc3RvcmVFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHZhbGlkRGF0YSAmJiB0YXJnZXRTdGF0ZS5lcnJvcikge1xuICAgICAgICAgICAgdmFsaWREYXRhID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0U3RhdGUuZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFN0YXRlLmVycm9yLmNvZGUgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgaWYgKHZhbGlkRGF0YSkge1xuICAgICAgICAgICAgICAgIGZpcmVzdG9yZUVycm9yID0gbmV3IEZpcmVzdG9yZUVycm9yKHRhcmdldFN0YXRlLmVycm9yLmNvZGUsIHRhcmdldFN0YXRlLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWxpZERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUXVlcnlUYXJnZXRNZXRhZGF0YSh0YXJnZXRJZCwgdGFyZ2V0U3RhdGUuc3RhdGUsIGZpcmVzdG9yZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYSwgYEZhaWxlZCB0byBwYXJzZSB0YXJnZXQgc3RhdGUgZm9yIElEICcke3RhcmdldElkfSc6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1dlYlN0b3JhZ2VKU09OKCkge1xuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHtcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgdXBkYXRlVGltZU1zOiBEYXRlLm5vdygpIC8vIE1vZGlmeSB0aGUgZXhpc3RpbmcgdmFsdWUgdG8gdHJpZ2dlciB1cGRhdGUuXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICB0YXJnZXRTdGF0ZS5lcnJvciA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiB0aGlzLmVycm9yLmNvZGUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5lcnJvci5tZXNzYWdlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0YXJnZXRTdGF0ZSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIGltbXV0YWJsZSBDbGllbnRTdGF0ZSBmb3IgYSBjbGllbnQgcmVhZCBmcm9tXG4gKiBXZWJTdG9yYWdlLCBjb250YWluaW5nIHRoZSBsaXN0IG9mIGFjdGl2ZSBxdWVyeSB0YXJnZXRzLlxuICovXG5jbGFzcyBSZW1vdGVDbGllbnRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50SWQsIGFjdGl2ZVRhcmdldElkcykge1xuICAgICAgICB0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgIHRoaXMuYWN0aXZlVGFyZ2V0SWRzID0gYWN0aXZlVGFyZ2V0SWRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBSZW1vdGVDbGllbnRTdGF0ZSBmcm9tIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIGluIFdlYlN0b3JhZ2UuXG4gICAgICogTG9ncyBhIHdhcm5pbmcgYW5kIHJldHVybnMgbnVsbCBpZiB0aGUgZm9ybWF0IG9mIHRoZSBkYXRhIGlzIG5vdCB2YWxpZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVdlYlN0b3JhZ2VFbnRyeShjbGllbnRJZCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2xpZW50U3RhdGUgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgbGV0IHZhbGlkRGF0YSA9IHR5cGVvZiBjbGllbnRTdGF0ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIGNsaWVudFN0YXRlLmFjdGl2ZVRhcmdldElkcyBpbnN0YW5jZW9mIEFycmF5O1xuICAgICAgICBsZXQgYWN0aXZlVGFyZ2V0SWRzU2V0ID0gdGFyZ2V0SWRTZXQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IHZhbGlkRGF0YSAmJiBpIDwgY2xpZW50U3RhdGUuYWN0aXZlVGFyZ2V0SWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YWxpZERhdGEgPSBpc1NhZmVJbnRlZ2VyKGNsaWVudFN0YXRlLmFjdGl2ZVRhcmdldElkc1tpXSk7XG4gICAgICAgICAgICBhY3RpdmVUYXJnZXRJZHNTZXQgPSBhY3RpdmVUYXJnZXRJZHNTZXQuYWRkKGNsaWVudFN0YXRlLmFjdGl2ZVRhcmdldElkc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdGVDbGllbnRTdGF0ZShjbGllbnRJZCwgYWN0aXZlVGFyZ2V0SWRzU2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYSwgYEZhaWxlZCB0byBwYXJzZSBjbGllbnQgZGF0YSBmb3IgaW5zdGFuY2UgJyR7Y2xpZW50SWR9JzogJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIG9ubGluZSBzdGF0ZSBmb3IgYWxsIGNsaWVudHMgcGFydGljaXBhdGluZyBpblxuICogbXVsdGktdGFiLiBUaGUgb25saW5lIHN0YXRlIGlzIG9ubHkgd3JpdHRlbiB0byBieSB0aGUgcHJpbWFyeSBjbGllbnQsIGFuZFxuICogdXNlZCBpbiBzZWNvbmRhcnkgY2xpZW50cyB0byB1cGRhdGUgdGhlaXIgcXVlcnkgdmlld3MuXG4gKi9cbmNsYXNzIFNoYXJlZE9ubGluZVN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnRJZCwgb25saW5lU3RhdGUpIHtcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICB0aGlzLm9ubGluZVN0YXRlID0gb25saW5lU3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIFNoYXJlZE9ubGluZVN0YXRlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gaW4gV2ViU3RvcmFnZS5cbiAgICAgKiBMb2dzIGEgd2FybmluZyBhbmQgcmV0dXJucyBudWxsIGlmIHRoZSBmb3JtYXQgb2YgdGhlIGRhdGEgaXMgbm90IHZhbGlkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tV2ViU3RvcmFnZUVudHJ5KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG9ubGluZVN0YXRlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHZhbGlkRGF0YSA9IHR5cGVvZiBvbmxpbmVTdGF0ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIFsnVW5rbm93bicsICdPbmxpbmUnLCAnT2ZmbGluZSddLmluZGV4T2Yob25saW5lU3RhdGUub25saW5lU3RhdGUpICE9PVxuICAgICAgICAgICAgICAgIC0xICYmXG4gICAgICAgICAgICB0eXBlb2Ygb25saW5lU3RhdGUuY2xpZW50SWQgPT09ICdzdHJpbmcnO1xuICAgICAgICBpZiAodmFsaWREYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNoYXJlZE9ubGluZVN0YXRlKG9ubGluZVN0YXRlLmNsaWVudElkLCBvbmxpbmVTdGF0ZS5vbmxpbmVTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dFcnJvcihMT0dfVEFHJGEsIGBGYWlsZWQgdG8gcGFyc2Ugb25saW5lIHN0YXRlOiAke3ZhbHVlfWApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIE1ldGFkYXRhIHN0YXRlIG9mIHRoZSBsb2NhbCBjbGllbnQuIFVubGlrZSBgUmVtb3RlQ2xpZW50U3RhdGVgLCB0aGlzIGNsYXNzIGlzXG4gKiBtdXRhYmxlIGFuZCBrZWVwcyB0cmFjayBvZiBhbGwgcGVuZGluZyBtdXRhdGlvbnMsIHdoaWNoIGFsbG93cyB1cyB0b1xuICogdXBkYXRlIHRoZSByYW5nZSBvZiBwZW5kaW5nIG11dGF0aW9uIGJhdGNoIElEcyBhcyBuZXcgbXV0YXRpb25zIGFyZSBhZGRlZCBvclxuICogcmVtb3ZlZC5cbiAqXG4gKiBUaGUgZGF0YSBpbiBgTG9jYWxDbGllbnRTdGF0ZWAgaXMgbm90IHJlYWQgZnJvbSBXZWJTdG9yYWdlIGFuZCBpbnN0ZWFkXG4gKiB1cGRhdGVkIHZpYSBpdHMgaW5zdGFuY2UgbWV0aG9kcy4gVGhlIHVwZGF0ZWQgc3RhdGUgY2FuIGJlIHNlcmlhbGl6ZWQgdmlhXG4gKiBgdG9XZWJTdG9yYWdlSlNPTigpYC5cbiAqL1xuLy8gVmlzaWJsZSBmb3IgdGVzdGluZy5cbmNsYXNzIExvY2FsQ2xpZW50U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZVRhcmdldElkcyA9IHRhcmdldElkU2V0KCk7XG4gICAgfVxuICAgIGFkZFF1ZXJ5VGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlVGFyZ2V0SWRzID0gdGhpcy5hY3RpdmVUYXJnZXRJZHMuYWRkKHRhcmdldElkKTtcbiAgICB9XG4gICAgcmVtb3ZlUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVUYXJnZXRJZHMgPSB0aGlzLmFjdGl2ZVRhcmdldElkcy5kZWxldGUodGFyZ2V0SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIGVudHJ5IGludG8gYSBKU09OLWVuY29kZWQgZm9ybWF0IHdlIGNhbiB1c2UgZm9yIFdlYlN0b3JhZ2UuXG4gICAgICogRG9lcyBub3QgZW5jb2RlIGBjbGllbnRJZGAgYXMgaXQgaXMgcGFydCBvZiB0aGUga2V5IGluIFdlYlN0b3JhZ2UuXG4gICAgICovXG4gICAgdG9XZWJTdG9yYWdlSlNPTigpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGFjdGl2ZVRhcmdldElkczogdGhpcy5hY3RpdmVUYXJnZXRJZHMudG9BcnJheSgpLFxuICAgICAgICAgICAgdXBkYXRlVGltZU1zOiBEYXRlLm5vdygpIC8vIE1vZGlmeSB0aGUgZXhpc3RpbmcgdmFsdWUgdG8gdHJpZ2dlciB1cGRhdGUuXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG59XG4vKipcbiAqIGBXZWJTdG9yYWdlU2hhcmVkQ2xpZW50U3RhdGVgIHVzZXMgV2ViU3RvcmFnZSAod2luZG93LmxvY2FsU3RvcmFnZSkgYXMgdGhlXG4gKiBiYWNraW5nIHN0b3JlIGZvciB0aGUgU2hhcmVkQ2xpZW50U3RhdGUuIEl0IGtlZXBzIHRyYWNrIG9mIGFsbCBhY3RpdmVcbiAqIGNsaWVudHMgYW5kIHN1cHBvcnRzIG1vZGlmaWNhdGlvbnMgb2YgdGhlIGxvY2FsIGNsaWVudCdzIGRhdGEuXG4gKi9cbmNsYXNzIFdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3Iod2luZG93LCBxdWV1ZSwgcGVyc2lzdGVuY2VLZXksIGxvY2FsQ2xpZW50SWQsIGluaXRpYWxVc2VyKSB7XG4gICAgICAgIHRoaXMud2luZG93ID0gd2luZG93O1xuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2VLZXkgPSBwZXJzaXN0ZW5jZUtleTtcbiAgICAgICAgdGhpcy5sb2NhbENsaWVudElkID0gbG9jYWxDbGllbnRJZDtcbiAgICAgICAgdGhpcy5zeW5jRW5naW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVySGFuZGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcmFnZUxpc3RlbmVyID0gdGhpcy5oYW5kbGVXZWJTdG9yYWdlRXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hY3RpdmVDbGllbnRzID0gbmV3IFNvcnRlZE1hcChwcmltaXRpdmVDb21wYXJhdG9yKTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXB0dXJlcyBXZWJTdG9yYWdlIGV2ZW50cyB0aGF0IG9jY3VyIGJlZm9yZSBgc3RhcnQoKWAgaXMgY2FsbGVkLiBUaGVzZVxuICAgICAgICAgKiBldmVudHMgYXJlIHJlcGxheWVkIG9uY2UgYFdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZWAgaXMgc3RhcnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWFybHlFdmVudHMgPSBbXTtcbiAgICAgICAgLy8gRXNjYXBlIHRoZSBzcGVjaWFsIGNoYXJhY3RlcnMgbWVudGlvbmVkIGhlcmU6XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvR3VpZGUvUmVndWxhcl9FeHByZXNzaW9uc1xuICAgICAgICBjb25zdCBlc2NhcGVkUGVyc2lzdGVuY2VLZXkgPSBwZXJzaXN0ZW5jZUtleS5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSB0aGlzLndpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSBpbml0aWFsVXNlcjtcbiAgICAgICAgdGhpcy5sb2NhbENsaWVudFN0b3JhZ2VLZXkgPSBjcmVhdGVXZWJTdG9yYWdlQ2xpZW50U3RhdGVLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgdGhpcy5sb2NhbENsaWVudElkKTtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZU51bWJlcktleSA9IGNyZWF0ZVdlYlN0b3JhZ2VTZXF1ZW5jZU51bWJlcktleSh0aGlzLnBlcnNpc3RlbmNlS2V5KTtcbiAgICAgICAgdGhpcy5hY3RpdmVDbGllbnRzID0gdGhpcy5hY3RpdmVDbGllbnRzLmluc2VydCh0aGlzLmxvY2FsQ2xpZW50SWQsIG5ldyBMb2NhbENsaWVudFN0YXRlKCkpO1xuICAgICAgICB0aGlzLmNsaWVudFN0YXRlS2V5UmUgPSBuZXcgUmVnRXhwKGBeJHtDTElFTlRfU1RBVEVfS0VZX1BSRUZJWH1fJHtlc2NhcGVkUGVyc2lzdGVuY2VLZXl9XyhbXl9dKikkYCk7XG4gICAgICAgIHRoaXMubXV0YXRpb25CYXRjaEtleVJlID0gbmV3IFJlZ0V4cChgXiR7TVVUQVRJT05fQkFUQ0hfS0VZX1BSRUZJWH1fJHtlc2NhcGVkUGVyc2lzdGVuY2VLZXl9XyhcXFxcZCspKD86XyguKikpPyRgKTtcbiAgICAgICAgdGhpcy5xdWVyeVRhcmdldEtleVJlID0gbmV3IFJlZ0V4cChgXiR7UVVFUllfVEFSR0VUX0tFWV9QUkVGSVh9XyR7ZXNjYXBlZFBlcnNpc3RlbmNlS2V5fV8oXFxcXGQrKSRgKTtcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZUtleSA9IGNyZWF0ZVdlYlN0b3JhZ2VPbmxpbmVTdGF0ZUtleSh0aGlzLnBlcnNpc3RlbmNlS2V5KTtcbiAgICAgICAgdGhpcy5idW5kbGVMb2FkZWRLZXkgPSBjcmVhdGVCdW5kbGVMb2FkZWRLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSk7XG4gICAgICAgIC8vIFJhdGhlciB0aGFuIGFkZGluZyB0aGUgc3RvcmFnZSBvYnNlcnZlciBkdXJpbmcgc3RhcnQoKSwgd2UgYWRkIHRoZVxuICAgICAgICAvLyBzdG9yYWdlIG9ic2VydmVyIGR1cmluZyBpbml0aWFsaXphdGlvbi4gVGhpcyBlbnN1cmVzIHRoYXQgd2UgY29sbGVjdFxuICAgICAgICAvLyBldmVudHMgYmVmb3JlIG90aGVyIGNvbXBvbmVudHMgcG9wdWxhdGUgdGhlaXIgaW5pdGlhbCBzdGF0ZSAoZHVyaW5nIHRoZWlyXG4gICAgICAgIC8vIHJlc3BlY3RpdmUgc3RhcnQoKSBjYWxscykuIE90aGVyd2lzZSwgd2UgbWlnaHQgZm9yIGV4YW1wbGUgbWlzcyBhXG4gICAgICAgIC8vIG11dGF0aW9uIHRoYXQgaXMgYWRkZWQgYWZ0ZXIgTG9jYWxTdG9yZSdzIHN0YXJ0KCkgcHJvY2Vzc2VkIHRoZSBleGlzdGluZ1xuICAgICAgICAvLyBtdXRhdGlvbnMgYnV0IGJlZm9yZSB3ZSBvYnNlcnZlIFdlYlN0b3JhZ2UgZXZlbnRzLlxuICAgICAgICB0aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgdGhpcy5zdG9yYWdlTGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyAndHJ1ZScgaWYgV2ViU3RvcmFnZSBpcyBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuICovXG4gICAgc3RhdGljIGlzQXZhaWxhYmxlKHdpbmRvdykge1xuICAgICAgICByZXR1cm4gISEod2luZG93ICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpO1xuICAgIH1cbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgLy8gUmV0cmlldmUgdGhlIGxpc3Qgb2YgZXhpc3RpbmcgY2xpZW50cyB0byBiYWNrZmlsbCB0aGUgZGF0YSBpblxuICAgICAgICAvLyBTaGFyZWRDbGllbnRTdGF0ZS5cbiAgICAgICAgY29uc3QgZXhpc3RpbmdDbGllbnRzID0gYXdhaXQgdGhpcy5zeW5jRW5naW5lLmdldEFjdGl2ZUNsaWVudHMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjbGllbnRJZCBvZiBleGlzdGluZ0NsaWVudHMpIHtcbiAgICAgICAgICAgIGlmIChjbGllbnRJZCA9PT0gdGhpcy5sb2NhbENsaWVudElkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdG9yYWdlSXRlbSA9IHRoaXMuZ2V0SXRlbShjcmVhdGVXZWJTdG9yYWdlQ2xpZW50U3RhdGVLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgY2xpZW50SWQpKTtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlSXRlbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFN0YXRlID0gUmVtb3RlQ2xpZW50U3RhdGUuZnJvbVdlYlN0b3JhZ2VFbnRyeShjbGllbnRJZCwgc3RvcmFnZUl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChjbGllbnRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudHMgPSB0aGlzLmFjdGl2ZUNsaWVudHMuaW5zZXJ0KGNsaWVudFN0YXRlLmNsaWVudElkLCBjbGllbnRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVyc2lzdENsaWVudFN0YXRlKCk7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIG9ubGluZSBzdGF0ZSBhbmQgY2FsbCB0aGUgY2FsbGJhY2sgaGFuZGxlclxuICAgICAgICAvLyBpZiBhcHBsaWNhYmxlLlxuICAgICAgICBjb25zdCBvbmxpbmVTdGF0ZUpTT04gPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLm9ubGluZVN0YXRlS2V5KTtcbiAgICAgICAgaWYgKG9ubGluZVN0YXRlSlNPTikge1xuICAgICAgICAgICAgY29uc3Qgb25saW5lU3RhdGUgPSB0aGlzLmZyb21XZWJTdG9yYWdlT25saW5lU3RhdGUob25saW5lU3RhdGVKU09OKTtcbiAgICAgICAgICAgIGlmIChvbmxpbmVTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlT25saW5lU3RhdGVFdmVudChvbmxpbmVTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiB0aGlzLmVhcmx5RXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVdlYlN0b3JhZ2VFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYXJseUV2ZW50cyA9IFtdO1xuICAgICAgICAvLyBSZWdpc3RlciBhIHdpbmRvdyB1bmxvYWQgaG9vayB0byByZW1vdmUgdGhlIGNsaWVudCBtZXRhZGF0YSBlbnRyeSBmcm9tXG4gICAgICAgIC8vIFdlYlN0b3JhZ2UgZXZlbiBpZiBgc2h1dGRvd24oKWAgd2FzIG5vdCBjYWxsZWQuXG4gICAgICAgIHRoaXMud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgKCkgPT4gdGhpcy5zaHV0ZG93bigpKTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgd3JpdGVTZXF1ZW5jZU51bWJlcihzZXF1ZW5jZU51bWJlcikge1xuICAgICAgICB0aGlzLnNldEl0ZW0odGhpcy5zZXF1ZW5jZU51bWJlcktleSwgSlNPTi5zdHJpbmdpZnkoc2VxdWVuY2VOdW1iZXIpKTtcbiAgICB9XG4gICAgZ2V0QWxsQWN0aXZlUXVlcnlUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0QWN0aXZlUXVlcnlUYXJnZXRzKHRoaXMuYWN0aXZlQ2xpZW50cyk7XG4gICAgfVxuICAgIGlzQWN0aXZlUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2xpZW50cy5mb3JFYWNoKChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUuYWN0aXZlVGFyZ2V0SWRzLmhhcyh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIGFkZFBlbmRpbmdNdXRhdGlvbihiYXRjaElkKSB7XG4gICAgICAgIHRoaXMucGVyc2lzdE11dGF0aW9uU3RhdGUoYmF0Y2hJZCwgJ3BlbmRpbmcnKTtcbiAgICB9XG4gICAgdXBkYXRlTXV0YXRpb25TdGF0ZShiYXRjaElkLCBzdGF0ZSwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0TXV0YXRpb25TdGF0ZShiYXRjaElkLCBzdGF0ZSwgZXJyb3IpO1xuICAgICAgICAvLyBPbmNlIGEgZmluYWwgbXV0YXRpb24gcmVzdWx0IGlzIG9ic2VydmVkIGJ5IG90aGVyIGNsaWVudHMsIHRoZXkgbm8gbG9uZ2VyXG4gICAgICAgIC8vIGFjY2VzcyB0aGUgbXV0YXRpb24ncyBtZXRhZGF0YSBlbnRyeS4gU2luY2UgV2ViU3RvcmFnZSByZXBsYXlzIGV2ZW50c1xuICAgICAgICAvLyBpbiBvcmRlciwgaXQgaXMgc2FmZSB0byBkZWxldGUgdGhlIGVudHJ5IHJpZ2h0IGFmdGVyIHVwZGF0aW5nIGl0LlxuICAgICAgICB0aGlzLnJlbW92ZU11dGF0aW9uU3RhdGUoYmF0Y2hJZCk7XG4gICAgfVxuICAgIGFkZExvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQsIGFkZFRvQWN0aXZlVGFyZ2V0SWRzID0gdHJ1ZSkge1xuICAgICAgICBsZXQgcXVlcnlTdGF0ZSA9ICdub3QtY3VycmVudCc7XG4gICAgICAgIC8vIExvb2t1cCBhbiBleGlzdGluZyBxdWVyeSBzdGF0ZSBpZiB0aGUgdGFyZ2V0IElEIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICAgICAgLy8gYnkgYW5vdGhlciB0YWJcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmVRdWVyeVRhcmdldCh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JhZ2VJdGVtID0gdGhpcy5zdG9yYWdlLmdldEl0ZW0oY3JlYXRlV2ViU3RvcmFnZVF1ZXJ5VGFyZ2V0TWV0YWRhdGFLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgdGFyZ2V0SWQpKTtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlSXRlbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gUXVlcnlUYXJnZXRNZXRhZGF0YS5mcm9tV2ViU3RvcmFnZUVudHJ5KHRhcmdldElkLCBzdG9yYWdlSXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5U3RhdGUgPSBtZXRhZGF0YS5zdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHF1ZXJ5IGlzIGxpc3RlbmluZyB0byBjYWNoZSBvbmx5LCB0aGUgdGFyZ2V0IElEIHNob3VsZCBub3QgYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZVxuICAgICAgICAvLyBsb2NhbCBGaXJlc3RvcmUgY2xpZW50IGFzIGFuIGFjdGl2ZSB3YXRjaCB0YXJnZXQuXG4gICAgICAgIGlmIChhZGRUb0FjdGl2ZVRhcmdldElkcykge1xuICAgICAgICAgICAgdGhpcy5sb2NhbENsaWVudFN0YXRlLmFkZFF1ZXJ5VGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlcnNpc3RDbGllbnRTdGF0ZSgpO1xuICAgICAgICByZXR1cm4gcXVlcnlTdGF0ZTtcbiAgICB9XG4gICAgcmVtb3ZlTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLmxvY2FsQ2xpZW50U3RhdGUucmVtb3ZlUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICB0aGlzLnBlcnNpc3RDbGllbnRTdGF0ZSgpO1xuICAgIH1cbiAgICBpc0xvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxDbGllbnRTdGF0ZS5hY3RpdmVUYXJnZXRJZHMuaGFzKHRhcmdldElkKTtcbiAgICB9XG4gICAgY2xlYXJRdWVyeVN0YXRlKHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShjcmVhdGVXZWJTdG9yYWdlUXVlcnlUYXJnZXRNZXRhZGF0YUtleSh0aGlzLnBlcnNpc3RlbmNlS2V5LCB0YXJnZXRJZCkpO1xuICAgIH1cbiAgICB1cGRhdGVRdWVyeVN0YXRlKHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0UXVlcnlUYXJnZXRTdGF0ZSh0YXJnZXRJZCwgc3RhdGUsIGVycm9yKTtcbiAgICB9XG4gICAgaGFuZGxlVXNlckNoYW5nZSh1c2VyLCByZW1vdmVkQmF0Y2hJZHMsIGFkZGVkQmF0Y2hJZHMpIHtcbiAgICAgICAgcmVtb3ZlZEJhdGNoSWRzLmZvckVhY2goYmF0Y2hJZCA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZU11dGF0aW9uU3RhdGUoYmF0Y2hJZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gdXNlcjtcbiAgICAgICAgYWRkZWRCYXRjaElkcy5mb3JFYWNoKGJhdGNoSWQgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRQZW5kaW5nTXV0YXRpb24oYmF0Y2hJZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRPbmxpbmVTdGF0ZShvbmxpbmVTdGF0ZSkge1xuICAgICAgICB0aGlzLnBlcnNpc3RPbmxpbmVTdGF0ZShvbmxpbmVTdGF0ZSk7XG4gICAgfVxuICAgIG5vdGlmeUJ1bmRsZUxvYWRlZChjb2xsZWN0aW9uR3JvdXBzKSB7XG4gICAgICAgIHRoaXMucGVyc2lzdEJ1bmRsZUxvYWRlZFN0YXRlKGNvbGxlY3Rpb25Hcm91cHMpO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIHRoaXMuc3RvcmFnZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSXRlbSh0aGlzLmxvY2FsQ2xpZW50U3RvcmFnZUtleSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckYSwgJ1JFQUQnLCBrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRhLCAnU0VUJywga2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZW1vdmVJdGVtKGtleSkge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGEsICdSRU1PVkUnLCBrZXkpO1xuICAgICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgIH1cbiAgICBoYW5kbGVXZWJTdG9yYWdlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgLy8gTm90ZTogVGhlIGZ1bmN0aW9uIGlzIHR5cGVkIHRvIHRha2UgRXZlbnQgdG8gYmUgaW50ZXJmYWNlLWNvbXBhdGlibGUgd2l0aFxuICAgICAgICAvLyBgV2luZG93LmFkZEV2ZW50TGlzdGVuZXJgLlxuICAgICAgICBjb25zdCBzdG9yYWdlRXZlbnQgPSBldmVudDtcbiAgICAgICAgaWYgKHN0b3JhZ2VFdmVudC5zdG9yYWdlQXJlYSA9PT0gdGhpcy5zdG9yYWdlKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGEsICdFVkVOVCcsIHN0b3JhZ2VFdmVudC5rZXksIHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50LmtleSA9PT0gdGhpcy5sb2NhbENsaWVudFN0b3JhZ2VLZXkpIHtcbiAgICAgICAgICAgICAgICBsb2dFcnJvcignUmVjZWl2ZWQgV2ViU3RvcmFnZSBub3RpZmljYXRpb24gZm9yIGxvY2FsIGNoYW5nZS4gQW5vdGhlciBjbGllbnQgbWlnaHQgaGF2ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2dhcmJhZ2UtY29sbGVjdGVkIG91ciBzdGF0ZScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZVJldHJ5YWJsZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYXJseUV2ZW50cy5wdXNoKHN0b3JhZ2VFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2VFdmVudC5rZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbGllbnRTdGF0ZUtleVJlLnRlc3Qoc3RvcmFnZUV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRTdGF0ZSA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VDbGllbnRTdGF0ZShzdG9yYWdlRXZlbnQua2V5LCBzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWVudFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQ2xpZW50U3RhdGVFdmVudChjbGllbnRTdGF0ZS5jbGllbnRJZCwgY2xpZW50U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50SWQgPSB0aGlzLmZyb21XZWJTdG9yYWdlQ2xpZW50U3RhdGVLZXkoc3RvcmFnZUV2ZW50LmtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDbGllbnRTdGF0ZUV2ZW50KGNsaWVudElkLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm11dGF0aW9uQmF0Y2hLZXlSZS50ZXN0KHN0b3JhZ2VFdmVudC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlRXZlbnQubmV3VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uTWV0YWRhdGEgPSB0aGlzLmZyb21XZWJTdG9yYWdlTXV0YXRpb25NZXRhZGF0YShzdG9yYWdlRXZlbnQua2V5LCBzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVNdXRhdGlvbkJhdGNoRXZlbnQobXV0YXRpb25NZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5xdWVyeVRhcmdldEtleVJlLnRlc3Qoc3RvcmFnZUV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcXVlcnlUYXJnZXRNZXRhZGF0YSA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VRdWVyeVRhcmdldE1ldGFkYXRhKHN0b3JhZ2VFdmVudC5rZXksIHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnlUYXJnZXRNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVF1ZXJ5VGFyZ2V0RXZlbnQocXVlcnlUYXJnZXRNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RvcmFnZUV2ZW50LmtleSA9PT0gdGhpcy5vbmxpbmVTdGF0ZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbmxpbmVTdGF0ZSA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VPbmxpbmVTdGF0ZShzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ubGluZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlT25saW5lU3RhdGVFdmVudChvbmxpbmVTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RvcmFnZUV2ZW50LmtleSA9PT0gdGhpcy5zZXF1ZW5jZU51bWJlcktleSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlciA9IGZyb21XZWJTdG9yYWdlU2VxdWVuY2VOdW1iZXIoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyICE9PSBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVySGFuZGxlcihzZXF1ZW5jZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RvcmFnZUV2ZW50LmtleSA9PT0gdGhpcy5idW5kbGVMb2FkZWRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbkdyb3VwcyA9IHRoaXMuZnJvbVdlYlN0b3JlQnVuZGxlTG9hZGVkU3RhdGUoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY29sbGVjdGlvbkdyb3Vwcy5tYXAoY2cgPT4gdGhpcy5zeW5jRW5naW5lLnN5bmNocm9uaXplV2l0aENoYW5nZWREb2N1bWVudHMoY2cpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGxvY2FsQ2xpZW50U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUNsaWVudHMuZ2V0KHRoaXMubG9jYWxDbGllbnRJZCk7XG4gICAgfVxuICAgIHBlcnNpc3RDbGllbnRTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5zZXRJdGVtKHRoaXMubG9jYWxDbGllbnRTdG9yYWdlS2V5LCB0aGlzLmxvY2FsQ2xpZW50U3RhdGUudG9XZWJTdG9yYWdlSlNPTigpKTtcbiAgICB9XG4gICAgcGVyc2lzdE11dGF0aW9uU3RhdGUoYmF0Y2hJZCwgc3RhdGUsIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uU3RhdGUgPSBuZXcgTXV0YXRpb25NZXRhZGF0YSh0aGlzLmN1cnJlbnRVc2VyLCBiYXRjaElkLCBzdGF0ZSwgZXJyb3IpO1xuICAgICAgICBjb25zdCBtdXRhdGlvbktleSA9IGNyZWF0ZVdlYlN0b3JhZ2VNdXRhdGlvbkJhdGNoS2V5KHRoaXMucGVyc2lzdGVuY2VLZXksIHRoaXMuY3VycmVudFVzZXIsIGJhdGNoSWQpO1xuICAgICAgICB0aGlzLnNldEl0ZW0obXV0YXRpb25LZXksIG11dGF0aW9uU3RhdGUudG9XZWJTdG9yYWdlSlNPTigpKTtcbiAgICB9XG4gICAgcmVtb3ZlTXV0YXRpb25TdGF0ZShiYXRjaElkKSB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uS2V5ID0gY3JlYXRlV2ViU3RvcmFnZU11dGF0aW9uQmF0Y2hLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgdGhpcy5jdXJyZW50VXNlciwgYmF0Y2hJZCk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShtdXRhdGlvbktleSk7XG4gICAgfVxuICAgIHBlcnNpc3RPbmxpbmVTdGF0ZShvbmxpbmVTdGF0ZSkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmxvY2FsQ2xpZW50SWQsXG4gICAgICAgICAgICBvbmxpbmVTdGF0ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLm9ubGluZVN0YXRlS2V5LCBKU09OLnN0cmluZ2lmeShlbnRyeSkpO1xuICAgIH1cbiAgICBwZXJzaXN0UXVlcnlUYXJnZXRTdGF0ZSh0YXJnZXRJZCwgc3RhdGUsIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEtleSA9IGNyZWF0ZVdlYlN0b3JhZ2VRdWVyeVRhcmdldE1ldGFkYXRhS2V5KHRoaXMucGVyc2lzdGVuY2VLZXksIHRhcmdldElkKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0TWV0YWRhdGEgPSBuZXcgUXVlcnlUYXJnZXRNZXRhZGF0YSh0YXJnZXRJZCwgc3RhdGUsIGVycm9yKTtcbiAgICAgICAgdGhpcy5zZXRJdGVtKHRhcmdldEtleSwgdGFyZ2V0TWV0YWRhdGEudG9XZWJTdG9yYWdlSlNPTigpKTtcbiAgICB9XG4gICAgcGVyc2lzdEJ1bmRsZUxvYWRlZFN0YXRlKGNvbGxlY3Rpb25Hcm91cHMpIHtcbiAgICAgICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20oY29sbGVjdGlvbkdyb3VwcykpO1xuICAgICAgICB0aGlzLnNldEl0ZW0odGhpcy5idW5kbGVMb2FkZWRLZXksIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBjbGllbnQgc3RhdGUga2V5IGluIFdlYlN0b3JhZ2UuIFJldHVybnMgbnVsbCBpZiB0aGUga2V5IGRvZXMgbm90XG4gICAgICogbWF0Y2ggdGhlIGV4cGVjdGVkIGtleSBmb3JtYXQuXG4gICAgICovXG4gICAgZnJvbVdlYlN0b3JhZ2VDbGllbnRTdGF0ZUtleShrZXkpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLmNsaWVudFN0YXRlS2V5UmUuZXhlYyhrZXkpO1xuICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGNsaWVudCBzdGF0ZSBpbiBXZWJTdG9yYWdlLiBSZXR1cm5zICdudWxsJyBpZiB0aGUgdmFsdWUgY291bGQgbm90XG4gICAgICogYmUgcGFyc2VkLlxuICAgICAqL1xuICAgIGZyb21XZWJTdG9yYWdlQ2xpZW50U3RhdGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBjbGllbnRJZCA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VDbGllbnRTdGF0ZUtleShrZXkpO1xuICAgICAgICByZXR1cm4gUmVtb3RlQ2xpZW50U3RhdGUuZnJvbVdlYlN0b3JhZ2VFbnRyeShjbGllbnRJZCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBtdXRhdGlvbiBiYXRjaCBzdGF0ZSBpbiBXZWJTdG9yYWdlLiBSZXR1cm5zICdudWxsJyBpZiB0aGUgdmFsdWVcbiAgICAgKiBjb3VsZCBub3QgYmUgcGFyc2VkLlxuICAgICAqL1xuICAgIGZyb21XZWJTdG9yYWdlTXV0YXRpb25NZXRhZGF0YShrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5tdXRhdGlvbkJhdGNoS2V5UmUuZXhlYyhrZXkpO1xuICAgICAgICBjb25zdCBiYXRjaElkID0gTnVtYmVyKG1hdGNoWzFdKTtcbiAgICAgICAgY29uc3QgdXNlcklkID0gbWF0Y2hbMl0gIT09IHVuZGVmaW5lZCA/IG1hdGNoWzJdIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIE11dGF0aW9uTWV0YWRhdGEuZnJvbVdlYlN0b3JhZ2VFbnRyeShuZXcgVXNlcih1c2VySWQpLCBiYXRjaElkLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHF1ZXJ5IHRhcmdldCBzdGF0ZSBmcm9tIFdlYlN0b3JhZ2UuIFJldHVybnMgJ251bGwnIGlmIHRoZSB2YWx1ZVxuICAgICAqIGNvdWxkIG5vdCBiZSBwYXJzZWQuXG4gICAgICovXG4gICAgZnJvbVdlYlN0b3JhZ2VRdWVyeVRhcmdldE1ldGFkYXRhKGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLnF1ZXJ5VGFyZ2V0S2V5UmUuZXhlYyhrZXkpO1xuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IE51bWJlcihtYXRjaFsxXSk7XG4gICAgICAgIHJldHVybiBRdWVyeVRhcmdldE1ldGFkYXRhLmZyb21XZWJTdG9yYWdlRW50cnkodGFyZ2V0SWQsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIG9ubGluZSBzdGF0ZSBmcm9tIFdlYlN0b3JhZ2UuIFJldHVybnMgJ251bGwnIGlmIHRoZSB2YWx1ZVxuICAgICAqIGNvdWxkIG5vdCBiZSBwYXJzZWQuXG4gICAgICovXG4gICAgZnJvbVdlYlN0b3JhZ2VPbmxpbmVTdGF0ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gU2hhcmVkT25saW5lU3RhdGUuZnJvbVdlYlN0b3JhZ2VFbnRyeSh2YWx1ZSk7XG4gICAgfVxuICAgIGZyb21XZWJTdG9yZUJ1bmRsZUxvYWRlZFN0YXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTXV0YXRpb25CYXRjaEV2ZW50KG11dGF0aW9uQmF0Y2gpIHtcbiAgICAgICAgaWYgKG11dGF0aW9uQmF0Y2gudXNlci51aWQgIT09IHRoaXMuY3VycmVudFVzZXIudWlkKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGEsIGBJZ25vcmluZyBtdXRhdGlvbiBmb3Igbm9uLWFjdGl2ZSB1c2VyICR7bXV0YXRpb25CYXRjaC51c2VyLnVpZH1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zeW5jRW5naW5lLmFwcGx5QmF0Y2hTdGF0ZShtdXRhdGlvbkJhdGNoLmJhdGNoSWQsIG11dGF0aW9uQmF0Y2guc3RhdGUsIG11dGF0aW9uQmF0Y2guZXJyb3IpO1xuICAgIH1cbiAgICBoYW5kbGVRdWVyeVRhcmdldEV2ZW50KHRhcmdldE1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bmNFbmdpbmUuYXBwbHlUYXJnZXRTdGF0ZSh0YXJnZXRNZXRhZGF0YS50YXJnZXRJZCwgdGFyZ2V0TWV0YWRhdGEuc3RhdGUsIHRhcmdldE1ldGFkYXRhLmVycm9yKTtcbiAgICB9XG4gICAgaGFuZGxlQ2xpZW50U3RhdGVFdmVudChjbGllbnRJZCwgY2xpZW50U3RhdGUpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZENsaWVudHMgPSBjbGllbnRTdGF0ZVxuICAgICAgICAgICAgPyB0aGlzLmFjdGl2ZUNsaWVudHMuaW5zZXJ0KGNsaWVudElkLCBjbGllbnRTdGF0ZSlcbiAgICAgICAgICAgIDogdGhpcy5hY3RpdmVDbGllbnRzLnJlbW92ZShjbGllbnRJZCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVGFyZ2V0cyA9IHRoaXMuZXh0cmFjdEFjdGl2ZVF1ZXJ5VGFyZ2V0cyh0aGlzLmFjdGl2ZUNsaWVudHMpO1xuICAgICAgICBjb25zdCBuZXdUYXJnZXRzID0gdGhpcy5leHRyYWN0QWN0aXZlUXVlcnlUYXJnZXRzKHVwZGF0ZWRDbGllbnRzKTtcbiAgICAgICAgY29uc3QgYWRkZWRUYXJnZXRzID0gW107XG4gICAgICAgIGNvbnN0IHJlbW92ZWRUYXJnZXRzID0gW107XG4gICAgICAgIG5ld1RhcmdldHMuZm9yRWFjaCh0YXJnZXRJZCA9PiB7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nVGFyZ2V0cy5oYXModGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICAgICAgYWRkZWRUYXJnZXRzLnB1c2godGFyZ2V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZXhpc3RpbmdUYXJnZXRzLmZvckVhY2godGFyZ2V0SWQgPT4ge1xuICAgICAgICAgICAgaWYgKCFuZXdUYXJnZXRzLmhhcyh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkVGFyZ2V0cy5wdXNoKHRhcmdldElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bmNFbmdpbmUuYXBwbHlBY3RpdmVUYXJnZXRzQ2hhbmdlKGFkZGVkVGFyZ2V0cywgcmVtb3ZlZFRhcmdldHMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDbGllbnRzID0gdXBkYXRlZENsaWVudHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVPbmxpbmVTdGF0ZUV2ZW50KG9ubGluZVN0YXRlKSB7XG4gICAgICAgIC8vIFdlIGNoZWNrIHdoZXRoZXIgdGhlIGNsaWVudCB0aGF0IHdyb3RlIHRoaXMgb25saW5lIHN0YXRlIGlzIHN0aWxsIGFjdGl2ZVxuICAgICAgICAvLyBieSBjb21wYXJpbmcgaXRzIGNsaWVudCBJRCB0byB0aGUgbGlzdCBvZiBjbGllbnRzIGtlcHQgYWN0aXZlIGluXG4gICAgICAgIC8vIEluZGV4ZWREYi4gSWYgYSBjbGllbnQgZG9lcyBub3QgdXBkYXRlIHRoZWlyIEluZGV4ZWREYiBjbGllbnQgc3RhdGVcbiAgICAgICAgLy8gd2l0aGluIDUgc2Vjb25kcywgaXQgaXMgY29uc2lkZXJlZCBpbmFjdGl2ZSBhbmQgd2UgZG9uJ3QgZW1pdCBhbiBvbmxpbmVcbiAgICAgICAgLy8gc3RhdGUgZXZlbnQuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUNsaWVudHMuZ2V0KG9ubGluZVN0YXRlLmNsaWVudElkKSkge1xuICAgICAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZUhhbmRsZXIob25saW5lU3RhdGUub25saW5lU3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4dHJhY3RBY3RpdmVRdWVyeVRhcmdldHMoY2xpZW50cykge1xuICAgICAgICBsZXQgYWN0aXZlVGFyZ2V0cyA9IHRhcmdldElkU2V0KCk7XG4gICAgICAgIGNsaWVudHMuZm9yRWFjaCgoa2V2LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgYWN0aXZlVGFyZ2V0cyA9IGFjdGl2ZVRhcmdldHMudW5pb25XaXRoKHZhbHVlLmFjdGl2ZVRhcmdldElkcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWN0aXZlVGFyZ2V0cztcbiAgICB9XG59XG5mdW5jdGlvbiBmcm9tV2ViU3RvcmFnZVNlcXVlbmNlTnVtYmVyKHNlcVN0cmluZykge1xuICAgIGxldCBzZXF1ZW5jZU51bWJlciA9IExpc3RlblNlcXVlbmNlLklOVkFMSUQ7XG4gICAgaWYgKHNlcVN0cmluZyAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHNlcVN0cmluZyk7XG4gICAgICAgICAgICBoYXJkQXNzZXJ0KHR5cGVvZiBwYXJzZWQgPT09ICdudW1iZXInKTtcbiAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dFcnJvcihMT0dfVEFHJGEsICdGYWlsZWQgdG8gcmVhZCBzZXF1ZW5jZSBudW1iZXIgZnJvbSBXZWJTdG9yYWdlJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcXVlbmNlTnVtYmVyO1xufVxuLyoqXG4gKiBgTWVtb3J5U2hhcmVkQ2xpZW50U3RhdGVgIGlzIGEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIFNoYXJlZENsaWVudFN0YXRlIGZvclxuICogY2xpZW50cyB1c2luZyBtZW1vcnkgcGVyc2lzdGVuY2UuIFRoZSBzdGF0ZSBpbiB0aGlzIGNsYXNzIHJlbWFpbnMgZnVsbHlcbiAqIGlzb2xhdGVkIGFuZCBubyBzeW5jaHJvbml6YXRpb24gaXMgcGVyZm9ybWVkLlxuICovXG5jbGFzcyBNZW1vcnlTaGFyZWRDbGllbnRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdGF0ZSA9IG5ldyBMb2NhbENsaWVudFN0YXRlKCk7XG4gICAgICAgIHRoaXMucXVlcnlTdGF0ZSA9IHt9O1xuICAgICAgICB0aGlzLm9ubGluZVN0YXRlSGFuZGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXJIYW5kbGVyID0gbnVsbDtcbiAgICB9XG4gICAgYWRkUGVuZGluZ011dGF0aW9uKGJhdGNoSWQpIHtcbiAgICAgICAgLy8gTm8gb3AuXG4gICAgfVxuICAgIHVwZGF0ZU11dGF0aW9uU3RhdGUoYmF0Y2hJZCwgc3RhdGUsIGVycm9yKSB7XG4gICAgICAgIC8vIE5vIG9wLlxuICAgIH1cbiAgICBhZGRMb2NhbFF1ZXJ5VGFyZ2V0KHRhcmdldElkLCBhZGRUb0FjdGl2ZVRhcmdldElkcyA9IHRydWUpIHtcbiAgICAgICAgaWYgKGFkZFRvQWN0aXZlVGFyZ2V0SWRzKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsU3RhdGUuYWRkUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U3RhdGVbdGFyZ2V0SWRdIHx8ICdub3QtY3VycmVudCc7XG4gICAgfVxuICAgIHVwZGF0ZVF1ZXJ5U3RhdGUodGFyZ2V0SWQsIHN0YXRlLCBlcnJvcikge1xuICAgICAgICB0aGlzLnF1ZXJ5U3RhdGVbdGFyZ2V0SWRdID0gc3RhdGU7XG4gICAgfVxuICAgIHJlbW92ZUxvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlLnJlbW92ZVF1ZXJ5VGFyZ2V0KHRhcmdldElkKTtcbiAgICB9XG4gICAgaXNMb2NhbFF1ZXJ5VGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RhdGUuYWN0aXZlVGFyZ2V0SWRzLmhhcyh0YXJnZXRJZCk7XG4gICAgfVxuICAgIGNsZWFyUXVlcnlTdGF0ZSh0YXJnZXRJZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5xdWVyeVN0YXRlW3RhcmdldElkXTtcbiAgICB9XG4gICAgZ2V0QWxsQWN0aXZlUXVlcnlUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0YXRlLmFjdGl2ZVRhcmdldElkcztcbiAgICB9XG4gICAgaXNBY3RpdmVRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0YXRlLmFjdGl2ZVRhcmdldElkcy5oYXModGFyZ2V0SWQpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlID0gbmV3IExvY2FsQ2xpZW50U3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBoYW5kbGVVc2VyQ2hhbmdlKHVzZXIsIHJlbW92ZWRCYXRjaElkcywgYWRkZWRCYXRjaElkcykge1xuICAgICAgICAvLyBObyBvcC5cbiAgICB9XG4gICAgc2V0T25saW5lU3RhdGUob25saW5lU3RhdGUpIHtcbiAgICAgICAgLy8gTm8gb3AuXG4gICAgfVxuICAgIHNodXRkb3duKCkgeyB9XG4gICAgd3JpdGVTZXF1ZW5jZU51bWJlcihzZXF1ZW5jZU51bWJlcikgeyB9XG4gICAgbm90aWZ5QnVuZGxlTG9hZGVkKGNvbGxlY3Rpb25Hcm91cHMpIHtcbiAgICAgICAgLy8gTm8gb3AuXG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTm9vcENvbm5lY3Rpdml0eU1vbml0b3Ige1xuICAgIGFkZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIE5vLW9wLlxuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgLy8gTm8tb3AuXG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlcyBhIHNpbXBsZSBoZWxwZXIgY2xhc3MgdGhhdCBpbXBsZW1lbnRzIHRoZSBTdHJlYW0gaW50ZXJmYWNlIHRvXG4gKiBicmlkZ2UgdG8gb3RoZXIgaW1wbGVtZW50YXRpb25zIHRoYXQgYXJlIHN0cmVhbXMgYnV0IGRvIG5vdCBpbXBsZW1lbnQgdGhlXG4gKiBpbnRlcmZhY2UuIFRoZSBzdHJlYW0gY2FsbGJhY2tzIGFyZSBpbnZva2VkIHdpdGggdGhlIGNhbGxPbi4uLiBtZXRob2RzLlxuICovXG5jbGFzcyBTdHJlYW1CcmlkZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5zZW5kRm4gPSBhcmdzLnNlbmRGbjtcbiAgICAgICAgdGhpcy5jbG9zZUZuID0gYXJncy5jbG9zZUZuO1xuICAgIH1cbiAgICBvbkNvbm5lY3RlZChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBwZWRPbkNvbm5lY3RlZCA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBvbk9wZW4oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwcGVkT25PcGVuID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIG9uQ2xvc2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwcGVkT25DbG9zZSA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBvbk1lc3NhZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwcGVkT25NZXNzYWdlID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmNsb3NlRm4oKTtcbiAgICB9XG4gICAgc2VuZChtc2cpIHtcbiAgICAgICAgdGhpcy5zZW5kRm4obXNnKTtcbiAgICB9XG4gICAgY2FsbE9uQ29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLndyYXBwZWRPbkNvbm5lY3RlZCgpO1xuICAgIH1cbiAgICBjYWxsT25PcGVuKCkge1xuICAgICAgICB0aGlzLndyYXBwZWRPbk9wZW4oKTtcbiAgICB9XG4gICAgY2FsbE9uQ2xvc2UoZXJyKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZE9uQ2xvc2UoZXJyKTtcbiAgICB9XG4gICAgY2FsbE9uTWVzc2FnZShtc2cpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkT25NZXNzYWdlKG1zZyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgdmFsdWUgcmV0dXJuZWQgZnJvbSB0aGUgbW9zdCByZWNlbnQgaW52b2NhdGlvbiBvZlxuICogYGdlbmVyYXRlVW5pcXVlRGVidWdJZCgpYCwgb3IgbnVsbCBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBpbnZva2VkLlxuICovXG5sZXQgbGFzdFVuaXF1ZURlYnVnSWQgPSBudWxsO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW5kIHJldHVybnMgYW4gaW5pdGlhbCB2YWx1ZSBmb3IgYGxhc3RVbmlxdWVEZWJ1Z0lkYC5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgdmFsdWUgaXMgcmFuZG9tbHkgc2VsZWN0ZWQgZnJvbSBhIHJhbmdlIG9mIGludGVnZXJzIHRoYXQgYXJlXG4gKiByZXByZXNlbnRlZCBhcyA4IGhleGFkZWNpbWFsIGRpZ2l0cy4gVGhpcyBtZWFucyB0aGF0ICh3aXRoaW4gcmVhc29uKSBhbnlcbiAqIG51bWJlcnMgZ2VuZXJhdGVkIGJ5IGluY3JlbWVudGluZyB0aGUgcmV0dXJuZWQgbnVtYmVyIGJ5IDEgd2lsbCBhbHNvIGJlXG4gKiByZXByZXNlbnRlZCBieSA4IGhleGFkZWNpbWFsIGRpZ2l0cy4gVGhpcyBsZWFkcyB0byBhbGwgXCJJRHNcIiBoYXZpbmcgdGhlIHNhbWVcbiAqIGxlbmd0aCB3aGVuIGNvbnZlcnRlZCB0byBhIGhleGFkZWNpbWFsIHN0cmluZywgbWFraW5nIHJlYWRpbmcgbG9ncyBjb250YWluaW5nXG4gKiB0aGVzZSBJRHMgZWFzaWVyIHRvIGZvbGxvdy4gQW5kIHNpbmNlIHRoZSByZXR1cm4gdmFsdWUgaXMgcmFuZG9tbHkgc2VsZWN0ZWRcbiAqIGl0IHdpbGwgaGVscCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbG9ncyBmcm9tIGRpZmZlcmVudCBleGVjdXRpb25zLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUluaXRpYWxVbmlxdWVEZWJ1Z0lkKCkge1xuICAgIGNvbnN0IG1pblJlc3VsdCA9IDB4MTAwMDAwMDA7XG4gICAgY29uc3QgbWF4UmVzdWx0ID0gMHg5MDAwMDAwMDtcbiAgICBjb25zdCByZXN1bHRSYW5nZSA9IG1heFJlc3VsdCAtIG1pblJlc3VsdDtcbiAgICBjb25zdCByZXN1bHRPZmZzZXQgPSBNYXRoLnJvdW5kKHJlc3VsdFJhbmdlICogTWF0aC5yYW5kb20oKSk7XG4gICAgcmV0dXJuIG1pblJlc3VsdCArIHJlc3VsdE9mZnNldDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGFuZCByZXR1cm5zIGEgdW5pcXVlIElEIGFzIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIFRoZSByZXR1cm5lZCBJRCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGluIGRlYnVnIGxvZ2dpbmcgbWVzc2FnZXMgdG8gaGVscFxuICogY29ycmVsYXRlIGxvZyBtZXNzYWdlcyB0aGF0IG1heSBiZSBzcGF0aWFsbHkgc2VwYXJhdGVkIGluIHRoZSBsb2dzLCBidXRcbiAqIGxvZ2ljYWxseSByZWxhdGVkLiBGb3IgZXhhbXBsZSwgYSBuZXR3b3JrIGNvbm5lY3Rpb24gY291bGQgaW5jbHVkZSB0aGUgc2FtZVxuICogXCJkZWJ1ZyBJRFwiIHN0cmluZyBpbiBhbGwgb2YgaXRzIGxvZyBtZXNzYWdlcyB0byBoZWxwIHRyYWNlIGEgc3BlY2lmaWNcbiAqIGNvbm5lY3Rpb24gb3ZlciB0aW1lLlxuICpcbiAqIEByZXR1cm4gdGhlIDEwLWNoYXJhY3RlciBnZW5lcmF0ZWQgSUQgKGUuZy4gXCIweGExYjJjM2Q0XCIpLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVVuaXF1ZURlYnVnSWQoKSB7XG4gICAgaWYgKGxhc3RVbmlxdWVEZWJ1Z0lkID09PSBudWxsKSB7XG4gICAgICAgIGxhc3RVbmlxdWVEZWJ1Z0lkID0gZ2VuZXJhdGVJbml0aWFsVW5pcXVlRGVidWdJZCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGFzdFVuaXF1ZURlYnVnSWQrKztcbiAgICB9XG4gICAgcmV0dXJuICcweCcgKyBsYXN0VW5pcXVlRGVidWdJZC50b1N0cmluZygxNik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKlxuICogVXRpbGl0aWVzIGZvciBkZWFsaW5nIHdpdGggbm9kZS5qcy1zdHlsZSBBUElzLiBTZWUgbm9kZVByb21pc2UgZm9yIG1vcmVcbiAqIGRldGFpbHMuXG4gKi9cbi8qKlxuICogQ3JlYXRlcyBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgdGhhdCByZXNvbHZlcyBvciByZWplY3RzIGEgbmV3IFByb21pc2UuIFRoZVxuICogY2FsbGJhY2sgaXMgcGFzc2VkIHRvIHRoZSBnaXZlbiBhY3Rpb24gd2hpY2ggY2FuIHRoZW4gdXNlIHRoZSBjYWxsYmFjayBhc1xuICogYSBwYXJhbWV0ZXIgdG8gYSBub2RlLXN0eWxlIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBpbnRlbnQgaXMgdG8gZGlyZWN0bHkgYnJpZGdlIGEgbm9kZS1zdHlsZSBmdW5jdGlvbiAod2hpY2ggdGFrZXMgYVxuICogY2FsbGJhY2spIGludG8gYSBQcm9taXNlIHdpdGhvdXQgbWFudWFsbHkgY29udmVydGluZyBiZXR3ZWVuIHRoZSBub2RlLXN0eWxlXG4gKiBjYWxsYmFjayBhbmQgdGhlIHByb21pc2UgYXQgZWFjaCBjYWxsLlxuICpcbiAqIEluIGVmZmVjdCBpdCBhbGxvd3MgeW91IHRvIGNvbnZlcnQ6XG4gKlxuICogQGV4YW1wbGVcbiAqIG5ldyBQcm9taXNlKChyZXNvbHZlOiAodmFsdWU/OiBmcy5TdGF0cykgPT4gdm9pZCxcbiAqICAgICAgICAgICAgICByZWplY3Q6IChlcnJvcj86IGFueSkgPT4gdm9pZCkgPT4ge1xuICogICBmcy5zdGF0KHBhdGgsIChlcnJvcj86IGFueSwgc3RhdD86IGZzLlN0YXRzKSA9PiB7XG4gKiAgICAgaWYgKGVycm9yKSB7XG4gKiAgICAgICByZWplY3QoZXJyb3IpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICByZXNvbHZlKHN0YXQpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKiB9KTtcbiAqXG4gKiBJbnRvXG4gKiBAZXhhbXBsZVxuICogbm9kZVByb21pc2UoKGNhbGxiYWNrOiBOb2RlQ2FsbGJhY2s8ZnMuU3RhdHM+KSA9PiB7XG4gKiAgIGZzLnN0YXQocGF0aCwgY2FsbGJhY2spO1xuICogfSk7XG4gKlxuICogQHBhcmFtIGFjdGlvbiAtIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgYW4gYXJndW1lbnRcbiAqICAgICBhbmQgdGhlbiB1c2VzIHRoYXQgY2FsbGJhY2sgdG8gaW52b2tlIHNvbWUgbm9kZS1zdHlsZSBBUEkuXG4gKiBAcmV0dXJucyBhIG5ldyBQcm9taXNlIHdoaWNoIHdpbGwgYmUgcmVqZWN0ZWQgaWYgdGhlIGNhbGxiYWNrIGlzIGdpdmVuIHRoZVxuICogICAgIGZpcnN0IEVycm9yIHBhcmFtZXRlciBvciB3aWxsIHJlc29sdmUgdG8gdGhlIHZhbHVlIGdpdmVuIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gbm9kZVByb21pc2UoYWN0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgYWN0aW9uKChlcnJvciwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBUT0RPOiBGZXRjaCBydW50aW1lIHZlcnNpb24gZnJvbSBncnBjLWpzL3BhY2thZ2UuanNvbiBpbnN0ZWFkXG4vLyB3aGVuIHRoZXJlJ3MgYSBjbGVhbmVyIHdheSB0byBkeW5hbWljIHJlcXVpcmUgSlNPTiBpbiBib3RoIE5vZGUgRVNNIGFuZCBDSlNcbmNvbnN0IGdycGNWZXJzaW9uID0gJzEuOS4xNSc7XG5jb25zdCBMT0dfVEFHJDkgPSAnR3JwY0Nvbm5lY3Rpb24nO1xuY29uc3QgWF9HT09HX0FQSV9DTElFTlRfVkFMVUUgPSBgZ2wtbm9kZS8ke3Byb2Nlc3MudmVyc2lvbnMubm9kZX0gZmlyZS8ke1NES19WRVJTSU9OfSBncnBjLyR7Z3JwY1ZlcnNpb259YDtcbmZ1bmN0aW9uIGNyZWF0ZU1ldGFkYXRhKGRhdGFiYXNlUGF0aCwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuLCBhcHBJZCkge1xuICAgIGhhcmRBc3NlcnQoYXV0aFRva2VuID09PSBudWxsIHx8IGF1dGhUb2tlbi50eXBlID09PSAnT0F1dGgnKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBncnBjLk1ldGFkYXRhKCk7XG4gICAgaWYgKGF1dGhUb2tlbikge1xuICAgICAgICBhdXRoVG9rZW4uaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBtZXRhZGF0YS5zZXQoa2V5LCB2YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAoYXBwQ2hlY2tUb2tlbikge1xuICAgICAgICBhcHBDaGVja1Rva2VuLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gbWV0YWRhdGEuc2V0KGtleSwgdmFsdWUpKTtcbiAgICB9XG4gICAgaWYgKGFwcElkKSB7XG4gICAgICAgIG1ldGFkYXRhLnNldCgnWC1GaXJlYmFzZS1HTVBJRCcsIGFwcElkKTtcbiAgICB9XG4gICAgbWV0YWRhdGEuc2V0KCdYLUdvb2ctQXBpLUNsaWVudCcsIFhfR09PR19BUElfQ0xJRU5UX1ZBTFVFKTtcbiAgICAvLyBUaGVzZSBoZWFkZXJzIGFyZSB1c2VkIHRvIGltcHJvdmUgcm91dGluZyBhbmQgcHJvamVjdCBpc29sYXRpb24gYnkgdGhlXG4gICAgLy8gYmFja2VuZC5cbiAgICAvLyBUT0RPKGIvMTk5NzY3NzEyKTogV2UgYXJlIGtlZXBpbmcgJ0dvb2dsZS1DbG91ZC1SZXNvdXJjZS1QcmVmaXgnIHVudGlsIEVtdWxhdG9ycyBjYW4gYmVcbiAgICAvLyByZWxlYXNlZCB3aXRoIGNsLzQyODgyMDA0Ni4gQ3VycmVudGx5IGJsb2NrZWQgYmVjYXVzZSBFbXVsYXRvcnMgYXJlIG5vdyBidWlsdCB3aXRoIEphdmFcbiAgICAvLyAxMSBmcm9tIEdvb2dsZTMuXG4gICAgbWV0YWRhdGEuc2V0KCdHb29nbGUtQ2xvdWQtUmVzb3VyY2UtUHJlZml4JywgZGF0YWJhc2VQYXRoKTtcbiAgICBtZXRhZGF0YS5zZXQoJ3gtZ29vZy1yZXF1ZXN0LXBhcmFtcycsIGRhdGFiYXNlUGF0aCk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xufVxuLyoqXG4gKiBBIENvbm5lY3Rpb24gaW1wbGVtZW50ZWQgYnkgR1JQQy1Ob2RlLlxuICovXG5jbGFzcyBHcnBjQ29ubmVjdGlvbiB7XG4gICAgZ2V0IHNob3VsZFJlc291cmNlUGF0aEJlSW5jbHVkZWRJblJlcXVlc3QoKSB7XG4gICAgICAgIC8vIEJvdGggYGludm9rZVJQQygpYCBhbmQgYGludm9rZVN0cmVhbWluZ1JQQygpYCBpZ25vcmUgdGhlaXIgYHBhdGhgIGFyZ3VtZW50cywgYW5kIGV4cGVjdFxuICAgICAgICAvLyB0aGUgXCJwYXRoXCIgdG8gYmUgcGFydCBvZiB0aGUgZ2l2ZW4gYHJlcXVlc3RgLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJvdG9zLCBkYXRhYmFzZUluZm8pIHtcbiAgICAgICAgdGhpcy5kYXRhYmFzZUluZm8gPSBkYXRhYmFzZUluZm87XG4gICAgICAgIC8vIFdlIGNhY2hlIHN0dWJzIGZvciB0aGUgbW9zdC1yZWNlbnRseS11c2VkIHRva2VuLlxuICAgICAgICB0aGlzLmNhY2hlZFN0dWIgPSBudWxsO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0aGlzLmZpcmVzdG9yZSA9IHByb3Rvc1snZ29vZ2xlJ11bJ2ZpcmVzdG9yZSddWyd2MSddO1xuICAgICAgICB0aGlzLmRhdGFiYXNlUGF0aCA9IGBwcm9qZWN0cy8ke2RhdGFiYXNlSW5mby5kYXRhYmFzZUlkLnByb2plY3RJZH0vZGF0YWJhc2VzLyR7ZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQuZGF0YWJhc2V9YDtcbiAgICB9XG4gICAgZW5zdXJlQWN0aXZlU3R1YigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlZFN0dWIpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgJ0NyZWF0aW5nIEZpcmVzdG9yZSBzdHViLicpO1xuICAgICAgICAgICAgY29uc3QgY3JlZGVudGlhbHMgPSB0aGlzLmRhdGFiYXNlSW5mby5zc2xcbiAgICAgICAgICAgICAgICA/IGdycGMuY3JlZGVudGlhbHMuY3JlYXRlU3NsKClcbiAgICAgICAgICAgICAgICA6IGdycGMuY3JlZGVudGlhbHMuY3JlYXRlSW5zZWN1cmUoKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkU3R1YiA9IG5ldyB0aGlzLmZpcmVzdG9yZS5GaXJlc3RvcmUodGhpcy5kYXRhYmFzZUluZm8uaG9zdCwgY3JlZGVudGlhbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlZFN0dWI7XG4gICAgfVxuICAgIGludm9rZVJQQyhycGNOYW1lLCBwYXRoLCByZXF1ZXN0LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtSWQgPSBnZW5lcmF0ZVVuaXF1ZURlYnVnSWQoKTtcbiAgICAgICAgY29uc3Qgc3R1YiA9IHRoaXMuZW5zdXJlQWN0aXZlU3R1YigpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGNyZWF0ZU1ldGFkYXRhKHRoaXMuZGF0YWJhc2VQYXRoLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIHRoaXMuZGF0YWJhc2VJbmZvLmFwcElkKTtcbiAgICAgICAgY29uc3QganNvblJlcXVlc3QgPSBPYmplY3QuYXNzaWduKHsgZGF0YWJhc2U6IHRoaXMuZGF0YWJhc2VQYXRoIH0sIHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gbm9kZVByb21pc2UoKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nICR7c3RyZWFtSWR9IGludm9rZWQgd2l0aCByZXF1ZXN0OmAsIHJlcXVlc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHN0dWJbcnBjTmFtZV0oanNvblJlcXVlc3QsIG1ldGFkYXRhLCAoZ3JwY0Vycm9yLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChncnBjRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyAke3N0cmVhbUlkfSBmYWlsZWQgd2l0aCBlcnJvcjpgLCBncnBjRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRmlyZXN0b3JlRXJyb3IobWFwQ29kZUZyb21ScGNDb2RlKGdycGNFcnJvci5jb2RlKSwgZ3JwY0Vycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgJHtzdHJlYW1JZH0gY29tcGxldGVkIHdpdGggcmVzcG9uc2U6YCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGludm9rZVN0cmVhbWluZ1JQQyhycGNOYW1lLCBwYXRoLCByZXF1ZXN0LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIGV4cGVjdGVkUmVzcG9uc2VDb3VudCkge1xuICAgICAgICBjb25zdCBzdHJlYW1JZCA9IGdlbmVyYXRlVW5pcXVlRGVidWdJZCgpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyAke3N0cmVhbUlkfSBpbnZva2VkIChzdHJlYW1pbmcpIHdpdGggcmVxdWVzdDpgLCByZXF1ZXN0KTtcbiAgICAgICAgY29uc3Qgc3R1YiA9IHRoaXMuZW5zdXJlQWN0aXZlU3R1YigpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGNyZWF0ZU1ldGFkYXRhKHRoaXMuZGF0YWJhc2VQYXRoLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIHRoaXMuZGF0YWJhc2VJbmZvLmFwcElkKTtcbiAgICAgICAgY29uc3QganNvblJlcXVlc3QgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpLCB7IGRhdGFiYXNlOiB0aGlzLmRhdGFiYXNlUGF0aCB9KTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gc3R1YltycGNOYW1lXShqc29uUmVxdWVzdCwgbWV0YWRhdGEpO1xuICAgICAgICBsZXQgY2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuICAgICAgICBzdHJlYW0ub24oJ2RhdGEnLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAke3JwY05hbWV9ICR7c3RyZWFtSWR9IHJlY2VpdmVkIHJlc3VsdDpgLCByZXNwb25zZSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzcG9uc2UpO1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkUmVzcG9uc2VDb3VudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5sZW5ndGggPT09IGV4cGVjdGVkUmVzcG9uc2VDb3VudCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrRmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlRGVmZXJyZWQucmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyAke3N0cmVhbUlkfSBjb21wbGV0ZWQuYCk7XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrRmlyZWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja0ZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXNwb25zZURlZmVycmVkLnJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgKGdycGNFcnJvcikgPT4ge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyAke3N0cmVhbUlkfSBmYWlsZWQgd2l0aCBlcnJvcjpgLCBncnBjRXJyb3IpO1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IG1hcENvZGVGcm9tUnBjQ29kZShncnBjRXJyb3IuY29kZSk7XG4gICAgICAgICAgICByZXNwb25zZURlZmVycmVkLnJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoY29kZSwgZ3JwY0Vycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZURlZmVycmVkLnByb21pc2U7XG4gICAgfVxuICAgIC8vIFRPRE8obWlrZWxlaGVuKTogVGhpcyBcIm1ldGhvZFwiIGlzIGEgbW9uc3Rlci4gU2hvdWxkIGJlIHJlZmFjdG9yZWQuXG4gICAgb3BlblN0cmVhbShycGNOYW1lLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtSWQgPSBnZW5lcmF0ZVVuaXF1ZURlYnVnSWQoKTtcbiAgICAgICAgY29uc3Qgc3R1YiA9IHRoaXMuZW5zdXJlQWN0aXZlU3R1YigpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGNyZWF0ZU1ldGFkYXRhKHRoaXMuZGF0YWJhc2VQYXRoLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIHRoaXMuZGF0YWJhc2VJbmZvLmFwcElkKTtcbiAgICAgICAgY29uc3QgZ3JwY1N0cmVhbSA9IHN0dWJbcnBjTmFtZV0obWV0YWRhdGEpO1xuICAgICAgICBsZXQgY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNsb3NlID0gKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5jYWxsT25DbG9zZShlcnIpO1xuICAgICAgICAgICAgICAgIGdycGNTdHJlYW0uZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBTdHJlYW1CcmlkZ2Uoe1xuICAgICAgICAgICAgc2VuZEZuOiAobXNnKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyBzdHJlYW0gJHtzdHJlYW1JZH0gc2VuZGluZzpgLCBtc2cpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JwY1N0cmVhbS53cml0ZShtc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHByb2JhYmx5IG1lYW5zIHdlIGRpZG4ndCBjb25mb3JtIHRvIHRoZSBwcm90by4gIE1ha2Ugc3VyZSB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9nIHRoZSBtZXNzYWdlIHdlIHNlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFcnJvcignRmFpbHVyZSBzZW5kaW5nOicsIG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFcnJvcignRXJyb3I6JywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdub3Qgc2VuZGluZyBiZWNhdXNlIGdSUEMgc3RyZWFtIGlzIGNsb3NlZDonLCBtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZUZuOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyBzdHJlYW0gJHtzdHJlYW1JZH0gY2xvc2VkIGxvY2FsbHkgdmlhIGNsb3NlKCkuYCk7XG4gICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBvbkNvbm5lY3RlZFNlbnQgPSBmYWxzZTtcbiAgICAgICAgZ3JwY1N0cmVhbS5vbignZGF0YScsIChtc2cpID0+IHtcbiAgICAgICAgICAgIGlmICghY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyBzdHJlYW0gJHtzdHJlYW1JZH0gcmVjZWl2ZWQ6YCwgbXNnKTtcbiAgICAgICAgICAgICAgICAvLyBFbXVsYXRlIHRoZSBcIm9uQ29ubmVjdGVkXCIgZXZlbnQgdGhhdCBXZWJDaGFubmVsQ29ubmVjdGlvbiBzZW5kcy5cbiAgICAgICAgICAgICAgICBpZiAoIW9uQ29ubmVjdGVkU2VudCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uY2FsbE9uQ29ubmVjdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uQ29ubmVjdGVkU2VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmVhbS5jYWxsT25NZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBncnBjU3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSBlbmRlZC5gKTtcbiAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBncnBjU3RyZWFtLm9uKCdlcnJvcicsIChncnBjRXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICghY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgbG9nV2FybihMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSBlcnJvci4gQ29kZTpgLCBncnBjRXJyb3IuY29kZSwgJ01lc3NhZ2U6JywgZ3JwY0Vycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBtYXBDb2RlRnJvbVJwY0NvZGUoZ3JwY0Vycm9yLmNvZGUpO1xuICAgICAgICAgICAgICAgIGNsb3NlKG5ldyBGaXJlc3RvcmVFcnJvcihjb2RlLCBncnBjRXJyb3IubWVzc2FnZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgT3BlbmluZyBSUEMgJyR7cnBjTmFtZX0nIHN0cmVhbSAke3N0cmVhbUlkfSBgICtcbiAgICAgICAgICAgIGB0byAke3RoaXMuZGF0YWJhc2VJbmZvLmhvc3R9YCk7XG4gICAgICAgIC8vIFRPRE8oZGltb25kKTogU2luY2UgZ3JwYyBoYXMgbm8gZXhwbGljaXQgb3BlbiBzdGF0dXMgKG9yIGRvZXMgaXQ/KSB3ZVxuICAgICAgICAvLyBzaW11bGF0ZSBhbiBvbk9wZW4gaW4gdGhlIG5leHQgbG9vcCBhZnRlciB0aGUgc3RyZWFtIGhhZCBpdCdzIGxpc3RlbmVyc1xuICAgICAgICAvLyByZWdpc3RlcmVkXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgc3RyZWFtLmNhbGxPbk9wZW4oKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyBhbmQgY2xlYW5zIHVwIGFueSByZXNvdXJjZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBHcnBjQ29ubmVjdGlvbi5cbiAgICAgKiBJZiBhIGdSUEMgY2xpZW50IGhhcyBiZWVuIGdlbmVyYXRlZCBmb3IgdGhpcyBjb25uZWN0aW9uLCB0aGUgZ1JQQyBjbGllbnRcbiAgICAgKiBpcyBjbG9zZWQuIEZhaWx1cmUgdG8gY2FsbCB0ZXJtaW5hdGUgb24gYSBHcnBjQ29ubmVjdGlvbiBjYW4gcmVzdWx0XG4gICAgICogaW4gbGVha2VkIHJlc291cmNlcyBvZiB0aGUgZ1JQQyBjbGllbnQuXG4gICAgICovXG4gICAgdGVybWluYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5jYWNoZWRTdHViKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZFN0dWIuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkU3R1YiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgbmVzdGVkID0ge1xuXHRnb29nbGU6IHtcblx0XHRuZXN0ZWQ6IHtcblx0XHRcdHByb3RvYnVmOiB7XG5cdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRjc2hhcnBfbmFtZXNwYWNlOiBcIkdvb2dsZS5Qcm90b2J1Zi5XZWxsS25vd25UeXBlc1wiLFxuXHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiZ2l0aHViLmNvbS9nb2xhbmcvcHJvdG9idWYvcHR5cGVzL3dyYXBwZXJzXCIsXG5cdFx0XHRcdFx0amF2YV9wYWNrYWdlOiBcImNvbS5nb29nbGUucHJvdG9idWZcIixcblx0XHRcdFx0XHRqYXZhX291dGVyX2NsYXNzbmFtZTogXCJXcmFwcGVyc1Byb3RvXCIsXG5cdFx0XHRcdFx0amF2YV9tdWx0aXBsZV9maWxlczogdHJ1ZSxcblx0XHRcdFx0XHRvYmpjX2NsYXNzX3ByZWZpeDogXCJHUEJcIixcblx0XHRcdFx0XHRjY19lbmFibGVfYXJlbmFzOiB0cnVlLFxuXHRcdFx0XHRcdG9wdGltaXplX2ZvcjogXCJTUEVFRFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFRpbWVzdGFtcDoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHNlY29uZHM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bmFub3M6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmlsZURlc2NyaXB0b3JTZXQ6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRmaWxlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmlsZURlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZpbGVEZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcInBhY2thZ2VcIjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHB1YmxpY0RlcGVuZGVuY3k6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMCxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYWNrZWQ6IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR3ZWFrRGVwZW5kZW5jeToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDExLFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhY2tlZDogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2VUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZW51bVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c2VydmljZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNlcnZpY2VEZXNjcmlwdG9yUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRleHRlbnNpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZERlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpbGVPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c291cmNlQ29kZUluZm86IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNvdXJjZUNvZGVJbmZvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDlcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c3ludGF4OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZERlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bmVzdGVkVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGVudW1UeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRW51bURlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvblJhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uUmFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvbmVvZkRlY2w6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPbmVvZkRlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cmVzZXJ2ZWRSYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlJlc2VydmVkUmFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRyZXNlcnZlZE5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTBcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRFeHRlbnNpb25SYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhcnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGVuZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRSZXNlcnZlZFJhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZpZWxkRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bnVtYmVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGxhYmVsOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJMYWJlbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlR5cGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR0eXBlTmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZXh0ZW5kZWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b25lb2ZJbmRleDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRqc29uTmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDEwXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9ET1VCTEU6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0ZMT0FUOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9JTlQ2NDogMyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfVUlOVDY0OiA0LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9JTlQzMjogNSxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfRklYRUQ2NDogNixcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfRklYRUQzMjogNyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfQk9PTDogOCxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU1RSSU5HOiA5LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9HUk9VUDogMTAsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX01FU1NBR0U6IDExLFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9CWVRFUzogMTIsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX1VJTlQzMjogMTMsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0VOVU06IDE0LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9TRklYRUQzMjogMTUsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX1NGSVhFRDY0OiAxNixcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU0lOVDMyOiAxNyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU0lOVDY0OiAxOFxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0TGFiZWw6IHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdExBQkVMX09QVElPTkFMOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0TEFCRUxfUkVRVUlSRUQ6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRMQUJFTF9SRVBFQVRFRDogM1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0T25lb2ZEZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPbmVvZk9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRFbnVtRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVudW1WYWx1ZURlc2NyaXB0b3JQcm90bzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG51bWJlcjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtVmFsdWVPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0U2VydmljZURlc2NyaXB0b3JQcm90bzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG1ldGhvZDoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk1ldGhvZERlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNlcnZpY2VPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0TWV0aG9kRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0aW5wdXRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvdXRwdXRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJNZXRob2RPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Y2xpZW50U3RyZWFtaW5nOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c2VydmVyU3RyZWFtaW5nOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmlsZU9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRqYXZhUGFja2FnZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0amF2YU91dGVyQ2xhc3NuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRqYXZhTXVsdGlwbGVGaWxlczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRqYXZhR2VuZXJhdGVFcXVhbHNBbmRIYXNoOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDIwLFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHRydWVcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGphdmFTdHJpbmdDaGVja1V0Zjg6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMjdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b3B0aW1pemVGb3I6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9wdGltaXplTW9kZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5LFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFwiZGVmYXVsdFwiOiBcIlNQRUVEXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGdvUGFja2FnZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDExXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGNjR2VuZXJpY1NlcnZpY2VzOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDE2XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGphdmFHZW5lcmljU2VydmljZXM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cHlHZW5lcmljU2VydmljZXM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMThcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjY0VuYWJsZUFyZW5hczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvYmpjQ2xhc3NQcmVmaXg6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzNlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjc2hhcnBOYW1lc3BhY2U6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNlcnZlZDogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MzgsXG5cdFx0XHRcdFx0XHRcdFx0Mzhcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRPcHRpbWl6ZU1vZGU6IHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFNQRUVEOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0Q09ERV9TSVpFOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0TElURV9SVU5USU1FOiAzXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRNZXNzYWdlT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2VTZXRXaXJlRm9ybWF0OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bm9TdGFuZGFyZERlc2NyaXB0b3JBY2Nlc3Nvcjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRtYXBFbnRyeToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmludGVycHJldGVkT3B0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDk5OVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MTAwMCxcblx0XHRcdFx0XHRcdFx0XHQ1MzY4NzA5MTFcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2VydmVkOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQ4LFxuXHRcdFx0XHRcdFx0XHRcdDhcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmllbGRPcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0Y3R5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkNUeXBlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiU1RSSU5HXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBhY2tlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGpzdHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiSlNUeXBlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDYsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiSlNfTk9STUFMXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGxhenk6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkZXByZWNhdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0d2Vhazoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNlcnZlZDogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0NCxcblx0XHRcdFx0XHRcdFx0XHQ0XG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0Q1R5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFNUUklORzogMCxcblx0XHRcdFx0XHRcdFx0XHRcdENPUkQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRTVFJJTkdfUElFQ0U6IDJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEpTVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0SlNfTk9STUFMOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0SlNfU1RSSU5HOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0SlNfTlVNQkVSOiAyXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRPbmVvZk9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVudW1PcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0YWxsb3dBbGlhczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVudW1WYWx1ZU9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRkZXByZWNhdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dW5pbnRlcnByZXRlZE9wdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlVuaW50ZXJwcmV0ZWRPcHRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOTk5XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRleHRlbnNpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQxMDAwLFxuXHRcdFx0XHRcdFx0XHRcdDUzNjg3MDkxMVxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRTZXJ2aWNlT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMzNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dW5pbnRlcnByZXRlZE9wdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlVuaW50ZXJwcmV0ZWRPcHRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOTk5XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRleHRlbnNpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQxMDAwLFxuXHRcdFx0XHRcdFx0XHRcdDUzNjg3MDkxMVxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRNZXRob2RPcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTmFtZVBhcnRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRpZGVudGlmaWVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBvc2l0aXZlSW50VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInVpbnQ2NFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG5lZ2F0aXZlSW50VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZG91YmxlVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHN0cmluZ1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGFnZ3JlZ2F0ZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdE5hbWVQYXJ0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lUGFydDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcXVpcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0aXNFeHRlbnNpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXF1aXJlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFNvdXJjZUNvZGVJbmZvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bG9jYXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJMb2NhdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0TG9jYXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhdGg6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3Bhbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsZWFkaW5nQ29tbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFpbGluZ0NvbW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bGVhZGluZ0RldGFjaGVkQ29tbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0R2VuZXJhdGVkQ29kZUluZm86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRhbm5vdGF0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQW5ub3RhdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0QW5ub3RhdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzb3VyY2VGaWxlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0YmVnaW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGVuZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRTdHJ1Y3Q6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRWYWx1ZToge1xuXHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdGtpbmQ6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJudWxsVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwibnVtYmVyVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwic3RyaW5nVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwiYm9vbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcInN0cnVjdFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcImxpc3RWYWx1ZVwiXG5cdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG51bGxWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTnVsbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bnVtYmVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHN0cmluZ1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRib29sVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRzdHJ1Y3RWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU3RydWN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bGlzdFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJMaXN0VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHROdWxsVmFsdWU6IHtcblx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHROVUxMX1ZBTFVFOiAwXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRMaXN0VmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVtcHR5OiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdERvdWJsZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZsb2F0VmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZmxvYXRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRJbnQ2NFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0VUludDY0VmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwidWludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0SW50MzJWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFVJbnQzMlZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInVpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEJvb2xWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0U3RyaW5nVmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Qnl0ZXNWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEFueToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHR5cGVVcmw6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmaXJlc3RvcmU6IHtcblx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0djE6IHtcblx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0Y3NoYXJwX25hbWVzcGFjZTogXCJHb29nbGUuQ2xvdWQuRmlyZXN0b3JlLlYxXCIsXG5cdFx0XHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiZ29vZ2xlLmdvbGFuZy5vcmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy9maXJlc3RvcmUvdjE7ZmlyZXN0b3JlXCIsXG5cdFx0XHRcdFx0XHRcdGphdmFfbXVsdGlwbGVfZmlsZXM6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGphdmFfb3V0ZXJfY2xhc3NuYW1lOiBcIldyaXRlUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0amF2YV9wYWNrYWdlOiBcImNvbS5nb29nbGUuZmlyZXN0b3JlLnYxXCIsXG5cdFx0XHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIkdDRlNcIixcblx0XHRcdFx0XHRcdFx0cGhwX25hbWVzcGFjZTogXCJHb29nbGVcXFxcQ2xvdWRcXFxcRmlyZXN0b3JlXFxcXFYxXCIsXG5cdFx0XHRcdFx0XHRcdHJ1YnlfcGFja2FnZTogXCJHb29nbGU6OkNsb3VkOjpGaXJlc3RvcmU6OlYxXCJcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0QWdncmVnYXRpb25SZXN1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGFnZ3JlZ2F0ZUZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRCaXRTZXF1ZW5jZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Yml0bWFwOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWRkaW5nOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJsb29tRmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRiaXRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQml0U2VxdWVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRoYXNoQ291bnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RG9jdW1lbnRNYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZFBhdGhzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFByZWNvbmRpdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uZGl0aW9uVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZXhpc3RzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ1cGRhdGVUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRleGlzdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFRyYW5zYWN0aW9uT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0bW9kZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZE9ubHlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRXcml0ZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZE9ubHk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJSZWFkT25seVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRXcml0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlJlYWRXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRSZWFkV3JpdGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0cnlUcmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRSZWFkT25seToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3JlYXRlVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibnVsbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJib29sZWFuVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImludGVnZXJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZG91YmxlVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInRpbWVzdGFtcFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJpbmdWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYnl0ZXNWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVmZXJlbmNlVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImdlb1BvaW50VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImFycmF5VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm1hcFZhbHVlXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRudWxsVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGJvb2xlYW5WYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRpbnRlZ2VyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQ2NFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvdWJsZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZG91YmxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGltZXN0YW1wVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cmluZ1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxN1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGJ5dGVzVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMThcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWZlcmVuY2VWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGdlb1BvaW50VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUudHlwZS5MYXRMbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRhcnJheVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQXJyYXlWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG1hcFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTWFwVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEFycmF5VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdE1hcFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5VHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RmlyZXN0b3JlOiB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5kZWZhdWx0X2hvc3QpXCI6IFwiZmlyZXN0b3JlLmdvb2dsZWFwaXMuY29tXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm9hdXRoX3Njb3BlcylcIjogXCJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtLGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZGF0YXN0b3JlXCJcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG1ldGhvZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdEdldERvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkdldERvY3VtZW50UmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuZ2V0XCI6IFwiL3YxL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRnZXQ6IFwiL3YxL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRMaXN0RG9jdW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkxpc3REb2N1bWVudHNSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJMaXN0RG9jdW1lbnRzUmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuZ2V0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn0ve2NvbGxlY3Rpb25faWR9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRnZXQ6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn0ve2NvbGxlY3Rpb25faWR9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRVcGRhdGVEb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJVcGRhdGVEb2N1bWVudFJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBhdGNoXCI6IFwiL3YxL3tkb2N1bWVudC5uYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiZG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwiZG9jdW1lbnQsdXBkYXRlX21hc2tcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBhdGNoOiBcIi92MS97ZG9jdW1lbnQubmFtZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcImRvY3VtZW50XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkb2N1bWVudCx1cGRhdGVfbWFza1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RGVsZXRlRG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiRGVsZXRlRG9jdW1lbnRSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJnb29nbGUucHJvdG9idWYuRW1wdHlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuZGVsZXRlXCI6IFwiL3YxL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcIm5hbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZGVsZXRlXCI6IFwiL3YxL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJuYW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRCYXRjaEdldERvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJCYXRjaEdldERvY3VtZW50c1JlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkJhdGNoR2V0RG9jdW1lbnRzUmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpiYXRjaEdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmF0Y2hHZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRCZWdpblRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkJlZ2luVHJhbnNhY3Rpb25SZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJCZWdpblRyYW5zYWN0aW9uUmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmJlZ2luVHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRhdGFiYXNlXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmJlZ2luVHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkYXRhYmFzZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Q29tbWl0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkNvbW1pdFJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkNvbW1pdFJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpjb21taXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRhdGFiYXNlLHdyaXRlc1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpjb21taXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkYXRhYmFzZSx3cml0ZXNcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFJvbGxiYWNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIlJvbGxiYWNrUmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLkVtcHR5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpyb2xsYmFja1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwiZGF0YWJhc2UsdHJhbnNhY3Rpb25cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6cm9sbGJhY2tcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkYXRhYmFzZSx0cmFuc2FjdGlvblwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0UnVuUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiUnVuUXVlcnlSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJSdW5RdWVyeVJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9OnJ1blF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5wb3N0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn06cnVuUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9OnJ1blF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRpdGlvbmFsX2JpbmRpbmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpydW5RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRSdW5BZ2dyZWdhdGlvblF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIlJ1bkFnZ3JlZ2F0aW9uUXVlcnlSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJSdW5BZ2dyZWdhdGlvblF1ZXJ5UmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cnVuQWdncmVnYXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnJ1bkFnZ3JlZ2F0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9OnJ1bkFnZ3JlZ2F0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFkZGl0aW9uYWxfYmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnJ1bkFnZ3JlZ2F0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0UGFydGl0aW9uUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiUGFydGl0aW9uUXVlcnlSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJQYXJ0aXRpb25RdWVyeVJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cGFydGl0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpwYXJ0aXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306cGFydGl0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFkZGl0aW9uYWxfYmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnBhcnRpdGlvblF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFdyaXRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIldyaXRlUmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0U3RyZWFtOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiV3JpdGVSZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVN0cmVhbTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOndyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czp3cml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdExpc3Rlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJMaXN0ZW5SZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJMaXN0ZW5SZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVN0cmVhbTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmxpc3RlblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6bGlzdGVuXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0TGlzdENvbGxlY3Rpb25JZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiTGlzdENvbGxlY3Rpb25JZHNSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJMaXN0Q29sbGVjdGlvbklkc1Jlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306bGlzdENvbGxlY3Rpb25JZHNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLnBvc3RcIjogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpsaXN0Q29sbGVjdGlvbklkc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5ib2R5XCI6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJwYXJlbnRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9Omxpc3RDb2xsZWN0aW9uSWRzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRpdGlvbmFsX2JpbmRpbmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpsaXN0Q29sbGVjdGlvbklkc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJwYXJlbnRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdEJhdGNoV3JpdGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiQmF0Y2hXcml0ZVJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkJhdGNoV3JpdGVSZXNwb25zZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmF0Y2hXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmF0Y2hXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdENyZWF0ZURvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkNyZWF0ZURvY3VtZW50UmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyoqfS97Y29sbGVjdGlvbl9pZH1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCJkb2N1bWVudFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qKn0ve2NvbGxlY3Rpb25faWR9XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiZG9jdW1lbnRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0R2V0RG9jdW1lbnRSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZFRpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG1hc2s6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudE1hc2tcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMaXN0RG9jdW1lbnRzUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc2lzdGVuY3lTZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvbGxlY3Rpb25JZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVNpemU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhZ2VUb2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG9yZGVyQnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMTBcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzaG93TWlzc2luZzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMaXN0RG9jdW1lbnRzUmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXh0UGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRDcmVhdGVEb2N1bWVudFJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29sbGVjdGlvbklkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudElkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VXBkYXRlRG9jdW1lbnRSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVNYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnREb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlByZWNvbmRpdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RGVsZXRlRG9jdW1lbnRSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50RG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJQcmVjb25kaXRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJhdGNoR2V0RG9jdW1lbnRzUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc2lzdGVuY3lTZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm5ld1RyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdUcmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRyYW5zYWN0aW9uT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0QmF0Y2hHZXREb2N1bWVudHNSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJmb3VuZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibWlzc2luZ1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm91bmQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG1pc3Npbmc6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRCZWdpblRyYW5zYWN0aW9uUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUcmFuc2FjdGlvbk9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJlZ2luVHJhbnNhY3Rpb25SZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Q29tbWl0UmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiV3JpdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRDb21taXRSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVSZXN1bHRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJXcml0ZVJlc3VsdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvbW1pdFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRSb2xsYmFja1JlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFiYXNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFJ1blF1ZXJ5UmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cXVlcnlUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJ1Y3R1cmVkUXVlcnlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc2lzdGVuY3lTZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm5ld1RyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJ1Y3R1cmVkUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJTdHJ1Y3R1cmVkUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3VHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUcmFuc2FjdGlvbk9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFJ1blF1ZXJ5UmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c2tpcHBlZFJlc3VsdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHF1ZXJ5VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic3RydWN0dXJlZEFnZ3JlZ2F0aW9uUXVlcnlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc2lzdGVuY3lTZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm5ld1RyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJ1Y3R1cmVkQWdncmVnYXRpb25RdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRBZ2dyZWdhdGlvblF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG5ld1RyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVHJhbnNhY3Rpb25PcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRSdW5BZ2dyZWdhdGlvblF1ZXJ5UmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkFnZ3JlZ2F0aW9uUmVzdWx0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UGFydGl0aW9uUXVlcnlSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRxdWVyeVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInN0cnVjdHVyZWRRdWVyeVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJ1Y3R1cmVkUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJTdHJ1Y3R1cmVkUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJ0aXRpb25Db3VudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVNpemU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UGFydGl0aW9uUXVlcnlSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFydGl0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ3Vyc29yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bmV4dFBhZ2VUb2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0V3JpdGVSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RyZWFtSWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR3cml0ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIldyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RyZWFtVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0V3JpdGVSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RyZWFtSWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1Ub2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVSZXN1bHRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJXcml0ZVJlc3VsdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvbW1pdFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMaXN0ZW5SZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRDaGFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImFkZFRhcmdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVtb3ZlVGFyZ2V0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0YWRkVGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVGFyZ2V0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVtb3ZlVGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5VHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3RlblJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInRhcmdldENoYW5nZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZG9jdW1lbnRDaGFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImRvY3VtZW50RGVsZXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJkb2N1bWVudFJlbW92ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZmlsdGVyXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRDaGFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUYXJnZXRDaGFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudENoYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50Q2hhbmdlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnREZWxldGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudERlbGV0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50UmVtb3ZlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRSZW1vdmVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRmaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFeGlzdGVuY2VGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFRhcmdldDoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImRvY3VtZW50c1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bWVUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZXN1bWVUb2tlblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZFRpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUXVlcnlUYXJnZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudHNUYXJnZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bWVUb2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldElkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRvbmNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGV4cGVjdGVkQ291bnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMTJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0RG9jdW1lbnRzVGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0UXVlcnlUYXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cXVlcnlUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInN0cnVjdHVyZWRRdWVyeVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3RydWN0dXJlZFF1ZXJ5OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRRdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFRhcmdldENoYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0Q2hhbmdlVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRhcmdldENoYW5nZVR5cGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRJZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y2F1c2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucnBjLlN0YXR1c1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VtZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0VGFyZ2V0Q2hhbmdlVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHROT19DSEFOR0U6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0QUREOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFJFTU9WRTogMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRDVVJSRU5UOiAzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFJFU0VUOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3RDb2xsZWN0aW9uSWRzUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlU2l6ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMaXN0Q29sbGVjdGlvbklkc1Jlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb2xsZWN0aW9uSWRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXh0UGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRCYXRjaFdyaXRlUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiV3JpdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5VHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJhdGNoV3JpdGVSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVSZXN1bHRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJXcml0ZVJlc3VsdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXR1czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnJwYy5TdGF0dXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFN0cnVjdHVyZWRRdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0c2VsZWN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUHJvamVjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZyb206IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkNvbGxlY3Rpb25TZWxlY3RvclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHdoZXJlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0b3JkZXJCeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiT3JkZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydEF0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ3Vyc29yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kQXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDdXJzb3JcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRvZmZzZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGxpbWl0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Q29sbGVjdGlvblNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbGxlY3Rpb25JZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhbGxEZXNjZW5kYW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdEZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWx0ZXJUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImNvbXBvc2l0ZUZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImZpZWxkRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidW5hcnlGaWx0ZXJcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29tcG9zaXRlRmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkNvbXBvc2l0ZUZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkRmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5hcnlGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5hcnlGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Q29tcG9zaXRlRmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9wZXJhdG9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmlsdGVyczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPcGVyYXRvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9QRVJBVE9SX1VOU1BFQ0lGSUVEOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBTkQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9SOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RmllbGRGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPcGVyYXRvclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0T3BlcmF0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPUEVSQVRPUl9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0TEVTU19USEFOOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRMRVNTX1RIQU5fT1JfRVFVQUw6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEdSRUFURVJfVEhBTjogMyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0R1JFQVRFUl9USEFOX09SX0VRVUFMOiA0LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRFUVVBTDogNSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Tk9UX0VRVUFMOiA2LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBUlJBWV9DT05UQUlOUzogNyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0SU46IDgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEFSUkFZX0NPTlRBSU5TX0FOWTogOSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Tk9UX0lOOiAxMFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFVuYXJ5RmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wZXJhbmRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImZpZWxkXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9wZXJhdG9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPcGVyYXRvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9QRVJBVE9SX1VOU1BFQ0lGSUVEOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRJU19OQU46IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdElTX05VTEw6IDMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdElTX05PVF9OQU46IDQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdElTX05PVF9OVUxMOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0T3JkZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkaXJlY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRGlyZWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdEZpZWxkUmVmZXJlbmNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkUGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0UHJvamVjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RGlyZWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdERJUkVDVElPTl9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBU0NFTkRJTkc6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0REVTQ0VORElORzogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRTdHJ1Y3R1cmVkQWdncmVnYXRpb25RdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cXVlcnlUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJ1Y3R1cmVkUXVlcnlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0cnVjdHVyZWRRdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRRdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGFnZ3JlZ2F0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQWdncmVnYXRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0QWdncmVnYXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3BlcmF0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiY291bnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdW1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJhdmdcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y291bnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ291bnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdW06IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU3VtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXZnOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkF2Z1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFsaWFzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdENvdW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dXBUbzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRTdW06IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBdmc6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRDdXJzb3I6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRiZWZvcmU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRXcml0ZToge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3BlcmF0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ1cGRhdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImRlbGV0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidmVyaWZ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2Zvcm1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWxldGVcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHZlcmlmeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zZm9ybToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50VHJhbnNmb3JtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlTWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZVRyYW5zZm9ybXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50VHJhbnNmb3JtLkZpZWxkVHJhbnNmb3JtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudERvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUHJlY29uZGl0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudFRyYW5zZm9ybToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZFRyYW5zZm9ybXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkVHJhbnNmb3JtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdEZpZWxkVHJhbnNmb3JtOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zZm9ybVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic2V0VG9TZXJ2ZXJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImluY3JlbWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm1heGltdW1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJtaW5pbXVtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYXBwZW5kTWlzc2luZ0VsZW1lbnRzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVtb3ZlQWxsRnJvbUFycmF5XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkUGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzZXRUb1NlcnZlclZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNlcnZlclZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW5jcmVtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4aW11bToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pbmltdW06IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcHBlbmRNaXNzaW5nRWxlbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQXJyYXlWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlbW92ZUFsbEZyb21BcnJheToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJBcnJheVZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0U2VydmVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRTRVJWRVJfVkFMVUVfVU5TUEVDSUZJRUQ6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFJFUVVFU1RfVElNRTogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0V3JpdGVSZXN1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZVRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtUmVzdWx0czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdERvY3VtZW50Q2hhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0SWRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlbW92ZWRUYXJnZXRJZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudERlbGV0ZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZW1vdmVkVGFyZ2V0SWRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RG9jdW1lbnRSZW1vdmU6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVtb3ZlZFRhcmdldElkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEV4aXN0ZW5jZUZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0SWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvdW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1bmNoYW5nZWROYW1lczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkJsb29tRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YXBpOiB7XG5cdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRnb19wYWNrYWdlOiBcImdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvYXBpL2Fubm90YXRpb25zO2Fubm90YXRpb25zXCIsXG5cdFx0XHRcdFx0amF2YV9tdWx0aXBsZV9maWxlczogdHJ1ZSxcblx0XHRcdFx0XHRqYXZhX291dGVyX2NsYXNzbmFtZTogXCJIdHRwUHJvdG9cIixcblx0XHRcdFx0XHRqYXZhX3BhY2thZ2U6IFwiY29tLmdvb2dsZS5hcGlcIixcblx0XHRcdFx0XHRvYmpjX2NsYXNzX3ByZWZpeDogXCJHQVBJXCIsXG5cdFx0XHRcdFx0Y2NfZW5hYmxlX2FyZW5hczogdHJ1ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRodHRwOiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcIkh0dHBSdWxlXCIsXG5cdFx0XHRcdFx0XHRpZDogNzIyOTU3MjgsXG5cdFx0XHRcdFx0XHRleHRlbmQ6IFwiZ29vZ2xlLnByb3RvYnVmLk1ldGhvZE9wdGlvbnNcIlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0SHR0cDoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHJ1bGVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiSHR0cFJ1bGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRIdHRwUnVsZToge1xuXHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdHBhdHRlcm46IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJnZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwicHV0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcInBvc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwiZGVsZXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcInBhdGNoXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcImN1c3RvbVwiXG5cdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGdldDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cHV0OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRwb3N0OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcImRlbGV0ZVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRwYXRjaDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Y3VzdG9tOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDdXN0b21IdHRwUGF0dGVyblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRib2R5OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRhZGRpdGlvbmFsQmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJIdHRwUnVsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRDdXN0b21IdHRwUGF0dGVybjoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGtpbmQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBhdGg6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG1ldGhvZFNpZ25hdHVyZToge1xuXHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdGlkOiAxMDUxLFxuXHRcdFx0XHRcdFx0ZXh0ZW5kOiBcImdvb2dsZS5wcm90b2J1Zi5NZXRob2RPcHRpb25zXCJcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGRlZmF1bHRIb3N0OiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0aWQ6IDEwNDksXG5cdFx0XHRcdFx0XHRleHRlbmQ6IFwiZ29vZ2xlLnByb3RvYnVmLlNlcnZpY2VPcHRpb25zXCJcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG9hdXRoU2NvcGVzOiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0aWQ6IDEwNTAsXG5cdFx0XHRcdFx0XHRleHRlbmQ6IFwiZ29vZ2xlLnByb3RvYnVmLlNlcnZpY2VPcHRpb25zXCJcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGZpZWxkQmVoYXZpb3I6IHtcblx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLmFwaS5GaWVsZEJlaGF2aW9yXCIsXG5cdFx0XHRcdFx0XHRpZDogMTA1Mixcblx0XHRcdFx0XHRcdGV4dGVuZDogXCJnb29nbGUucHJvdG9idWYuRmllbGRPcHRpb25zXCJcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZpZWxkQmVoYXZpb3I6IHtcblx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRGSUVMRF9CRUhBVklPUl9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0T1BUSU9OQUw6IDEsXG5cdFx0XHRcdFx0XHRcdFJFUVVJUkVEOiAyLFxuXHRcdFx0XHRcdFx0XHRPVVRQVVRfT05MWTogMyxcblx0XHRcdFx0XHRcdFx0SU5QVVRfT05MWTogNCxcblx0XHRcdFx0XHRcdFx0SU1NVVRBQkxFOiA1LFxuXHRcdFx0XHRcdFx0XHRVTk9SREVSRURfTElTVDogNixcblx0XHRcdFx0XHRcdFx0Tk9OX0VNUFRZX0RFRkFVTFQ6IDdcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR0eXBlOiB7XG5cdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRjY19lbmFibGVfYXJlbmFzOiB0cnVlLFxuXHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiZ29vZ2xlLmdvbGFuZy5vcmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy90eXBlL2xhdGxuZztsYXRsbmdcIixcblx0XHRcdFx0XHRqYXZhX211bHRpcGxlX2ZpbGVzOiB0cnVlLFxuXHRcdFx0XHRcdGphdmFfb3V0ZXJfY2xhc3NuYW1lOiBcIkxhdExuZ1Byb3RvXCIsXG5cdFx0XHRcdFx0amF2YV9wYWNrYWdlOiBcImNvbS5nb29nbGUudHlwZVwiLFxuXHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIkdUUFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdExhdExuZzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGxhdGl0dWRlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJkb3VibGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRsb25naXR1ZGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRycGM6IHtcblx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdGNjX2VuYWJsZV9hcmVuYXM6IHRydWUsXG5cdFx0XHRcdFx0Z29fcGFja2FnZTogXCJnb29nbGUuZ29sYW5nLm9yZy9nZW5wcm90by9nb29nbGVhcGlzL3JwYy9zdGF0dXM7c3RhdHVzXCIsXG5cdFx0XHRcdFx0amF2YV9tdWx0aXBsZV9maWxlczogdHJ1ZSxcblx0XHRcdFx0XHRqYXZhX291dGVyX2NsYXNzbmFtZTogXCJTdGF0dXNQcm90b1wiLFxuXHRcdFx0XHRcdGphdmFfcGFja2FnZTogXCJjb20uZ29vZ2xlLnJwY1wiLFxuXHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIlJQQ1wiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFN0YXR1czoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGNvZGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bWVzc2FnZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGV0YWlsczoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5BbnlcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xudmFyIHByb3RvcyA9IHtcblx0bmVzdGVkOiBuZXN0ZWRcbn07XG5cbnZhciBwcm90b3MkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBuZXN0ZWQ6IG5lc3RlZCxcbiAgJ2RlZmF1bHQnOiBwcm90b3Ncbn0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIFVzZWQgYnkgdGVzdHMgc28gd2UgY2FuIG1hdGNoIEBncnBjL3Byb3RvLWxvYWRlciBiZWhhdmlvci4gKi9cbmNvbnN0IHByb3RvTG9hZGVyT3B0aW9ucyA9IHtcbiAgICBsb25nczogU3RyaW5nLFxuICAgIGVudW1zOiBTdHJpbmcsXG4gICAgZGVmYXVsdHM6IHRydWUsXG4gICAgb25lb2ZzOiBmYWxzZVxufTtcbi8qKlxuICogTG9hZHMgdGhlIHByb3RvY29sIGJ1ZmZlciBkZWZpbml0aW9ucyBmb3IgRmlyZXN0b3JlLlxuICpcbiAqIEByZXR1cm5zIFRoZSBHcnBjT2JqZWN0IHJlcHJlc2VudGluZyBvdXIgcHJvdG9zLlxuICovXG5mdW5jdGlvbiBsb2FkUHJvdG9zKCkge1xuICAgIGNvbnN0IHBhY2thZ2VEZWZpbml0aW9uID0gcHJvdG9Mb2FkZXIuZnJvbUpTT04ocHJvdG9zJDEsIHByb3RvTG9hZGVyT3B0aW9ucyk7XG4gICAgcmV0dXJuIGdycGMubG9hZFBhY2thZ2VEZWZpbml0aW9uKHBhY2thZ2VEZWZpbml0aW9uKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKiBMb2FkcyB0aGUgR1JQQyBzdGFjayAqL1xuZnVuY3Rpb24gbmV3Q29ubmVjdGlvbihkYXRhYmFzZUluZm8pIHtcbiAgICBjb25zdCBwcm90b3MgPSBsb2FkUHJvdG9zKCk7XG4gICAgcmV0dXJuIG5ldyBHcnBjQ29ubmVjdGlvbihwcm90b3MsIGRhdGFiYXNlSW5mbyk7XG59XG4vKiogUmV0dXJuIHRoZSBQbGF0Zm9ybS1zcGVjaWZpYyBjb25uZWN0aXZpdHkgbW9uaXRvci4gKi9cbmZ1bmN0aW9uIG5ld0Nvbm5lY3Rpdml0eU1vbml0b3IoKSB7XG4gICAgcmV0dXJuIG5ldyBOb29wQ29ubmVjdGl2aXR5TW9uaXRvcigpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIFRoZSBQbGF0Zm9ybSdzICd3aW5kb3cnIGltcGxlbWVudGF0aW9uIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZS4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdygpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuVVNFX01PQ0tfUEVSU0lTVEVOQ0UgPT09ICdZRVMnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKiogVGhlIFBsYXRmb3JtJ3MgJ2RvY3VtZW50JyBpbXBsZW1lbnRhdGlvbiBvciBudWxsIGlmIG5vdCBhdmFpbGFibGUuICovXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIG5ld1NlcmlhbGl6ZXIoZGF0YWJhc2VJZCkge1xuICAgIHJldHVybiBuZXcgSnNvblByb3RvU2VyaWFsaXplcihkYXRhYmFzZUlkLCAvKiB1c2VQcm90bzNKc29uPSAqLyBmYWxzZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJDggPSAnRXhwb25lbnRpYWxCYWNrb2ZmJztcbi8qKlxuICogSW5pdGlhbCBiYWNrb2ZmIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFmdGVyIGFuIGVycm9yLlxuICogU2V0IHRvIDFzIGFjY29yZGluZyB0byBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vYXBpcy9kZXNpZ24vZXJyb3JzLlxuICovXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfSU5JVElBTF9ERUxBWV9NUyA9IDEwMDA7XG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SID0gMS41O1xuLyoqIE1heGltdW0gYmFja29mZiB0aW1lIGluIG1pbGxpc2Vjb25kcyAqL1xuY29uc3QgREVGQVVMVF9CQUNLT0ZGX01BWF9ERUxBWV9NUyA9IDYwICogMTAwMDtcbi8qKlxuICogQSBoZWxwZXIgZm9yIHJ1bm5pbmcgZGVsYXllZCB0YXNrcyBmb2xsb3dpbmcgYW4gZXhwb25lbnRpYWwgYmFja29mZiBjdXJ2ZVxuICogYmV0d2VlbiBhdHRlbXB0cy5cbiAqXG4gKiBFYWNoIGRlbGF5IGlzIG1hZGUgdXAgb2YgYSBcImJhc2VcIiBkZWxheSB3aGljaCBmb2xsb3dzIHRoZSBleHBvbmVudGlhbFxuICogYmFja29mZiBjdXJ2ZSwgYW5kIGEgKy8tIDUwJSBcImppdHRlclwiIHRoYXQgaXMgY2FsY3VsYXRlZCBhbmQgYWRkZWQgdG8gdGhlXG4gKiBiYXNlIGRlbGF5LiBUaGlzIHByZXZlbnRzIGNsaWVudHMgZnJvbSBhY2NpZGVudGFsbHkgc3luY2hyb25pemluZyB0aGVpclxuICogZGVsYXlzIGNhdXNpbmcgc3Bpa2VzIG9mIGxvYWQgdG8gdGhlIGJhY2tlbmQuXG4gKi9cbmNsYXNzIEV4cG9uZW50aWFsQmFja29mZiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIEFzeW5jUXVldWUgdG8gcnVuIGJhY2tvZmYgb3BlcmF0aW9ucyBvbi5cbiAgICAgKi9cbiAgICBxdWV1ZSwgXG4gICAgLyoqXG4gICAgICogVGhlIElEIHRvIHVzZSB3aGVuIHNjaGVkdWxpbmcgYmFja29mZiBvcGVyYXRpb25zIG9uIHRoZSBBc3luY1F1ZXVlLlxuICAgICAqL1xuICAgIHRpbWVySWQsIFxuICAgIC8qKlxuICAgICAqIFRoZSBpbml0aWFsIGRlbGF5ICh1c2VkIGFzIHRoZSBiYXNlIGRlbGF5IG9uIHRoZSBmaXJzdCByZXRyeSBhdHRlbXB0KS5cbiAgICAgKiBOb3RlIHRoYXQgaml0dGVyIHdpbGwgc3RpbGwgYmUgYXBwbGllZCwgc28gdGhlIGFjdHVhbCBkZWxheSBjb3VsZCBiZSBhc1xuICAgICAqIGxpdHRsZSBhcyAwLjUqaW5pdGlhbERlbGF5TXMuXG4gICAgICovXG4gICAgaW5pdGlhbERlbGF5TXMgPSBERUZBVUxUX0JBQ0tPRkZfSU5JVElBTF9ERUxBWV9NUywgXG4gICAgLyoqXG4gICAgICogVGhlIG11bHRpcGxpZXIgdG8gdXNlIHRvIGRldGVybWluZSB0aGUgZXh0ZW5kZWQgYmFzZSBkZWxheSBhZnRlciBlYWNoXG4gICAgICogYXR0ZW1wdC5cbiAgICAgKi9cbiAgICBiYWNrb2ZmRmFjdG9yID0gREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUiwgXG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gYmFzZSBkZWxheSBhZnRlciB3aGljaCBubyBmdXJ0aGVyIGJhY2tvZmYgaXMgcGVyZm9ybWVkLlxuICAgICAqIE5vdGUgdGhhdCBqaXR0ZXIgd2lsbCBzdGlsbCBiZSBhcHBsaWVkLCBzbyB0aGUgYWN0dWFsIGRlbGF5IGNvdWxkIGJlIGFzXG4gICAgICogbXVjaCBhcyAxLjUqbWF4RGVsYXlNcy5cbiAgICAgKi9cbiAgICBtYXhEZWxheU1zID0gREVGQVVMVF9CQUNLT0ZGX01BWF9ERUxBWV9NUykge1xuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgICAgIHRoaXMudGltZXJJZCA9IHRpbWVySWQ7XG4gICAgICAgIHRoaXMuaW5pdGlhbERlbGF5TXMgPSBpbml0aWFsRGVsYXlNcztcbiAgICAgICAgdGhpcy5iYWNrb2ZmRmFjdG9yID0gYmFja29mZkZhY3RvcjtcbiAgICAgICAgdGhpcy5tYXhEZWxheU1zID0gbWF4RGVsYXlNcztcbiAgICAgICAgdGhpcy5jdXJyZW50QmFzZU1zID0gMDtcbiAgICAgICAgdGhpcy50aW1lclByb21pc2UgPSBudWxsO1xuICAgICAgICAvKiogVGhlIGxhc3QgYmFja29mZiBhdHRlbXB0LCBhcyBlcG9jaCBtaWxsaXNlY29uZHMuICovXG4gICAgICAgIHRoaXMubGFzdEF0dGVtcHRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGJhY2tvZmYgZGVsYXkuXG4gICAgICpcbiAgICAgKiBUaGUgdmVyeSBuZXh0IGJhY2tvZmZBbmRXYWl0KCkgd2lsbCBoYXZlIG5vIGRlbGF5LiBJZiBpdCBpcyBjYWxsZWQgYWdhaW5cbiAgICAgKiAoaS5lLiBkdWUgdG8gYW4gZXJyb3IpLCBpbml0aWFsRGVsYXlNcyAocGx1cyBqaXR0ZXIpIHdpbGwgYmUgdXNlZCwgYW5kXG4gICAgICogc3Vic2VxdWVudCBvbmVzIHdpbGwgaW5jcmVhc2UgYWNjb3JkaW5nIHRvIHRoZSBiYWNrb2ZmRmFjdG9yLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRCYXNlTXMgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGJhY2tvZmYgZGVsYXkgdG8gdGhlIG1heGltdW0gZGVsYXkgKGUuZy4gZm9yIHVzZSBhZnRlciBhXG4gICAgICogUkVTT1VSQ0VfRVhIQVVTVEVEIGVycm9yKS5cbiAgICAgKi9cbiAgICByZXNldFRvTWF4KCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRCYXNlTXMgPSB0aGlzLm1heERlbGF5TXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgY3VycmVudERlbGF5TXMsIGFuZCBpbmNyZWFzZXMgdGhlXG4gICAgICogZGVsYXkgZm9yIGFueSBzdWJzZXF1ZW50IGF0dGVtcHRzLiBJZiB0aGVyZSB3YXMgYSBwZW5kaW5nIGJhY2tvZmYgb3BlcmF0aW9uXG4gICAgICogYWxyZWFkeSwgaXQgd2lsbCBiZSBjYW5jZWxlZC5cbiAgICAgKi9cbiAgICBiYWNrb2ZmQW5kUnVuKG9wKSB7XG4gICAgICAgIC8vIENhbmNlbCBhbnkgcGVuZGluZyBiYWNrb2ZmIG9wZXJhdGlvbi5cbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgLy8gRmlyc3Qgc2NoZWR1bGUgdXNpbmcgdGhlIGN1cnJlbnQgYmFzZSAod2hpY2ggbWF5IGJlIDAgYW5kIHNob3VsZCBiZVxuICAgICAgICAvLyBob25vcmVkIGFzIHN1Y2gpLlxuICAgICAgICBjb25zdCBkZXNpcmVkRGVsYXlXaXRoSml0dGVyTXMgPSBNYXRoLmZsb29yKHRoaXMuY3VycmVudEJhc2VNcyArIHRoaXMuaml0dGVyRGVsYXlNcygpKTtcbiAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCBsYXN0QXR0ZW1wdFRpbWUgYmVpbmcgaW4gdGhlIGZ1dHVyZSBkdWUgdG8gYSBjbG9jayBjaGFuZ2UuXG4gICAgICAgIGNvbnN0IGRlbGF5U29GYXJNcyA9IE1hdGgubWF4KDAsIERhdGUubm93KCkgLSB0aGlzLmxhc3RBdHRlbXB0VGltZSk7XG4gICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIGJhY2tvZmYgZGVsYXkgYWxyZWFkeSBiZWluZyBwYXN0LlxuICAgICAgICBjb25zdCByZW1haW5pbmdEZWxheU1zID0gTWF0aC5tYXgoMCwgZGVzaXJlZERlbGF5V2l0aEppdHRlck1zIC0gZGVsYXlTb0Zhck1zKTtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0RlbGF5TXMgPiAwKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDgsIGBCYWNraW5nIG9mZiBmb3IgJHtyZW1haW5pbmdEZWxheU1zfSBtcyBgICtcbiAgICAgICAgICAgICAgICBgKGJhc2UgZGVsYXk6ICR7dGhpcy5jdXJyZW50QmFzZU1zfSBtcywgYCArXG4gICAgICAgICAgICAgICAgYGRlbGF5IHdpdGggaml0dGVyOiAke2Rlc2lyZWREZWxheVdpdGhKaXR0ZXJNc30gbXMsIGAgK1xuICAgICAgICAgICAgICAgIGBsYXN0IGF0dGVtcHQ6ICR7ZGVsYXlTb0Zhck1zfSBtcyBhZ28pYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lclByb21pc2UgPSB0aGlzLnF1ZXVlLmVucXVldWVBZnRlckRlbGF5KHRoaXMudGltZXJJZCwgcmVtYWluaW5nRGVsYXlNcywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sYXN0QXR0ZW1wdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgcmV0dXJuIG9wKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBcHBseSBiYWNrb2ZmIGZhY3RvciB0byBkZXRlcm1pbmUgbmV4dCBkZWxheSBhbmQgZW5zdXJlIGl0IGlzIHdpdGhpblxuICAgICAgICAvLyBib3VuZHMuXG4gICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyAqPSB0aGlzLmJhY2tvZmZGYWN0b3I7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRCYXNlTXMgPCB0aGlzLmluaXRpYWxEZWxheU1zKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRCYXNlTXMgPSB0aGlzLmluaXRpYWxEZWxheU1zO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRCYXNlTXMgPiB0aGlzLm1heERlbGF5TXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyA9IHRoaXMubWF4RGVsYXlNcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBza2lwQmFja29mZigpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXJQcm9taXNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZS5za2lwRGVsYXkoKTtcbiAgICAgICAgICAgIHRoaXMudGltZXJQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyUHJvbWlzZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aW1lclByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSByYW5kb20gdmFsdWUgaW4gdGhlIHJhbmdlIFstY3VycmVudEJhc2VNcy8yLCBjdXJyZW50QmFzZU1zLzJdICovXG4gICAgaml0dGVyRGVsYXlNcygpIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHRoaXMuY3VycmVudEJhc2VNcztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJDcgPSAnUGVyc2lzdGVudFN0cmVhbSc7XG4vKiogVGhlIHRpbWUgYSBzdHJlYW0gc3RheXMgb3BlbiBhZnRlciBpdCBpcyBtYXJrZWQgaWRsZS4gKi9cbmNvbnN0IElETEVfVElNRU9VVF9NUyA9IDYwICogMTAwMDtcbi8qKiBUaGUgdGltZSBhIHN0cmVhbSBzdGF5cyBvcGVuIHVudGlsIHdlIGNvbnNpZGVyIGl0IGhlYWx0aHkuICovXG5jb25zdCBIRUFMVEhZX1RJTUVPVVRfTVMgPSAxMCAqIDEwMDA7XG4vKipcbiAqIEEgUGVyc2lzdGVudFN0cmVhbSBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHN0cmVhbWluZyBSUENcbiAqIHRvIHRoZSBGaXJlc3RvcmUgYmFja2VuZC4gSXQncyBidWlsdCBvbiB0b3Agb2YgdGhlIGNvbm5lY3Rpb25zIG93biBzdXBwb3J0XG4gKiBmb3Igc3RyZWFtaW5nIFJQQ3MsIGFuZCBhZGRzIHNldmVyYWwgY3JpdGljYWwgZmVhdHVyZXMgZm9yIG91ciBjbGllbnRzOlxuICpcbiAqICAgLSBFeHBvbmVudGlhbCBiYWNrb2ZmIG9uIGZhaWx1cmVcbiAqICAgLSBBdXRoZW50aWNhdGlvbiB2aWEgQ3JlZGVudGlhbHNQcm92aWRlclxuICogICAtIERpc3BhdGNoaW5nIGFsbCBjYWxsYmFja3MgaW50byB0aGUgc2hhcmVkIHdvcmtlciBxdWV1ZVxuICogICAtIENsb3NpbmcgaWRsZSBzdHJlYW1zIGFmdGVyIDYwIHNlY29uZHMgb2YgaW5hY3Rpdml0eVxuICpcbiAqIFN1YmNsYXNzZXMgb2YgUGVyc2lzdGVudFN0cmVhbSBpbXBsZW1lbnQgc2VyaWFsaXphdGlvbiBvZiBtb2RlbHMgdG8gYW5kXG4gKiBmcm9tIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcm90b2NvbCBidWZmZXJzIGZvciBhIHNwZWNpZmljXG4gKiBzdHJlYW1pbmcgUlBDLlxuICpcbiAqICMjIFN0YXJ0aW5nIGFuZCBTdG9wcGluZ1xuICpcbiAqIFN0cmVhbWluZyBSUENzIGFyZSBzdGF0ZWZ1bCBhbmQgbmVlZCB0byBiZSBzdGFydCgpZWQgYmVmb3JlIG1lc3NhZ2VzIGNhblxuICogYmUgc2VudCBhbmQgcmVjZWl2ZWQuIFRoZSBQZXJzaXN0ZW50U3RyZWFtIHdpbGwgY2FsbCB0aGUgb25PcGVuKCkgZnVuY3Rpb25cbiAqIG9mIHRoZSBsaXN0ZW5lciBvbmNlIHRoZSBzdHJlYW0gaXMgcmVhZHkgdG8gYWNjZXB0IHJlcXVlc3RzLlxuICpcbiAqIFNob3VsZCBhIHN0YXJ0KCkgZmFpbCwgUGVyc2lzdGVudFN0cmVhbSB3aWxsIGNhbGwgdGhlIHJlZ2lzdGVyZWQgb25DbG9zZSgpXG4gKiBsaXN0ZW5lciB3aXRoIGEgRmlyZXN0b3JlRXJyb3IgaW5kaWNhdGluZyB3aGF0IHdlbnQgd3JvbmcuXG4gKlxuICogQSBQZXJzaXN0ZW50U3RyZWFtIGNhbiBiZSBzdGFydGVkIGFuZCBzdG9wcGVkIHJlcGVhdGVkbHkuXG4gKlxuICogR2VuZXJpYyB0eXBlczpcbiAqICBTZW5kVHlwZTogVGhlIHR5cGUgb2YgdGhlIG91dGdvaW5nIG1lc3NhZ2Ugb2YgdGhlIHVuZGVybHlpbmdcbiAqICAgIGNvbm5lY3Rpb24gc3RyZWFtXG4gKiAgUmVjZWl2ZVR5cGU6IFRoZSB0eXBlIG9mIHRoZSBpbmNvbWluZyBtZXNzYWdlIG9mIHRoZSB1bmRlcmx5aW5nXG4gKiAgICBjb25uZWN0aW9uIHN0cmVhbVxuICogIExpc3RlbmVyVHlwZTogVGhlIHR5cGUgb2YgdGhlIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBjYWxsYmFja3NcbiAqL1xuY2xhc3MgUGVyc2lzdGVudFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IocXVldWUsIGNvbm5lY3Rpb25UaW1lcklkLCBpZGxlVGltZXJJZCwgaGVhbHRoVGltZXJJZCwgY29ubmVjdGlvbiwgYXV0aENyZWRlbnRpYWxzUHJvdmlkZXIsIGFwcENoZWNrQ3JlZGVudGlhbHNQcm92aWRlciwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IHF1ZXVlO1xuICAgICAgICB0aGlzLmlkbGVUaW1lcklkID0gaWRsZVRpbWVySWQ7XG4gICAgICAgIHRoaXMuaGVhbHRoVGltZXJJZCA9IGhlYWx0aFRpbWVySWQ7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxzUHJvdmlkZXIgPSBhdXRoQ3JlZGVudGlhbHNQcm92aWRlcjtcbiAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXIgPSBhcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXI7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDAgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkluaXRpYWwgKi87XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNsb3NlIGNvdW50IHRoYXQncyBpbmNyZW1lbnRlZCBldmVyeSB0aW1lIHRoZSBzdHJlYW0gaXMgY2xvc2VkOyB1c2VkIGJ5XG4gICAgICAgICAqIGdldENsb3NlR3VhcmRlZERpc3BhdGNoZXIoKSB0byBpbnZhbGlkYXRlIGNhbGxiYWNrcyB0aGF0IGhhcHBlbiBhZnRlclxuICAgICAgICAgKiBjbG9zZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2VDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5oZWFsdGhDaGVjayA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50IG9mIHJlc3BvbnNlIG1lc3NhZ2VzIHJlY2VpdmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNwb25zZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5iYWNrb2ZmID0gbmV3IEV4cG9uZW50aWFsQmFja29mZihxdWV1ZSwgY29ubmVjdGlvblRpbWVySWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgc3RhcnQoKSBoYXMgYmVlbiBjYWxsZWQgYW5kIG5vIGVycm9yIGhhcyBvY2N1cnJlZC4gVHJ1ZVxuICAgICAqIGluZGljYXRlcyB0aGUgc3RyZWFtIGlzIG9wZW4gb3IgaW4gdGhlIHByb2Nlc3Mgb2Ygb3BlbmluZyAod2hpY2hcbiAgICAgKiBlbmNvbXBhc3NlcyByZXNwZWN0aW5nIGJhY2tvZmYsIGdldHRpbmcgYXV0aCB0b2tlbnMsIGFuZCBzdGFydGluZyB0aGVcbiAgICAgKiBhY3R1YWwgUlBDKS4gVXNlIGlzT3BlbigpIHRvIGRldGVybWluZSBpZiB0aGUgc3RyZWFtIGlzIG9wZW4gYW5kIHJlYWR5IGZvclxuICAgICAqIG91dGJvdW5kIHJlcXVlc3RzLlxuICAgICAqL1xuICAgIGlzU3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXRlID09PSAxIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5TdGFydGluZyAqLyB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gNSAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuQmFja29mZiAqLyB8fFxuICAgICAgICAgICAgdGhpcy5pc09wZW4oKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdW5kZXJseWluZyBSUEMgaXMgb3BlbiAodGhlIG9uT3BlbigpIGxpc3RlbmVyIGhhcyBiZWVuXG4gICAgICogY2FsbGVkKSBhbmQgdGhlIHN0cmVhbSBpcyByZWFkeSBmb3Igb3V0Ym91bmQgcmVxdWVzdHMuXG4gICAgICovXG4gICAgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGUgPT09IDIgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLk9wZW4gKi8gfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IDMgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkhlYWx0aHkgKi8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIFJQQy4gT25seSBhbGxvd2VkIGlmIGlzU3RhcnRlZCgpIHJldHVybnMgZmFsc2UuIFRoZSBzdHJlYW0gaXNcbiAgICAgKiBub3QgaW1tZWRpYXRlbHkgcmVhZHkgZm9yIHVzZTogb25PcGVuKCkgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIFJQQyBpc1xuICAgICAqIHJlYWR5IGZvciBvdXRib3VuZCByZXF1ZXN0cywgYXQgd2hpY2ggcG9pbnQgaXNPcGVuKCkgd2lsbCByZXR1cm4gdHJ1ZS5cbiAgICAgKlxuICAgICAqIFdoZW4gc3RhcnQgcmV0dXJucywgaXNTdGFydGVkKCkgd2lsbCByZXR1cm4gdHJ1ZS5cbiAgICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZUNvdW50ID0gMDtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IDQgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkVycm9yICovKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1CYWNrb2ZmKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdXRoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBSUEMuIFRoaXMgY2FsbCBpcyBpZGVtcG90ZW50IGFuZCBhbGxvd2VkIHJlZ2FyZGxlc3Mgb2YgdGhlXG4gICAgICogY3VycmVudCBpc1N0YXJ0ZWQoKSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIFdoZW4gc3RvcCByZXR1cm5zLCBpc1N0YXJ0ZWQoKSBhbmQgaXNPcGVuKCkgd2lsbCBib3RoIHJldHVybiBmYWxzZS5cbiAgICAgKi9cbiAgICBhc3luYyBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jbG9zZSgwIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5Jbml0aWFsICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZnRlciBhbiBlcnJvciB0aGUgc3RyZWFtIHdpbGwgdXN1YWxseSBiYWNrIG9mZiBvbiB0aGUgbmV4dCBhdHRlbXB0IHRvXG4gICAgICogc3RhcnQgaXQuIElmIHRoZSBlcnJvciB3YXJyYW50cyBhbiBpbW1lZGlhdGUgcmVzdGFydCBvZiB0aGUgc3RyZWFtLCB0aGVcbiAgICAgKiBzZW5kZXIgY2FuIHVzZSB0aGlzIHRvIGluZGljYXRlIHRoYXQgdGhlIHJlY2VpdmVyIHNob3VsZCBub3QgYmFjayBvZmYuXG4gICAgICpcbiAgICAgKiBFYWNoIGVycm9yIHdpbGwgY2FsbCB0aGUgb25DbG9zZSgpIGxpc3RlbmVyLiBUaGF0IGZ1bmN0aW9uIGNhbiBkZWNpZGUgdG9cbiAgICAgKiBpbmhpYml0IGJhY2tvZmYgaWYgcmVxdWlyZWQuXG4gICAgICovXG4gICAgaW5oaWJpdEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAwIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5Jbml0aWFsICovO1xuICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgdGhpcyBzdHJlYW0gYXMgaWRsZS4gSWYgbm8gZnVydGhlciBhY3Rpb25zIGFyZSBwZXJmb3JtZWQgb24gdGhlXG4gICAgICogc3RyZWFtIGZvciBvbmUgbWludXRlLCB0aGUgc3RyZWFtIHdpbGwgYXV0b21hdGljYWxseSBjbG9zZSBpdHNlbGYgYW5kXG4gICAgICogbm90aWZ5IHRoZSBzdHJlYW0ncyBvbkNsb3NlKCkgaGFuZGxlciB3aXRoIFN0YXR1cy5PSy4gVGhlIHN0cmVhbSB3aWxsIHRoZW5cbiAgICAgKiBiZSBpbiBhICFpc1N0YXJ0ZWQoKSBzdGF0ZSwgcmVxdWlyaW5nIHRoZSBjYWxsZXIgdG8gc3RhcnQgdGhlIHN0cmVhbSBhZ2FpblxuICAgICAqIGJlZm9yZSBmdXJ0aGVyIHVzZS5cbiAgICAgKlxuICAgICAqIE9ubHkgc3RyZWFtcyB0aGF0IGFyZSBpbiBzdGF0ZSAnT3BlbicgY2FuIGJlIG1hcmtlZCBpZGxlLCBhcyBhbGwgb3RoZXJcbiAgICAgKiBzdGF0ZXMgaW1wbHkgcGVuZGluZyBuZXR3b3JrIG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgbWFya0lkbGUoKSB7XG4gICAgICAgIC8vIFN0YXJ0cyB0aGUgaWRsZSB0aW1lIGlmIHdlIGFyZSBpbiBzdGF0ZSAnT3BlbicgYW5kIGFyZSBub3QgeWV0IGFscmVhZHlcbiAgICAgICAgLy8gcnVubmluZyBhIHRpbWVyIChpbiB3aGljaCBjYXNlIHRoZSBwcmV2aW91cyBpZGxlIHRpbWVvdXQgc3RpbGwgYXBwbGllcykuXG4gICAgICAgIGlmICh0aGlzLmlzT3BlbigpICYmIHRoaXMuaWRsZVRpbWVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlkbGVUaW1lciA9IHRoaXMucXVldWUuZW5xdWV1ZUFmdGVyRGVsYXkodGhpcy5pZGxlVGltZXJJZCwgSURMRV9USU1FT1VUX01TLCAoKSA9PiB0aGlzLmhhbmRsZUlkbGVDbG9zZVRpbWVyKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIHVuZGVybHlpbmcgc3RyZWFtLiAqL1xuICAgIHNlbmRSZXF1ZXN0KG1zZykge1xuICAgICAgICB0aGlzLmNhbmNlbElkbGVDaGVjaygpO1xuICAgICAgICB0aGlzLnN0cmVhbS5zZW5kKG1zZyk7XG4gICAgfVxuICAgIC8qKiBDYWxsZWQgYnkgdGhlIGlkbGUgdGltZXIgd2hlbiB0aGUgc3RyZWFtIHNob3VsZCBjbG9zZSBkdWUgdG8gaW5hY3Rpdml0eS4gKi9cbiAgICBhc3luYyBoYW5kbGVJZGxlQ2xvc2VUaW1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGltaW5nIG91dCBhbiBpZGxlIHN0cmVhbSB0aGVyZSdzIG5vIHJlYXNvbiB0byBmb3JjZSB0aGUgc3RyZWFtIGludG8gYmFja29mZiB3aGVuXG4gICAgICAgICAgICAvLyBpdCByZXN0YXJ0cyBzbyBzZXQgdGhlIHN0cmVhbSBzdGF0ZSB0byBJbml0aWFsIGluc3RlYWQgb2YgRXJyb3IuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZSgwIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5Jbml0aWFsICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogTWFya3MgdGhlIHN0cmVhbSBhcyBhY3RpdmUgYWdhaW4uICovXG4gICAgY2FuY2VsSWRsZUNoZWNrKCkge1xuICAgICAgICBpZiAodGhpcy5pZGxlVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaWRsZVRpbWVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBDYW5jZWxzIHRoZSBoZWFsdGggY2hlY2sgZGVsYXllZCBvcGVyYXRpb24uICovXG4gICAgY2FuY2VsSGVhbHRoQ2hlY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWx0aENoZWNrKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWx0aENoZWNrLmNhbmNlbCgpO1xuICAgICAgICAgICAgdGhpcy5oZWFsdGhDaGVjayA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBzdHJlYW0gYW5kIGNsZWFucyB1cCBhcyBuZWNlc3Nhcnk6XG4gICAgICpcbiAgICAgKiAqIGNsb3NlcyB0aGUgdW5kZXJseWluZyBHUlBDIHN0cmVhbTtcbiAgICAgKiAqIGNhbGxzIHRoZSBvbkNsb3NlIGhhbmRsZXIgd2l0aCB0aGUgZ2l2ZW4gJ2Vycm9yJztcbiAgICAgKiAqIHNldHMgaW50ZXJuYWwgc3RyZWFtIHN0YXRlIHRvICdmaW5hbFN0YXRlJztcbiAgICAgKiAqIGFkanVzdHMgdGhlIGJhY2tvZmYgdGltZXIgYmFzZWQgb24gdGhlIGVycm9yXG4gICAgICpcbiAgICAgKiBBIG5ldyBzdHJlYW0gY2FuIGJlIG9wZW5lZCBieSBjYWxsaW5nIHN0YXJ0KCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmluYWxTdGF0ZSAtIHRoZSBpbnRlbmRlZCBzdGF0ZSBvZiB0aGUgc3RyZWFtIGFmdGVyIGNsb3NpbmcuXG4gICAgICogQHBhcmFtIGVycm9yIC0gdGhlIGVycm9yIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgd2l0aC5cbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZShmaW5hbFN0YXRlLCBlcnJvcikge1xuICAgICAgICAvLyBDYW5jZWwgYW55IG91dHN0YW5kaW5nIHRpbWVycyAodGhleSdyZSBndWFyYW50ZWVkIG5vdCB0byBleGVjdXRlKS5cbiAgICAgICAgdGhpcy5jYW5jZWxJZGxlQ2hlY2soKTtcbiAgICAgICAgdGhpcy5jYW5jZWxIZWFsdGhDaGVjaygpO1xuICAgICAgICB0aGlzLmJhY2tvZmYuY2FuY2VsKCk7XG4gICAgICAgIC8vIEludmFsaWRhdGVzIGFueSBzdHJlYW0tcmVsYXRlZCBjYWxsYmFja3MgKGUuZy4gZnJvbSBhdXRoIG9yIHRoZVxuICAgICAgICAvLyB1bmRlcmx5aW5nIHN0cmVhbSksIGd1YXJhbnRlZWluZyB0aGV5IHdvbid0IGV4ZWN1dGUuXG4gICAgICAgIHRoaXMuY2xvc2VDb3VudCsrO1xuICAgICAgICBpZiAoZmluYWxTdGF0ZSAhPT0gNCAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuRXJyb3IgKi8pIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYW4gaW50ZW50aW9uYWwgY2xvc2UgZW5zdXJlIHdlIGRvbid0IGRlbGF5IG91ciBuZXh0IGNvbm5lY3Rpb24gYXR0ZW1wdC5cbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgPT09IENvZGUuUkVTT1VSQ0VfRVhIQVVTVEVEKSB7XG4gICAgICAgICAgICAvLyBMb2cgdGhlIGVycm9yLiAoUHJvYmFibHkgZWl0aGVyICdxdW90YSBleGNlZWRlZCcgb3IgJ21heCBxdWV1ZSBsZW5ndGggcmVhY2hlZCcuKVxuICAgICAgICAgICAgbG9nRXJyb3IoZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBsb2dFcnJvcignVXNpbmcgbWF4aW11bSBiYWNrb2ZmIGRlbGF5IHRvIHByZXZlbnQgb3ZlcmxvYWRpbmcgdGhlIGJhY2tlbmQuJyk7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXRUb01heCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVycm9yICYmXG4gICAgICAgICAgICBlcnJvci5jb2RlID09PSBDb2RlLlVOQVVUSEVOVElDQVRFRCAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gMyAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuSGVhbHRoeSAqLykge1xuICAgICAgICAgICAgLy8gXCJ1bmF1dGhlbnRpY2F0ZWRcIiBlcnJvciBtZWFucyB0aGUgdG9rZW4gd2FzIHJlamVjdGVkLiBUaGlzIHNob3VsZCByYXJlbHlcbiAgICAgICAgICAgIC8vIGhhcHBlbiBzaW5jZSBib3RoIEF1dGggYW5kIEFwcENoZWNrIGVuc3VyZSBhIHN1ZmZpY2llbnQgVFRMIHdoZW4gd2VcbiAgICAgICAgICAgIC8vIHJlcXVlc3QgYSB0b2tlbi4gSWYgYSB1c2VyIG1hbnVhbGx5IHJlc2V0cyB0aGVpciBzeXN0ZW0gY2xvY2sgdGhpcyBjYW5cbiAgICAgICAgICAgIC8vIGZhaWwsIGhvd2V2ZXIuIEluIHRoaXMgY2FzZSwgd2Ugc2hvdWxkIGdldCBhIENvZGUuVU5BVVRIRU5USUNBVEVEIGVycm9yXG4gICAgICAgICAgICAvLyBiZWZvcmUgd2UgcmVjZWl2ZWQgdGhlIGZpcnN0IG1lc3NhZ2UgYW5kIHdlIG5lZWQgdG8gaW52YWxpZGF0ZSB0aGUgdG9rZW5cbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSB0aGF0IHdlIGZldGNoIGEgbmV3IHRva2VuLlxuICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHNQcm92aWRlci5pbnZhbGlkYXRlVG9rZW4oKTtcbiAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFsc1Byb3ZpZGVyLmludmFsaWRhdGVUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFuIHVwIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBiZWNhdXNlIHdlIGFyZSBubyBsb25nZXIgaW50ZXJlc3RlZCBpbiBldmVudHMuXG4gICAgICAgIGlmICh0aGlzLnN0cmVhbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50ZWFyRG93bigpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0uY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHN0YXRlIG11c3QgYmUgYXNzaWduZWQgYmVmb3JlIGNhbGxpbmcgb25DbG9zZSgpIHRvIGFsbG93IHRoZSBjYWxsYmFjayB0b1xuICAgICAgICAvLyBpbmhpYml0IGJhY2tvZmYgb3Igb3RoZXJ3aXNlIG1hbmlwdWxhdGUgdGhlIHN0YXRlIGluIGl0cyBub24tc3RhcnRlZCBzdGF0ZS5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IGZpbmFsU3RhdGU7XG4gICAgICAgIC8vIE5vdGlmeSB0aGUgbGlzdGVuZXIgdGhhdCB0aGUgc3RyZWFtIGNsb3NlZC5cbiAgICAgICAgYXdhaXQgdGhpcy5saXN0ZW5lci5vbkNsb3NlKGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuIGJlIG92ZXJyaWRkZW4gdG8gcGVyZm9ybSBhZGRpdGlvbmFsIGNsZWFudXAgYmVmb3JlIHRoZSBzdHJlYW0gaXMgY2xvc2VkLlxuICAgICAqIENhbGxpbmcgc3VwZXIudGVhckRvd24oKSBpcyBub3QgcmVxdWlyZWQuXG4gICAgICovXG4gICAgdGVhckRvd24oKSB7IH1cbiAgICBhdXRoKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gMSAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuU3RhcnRpbmcgKi87XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoSWZOb3RDbG9zZWQgPSB0aGlzLmdldENsb3NlR3VhcmRlZERpc3BhdGNoZXIodGhpcy5jbG9zZUNvdW50KTtcbiAgICAgICAgLy8gVE9ETyhtaWtlbGVoZW4pOiBKdXN0IHVzZSBkaXNwYXRjaElmTm90Q2xvc2VkLCBidXQgc2VlIFRPRE8gYmVsb3cuXG4gICAgICAgIGNvbnN0IGNsb3NlQ291bnQgPSB0aGlzLmNsb3NlQ291bnQ7XG4gICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxzUHJvdmlkZXIuZ2V0VG9rZW4oKSxcbiAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFsc1Byb3ZpZGVyLmdldFRva2VuKClcbiAgICAgICAgXSkudGhlbigoW2F1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbl0pID0+IHtcbiAgICAgICAgICAgIC8vIFN0cmVhbSBjYW4gYmUgc3RvcHBlZCB3aGlsZSB3YWl0aW5nIGZvciBhdXRoZW50aWNhdGlvbi5cbiAgICAgICAgICAgIC8vIFRPRE8obWlrZWxlaGVuKTogV2UgcmVhbGx5IHNob3VsZCBqdXN0IHVzZSBkaXNwYXRjaElmTm90Q2xvc2VkXG4gICAgICAgICAgICAvLyBhbmQgbGV0IHRoaXMgZGlzcGF0Y2ggb250byB0aGUgcXVldWUsIGJ1dCB0aGF0IG9wZW5lZCBhIHNwZWMgdGVzdCBjYW5cbiAgICAgICAgICAgIC8vIG9mIHdvcm1zIHRoYXQgSSBkb24ndCB3YW50IHRvIGRlYWwgd2l0aCBpbiB0aGlzIFBSLlxuICAgICAgICAgICAgaWYgKHRoaXMuY2xvc2VDb3VudCA9PT0gY2xvc2VDb3VudCkge1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbGx5IHdlJ2QgaGF2ZSB0byBzY2hlZHVsZSB0aGUgY2FsbGJhY2sgb24gdGhlIEFzeW5jUXVldWUuXG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgdGhlIGZvbGxvd2luZyBjYWxscyBhcmUgc2FmZSB0byBiZSBjYWxsZWQgb3V0c2lkZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBBc3luY1F1ZXVlIHNpbmNlIHRoZXkgZG9uJ3QgY2hhaW4gYXN5bmNocm9ub3VzIGNhbGxzXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFN0cmVhbShhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoSWZOb3RDbG9zZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJwY0Vycm9yID0gbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5LTk9XTiwgJ0ZldGNoaW5nIGF1dGggdG9rZW4gZmFpbGVkOiAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU3RyZWFtQ2xvc2UocnBjRXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydFN0cmVhbShhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pIHtcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hJZk5vdENsb3NlZCA9IHRoaXMuZ2V0Q2xvc2VHdWFyZGVkRGlzcGF0Y2hlcih0aGlzLmNsb3NlQ291bnQpO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHRoaXMuc3RhcnRScGMoYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKTtcbiAgICAgICAgdGhpcy5zdHJlYW0ub25Db25uZWN0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2hJZk5vdENsb3NlZCgoKSA9PiB0aGlzLmxpc3RlbmVyLm9uQ29ubmVjdGVkKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0ub25PcGVuKCgpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoSWZOb3RDbG9zZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5PcGVuICovO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhbHRoQ2hlY2sgPSB0aGlzLnF1ZXVlLmVucXVldWVBZnRlckRlbGF5KHRoaXMuaGVhbHRoVGltZXJJZCwgSEVBTFRIWV9USU1FT1VUX01TLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMyAvKiBQZXJzaXN0ZW50U3RyZWFtU3RhdGUuSGVhbHRoeSAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIub25PcGVuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uQ2xvc2UoKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaElmTm90Q2xvc2VkKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTdHJlYW1DbG9zZShlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uTWVzc2FnZSgobXNnKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaElmTm90Q2xvc2VkKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoKyt0aGlzLnJlc3BvbnNlQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25GaXJzdChtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25OZXh0KG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJmb3JtQmFja29mZigpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDUgLyogUGVyc2lzdGVudFN0cmVhbVN0YXRlLkJhY2tvZmYgKi87XG4gICAgICAgIHRoaXMuYmFja29mZi5iYWNrb2ZmQW5kUnVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAwIC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5Jbml0aWFsICovO1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVmlzaWJsZSBmb3IgdGVzdHNcbiAgICBoYW5kbGVTdHJlYW1DbG9zZShlcnJvcikge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDcsIGBjbG9zZSB3aXRoIGVycm9yOiAke2Vycm9yfWApO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IG51bGw7XG4gICAgICAgIC8vIEluIHRoZW9yeSB0aGUgc3RyZWFtIGNvdWxkIGNsb3NlIGNsZWFubHksIGhvd2V2ZXIsIGluIG91ciBjdXJyZW50IG1vZGVsXG4gICAgICAgIC8vIHdlIG5ldmVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWNhdXNlIGlmIHdlIHN0b3AgYSBzdHJlYW0gb3Vyc2VsdmVzLFxuICAgICAgICAvLyB0aGlzIGNhbGxiYWNrIHdpbGwgbmV2ZXIgYmUgY2FsbGVkLiBUbyBwcmV2ZW50IGNhc2VzIHdoZXJlIHdlIHJldHJ5XG4gICAgICAgIC8vIHdpdGhvdXQgYSBiYWNrb2ZmIGFjY2lkZW50YWxseSwgd2Ugc2V0IHRoZSBzdHJlYW0gdG8gZXJyb3IgaW4gYWxsIGNhc2VzLlxuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZSg0IC8qIFBlcnNpc3RlbnRTdHJlYW1TdGF0ZS5FcnJvciAqLywgZXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgXCJkaXNwYXRjaGVyXCIgZnVuY3Rpb24gdGhhdCBkaXNwYXRjaGVzIG9wZXJhdGlvbnMgb250byB0aGVcbiAgICAgKiBBc3luY1F1ZXVlIGJ1dCBvbmx5IHJ1bnMgdGhlbSBpZiBjbG9zZUNvdW50IHJlbWFpbnMgdW5jaGFuZ2VkLiBUaGlzIGFsbG93c1xuICAgICAqIHVzIHRvIHR1cm4gYXV0aCAvIHN0cmVhbSBjYWxsYmFja3MgaW50byBuby1vcHMgaWYgdGhlIHN0cmVhbSBpcyBjbG9zZWQgL1xuICAgICAqIHJlLW9wZW5lZCwgZXRjLlxuICAgICAqL1xuICAgIGdldENsb3NlR3VhcmRlZERpc3BhdGNoZXIoc3RhcnRDbG9zZUNvdW50KSB7XG4gICAgICAgIHJldHVybiAoZm4pID0+IHtcbiAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xvc2VDb3VudCA9PT0gc3RhcnRDbG9zZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ3LCAnc3RyZWFtIGNhbGxiYWNrIHNraXBwZWQgYnkgZ2V0Q2xvc2VHdWFyZGVkRGlzcGF0Y2hlci4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogQSBQZXJzaXN0ZW50U3RyZWFtIHRoYXQgaW1wbGVtZW50cyB0aGUgTGlzdGVuIFJQQy5cbiAqXG4gKiBPbmNlIHRoZSBMaXN0ZW4gc3RyZWFtIGhhcyBjYWxsZWQgdGhlIG9uT3BlbigpIGxpc3RlbmVyLCBhbnkgbnVtYmVyIG9mXG4gKiBsaXN0ZW4oKSBhbmQgdW5saXN0ZW4oKSBjYWxscyBjYW4gYmUgbWFkZSB0byBjb250cm9sIHdoYXQgY2hhbmdlcyB3aWxsIGJlXG4gKiBzZW50IGZyb20gdGhlIHNlcnZlciBmb3IgTGlzdGVuUmVzcG9uc2VzLlxuICovXG5jbGFzcyBQZXJzaXN0ZW50TGlzdGVuU3RyZWFtIGV4dGVuZHMgUGVyc2lzdGVudFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IocXVldWUsIGNvbm5lY3Rpb24sIGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgc2VyaWFsaXplciwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIocXVldWUsIFwibGlzdGVuX3N0cmVhbV9jb25uZWN0aW9uX2JhY2tvZmZcIiAvKiBUaW1lcklkLkxpc3RlblN0cmVhbUNvbm5lY3Rpb25CYWNrb2ZmICovLCBcImxpc3Rlbl9zdHJlYW1faWRsZVwiIC8qIFRpbWVySWQuTGlzdGVuU3RyZWFtSWRsZSAqLywgXCJoZWFsdGhfY2hlY2tfdGltZW91dFwiIC8qIFRpbWVySWQuSGVhbHRoQ2hlY2tUaW1lb3V0ICovLCBjb25uZWN0aW9uLCBhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIGxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICB9XG4gICAgc3RhcnRScGMoYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24ub3BlblN0cmVhbSgnTGlzdGVuJywgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKTtcbiAgICB9XG4gICAgb25GaXJzdCh3YXRjaENoYW5nZVByb3RvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uTmV4dCh3YXRjaENoYW5nZVByb3RvKTtcbiAgICB9XG4gICAgb25OZXh0KHdhdGNoQ2hhbmdlUHJvdG8pIHtcbiAgICAgICAgLy8gQSBzdWNjZXNzZnVsIHJlc3BvbnNlIG1lYW5zIHRoZSBzdHJlYW0gaXMgaGVhbHRoeVxuICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgY29uc3Qgd2F0Y2hDaGFuZ2UgPSBmcm9tV2F0Y2hDaGFuZ2UodGhpcy5zZXJpYWxpemVyLCB3YXRjaENoYW5nZVByb3RvKTtcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSB2ZXJzaW9uRnJvbUxpc3RlblJlc3BvbnNlKHdhdGNoQ2hhbmdlUHJvdG8pO1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5vbldhdGNoQ2hhbmdlKHdhdGNoQ2hhbmdlLCBzbmFwc2hvdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBpbnRlcmVzdCBpbiB0aGUgcmVzdWx0cyBvZiB0aGUgZ2l2ZW4gdGFyZ2V0LiBJZiB0aGUgdGFyZ2V0XG4gICAgICogaW5jbHVkZXMgYSByZXN1bWVUb2tlbiBpdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSByZXF1ZXN0LiBSZXN1bHRzIHRoYXRcbiAgICAgKiBhZmZlY3QgdGhlIHRhcmdldCB3aWxsIGJlIHN0cmVhbWVkIGJhY2sgYXMgV2F0Y2hDaGFuZ2UgbWVzc2FnZXMgdGhhdFxuICAgICAqIHJlZmVyZW5jZSB0aGUgdGFyZ2V0SWQuXG4gICAgICovXG4gICAgd2F0Y2godGFyZ2V0RGF0YSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge307XG4gICAgICAgIHJlcXVlc3QuZGF0YWJhc2UgPSBnZXRFbmNvZGVkRGF0YWJhc2VJZCh0aGlzLnNlcmlhbGl6ZXIpO1xuICAgICAgICByZXF1ZXN0LmFkZFRhcmdldCA9IHRvVGFyZ2V0KHRoaXMuc2VyaWFsaXplciwgdGFyZ2V0RGF0YSk7XG4gICAgICAgIGNvbnN0IGxhYmVscyA9IHRvTGlzdGVuUmVxdWVzdExhYmVscyh0aGlzLnNlcmlhbGl6ZXIsIHRhcmdldERhdGEpO1xuICAgICAgICBpZiAobGFiZWxzKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmxhYmVscyA9IGxhYmVscztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVycyBpbnRlcmVzdCBpbiB0aGUgcmVzdWx0cyBvZiB0aGUgdGFyZ2V0IGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICAgKiBnaXZlbiB0YXJnZXRJZC5cbiAgICAgKi9cbiAgICB1bndhdGNoKHRhcmdldElkKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgcmVxdWVzdC5kYXRhYmFzZSA9IGdldEVuY29kZWREYXRhYmFzZUlkKHRoaXMuc2VyaWFsaXplcik7XG4gICAgICAgIHJlcXVlc3QucmVtb3ZlVGFyZ2V0ID0gdGFyZ2V0SWQ7XG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QocmVxdWVzdCk7XG4gICAgfVxufVxuLyoqXG4gKiBBIFN0cmVhbSB0aGF0IGltcGxlbWVudHMgdGhlIFdyaXRlIFJQQy5cbiAqXG4gKiBUaGUgV3JpdGUgUlBDIHJlcXVpcmVzIHRoZSBjYWxsZXIgdG8gbWFpbnRhaW4gc3BlY2lhbCBzdHJlYW1Ub2tlblxuICogc3RhdGUgaW4gYmV0d2VlbiBjYWxscywgdG8gaGVscCB0aGUgc2VydmVyIHVuZGVyc3RhbmQgd2hpY2ggcmVzcG9uc2VzIHRoZVxuICogY2xpZW50IGhhcyBwcm9jZXNzZWQgYnkgdGhlIHRpbWUgdGhlIG5leHQgcmVxdWVzdCBpcyBtYWRlLiBFdmVyeSByZXNwb25zZVxuICogd2lsbCBjb250YWluIGEgc3RyZWFtVG9rZW47IHRoaXMgdmFsdWUgbXVzdCBiZSBwYXNzZWQgdG8gdGhlIG5leHRcbiAqIHJlcXVlc3QuXG4gKlxuICogQWZ0ZXIgY2FsbGluZyBzdGFydCgpIG9uIHRoaXMgc3RyZWFtLCB0aGUgbmV4dCByZXF1ZXN0IG11c3QgYmUgYSBoYW5kc2hha2UsXG4gKiBjb250YWluaW5nIHdoYXRldmVyIHN0cmVhbVRva2VuIGlzIG9uIGhhbmQuIE9uY2UgYSByZXNwb25zZSB0byB0aGlzXG4gKiByZXF1ZXN0IGlzIHJlY2VpdmVkLCBhbGwgcGVuZGluZyBtdXRhdGlvbnMgbWF5IGJlIHN1Ym1pdHRlZC4gV2hlblxuICogc3VibWl0dGluZyBtdWx0aXBsZSBiYXRjaGVzIG9mIG11dGF0aW9ucyBhdCB0aGUgc2FtZSB0aW1lLCBpdCdzXG4gKiBva2F5IHRvIHVzZSB0aGUgc2FtZSBzdHJlYW1Ub2tlbiBmb3IgdGhlIGNhbGxzIHRvIHdyaXRlTXV0YXRpb25zLlxuICpcbiAqIFRPRE8oYi8zMzI3MTIzNSk6IFVzZSBwcm90byB0eXBlc1xuICovXG5jbGFzcyBQZXJzaXN0ZW50V3JpdGVTdHJlYW0gZXh0ZW5kcyBQZXJzaXN0ZW50U3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihxdWV1ZSwgY29ubmVjdGlvbiwgYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBzZXJpYWxpemVyLCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlcihxdWV1ZSwgXCJ3cml0ZV9zdHJlYW1fY29ubmVjdGlvbl9iYWNrb2ZmXCIgLyogVGltZXJJZC5Xcml0ZVN0cmVhbUNvbm5lY3Rpb25CYWNrb2ZmICovLCBcIndyaXRlX3N0cmVhbV9pZGxlXCIgLyogVGltZXJJZC5Xcml0ZVN0cmVhbUlkbGUgKi8sIFwiaGVhbHRoX2NoZWNrX3RpbWVvdXRcIiAvKiBUaW1lcklkLkhlYWx0aENoZWNrVGltZW91dCAqLywgY29ubmVjdGlvbiwgYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBsaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYWNrcyB3aGV0aGVyIG9yIG5vdCBhIGhhbmRzaGFrZSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgZXhjaGFuZ2VkIGFuZFxuICAgICAqIHRoZSBzdHJlYW0gaXMgcmVhZHkgdG8gYWNjZXB0IG11dGF0aW9ucy5cbiAgICAgKi9cbiAgICBnZXQgaGFuZHNoYWtlQ29tcGxldGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlQ291bnQgPiAwO1xuICAgIH1cbiAgICAvLyBPdmVycmlkZSBvZiBQZXJzaXN0ZW50U3RyZWFtLnN0YXJ0XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMubGFzdFN0cmVhbVRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICBzdXBlci5zdGFydCgpO1xuICAgIH1cbiAgICB0ZWFyRG93bigpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFuZHNoYWtlQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVNdXRhdGlvbnMoW10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0UnBjKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLm9wZW5TdHJlYW0oJ1dyaXRlJywgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKTtcbiAgICB9XG4gICAgb25GaXJzdChyZXNwb25zZVByb3RvKSB7XG4gICAgICAgIC8vIEFsd2F5cyBjYXB0dXJlIHRoZSBsYXN0IHN0cmVhbSB0b2tlbi5cbiAgICAgICAgaGFyZEFzc2VydCghIXJlc3BvbnNlUHJvdG8uc3RyZWFtVG9rZW4pO1xuICAgICAgICB0aGlzLmxhc3RTdHJlYW1Ub2tlbiA9IHJlc3BvbnNlUHJvdG8uc3RyZWFtVG9rZW47XG4gICAgICAgIC8vIFRoZSBmaXJzdCByZXNwb25zZSBpcyBhbHdheXMgdGhlIGhhbmRzaGFrZSByZXNwb25zZVxuICAgICAgICBoYXJkQXNzZXJ0KCFyZXNwb25zZVByb3RvLndyaXRlUmVzdWx0cyB8fCByZXNwb25zZVByb3RvLndyaXRlUmVzdWx0cy5sZW5ndGggPT09IDApO1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5vbkhhbmRzaGFrZUNvbXBsZXRlKCk7XG4gICAgfVxuICAgIG9uTmV4dChyZXNwb25zZVByb3RvKSB7XG4gICAgICAgIC8vIEFsd2F5cyBjYXB0dXJlIHRoZSBsYXN0IHN0cmVhbSB0b2tlbi5cbiAgICAgICAgaGFyZEFzc2VydCghIXJlc3BvbnNlUHJvdG8uc3RyZWFtVG9rZW4pO1xuICAgICAgICB0aGlzLmxhc3RTdHJlYW1Ub2tlbiA9IHJlc3BvbnNlUHJvdG8uc3RyZWFtVG9rZW47XG4gICAgICAgIC8vIEEgc3VjY2Vzc2Z1bCBmaXJzdCB3cml0ZSByZXNwb25zZSBtZWFucyB0aGUgc3RyZWFtIGlzIGhlYWx0aHksXG4gICAgICAgIC8vIE5vdGUsIHRoYXQgd2UgY291bGQgY29uc2lkZXIgYSBzdWNjZXNzZnVsIGhhbmRzaGFrZSBoZWFsdGh5LCBob3dldmVyLFxuICAgICAgICAvLyB0aGUgd3JpdGUgaXRzZWxmIG1pZ2h0IGJlIGNhdXNpbmcgYW4gZXJyb3Igd2Ugd2FudCB0byBiYWNrIG9mZiBmcm9tLlxuICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGZyb21Xcml0ZVJlc3VsdHMocmVzcG9uc2VQcm90by53cml0ZVJlc3VsdHMsIHJlc3BvbnNlUHJvdG8uY29tbWl0VGltZSk7XG4gICAgICAgIGNvbnN0IGNvbW1pdFZlcnNpb24gPSBmcm9tVmVyc2lvbihyZXNwb25zZVByb3RvLmNvbW1pdFRpbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5vbk11dGF0aW9uUmVzdWx0KGNvbW1pdFZlcnNpb24sIHJlc3VsdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhbiBpbml0aWFsIHN0cmVhbVRva2VuIHRvIHRoZSBzZXJ2ZXIsIHBlcmZvcm1pbmcgdGhlIGhhbmRzaGFrZVxuICAgICAqIHJlcXVpcmVkIHRvIG1ha2UgdGhlIFN0cmVhbWluZ1dyaXRlIFJQQyB3b3JrLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgc2hvdWxkIHdhaXQgdW50aWwgb25IYW5kc2hha2VDb21wbGV0ZSB3YXMgY2FsbGVkLlxuICAgICAqL1xuICAgIHdyaXRlSGFuZHNoYWtlKCkge1xuICAgICAgICAvLyBUT0RPKGRpbW9uZCk6IFN1cHBvcnQgc3RyZWFtIHJlc3VtcHRpb24uIFdlIGludGVudGlvbmFsbHkgZG8gbm90IHNldCB0aGVcbiAgICAgICAgLy8gc3RyZWFtIHRva2VuIG9uIHRoZSBoYW5kc2hha2UsIGlnbm9yaW5nIGFueSBzdHJlYW0gdG9rZW4gd2UgbWlnaHQgaGF2ZS5cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHt9O1xuICAgICAgICByZXF1ZXN0LmRhdGFiYXNlID0gZ2V0RW5jb2RlZERhdGFiYXNlSWQodGhpcy5zZXJpYWxpemVyKTtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqIFNlbmRzIGEgZ3JvdXAgb2YgbXV0YXRpb25zIHRvIHRoZSBGaXJlc3RvcmUgYmFja2VuZCB0byBhcHBseS4gKi9cbiAgICB3cml0ZU11dGF0aW9ucyhtdXRhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHN0cmVhbVRva2VuOiB0aGlzLmxhc3RTdHJlYW1Ub2tlbixcbiAgICAgICAgICAgIHdyaXRlczogbXV0YXRpb25zLm1hcChtdXRhdGlvbiA9PiB0b011dGF0aW9uKHRoaXMuc2VyaWFsaXplciwgbXV0YXRpb24pKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRGF0YXN0b3JlIGFuZCBpdHMgcmVsYXRlZCBtZXRob2RzIGFyZSBhIHdyYXBwZXIgYXJvdW5kIHRoZSBleHRlcm5hbCBHb29nbGVcbiAqIENsb3VkIERhdGFzdG9yZSBncnBjIEFQSSwgd2hpY2ggcHJvdmlkZXMgYW4gaW50ZXJmYWNlIHRoYXQgaXMgbW9yZSBjb252ZW5pZW50XG4gKiBmb3IgdGhlIHJlc3Qgb2YgdGhlIGNsaWVudCBTREsgYXJjaGl0ZWN0dXJlIHRvIGNvbnN1bWUuXG4gKi9cbmNsYXNzIERhdGFzdG9yZSB7XG59XG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIERhdGFzdG9yZSB0aGF0IGV4cG9zZXMgYWRkaXRpb25hbCBzdGF0ZSBmb3IgaW50ZXJuYWxcbiAqIGNvbnN1bXB0aW9uLlxuICovXG5jbGFzcyBEYXRhc3RvcmVJbXBsIGV4dGVuZHMgRGF0YXN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIGNvbm5lY3Rpb24sIHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMgPSBhdXRoQ3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscyA9IGFwcENoZWNrQ3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgICAgIHRoaXMudGVybWluYXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB2ZXJpZnlJbml0aWFsaXplZCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ1RoZSBjbGllbnQgaGFzIGFscmVhZHkgYmVlbiB0ZXJtaW5hdGVkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBJbnZva2VzIHRoZSBwcm92aWRlZCBSUEMgd2l0aCBhdXRoIGFuZCBBcHBDaGVjayB0b2tlbnMuICovXG4gICAgaW52b2tlUlBDKHJwY05hbWUsIGRhdGFiYXNlSWQsIHJlc291cmNlUGF0aCwgcmVxdWVzdCkge1xuICAgICAgICB0aGlzLnZlcmlmeUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscy5nZXRUb2tlbigpLFxuICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmdldFRva2VuKClcbiAgICAgICAgXSlcbiAgICAgICAgICAgIC50aGVuKChbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5pbnZva2VSUEMocnBjTmFtZSwgdG9SZXNvdXJjZVBhdGgoZGF0YWJhc2VJZCwgcmVzb3VyY2VQYXRoKSwgcmVxdWVzdCwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnRmlyZWJhc2VFcnJvcicpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gQ29kZS5VTkFVVEhFTlRJQ0FURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuaW52YWxpZGF0ZVRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscy5pbnZhbGlkYXRlVG9rZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTktOT1dOLCBlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBJbnZva2VzIHRoZSBwcm92aWRlZCBSUEMgd2l0aCBzdHJlYW1lZCByZXN1bHRzIHdpdGggYXV0aCBhbmQgQXBwQ2hlY2sgdG9rZW5zLiAqL1xuICAgIGludm9rZVN0cmVhbWluZ1JQQyhycGNOYW1lLCBkYXRhYmFzZUlkLCByZXNvdXJjZVBhdGgsIHJlcXVlc3QsIGV4cGVjdGVkUmVzcG9uc2VDb3VudCkge1xuICAgICAgICB0aGlzLnZlcmlmeUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscy5nZXRUb2tlbigpLFxuICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmdldFRva2VuKClcbiAgICAgICAgXSlcbiAgICAgICAgICAgIC50aGVuKChbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5pbnZva2VTdHJlYW1pbmdSUEMocnBjTmFtZSwgdG9SZXNvdXJjZVBhdGgoZGF0YWJhc2VJZCwgcmVzb3VyY2VQYXRoKSwgcmVxdWVzdCwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuLCBleHBlY3RlZFJlc3BvbnNlQ291bnQpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdGaXJlYmFzZUVycm9yJykge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBDb2RlLlVOQVVUSEVOVElDQVRFRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscy5pbnZhbGlkYXRlVG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmludmFsaWRhdGVUb2tlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOS05PV04sIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGVybWluYXRlKCkge1xuICAgICAgICB0aGlzLnRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24udGVybWluYXRlKCk7XG4gICAgfVxufVxuLy8gVE9ETyhmaXJlc3RvcmV4cCk6IE1ha2Ugc3VyZSB0aGVyZSBpcyBvbmx5IG9uZSBEYXRhc3RvcmUgaW5zdGFuY2UgcGVyXG4vLyBmaXJlc3RvcmUtZXhwIGNsaWVudC5cbmZ1bmN0aW9uIG5ld0RhdGFzdG9yZShhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIGNvbm5lY3Rpb24sIHNlcmlhbGl6ZXIpIHtcbiAgICByZXR1cm4gbmV3IERhdGFzdG9yZUltcGwoYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBjb25uZWN0aW9uLCBzZXJpYWxpemVyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGludm9rZUNvbW1pdFJwYyhkYXRhc3RvcmUsIG11dGF0aW9ucykge1xuICAgIGNvbnN0IGRhdGFzdG9yZUltcGwgPSBkZWJ1Z0Nhc3QoZGF0YXN0b3JlKTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICB3cml0ZXM6IG11dGF0aW9ucy5tYXAobSA9PiB0b011dGF0aW9uKGRhdGFzdG9yZUltcGwuc2VyaWFsaXplciwgbSkpXG4gICAgfTtcbiAgICBhd2FpdCBkYXRhc3RvcmVJbXBsLmludm9rZVJQQygnQ29tbWl0JywgZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLmRhdGFiYXNlSWQsIFJlc291cmNlUGF0aC5lbXB0eVBhdGgoKSwgcmVxdWVzdCk7XG59XG5hc3luYyBmdW5jdGlvbiBpbnZva2VCYXRjaEdldERvY3VtZW50c1JwYyhkYXRhc3RvcmUsIGtleXMpIHtcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgZG9jdW1lbnRzOiBrZXlzLm1hcChrID0+IHRvTmFtZShkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIsIGspKVxuICAgIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkYXRhc3RvcmVJbXBsLmludm9rZVN0cmVhbWluZ1JQQygnQmF0Y2hHZXREb2N1bWVudHMnLCBkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIuZGF0YWJhc2VJZCwgUmVzb3VyY2VQYXRoLmVtcHR5UGF0aCgpLCByZXF1ZXN0LCBrZXlzLmxlbmd0aCk7XG4gICAgY29uc3QgZG9jcyA9IG5ldyBNYXAoKTtcbiAgICByZXNwb25zZS5mb3JFYWNoKHByb3RvID0+IHtcbiAgICAgICAgY29uc3QgZG9jID0gZnJvbUJhdGNoR2V0RG9jdW1lbnRzUmVzcG9uc2UoZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBwcm90byk7XG4gICAgICAgIGRvY3Muc2V0KGRvYy5rZXkudG9TdHJpbmcoKSwgZG9jKTtcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgY29uc3QgZG9jID0gZG9jcy5nZXQoa2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICBoYXJkQXNzZXJ0KCEhZG9jKTtcbiAgICAgICAgcmVzdWx0LnB1c2goZG9jKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuYXN5bmMgZnVuY3Rpb24gaW52b2tlUnVuQWdncmVnYXRpb25RdWVyeVJwYyhkYXRhc3RvcmUsIHF1ZXJ5LCBhZ2dyZWdhdGVzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGRhdGFzdG9yZUltcGwgPSBkZWJ1Z0Nhc3QoZGF0YXN0b3JlKTtcbiAgICBjb25zdCB7IHJlcXVlc3QsIGFsaWFzTWFwLCBwYXJlbnQgfSA9IHRvUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3QoZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBxdWVyeVRvQWdncmVnYXRlVGFyZ2V0KHF1ZXJ5KSwgYWdncmVnYXRlcyk7XG4gICAgaWYgKCFkYXRhc3RvcmVJbXBsLmNvbm5lY3Rpb24uc2hvdWxkUmVzb3VyY2VQYXRoQmVJbmNsdWRlZEluUmVxdWVzdCkge1xuICAgICAgICBkZWxldGUgcmVxdWVzdC5wYXJlbnQ7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZGF0YXN0b3JlSW1wbC5pbnZva2VTdHJlYW1pbmdSUEMoJ1J1bkFnZ3JlZ2F0aW9uUXVlcnknLCBkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIuZGF0YWJhc2VJZCwgcGFyZW50LCByZXF1ZXN0LCBcbiAgICAvKmV4cGVjdGVkUmVzcG9uc2VDb3VudD0qLyAxKTtcbiAgICAvLyBPbWl0IFJ1bkFnZ3JlZ2F0aW9uUXVlcnlSZXNwb25zZSB0aGF0IG9ubHkgY29udGFpbiByZWFkVGltZXMuXG4gICAgY29uc3QgZmlsdGVyZWRSZXN1bHQgPSByZXNwb25zZS5maWx0ZXIocHJvdG8gPT4gISFwcm90by5yZXN1bHQpO1xuICAgIGhhcmRBc3NlcnQoZmlsdGVyZWRSZXN1bHQubGVuZ3RoID09PSAxKTtcbiAgICAvLyBSZW1hcCB0aGUgc2hvcnQtZm9ybSBhbGlhc2VzIHRoYXQgd2VyZSBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICAvLyB0byB0aGUgY2xpZW50LXNpZGUgYWxpYXNlcy4gVXNlcnMgd2lsbCBhY2Nlc3MgdGhlIHJlc3VsdHNcbiAgICAvLyB1c2luZyB0aGUgY2xpZW50LXNpZGUgYWxpYXMuXG4gICAgY29uc3QgdW5tYXBwZWRBZ2dyZWdhdGVGaWVsZHMgPSAoX2EgPSBmaWx0ZXJlZFJlc3VsdFswXS5yZXN1bHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZ2dyZWdhdGVGaWVsZHM7XG4gICAgY29uc3QgcmVtYXBwZWRGaWVsZHMgPSBPYmplY3Qua2V5cyh1bm1hcHBlZEFnZ3JlZ2F0ZUZpZWxkcykucmVkdWNlKChhY2N1bXVsYXRvciwga2V5KSA9PiB7XG4gICAgICAgIGFjY3VtdWxhdG9yW2FsaWFzTWFwW2tleV1dID0gdW5tYXBwZWRBZ2dyZWdhdGVGaWVsZHNba2V5XTtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gcmVtYXBwZWRGaWVsZHM7XG59XG5mdW5jdGlvbiBuZXdQZXJzaXN0ZW50V3JpdGVTdHJlYW0oZGF0YXN0b3JlLCBxdWV1ZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBkYXRhc3RvcmVJbXBsID0gZGVidWdDYXN0KGRhdGFzdG9yZSk7XG4gICAgZGF0YXN0b3JlSW1wbC52ZXJpZnlJbml0aWFsaXplZCgpO1xuICAgIHJldHVybiBuZXcgUGVyc2lzdGVudFdyaXRlU3RyZWFtKHF1ZXVlLCBkYXRhc3RvcmVJbXBsLmNvbm5lY3Rpb24sIGRhdGFzdG9yZUltcGwuYXV0aENyZWRlbnRpYWxzLCBkYXRhc3RvcmVJbXBsLmFwcENoZWNrQ3JlZGVudGlhbHMsIGRhdGFzdG9yZUltcGwuc2VyaWFsaXplciwgbGlzdGVuZXIpO1xufVxuZnVuY3Rpb24gbmV3UGVyc2lzdGVudFdhdGNoU3RyZWFtKGRhdGFzdG9yZSwgcXVldWUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgZGF0YXN0b3JlSW1wbCA9IGRlYnVnQ2FzdChkYXRhc3RvcmUpO1xuICAgIGRhdGFzdG9yZUltcGwudmVyaWZ5SW5pdGlhbGl6ZWQoKTtcbiAgICByZXR1cm4gbmV3IFBlcnNpc3RlbnRMaXN0ZW5TdHJlYW0ocXVldWUsIGRhdGFzdG9yZUltcGwuY29ubmVjdGlvbiwgZGF0YXN0b3JlSW1wbC5hdXRoQ3JlZGVudGlhbHMsIGRhdGFzdG9yZUltcGwuYXBwQ2hlY2tDcmVkZW50aWFscywgZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBsaXN0ZW5lcik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJDYgPSAnT25saW5lU3RhdGVUcmFja2VyJztcbi8vIFRvIGRlYWwgd2l0aCB0cmFuc2llbnQgZmFpbHVyZXMsIHdlIGFsbG93IG11bHRpcGxlIHN0cmVhbSBhdHRlbXB0cyBiZWZvcmVcbi8vIGdpdmluZyB1cCBhbmQgdHJhbnNpdGlvbmluZyBmcm9tIE9ubGluZVN0YXRlLlVua25vd24gdG8gT2ZmbGluZS5cbi8vIFRPRE8obWlrZWxlaGVuKTogVGhpcyB1c2VkIHRvIGJlIHNldCB0byAyIGFzIGEgbWl0aWdhdGlvbiBmb3IgYi82NjIyODM5NC5cbi8vIEBqZGltb25kIHRoaW5rcyB0aGF0IGJ1ZyBpcyBzdWZmaWNpZW50bHkgZml4ZWQgc28gdGhhdCB3ZSBjYW4gc2V0IHRoaXMgYmFja1xuLy8gdG8gMS4gSWYgdGhhdCB3b3JrcyBva2F5LCB3ZSBjb3VsZCBwb3RlbnRpYWxseSByZW1vdmUgdGhpcyBsb2dpYyBlbnRpcmVseS5cbmNvbnN0IE1BWF9XQVRDSF9TVFJFQU1fRkFJTFVSRVMgPSAxO1xuLy8gVG8gZGVhbCB3aXRoIHN0cmVhbSBhdHRlbXB0cyB0aGF0IGRvbid0IHN1Y2NlZWQgb3IgZmFpbCBpbiBhIHRpbWVseSBtYW5uZXIsXG4vLyB3ZSBoYXZlIGEgdGltZW91dCBmb3IgT25saW5lU3RhdGUgdG8gcmVhY2ggT25saW5lIG9yIE9mZmxpbmUuXG4vLyBJZiB0aGUgdGltZW91dCBpcyByZWFjaGVkLCB3ZSB0cmFuc2l0aW9uIHRvIE9mZmxpbmUgcmF0aGVyIHRoYW4gd2FpdGluZ1xuLy8gaW5kZWZpbml0ZWx5LlxuY29uc3QgT05MSU5FX1NUQVRFX1RJTUVPVVRfTVMgPSAxMCAqIDEwMDA7XG4vKipcbiAqIEEgY29tcG9uZW50IHVzZWQgYnkgdGhlIFJlbW90ZVN0b3JlIHRvIHRyYWNrIHRoZSBPbmxpbmVTdGF0ZSAodGhhdCBpcyxcbiAqIHdoZXRoZXIgb3Igbm90IHRoZSBjbGllbnQgYXMgYSB3aG9sZSBzaG91bGQgYmUgY29uc2lkZXJlZCB0byBiZSBvbmxpbmUgb3JcbiAqIG9mZmxpbmUpLCBpbXBsZW1lbnRpbmcgdGhlIGFwcHJvcHJpYXRlIGhldXJpc3RpY3MuXG4gKlxuICogSW4gcGFydGljdWxhciwgd2hlbiB0aGUgY2xpZW50IGlzIHRyeWluZyB0byBjb25uZWN0IHRvIHRoZSBiYWNrZW5kLCB3ZVxuICogYWxsb3cgdXAgdG8gTUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFUyB3aXRoaW4gT05MSU5FX1NUQVRFX1RJTUVPVVRfTVMgZm9yXG4gKiBhIGNvbm5lY3Rpb24gdG8gc3VjY2VlZC4gSWYgd2UgaGF2ZSB0b28gbWFueSBmYWlsdXJlcyBvciB0aGUgdGltZW91dCBlbGFwc2VzLFxuICogdGhlbiB3ZSBzZXQgdGhlIE9ubGluZVN0YXRlIHRvIE9mZmxpbmUsIGFuZCB0aGUgY2xpZW50IHdpbGwgYmVoYXZlIGFzIGlmXG4gKiBpdCBpcyBvZmZsaW5lIChnZXQoKXMgd2lsbCByZXR1cm4gY2FjaGVkIGRhdGEsIGV0Yy4pLlxuICovXG5jbGFzcyBPbmxpbmVTdGF0ZVRyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKGFzeW5jUXVldWUsIG9ubGluZVN0YXRlSGFuZGxlcikge1xuICAgICAgICB0aGlzLmFzeW5jUXVldWUgPSBhc3luY1F1ZXVlO1xuICAgICAgICB0aGlzLm9ubGluZVN0YXRlSGFuZGxlciA9IG9ubGluZVN0YXRlSGFuZGxlcjtcbiAgICAgICAgLyoqIFRoZSBjdXJyZW50IE9ubGluZVN0YXRlLiAqL1xuICAgICAgICB0aGlzLnN0YXRlID0gXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY291bnQgb2YgY29uc2VjdXRpdmUgZmFpbHVyZXMgdG8gb3BlbiB0aGUgc3RyZWFtLiBJZiBpdCByZWFjaGVzIHRoZVxuICAgICAgICAgKiBtYXhpbXVtIGRlZmluZWQgYnkgTUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFUywgd2UnbGwgc2V0IHRoZSBPbmxpbmVTdGF0ZSB0b1xuICAgICAgICAgKiBPZmZsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53YXRjaFN0cmVhbUZhaWx1cmVzID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdGltZXIgdGhhdCBlbGFwc2VzIGFmdGVyIE9OTElORV9TVEFURV9USU1FT1VUX01TLCBhdCB3aGljaCBwb2ludCB3ZVxuICAgICAgICAgKiB0cmFuc2l0aW9uIGZyb20gT25saW5lU3RhdGUuVW5rbm93biB0byBPbmxpbmVTdGF0ZS5PZmZsaW5lIHdpdGhvdXQgd2FpdGluZ1xuICAgICAgICAgKiBmb3IgdGhlIHN0cmVhbSB0byBhY3R1YWxseSBmYWlsIChNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTIHRpbWVzKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25saW5lU3RhdGVUaW1lciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjbGllbnQgc2hvdWxkIGxvZyBhIHdhcm5pbmcgbWVzc2FnZSBpZiBpdCBmYWlscyB0byBjb25uZWN0IHRvXG4gICAgICAgICAqIHRoZSBiYWNrZW5kIChpbml0aWFsbHkgdHJ1ZSwgY2xlYXJlZCBhZnRlciBhIHN1Y2Nlc3NmdWwgc3RyZWFtLCBvciBpZiB3ZSd2ZVxuICAgICAgICAgKiBsb2dnZWQgdGhlIG1lc3NhZ2UgYWxyZWFkeSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3VsZFdhcm5DbGllbnRJc09mZmxpbmUgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYnkgUmVtb3RlU3RvcmUgd2hlbiBhIHdhdGNoIHN0cmVhbSBpcyBzdGFydGVkIChpbmNsdWRpbmcgb24gZWFjaFxuICAgICAqIGJhY2tvZmYgYXR0ZW1wdCkuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIGlzIHRoZSBmaXJzdCBhdHRlbXB0LCBpdCBzZXRzIHRoZSBPbmxpbmVTdGF0ZSB0byBVbmtub3duIGFuZCBzdGFydHNcbiAgICAgKiB0aGUgb25saW5lU3RhdGVUaW1lci5cbiAgICAgKi9cbiAgICBoYW5kbGVXYXRjaFN0cmVhbVN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy53YXRjaFN0cmVhbUZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFuZEJyb2FkY2FzdChcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovKTtcbiAgICAgICAgICAgIHRoaXMub25saW5lU3RhdGVUaW1lciA9IHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheShcIm9ubGluZV9zdGF0ZV90aW1lb3V0XCIgLyogVGltZXJJZC5PbmxpbmVTdGF0ZVRpbWVvdXQgKi8sIE9OTElORV9TVEFURV9USU1FT1VUX01TLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ0NsaWVudE9mZmxpbmVXYXJuaW5nSWZOZWNlc3NhcnkoYEJhY2tlbmQgZGlkbid0IHJlc3BvbmQgd2l0aGluICR7T05MSU5FX1NUQVRFX1RJTUVPVVRfTVMgLyAxMDAwfSBgICtcbiAgICAgICAgICAgICAgICAgICAgYHNlY29uZHMuYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBbmRCcm9hZGNhc3QoXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLyk7XG4gICAgICAgICAgICAgICAgLy8gTk9URTogaGFuZGxlV2F0Y2hTdHJlYW1GYWlsdXJlKCkgd2lsbCBjb250aW51ZSB0byBpbmNyZW1lbnRcbiAgICAgICAgICAgICAgICAvLyB3YXRjaFN0cmVhbUZhaWx1cmVzIGV2ZW4gdGhvdWdoIHdlIGFyZSBhbHJlYWR5IG1hcmtlZCBPZmZsaW5lLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGlzIGlzIG5vbi1oYXJtZnVsLlxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgb3VyIE9ubGluZVN0YXRlIGFzIGFwcHJvcHJpYXRlIGFmdGVyIHRoZSB3YXRjaCBzdHJlYW0gcmVwb3J0cyBhXG4gICAgICogZmFpbHVyZS4gVGhlIGZpcnN0IGZhaWx1cmUgbW92ZXMgdXMgdG8gdGhlICdVbmtub3duJyBzdGF0ZS4gV2UgdGhlbiBtYXlcbiAgICAgKiBhbGxvdyBtdWx0aXBsZSBmYWlsdXJlcyAoYmFzZWQgb24gTUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFUykgYmVmb3JlIHdlXG4gICAgICogYWN0dWFsbHkgdHJhbnNpdGlvbiB0byB0aGUgJ09mZmxpbmUnIHN0YXRlLlxuICAgICAqL1xuICAgIGhhbmRsZVdhdGNoU3RyZWFtRmFpbHVyZShlcnJvcikge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJPbmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PbmxpbmUgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QW5kQnJvYWRjYXN0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53YXRjaFN0cmVhbUZhaWx1cmVzKys7XG4gICAgICAgICAgICBpZiAodGhpcy53YXRjaFN0cmVhbUZhaWx1cmVzID49IE1BWF9XQVRDSF9TVFJFQU1fRkFJTFVSRVMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyT25saW5lU3RhdGVUaW1lcigpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nQ2xpZW50T2ZmbGluZVdhcm5pbmdJZk5lY2Vzc2FyeShgQ29ubmVjdGlvbiBmYWlsZWQgJHtNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTfSBgICtcbiAgICAgICAgICAgICAgICAgICAgYHRpbWVzLiBNb3N0IHJlY2VudCBlcnJvcjogJHtlcnJvci50b1N0cmluZygpfWApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QW5kQnJvYWRjYXN0KFwiT2ZmbGluZVwiIC8qIE9ubGluZVN0YXRlLk9mZmxpbmUgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cGxpY2l0bHkgc2V0cyB0aGUgT25saW5lU3RhdGUgdG8gdGhlIHNwZWNpZmllZCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIHJlc2V0cyBvdXIgdGltZXJzIC8gZmFpbHVyZSBjb3VudGVycywgZXRjLiB1c2VkIGJ5IG91clxuICAgICAqIE9mZmxpbmUgaGV1cmlzdGljcywgc28gbXVzdCBub3QgYmUgdXNlZCBpbiBwbGFjZSBvZlxuICAgICAqIGhhbmRsZVdhdGNoU3RyZWFtU3RhcnQoKSBhbmQgaGFuZGxlV2F0Y2hTdHJlYW1GYWlsdXJlKCkuXG4gICAgICovXG4gICAgc2V0KG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJPbmxpbmVTdGF0ZVRpbWVyKCk7XG4gICAgICAgIHRoaXMud2F0Y2hTdHJlYW1GYWlsdXJlcyA9IDA7XG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gXCJPbmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PbmxpbmUgKi8pIHtcbiAgICAgICAgICAgIC8vIFdlJ3ZlIGNvbm5lY3RlZCB0byB3YXRjaCBhdCBsZWFzdCBvbmNlLiBEb24ndCB3YXJuIHRoZSBkZXZlbG9wZXJcbiAgICAgICAgICAgIC8vIGFib3V0IGJlaW5nIG9mZmxpbmUgZ29pbmcgZm9yd2FyZC5cbiAgICAgICAgICAgIHRoaXMuc2hvdWxkV2FybkNsaWVudElzT2ZmbGluZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0QW5kQnJvYWRjYXN0KG5ld1N0YXRlKTtcbiAgICB9XG4gICAgc2V0QW5kQnJvYWRjYXN0KG5ld1N0YXRlKSB7XG4gICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZUhhbmRsZXIobmV3U3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvZ0NsaWVudE9mZmxpbmVXYXJuaW5nSWZOZWNlc3NhcnkoZGV0YWlscykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYENvdWxkIG5vdCByZWFjaCBDbG91ZCBGaXJlc3RvcmUgYmFja2VuZC4gJHtkZXRhaWxzfVxcbmAgK1xuICAgICAgICAgICAgYFRoaXMgdHlwaWNhbGx5IGluZGljYXRlcyB0aGF0IHlvdXIgZGV2aWNlIGRvZXMgbm90IGhhdmUgYSBoZWFsdGh5IGAgK1xuICAgICAgICAgICAgYEludGVybmV0IGNvbm5lY3Rpb24gYXQgdGhlIG1vbWVudC4gVGhlIGNsaWVudCB3aWxsIG9wZXJhdGUgaW4gb2ZmbGluZSBgICtcbiAgICAgICAgICAgIGBtb2RlIHVudGlsIGl0IGlzIGFibGUgdG8gc3VjY2Vzc2Z1bGx5IGNvbm5lY3QgdG8gdGhlIGJhY2tlbmQuYDtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2FybkNsaWVudElzT2ZmbGluZSkge1xuICAgICAgICAgICAgbG9nRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLnNob3VsZFdhcm5DbGllbnRJc09mZmxpbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNiwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJPbmxpbmVTdGF0ZVRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5vbmxpbmVTdGF0ZVRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm9ubGluZVN0YXRlVGltZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLm9ubGluZVN0YXRlVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyQ1ID0gJ1JlbW90ZVN0b3JlJztcbi8vIFRPRE8oYi8zNTg1MzQwMik6IE5lZ290aWF0ZSB0aGlzIHdpdGggdGhlIHN0cmVhbS5cbmNvbnN0IE1BWF9QRU5ESU5HX1dSSVRFUyA9IDEwO1xuY2xhc3MgUmVtb3RlU3RvcmVJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYWwgc3RvcmUsIHVzZWQgdG8gZmlsbCB0aGUgd3JpdGUgcGlwZWxpbmUgd2l0aCBvdXRib3VuZCBtdXRhdGlvbnMuXG4gICAgICovXG4gICAgbG9jYWxTdG9yZSwgXG4gICAgLyoqIFRoZSBjbGllbnQtc2lkZSBwcm94eSBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgYmFja2VuZC4gKi9cbiAgICBkYXRhc3RvcmUsIGFzeW5jUXVldWUsIG9ubGluZVN0YXRlSGFuZGxlciwgY29ubmVjdGl2aXR5TW9uaXRvcikge1xuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IGRhdGFzdG9yZTtcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcbiAgICAgICAgdGhpcy5yZW1vdGVTeW5jZXIgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiB1cCB0byBNQVhfUEVORElOR19XUklURVMgd3JpdGVzIHRoYXQgd2UgaGF2ZSBmZXRjaGVkIGZyb20gdGhlXG4gICAgICAgICAqIExvY2FsU3RvcmUgdmlhIGZpbGxXcml0ZVBpcGVsaW5lKCkgYW5kIGhhdmUgb3Igd2lsbCBzZW5kIHRvIHRoZSB3cml0ZVxuICAgICAgICAgKiBzdHJlYW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW5ldmVyIHdyaXRlUGlwZWxpbmUubGVuZ3RoID4gMCB0aGUgUmVtb3RlU3RvcmUgd2lsbCBhdHRlbXB0IHRvIHN0YXJ0IG9yXG4gICAgICAgICAqIHJlc3RhcnQgdGhlIHdyaXRlIHN0cmVhbS4gV2hlbiB0aGUgc3RyZWFtIGlzIGVzdGFibGlzaGVkIHRoZSB3cml0ZXMgaW4gdGhlXG4gICAgICAgICAqIHBpcGVsaW5lIHdpbGwgYmUgc2VudCBpbiBvcmRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogV3JpdGVzIHJlbWFpbiBpbiB3cml0ZVBpcGVsaW5lIHVudGlsIHRoZXkgYXJlIGFja25vd2xlZGdlZCBieSB0aGUgYmFja2VuZFxuICAgICAgICAgKiBhbmQgdGh1cyB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgcmUtc2VudCBpZiB0aGUgc3RyZWFtIGlzIGludGVycnVwdGVkIC9cbiAgICAgICAgICogcmVzdGFydGVkIGJlZm9yZSB0aGV5J3JlIGFja25vd2xlZGdlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogV3JpdGUgcmVzcG9uc2VzIGZyb20gdGhlIGJhY2tlbmQgYXJlIGxpbmtlZCB0byB0aGVpciBvcmlnaW5hdGluZyByZXF1ZXN0XG4gICAgICAgICAqIHB1cmVseSBiYXNlZCBvbiBvcmRlciwgYW5kIHNvIHdlIGNhbiBqdXN0IHNoaWZ0KCkgd3JpdGVzIGZyb20gdGhlIGZyb250IG9mXG4gICAgICAgICAqIHRoZSB3cml0ZVBpcGVsaW5lIGFzIHdlIHJlY2VpdmUgcmVzcG9uc2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cml0ZVBpcGVsaW5lID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcHBpbmcgb2Ygd2F0Y2hlZCB0YXJnZXRzIHRoYXQgdGhlIGNsaWVudCBjYXJlcyBhYm91dCB0cmFja2luZyBhbmQgdGhlXG4gICAgICAgICAqIHVzZXIgaGFzIGV4cGxpY2l0bHkgY2FsbGVkIGEgJ2xpc3RlbicgZm9yIHRoaXMgdGFyZ2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGVzZSB0YXJnZXRzIG1heSBvciBtYXkgbm90IGhhdmUgYmVlbiBzZW50IHRvIG9yIGFja25vd2xlZGdlZCBieSB0aGVcbiAgICAgICAgICogc2VydmVyLiBPbiByZS1lc3RhYmxpc2hpbmcgdGhlIGxpc3RlbiBzdHJlYW0sIHRoZXNlIHRhcmdldHMgc2hvdWxkIGJlIHNlbnRcbiAgICAgICAgICogdG8gdGhlIHNlcnZlci4gVGhlIHRhcmdldHMgcmVtb3ZlZCB3aXRoIHVubGlzdGVucyBhcmUgcmVtb3ZlZCBlYWdlcmx5XG4gICAgICAgICAqIHdpdGhvdXQgd2FpdGluZyBmb3IgY29uZmlybWF0aW9uIGZyb20gdGhlIGxpc3RlbiBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpc3RlblRhcmdldHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNldCBvZiByZWFzb25zIGZvciB3aHkgdGhlIFJlbW90ZVN0b3JlIG1heSBiZSBvZmZsaW5lLiBJZiBlbXB0eSwgdGhlXG4gICAgICAgICAqIFJlbW90ZVN0b3JlIG1heSBzdGFydCBpdHMgbmV0d29yayBjb25uZWN0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub2ZmbGluZUNhdXNlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGhhbmRsZXJzIHRoYXQgZ2V0IGNhbGxlZCB3aGVuIHRoZSBuZXR3b3JrIGlzIGRpc2FibGVkIG9yIGVuYWJsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBPUlRJTkcgTk9URTogVGhlc2UgZnVuY3Rpb25zIGFyZSB1c2VkIG9uIHRoZSBXZWIgY2xpZW50IHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogdW5kZXJseWluZyBzdHJlYW1zICh0byBzdXBwb3J0IHRyZWUtc2hha2VhYmxlIHN0cmVhbXMpLiBPbiBBbmRyb2lkIGFuZCBpT1MsXG4gICAgICAgICAqIHRoZSBzdHJlYW1zIGFyZSBjcmVhdGVkIGR1cmluZyBjb25zdHJ1Y3Rpb24gb2YgUmVtb3RlU3RvcmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uTmV0d29ya1N0YXR1c0NoYW5nZSA9IFtdO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eU1vbml0b3IgPSBjb25uZWN0aXZpdHlNb25pdG9yO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eU1vbml0b3IuYWRkQ2FsbGJhY2soKF8pID0+IHtcbiAgICAgICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUG9ydGluZyBOb3RlOiBVbmxpa2UgaU9TLCBgcmVzdGFydE5ldHdvcmsoKWAgaXMgY2FsbGVkIGV2ZW4gd2hlbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXR3b3JrIGJlY29tZXMgdW5yZWFjaGFibGUgYXMgd2UgZG9uJ3QgaGF2ZSBhbnkgb3RoZXIgd2F5IHRvIHRlYXJcbiAgICAgICAgICAgICAgICAvLyBkb3duIG91ciBzdHJlYW1zLlxuICAgICAgICAgICAgICAgIGlmIChjYW5Vc2VOZXR3b3JrKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNSwgJ1Jlc3RhcnRpbmcgc3RyZWFtcyBmb3IgbmV0d29yayByZWFjaGFiaWxpdHkgY2hhbmdlLicpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXN0YXJ0TmV0d29yayh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25saW5lU3RhdGVUcmFja2VyID0gbmV3IE9ubGluZVN0YXRlVHJhY2tlcihhc3luY1F1ZXVlLCBvbmxpbmVTdGF0ZUhhbmRsZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld1JlbW90ZVN0b3JlKGxvY2FsU3RvcmUsIGRhdGFzdG9yZSwgYXN5bmNRdWV1ZSwgb25saW5lU3RhdGVIYW5kbGVyLCBjb25uZWN0aXZpdHlNb25pdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBSZW1vdGVTdG9yZUltcGwobG9jYWxTdG9yZSwgZGF0YXN0b3JlLCBhc3luY1F1ZXVlLCBvbmxpbmVTdGF0ZUhhbmRsZXIsIGNvbm5lY3Rpdml0eU1vbml0b3IpO1xufVxuLyoqIFJlLWVuYWJsZXMgdGhlIG5ldHdvcmsuIElkZW1wb3RlbnQuICovXG5mdW5jdGlvbiByZW1vdGVTdG9yZUVuYWJsZU5ldHdvcmsocmVtb3RlU3RvcmUpIHtcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xuICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmRlbGV0ZSgwIC8qIE9mZmxpbmVDYXVzZS5Vc2VyRGlzYWJsZWQgKi8pO1xuICAgIHJldHVybiBlbmFibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpIHtcbiAgICBpZiAoY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZUltcGwpKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmV0d29ya1N0YXR1c0hhbmRsZXIgb2YgcmVtb3RlU3RvcmVJbXBsLm9uTmV0d29ya1N0YXR1c0NoYW5nZSkge1xuICAgICAgICAgICAgYXdhaXQgbmV0d29ya1N0YXR1c0hhbmRsZXIoLyogZW5hYmxlZD0gKi8gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRlbXBvcmFyaWx5IGRpc2FibGVzIHRoZSBuZXR3b3JrLiBUaGUgbmV0d29yayBjYW4gYmUgcmUtZW5hYmxlZCB1c2luZ1xuICogZW5hYmxlTmV0d29yaygpLlxuICovXG5hc3luYyBmdW5jdGlvbiByZW1vdGVTdG9yZURpc2FibGVOZXR3b3JrKHJlbW90ZVN0b3JlKSB7XG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoMCAvKiBPZmZsaW5lQ2F1c2UuVXNlckRpc2FibGVkICovKTtcbiAgICBhd2FpdCBkaXNhYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgLy8gU2V0IHRoZSBPbmxpbmVTdGF0ZSB0byBPZmZsaW5lIHNvIGdldCgpcyByZXR1cm4gZnJvbSBjYWNoZSwgZXRjLlxuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiT2ZmbGluZVwiIC8qIE9ubGluZVN0YXRlLk9mZmxpbmUgKi8pO1xufVxuYXN5bmMgZnVuY3Rpb24gZGlzYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpIHtcbiAgICBmb3IgKGNvbnN0IG5ldHdvcmtTdGF0dXNIYW5kbGVyIG9mIHJlbW90ZVN0b3JlSW1wbC5vbk5ldHdvcmtTdGF0dXNDaGFuZ2UpIHtcbiAgICAgICAgYXdhaXQgbmV0d29ya1N0YXR1c0hhbmRsZXIoLyogZW5hYmxlZD0gKi8gZmFsc2UpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHJlbW90ZVN0b3JlU2h1dGRvd24ocmVtb3RlU3RvcmUpIHtcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xuICAgIGxvZ0RlYnVnKExPR19UQUckNSwgJ1JlbW90ZVN0b3JlIHNodXR0aW5nIGRvd24uJyk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuYWRkKDUgLyogT2ZmbGluZUNhdXNlLlNodXRkb3duICovKTtcbiAgICBhd2FpdCBkaXNhYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLmNvbm5lY3Rpdml0eU1vbml0b3Iuc2h1dGRvd24oKTtcbiAgICAvLyBTZXQgdGhlIE9ubGluZVN0YXRlIHRvIFVua25vd24gKHJhdGhlciB0aGFuIE9mZmxpbmUpIHRvIGF2b2lkIHBvdGVudGlhbGx5XG4gICAgLy8gdHJpZ2dlcmluZyBzcHVyaW91cyBsaXN0ZW5lciBldmVudHMgd2l0aCBjYWNoZWQgZGF0YSwgZXRjLlxuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xufVxuLyoqXG4gKiBTdGFydHMgbmV3IGxpc3RlbiBmb3IgdGhlIGdpdmVuIHRhcmdldC4gVXNlcyByZXN1bWUgdG9rZW4gaWYgcHJvdmlkZWQuIEl0XG4gKiBpcyBhIG5vLW9wIGlmIHRoZSB0YXJnZXQgb2YgZ2l2ZW4gYFRhcmdldERhdGFgIGlzIGFscmVhZHkgYmVpbmcgbGlzdGVuZWQgdG8uXG4gKi9cbmZ1bmN0aW9uIHJlbW90ZVN0b3JlTGlzdGVuKHJlbW90ZVN0b3JlLCB0YXJnZXREYXRhKSB7XG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcbiAgICBpZiAocmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuaGFzKHRhcmdldERhdGEudGFyZ2V0SWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gTWFyayB0aGlzIGFzIHNvbWV0aGluZyB0aGUgY2xpZW50IGlzIGN1cnJlbnRseSBsaXN0ZW5pbmcgZm9yLlxuICAgIHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLnNldCh0YXJnZXREYXRhLnRhcmdldElkLCB0YXJnZXREYXRhKTtcbiAgICBpZiAoc2hvdWxkU3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XG4gICAgICAgIC8vIFRoZSBsaXN0ZW4gd2lsbCBiZSBzZW50IGluIG9uV2F0Y2hTdHJlYW1PcGVuXG4gICAgICAgIHN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZW5zdXJlV2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS5pc09wZW4oKSkge1xuICAgICAgICBzZW5kV2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0RGF0YSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZW1vdmVzIHRoZSBsaXN0ZW4gZnJvbSBzZXJ2ZXIuIEl0IGlzIGEgbm8tb3AgaWYgdGhlIGdpdmVuIHRhcmdldCBpZCBpc1xuICogbm90IGJlaW5nIGxpc3RlbmVkIHRvLlxuICovXG5mdW5jdGlvbiByZW1vdGVTdG9yZVVubGlzdGVuKHJlbW90ZVN0b3JlLCB0YXJnZXRJZCkge1xuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XG4gICAgY29uc3Qgd2F0Y2hTdHJlYW0gPSBlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xuICAgIHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmRlbGV0ZSh0YXJnZXRJZCk7XG4gICAgaWYgKHdhdGNoU3RyZWFtLmlzT3BlbigpKSB7XG4gICAgICAgIHNlbmRVbndhdGNoUmVxdWVzdChyZW1vdGVTdG9yZUltcGwsIHRhcmdldElkKTtcbiAgICB9XG4gICAgaWYgKHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLnNpemUgPT09IDApIHtcbiAgICAgICAgaWYgKHdhdGNoU3RyZWFtLmlzT3BlbigpKSB7XG4gICAgICAgICAgICB3YXRjaFN0cmVhbS5tYXJrSWRsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhblVzZU5ldHdvcmsocmVtb3RlU3RvcmVJbXBsKSkge1xuICAgICAgICAgICAgLy8gUmV2ZXJ0IHRvIE9ubGluZVN0YXRlLlVua25vd24gaWYgdGhlIHdhdGNoIHN0cmVhbSBpcyBub3Qgb3BlbiBhbmQgd2VcbiAgICAgICAgICAgIC8vIGhhdmUgbm8gbGlzdGVuZXJzLCBzaW5jZSB3aXRob3V0IGFueSBsaXN0ZW5zIHRvIHNlbmQgd2UgY2Fubm90XG4gICAgICAgICAgICAvLyBjb25maXJtIGlmIHRoZSBzdHJlYW0gaXMgaGVhbHRoeSBhbmQgdXBncmFkZSB0byBPbmxpbmVTdGF0ZS5PbmxpbmUuXG4gICAgICAgICAgICByZW1vdGVTdG9yZUltcGwub25saW5lU3RhdGVUcmFja2VyLnNldChcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogV2UgbmVlZCB0byBpbmNyZW1lbnQgdGhlIGV4cGVjdGVkIG51bWJlciBvZiBwZW5kaW5nIHJlc3BvbnNlcyB3ZSdyZSBkdWVcbiAqIGZyb20gd2F0Y2ggc28gd2Ugd2FpdCBmb3IgdGhlIGFjayB0byBwcm9jZXNzIGFueSBtZXNzYWdlcyBmcm9tIHRoaXMgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBzZW5kV2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0RGF0YSkge1xuICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IucmVjb3JkUGVuZGluZ1RhcmdldFJlcXVlc3QodGFyZ2V0RGF0YS50YXJnZXRJZCk7XG4gICAgaWYgKHRhcmdldERhdGEucmVzdW1lVG9rZW4uYXBwcm94aW1hdGVCeXRlU2l6ZSgpID4gMCB8fFxuICAgICAgICB0YXJnZXREYXRhLnNuYXBzaG90VmVyc2lvbi5jb21wYXJlVG8oU25hcHNob3RWZXJzaW9uLm1pbigpKSA+IDApIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRDb3VudCA9IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCh0YXJnZXREYXRhLnRhcmdldElkKS5zaXplO1xuICAgICAgICB0YXJnZXREYXRhID0gdGFyZ2V0RGF0YS53aXRoRXhwZWN0ZWRDb3VudChleHBlY3RlZENvdW50KTtcbiAgICB9XG4gICAgZW5zdXJlV2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS53YXRjaCh0YXJnZXREYXRhKTtcbn1cbi8qKlxuICogV2UgbmVlZCB0byBpbmNyZW1lbnQgdGhlIGV4cGVjdGVkIG51bWJlciBvZiBwZW5kaW5nIHJlc3BvbnNlcyB3ZSdyZSBkdWVcbiAqIGZyb20gd2F0Y2ggc28gd2Ugd2FpdCBmb3IgdGhlIHJlbW92YWwgb24gdGhlIHNlcnZlciBiZWZvcmUgd2UgcHJvY2VzcyBhbnlcbiAqIG1lc3NhZ2VzIGZyb20gdGhpcyB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRVbndhdGNoUmVxdWVzdChyZW1vdGVTdG9yZUltcGwsIHRhcmdldElkKSB7XG4gICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5yZWNvcmRQZW5kaW5nVGFyZ2V0UmVxdWVzdCh0YXJnZXRJZCk7XG4gICAgZW5zdXJlV2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS51bndhdGNoKHRhcmdldElkKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSB7XG4gICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvciA9IG5ldyBXYXRjaENoYW5nZUFnZ3JlZ2F0b3Ioe1xuICAgICAgICBnZXRSZW1vdGVLZXlzRm9yVGFyZ2V0OiB0YXJnZXRJZCA9PiByZW1vdGVTdG9yZUltcGwucmVtb3RlU3luY2VyLmdldFJlbW90ZUtleXNGb3JUYXJnZXQodGFyZ2V0SWQpLFxuICAgICAgICBnZXRUYXJnZXREYXRhRm9yVGFyZ2V0OiB0YXJnZXRJZCA9PiByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5nZXQodGFyZ2V0SWQpIHx8IG51bGwsXG4gICAgICAgIGdldERhdGFiYXNlSWQ6ICgpID0+IHJlbW90ZVN0b3JlSW1wbC5kYXRhc3RvcmUuc2VyaWFsaXplci5kYXRhYmFzZUlkXG4gICAgfSk7XG4gICAgZW5zdXJlV2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS5zdGFydCgpO1xuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuaGFuZGxlV2F0Y2hTdHJlYW1TdGFydCgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHdhdGNoIHN0cmVhbSBzaG91bGQgYmUgc3RhcnRlZCBiZWNhdXNlIGl0J3MgbmVjZXNzYXJ5XG4gKiBhbmQgaGFzIG5vdCB5ZXQgYmVlbiBzdGFydGVkLlxuICovXG5mdW5jdGlvbiBzaG91bGRTdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIHJldHVybiAoY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZUltcGwpICYmXG4gICAgICAgICFlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpLmlzU3RhcnRlZCgpICYmXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLnNpemUgPiAwKTtcbn1cbmZ1bmN0aW9uIGNhblVzZU5ldHdvcmsocmVtb3RlU3RvcmUpIHtcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xuICAgIHJldHVybiByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5zaXplID09PSAwO1xufVxuZnVuY3Rpb24gY2xlYW5VcFdhdGNoU3RyZWFtU3RhdGUocmVtb3RlU3RvcmVJbXBsKSB7XG4gICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvciA9IHVuZGVmaW5lZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIG9uV2F0Y2hTdHJlYW1Db25uZWN0ZWQocmVtb3RlU3RvcmVJbXBsKSB7XG4gICAgLy8gTWFyayB0aGUgY2xpZW50IGFzIG9ubGluZSBzaW5jZSB3ZSBnb3QgYSBcImNvbm5lY3RlZFwiIG5vdGlmaWNhdGlvbi5cbiAgICByZW1vdGVTdG9yZUltcGwub25saW5lU3RhdGVUcmFja2VyLnNldChcIk9ubGluZVwiIC8qIE9ubGluZVN0YXRlLk9ubGluZSAqLyk7XG59XG5hc3luYyBmdW5jdGlvbiBvbldhdGNoU3RyZWFtT3BlbihyZW1vdGVTdG9yZUltcGwpIHtcbiAgICByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5mb3JFYWNoKCh0YXJnZXREYXRhLCB0YXJnZXRJZCkgPT4ge1xuICAgICAgICBzZW5kV2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0RGF0YSk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBvbldhdGNoU3RyZWFtQ2xvc2UocmVtb3RlU3RvcmVJbXBsLCBlcnJvcikge1xuICAgIGNsZWFuVXBXYXRjaFN0cmVhbVN0YXRlKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgLy8gSWYgd2Ugc3RpbGwgbmVlZCB0aGUgd2F0Y2ggc3RyZWFtLCByZXRyeSB0aGUgY29ubmVjdGlvbi5cbiAgICBpZiAoc2hvdWxkU3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuaGFuZGxlV2F0Y2hTdHJlYW1GYWlsdXJlKGVycm9yKTtcbiAgICAgICAgc3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byByZXN0YXJ0IHdhdGNoIHN0cmVhbSBiZWNhdXNlIHRoZXJlIGFyZSBubyBhY3RpdmUgdGFyZ2V0cy5cbiAgICAgICAgLy8gVGhlIG9ubGluZSBzdGF0ZSBpcyBzZXQgdG8gdW5rbm93biBiZWNhdXNlIHRoZXJlIGlzIG5vIGFjdGl2ZSBhdHRlbXB0XG4gICAgICAgIC8vIGF0IGVzdGFibGlzaGluZyBhIGNvbm5lY3Rpb25cbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLyk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gb25XYXRjaFN0cmVhbUNoYW5nZShyZW1vdGVTdG9yZUltcGwsIHdhdGNoQ2hhbmdlLCBzbmFwc2hvdFZlcnNpb24pIHtcbiAgICAvLyBNYXJrIHRoZSBjbGllbnQgYXMgb25saW5lIHNpbmNlIHdlIGdvdCBhIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJPbmxpbmVcIiAvKiBPbmxpbmVTdGF0ZS5PbmxpbmUgKi8pO1xuICAgIGlmICh3YXRjaENoYW5nZSBpbnN0YW5jZW9mIFdhdGNoVGFyZ2V0Q2hhbmdlICYmXG4gICAgICAgIHdhdGNoQ2hhbmdlLnN0YXRlID09PSAyIC8qIFdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUuUmVtb3ZlZCAqLyAmJlxuICAgICAgICB3YXRjaENoYW5nZS5jYXVzZSkge1xuICAgICAgICAvLyBUaGVyZSB3YXMgYW4gZXJyb3Igb24gYSB0YXJnZXQsIGRvbid0IHdhaXQgZm9yIGEgY29uc2lzdGVudCBzbmFwc2hvdFxuICAgICAgICAvLyB0byByYWlzZSBldmVudHNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZVRhcmdldEVycm9yKHJlbW90ZVN0b3JlSW1wbCwgd2F0Y2hDaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDUsICdGYWlsZWQgdG8gcmVtb3ZlIHRhcmdldHMgJXM6ICVzICcsIHdhdGNoQ2hhbmdlLnRhcmdldElkcy5qb2luKCcsJyksIGUpO1xuICAgICAgICAgICAgYXdhaXQgZGlzYWJsZU5ldHdvcmtVbnRpbFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAod2F0Y2hDaGFuZ2UgaW5zdGFuY2VvZiBEb2N1bWVudFdhdGNoQ2hhbmdlKSB7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IuaGFuZGxlRG9jdW1lbnRDaGFuZ2Uod2F0Y2hDaGFuZ2UpO1xuICAgIH1cbiAgICBlbHNlIGlmICh3YXRjaENoYW5nZSBpbnN0YW5jZW9mIEV4aXN0ZW5jZUZpbHRlckNoYW5nZSkge1xuICAgICAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yLmhhbmRsZUV4aXN0ZW5jZUZpbHRlcih3YXRjaENoYW5nZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yLmhhbmRsZVRhcmdldENoYW5nZSh3YXRjaENoYW5nZSk7XG4gICAgfVxuICAgIGlmICghc25hcHNob3RWZXJzaW9uLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbiA9IGF3YWl0IGxvY2FsU3RvcmVHZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKHJlbW90ZVN0b3JlSW1wbC5sb2NhbFN0b3JlKTtcbiAgICAgICAgICAgIGlmIChzbmFwc2hvdFZlcnNpb24uY29tcGFyZVRvKGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24pID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHJlY2VpdmVkIGEgdGFyZ2V0IGNoYW5nZSB3aXRoIGEgZ2xvYmFsIHNuYXBzaG90IGlmIHRoZSBzbmFwc2hvdFxuICAgICAgICAgICAgICAgIC8vIHZlcnNpb24gaXMgbm90IGVxdWFsIHRvIFNuYXBzaG90VmVyc2lvbi5taW4oKS5cbiAgICAgICAgICAgICAgICBhd2FpdCByYWlzZVdhdGNoU25hcHNob3QocmVtb3RlU3RvcmVJbXBsLCBzbmFwc2hvdFZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDUsICdGYWlsZWQgdG8gcmFpc2Ugc25hcHNob3Q6JywgZSk7XG4gICAgICAgICAgICBhd2FpdCBkaXNhYmxlTmV0d29ya1VudGlsUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUmVjb3ZlcnkgbG9naWMgZm9yIEluZGV4ZWREQiBlcnJvcnMgdGhhdCB0YWtlcyB0aGUgbmV0d29yayBvZmZsaW5lIHVudGlsXG4gKiBgb3BgIHN1Y2NlZWRzLiBSZXRyaWVzIGFyZSBzY2hlZHVsZWQgd2l0aCBiYWNrb2ZmIHVzaW5nXG4gKiBgZW5xdWV1ZVJldHJ5YWJsZSgpYC4gSWYgYG9wKClgIGlzIG5vdCBwcm92aWRlZCwgSW5kZXhlZERCIGFjY2VzcyBpc1xuICogdmFsaWRhdGVkIHZpYSBhIGdlbmVyaWMgb3BlcmF0aW9uLlxuICpcbiAqIFRoZSByZXR1cm5lZCBQcm9taXNlIGlzIHJlc29sdmVkIG9uY2UgdGhlIG5ldHdvcmsgaXMgZGlzYWJsZWQgYW5kIGJlZm9yZVxuICogYW55IHJldHJ5IGF0dGVtcHQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRpc2FibGVOZXR3b3JrVW50aWxSZWNvdmVyeShyZW1vdGVTdG9yZUltcGwsIGUsIG9wKSB7XG4gICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xuICAgICAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoMSAvKiBPZmZsaW5lQ2F1c2UuSW5kZXhlZERiRmFpbGVkICovKTtcbiAgICAgICAgLy8gRGlzYWJsZSBuZXR3b3JrIGFuZCByYWlzZSBvZmZsaW5lIHNuYXBzaG90c1xuICAgICAgICBhd2FpdCBkaXNhYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiT2ZmbGluZVwiIC8qIE9ubGluZVN0YXRlLk9mZmxpbmUgKi8pO1xuICAgICAgICBpZiAoIW9wKSB7XG4gICAgICAgICAgICAvLyBVc2UgYSBzaW1wbGUgcmVhZCBvcGVyYXRpb24gdG8gZGV0ZXJtaW5lIGlmIEluZGV4ZWREQiByZWNvdmVyZWQuXG4gICAgICAgICAgICAvLyBJZGVhbGx5LCB3ZSB3b3VsZCBleHBvc2UgYSBoZWFsdGggY2hlY2sgZGlyZWN0bHkgb24gU2ltcGxlRGIsIGJ1dFxuICAgICAgICAgICAgLy8gUmVtb3RlU3RvcmUgb25seSBoYXMgYWNjZXNzIHRvIHBlcnNpc3RlbmNlIHRocm91Z2ggTG9jYWxTdG9yZS5cbiAgICAgICAgICAgIG9wID0gKCkgPT4gbG9jYWxTdG9yZUdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24ocmVtb3RlU3RvcmVJbXBsLmxvY2FsU3RvcmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb2JlIEluZGV4ZWREQiBwZXJpb2RpY2FsbHkgYW5kIHJlLWVuYWJsZSBuZXR3b3JrXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5hc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ1LCAnUmV0cnlpbmcgSW5kZXhlZERCIGFjY2VzcycpO1xuICAgICAgICAgICAgYXdhaXQgb3AoKTtcbiAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmRlbGV0ZSgxIC8qIE9mZmxpbmVDYXVzZS5JbmRleGVkRGJGYWlsZWQgKi8pO1xuICAgICAgICAgICAgYXdhaXQgZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG4vKipcbiAqIEV4ZWN1dGVzIGBvcGAuIElmIGBvcGAgZmFpbHMsIHRha2VzIHRoZSBuZXR3b3JrIG9mZmxpbmUgdW50aWwgYG9wYFxuICogc3VjY2VlZHMuIFJldHVybnMgYWZ0ZXIgdGhlIGZpcnN0IGF0dGVtcHQuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVXaXRoUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBvcCkge1xuICAgIHJldHVybiBvcCgpLmNhdGNoKGUgPT4gZGlzYWJsZU5ldHdvcmtVbnRpbFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgZSwgb3ApKTtcbn1cbi8qKlxuICogVGFrZXMgYSBiYXRjaCBvZiBjaGFuZ2VzIGZyb20gdGhlIERhdGFzdG9yZSwgcmVwYWNrYWdlcyB0aGVtIGFzIGFcbiAqIFJlbW90ZUV2ZW50LCBhbmQgcGFzc2VzIHRoYXQgb24gdG8gdGhlIGxpc3RlbmVyLCB3aGljaCBpcyB0eXBpY2FsbHkgdGhlXG4gKiBTeW5jRW5naW5lLlxuICovXG5mdW5jdGlvbiByYWlzZVdhdGNoU25hcHNob3QocmVtb3RlU3RvcmVJbXBsLCBzbmFwc2hvdFZlcnNpb24pIHtcbiAgICBjb25zdCByZW1vdGVFdmVudCA9IHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IuY3JlYXRlUmVtb3RlRXZlbnQoc25hcHNob3RWZXJzaW9uKTtcbiAgICAvLyBVcGRhdGUgaW4tbWVtb3J5IHJlc3VtZSB0b2tlbnMuIExvY2FsU3RvcmUgd2lsbCB1cGRhdGUgdGhlXG4gICAgLy8gcGVyc2lzdGVudCB2aWV3IG9mIHRoZXNlIHdoZW4gYXBwbHlpbmcgdGhlIGNvbXBsZXRlZCBSZW1vdGVFdmVudC5cbiAgICByZW1vdGVFdmVudC50YXJnZXRDaGFuZ2VzLmZvckVhY2goKGNoYW5nZSwgdGFyZ2V0SWQpID0+IHtcbiAgICAgICAgaWYgKGNoYW5nZS5yZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuZ2V0KHRhcmdldElkKTtcbiAgICAgICAgICAgIC8vIEEgd2F0Y2hlZCB0YXJnZXQgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWQgYWxyZWFkeS5cbiAgICAgICAgICAgIGlmICh0YXJnZXREYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuc2V0KHRhcmdldElkLCB0YXJnZXREYXRhLndpdGhSZXN1bWVUb2tlbihjaGFuZ2UucmVzdW1lVG9rZW4sIHNuYXBzaG90VmVyc2lvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gUmUtZXN0YWJsaXNoIGxpc3RlbnMgZm9yIHRoZSB0YXJnZXRzIHRoYXQgaGF2ZSBiZWVuIGludmFsaWRhdGVkIGJ5XG4gICAgLy8gZXhpc3RlbmNlIGZpbHRlciBtaXNtYXRjaGVzLlxuICAgIHJlbW90ZUV2ZW50LnRhcmdldE1pc21hdGNoZXMuZm9yRWFjaCgodGFyZ2V0SWQsIHRhcmdldFB1cnBvc2UpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmdldCh0YXJnZXRJZCk7XG4gICAgICAgIGlmICghdGFyZ2V0RGF0YSkge1xuICAgICAgICAgICAgLy8gQSB3YXRjaGVkIHRhcmdldCBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZCBhbHJlYWR5LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIHRoZSByZXN1bWUgdG9rZW4gZm9yIHRoZSB0YXJnZXQsIHNpbmNlIHdlJ3JlIGluIGEga25vd24gbWlzbWF0Y2hcbiAgICAgICAgLy8gc3RhdGUuXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLnNldCh0YXJnZXRJZCwgdGFyZ2V0RGF0YS53aXRoUmVzdW1lVG9rZW4oQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORywgdGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24pKTtcbiAgICAgICAgLy8gQ2F1c2UgYSBoYXJkIHJlc2V0IGJ5IHVud2F0Y2hpbmcgYW5kIHJld2F0Y2hpbmcgaW1tZWRpYXRlbHksIGJ1dFxuICAgICAgICAvLyBkZWxpYmVyYXRlbHkgZG9uJ3Qgc2VuZCBhIHJlc3VtZSB0b2tlbiBzbyB0aGF0IHdlIGdldCBhIGZ1bGwgdXBkYXRlLlxuICAgICAgICBzZW5kVW53YXRjaFJlcXVlc3QocmVtb3RlU3RvcmVJbXBsLCB0YXJnZXRJZCk7XG4gICAgICAgIC8vIE1hcmsgdGhlIHRhcmdldCB3ZSBzZW5kIGFzIGJlaW5nIG9uIGJlaGFsZiBvZiBhbiBleGlzdGVuY2UgZmlsdGVyXG4gICAgICAgIC8vIG1pc21hdGNoLCBidXQgZG9uJ3QgYWN0dWFsbHkgcmV0YWluIHRoYXQgaW4gbGlzdGVuVGFyZ2V0cy4gVGhpcyBlbnN1cmVzXG4gICAgICAgIC8vIHRoYXQgd2UgZmxhZyB0aGUgZmlyc3QgcmUtbGlzdGVuIHRoaXMgd2F5IHdpdGhvdXQgaW1wYWN0aW5nIGZ1dHVyZVxuICAgICAgICAvLyBsaXN0ZW5zIG9mIHRoaXMgdGFyZ2V0ICh0aGF0IG1pZ2h0IGhhcHBlbiBlLmcuIG9uIHJlY29ubmVjdCkuXG4gICAgICAgIGNvbnN0IHJlcXVlc3RUYXJnZXREYXRhID0gbmV3IFRhcmdldERhdGEodGFyZ2V0RGF0YS50YXJnZXQsIHRhcmdldElkLCB0YXJnZXRQdXJwb3NlLCB0YXJnZXREYXRhLnNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgc2VuZFdhdGNoUmVxdWVzdChyZW1vdGVTdG9yZUltcGwsIHJlcXVlc3RUYXJnZXREYXRhKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVtb3RlU3RvcmVJbXBsLnJlbW90ZVN5bmNlci5hcHBseVJlbW90ZUV2ZW50KHJlbW90ZUV2ZW50KTtcbn1cbi8qKiBIYW5kbGVzIGFuIGVycm9yIG9uIGEgdGFyZ2V0ICovXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVUYXJnZXRFcnJvcihyZW1vdGVTdG9yZUltcGwsIHdhdGNoQ2hhbmdlKSB7XG4gICAgY29uc3QgZXJyb3IgPSB3YXRjaENoYW5nZS5jYXVzZTtcbiAgICBmb3IgKGNvbnN0IHRhcmdldElkIG9mIHdhdGNoQ2hhbmdlLnRhcmdldElkcykge1xuICAgICAgICAvLyBBIHdhdGNoZWQgdGFyZ2V0IG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkIGFscmVhZHkuXG4gICAgICAgIGlmIChyZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5oYXModGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICBhd2FpdCByZW1vdGVTdG9yZUltcGwucmVtb3RlU3luY2VyLnJlamVjdExpc3Rlbih0YXJnZXRJZCwgZXJyb3IpO1xuICAgICAgICAgICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuZGVsZXRlKHRhcmdldElkKTtcbiAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IucmVtb3ZlVGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQXR0ZW1wdHMgdG8gZmlsbCBvdXIgd3JpdGUgcGlwZWxpbmUgd2l0aCB3cml0ZXMgZnJvbSB0aGUgTG9jYWxTdG9yZS5cbiAqXG4gKiBDYWxsZWQgaW50ZXJuYWxseSB0byBib290c3RyYXAgb3IgcmVmaWxsIHRoZSB3cml0ZSBwaXBlbGluZSBhbmQgYnlcbiAqIFN5bmNFbmdpbmUgd2hlbmV2ZXIgdGhlcmUgYXJlIG5ldyBtdXRhdGlvbnMgdG8gcHJvY2Vzcy5cbiAqXG4gKiBTdGFydHMgdGhlIHdyaXRlIHN0cmVhbSBpZiBuZWNlc3NhcnkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZpbGxXcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlKSB7XG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcbiAgICBjb25zdCB3cml0ZVN0cmVhbSA9IGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgbGV0IGxhc3RCYXRjaElkUmV0cmlldmVkID0gcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoID4gMFxuICAgICAgICA/IHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lW3JlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAuYmF0Y2hJZFxuICAgICAgICA6IEJBVENISURfVU5LTk9XTjtcbiAgICB3aGlsZSAoY2FuQWRkVG9Xcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gYXdhaXQgbG9jYWxTdG9yZUdldE5leHRNdXRhdGlvbkJhdGNoKHJlbW90ZVN0b3JlSW1wbC5sb2NhbFN0b3JlLCBsYXN0QmF0Y2hJZFJldHJpZXZlZCk7XG4gICAgICAgICAgICBpZiAoYmF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlU3RyZWFtLm1hcmtJZGxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFzdEJhdGNoSWRSZXRyaWV2ZWQgPSBiYXRjaC5iYXRjaElkO1xuICAgICAgICAgICAgICAgIGFkZFRvV3JpdGVQaXBlbGluZShyZW1vdGVTdG9yZUltcGwsIGJhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgZGlzYWJsZU5ldHdvcmtVbnRpbFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZFN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSkge1xuICAgICAgICBzdGFydFdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgd2UgY2FuIGFkZCB0byB0aGUgd3JpdGUgcGlwZWxpbmUgKGkuZS4gdGhlIG5ldHdvcmsgaXNcbiAqIGVuYWJsZWQgYW5kIHRoZSB3cml0ZSBwaXBlbGluZSBpcyBub3QgZnVsbCkuXG4gKi9cbmZ1bmN0aW9uIGNhbkFkZFRvV3JpdGVQaXBlbGluZShyZW1vdGVTdG9yZUltcGwpIHtcbiAgICByZXR1cm4gKGNhblVzZU5ldHdvcmsocmVtb3RlU3RvcmVJbXBsKSAmJlxuICAgICAgICByZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5sZW5ndGggPCBNQVhfUEVORElOR19XUklURVMpO1xufVxuLyoqXG4gKiBRdWV1ZXMgYWRkaXRpb25hbCB3cml0ZXMgdG8gYmUgc2VudCB0byB0aGUgd3JpdGUgc3RyZWFtLCBzZW5kaW5nIHRoZW1cbiAqIGltbWVkaWF0ZWx5IGlmIHRoZSB3cml0ZSBzdHJlYW0gaXMgZXN0YWJsaXNoZWQuXG4gKi9cbmZ1bmN0aW9uIGFkZFRvV3JpdGVQaXBlbGluZShyZW1vdGVTdG9yZUltcGwsIGJhdGNoKSB7XG4gICAgcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUucHVzaChiYXRjaCk7XG4gICAgY29uc3Qgd3JpdGVTdHJlYW0gPSBlbnN1cmVXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xuICAgIGlmICh3cml0ZVN0cmVhbS5pc09wZW4oKSAmJiB3cml0ZVN0cmVhbS5oYW5kc2hha2VDb21wbGV0ZSkge1xuICAgICAgICB3cml0ZVN0cmVhbS53cml0ZU11dGF0aW9ucyhiYXRjaC5tdXRhdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNob3VsZFN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSB7XG4gICAgcmV0dXJuIChjYW5Vc2VOZXR3b3JrKHJlbW90ZVN0b3JlSW1wbCkgJiZcbiAgICAgICAgIWVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuaXNTdGFydGVkKCkgJiZcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoID4gMCk7XG59XG5mdW5jdGlvbiBzdGFydFdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuc3RhcnQoKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG9uV3JpdGVTdHJlYW1PcGVuKHJlbW90ZVN0b3JlSW1wbCkge1xuICAgIGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkud3JpdGVIYW5kc2hha2UoKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG9uV3JpdGVIYW5kc2hha2VDb21wbGV0ZShyZW1vdGVTdG9yZUltcGwpIHtcbiAgICBjb25zdCB3cml0ZVN0cmVhbSA9IGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgLy8gU2VuZCB0aGUgd3JpdGUgcGlwZWxpbmUgbm93IHRoYXQgdGhlIHN0cmVhbSBpcyBlc3RhYmxpc2hlZC5cbiAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lKSB7XG4gICAgICAgIHdyaXRlU3RyZWFtLndyaXRlTXV0YXRpb25zKGJhdGNoLm11dGF0aW9ucyk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gb25NdXRhdGlvblJlc3VsdChyZW1vdGVTdG9yZUltcGwsIGNvbW1pdFZlcnNpb24sIHJlc3VsdHMpIHtcbiAgICBjb25zdCBiYXRjaCA9IHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLnNoaWZ0KCk7XG4gICAgY29uc3Qgc3VjY2VzcyA9IE11dGF0aW9uQmF0Y2hSZXN1bHQuZnJvbShiYXRjaCwgY29tbWl0VmVyc2lvbiwgcmVzdWx0cyk7XG4gICAgYXdhaXQgZXhlY3V0ZVdpdGhSZWNvdmVyeShyZW1vdGVTdG9yZUltcGwsICgpID0+IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIuYXBwbHlTdWNjZXNzZnVsV3JpdGUoc3VjY2VzcykpO1xuICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCB3aXRoIHRoZSBjb21wbGV0aW9uIG9mIHRoaXMgbXV0YXRpb24gYW5vdGhlclxuICAgIC8vIHNsb3QgaGFzIGZyZWVkIHVwLlxuICAgIGF3YWl0IGZpbGxXcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCk7XG59XG5hc3luYyBmdW5jdGlvbiBvbldyaXRlU3RyZWFtQ2xvc2UocmVtb3RlU3RvcmVJbXBsLCBlcnJvcikge1xuICAgIC8vIElmIHRoZSB3cml0ZSBzdHJlYW0gY2xvc2VkIGFmdGVyIHRoZSB3cml0ZSBoYW5kc2hha2UgY29tcGxldGVzLCBhIHdyaXRlXG4gICAgLy8gb3BlcmF0aW9uIGZhaWxlZCBhbmQgd2UgZmFpbCB0aGUgcGVuZGluZyBvcGVyYXRpb24uXG4gICAgaWYgKGVycm9yICYmIGVuc3VyZVdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuaGFuZHNoYWtlQ29tcGxldGUpIHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciBhZmZlY3RzIHRoZSBhY3R1YWwgd3JpdGUuXG4gICAgICAgIGF3YWl0IGhhbmRsZVdyaXRlRXJyb3IocmVtb3RlU3RvcmVJbXBsLCBlcnJvcik7XG4gICAgfVxuICAgIC8vIFRoZSB3cml0ZSBzdHJlYW0gbWlnaHQgaGF2ZSBiZWVuIHN0YXJ0ZWQgYnkgcmVmaWxsaW5nIHRoZSB3cml0ZVxuICAgIC8vIHBpcGVsaW5lIGZvciBmYWlsZWQgd3JpdGVzXG4gICAgaWYgKHNob3VsZFN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSkge1xuICAgICAgICBzdGFydFdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlV3JpdGVFcnJvcihyZW1vdGVTdG9yZUltcGwsIGVycm9yKSB7XG4gICAgLy8gT25seSBoYW5kbGUgcGVybWFuZW50IGVycm9ycyBoZXJlLiBJZiBpdCdzIHRyYW5zaWVudCwganVzdCBsZXQgdGhlIHJldHJ5XG4gICAgLy8gbG9naWMga2ljayBpbi5cbiAgICBpZiAoaXNQZXJtYW5lbnRXcml0ZUVycm9yKGVycm9yLmNvZGUpKSB7XG4gICAgICAgIC8vIFRoaXMgd2FzIGEgcGVybWFuZW50IGVycm9yLCB0aGUgcmVxdWVzdCBpdHNlbGYgd2FzIHRoZSBwcm9ibGVtXG4gICAgICAgIC8vIHNvIGl0J3Mgbm90IGdvaW5nIHRvIHN1Y2NlZWQgaWYgd2UgcmVzZW5kIGl0LlxuICAgICAgICBjb25zdCBiYXRjaCA9IHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLnNoaWZ0KCk7XG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSBpdCdzIGFsc28gdW5saWtlbHkgdGhhdCB0aGUgc2VydmVyIGl0c2VsZiBpcyBtZWx0aW5nXG4gICAgICAgIC8vIGRvd24gLS0gdGhpcyB3YXMganVzdCBhIGJhZCByZXF1ZXN0IHNvIGluaGliaXQgYmFja29mZiBvbiB0aGUgbmV4dFxuICAgICAgICAvLyByZXN0YXJ0LlxuICAgICAgICBlbnN1cmVXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpLmluaGliaXRCYWNrb2ZmKCk7XG4gICAgICAgIGF3YWl0IGV4ZWN1dGVXaXRoUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCAoKSA9PiByZW1vdGVTdG9yZUltcGwucmVtb3RlU3luY2VyLnJlamVjdEZhaWxlZFdyaXRlKGJhdGNoLmJhdGNoSWQsIGVycm9yKSk7XG4gICAgICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCB3aXRoIHRoZSBjb21wbGV0aW9uIG9mIHRoaXMgbXV0YXRpb25cbiAgICAgICAgLy8gYW5vdGhlciBzbG90IGhhcyBmcmVlZCB1cC5cbiAgICAgICAgYXdhaXQgZmlsbFdyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiByZXN0YXJ0TmV0d29yayhyZW1vdGVTdG9yZSkge1xuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuYWRkKDQgLyogT2ZmbGluZUNhdXNlLkNvbm5lY3Rpdml0eUNoYW5nZSAqLyk7XG4gICAgYXdhaXQgZGlzYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xuICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmRlbGV0ZSg0IC8qIE9mZmxpbmVDYXVzZS5Db25uZWN0aXZpdHlDaGFuZ2UgKi8pO1xuICAgIGF3YWl0IGVuYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVtb3RlU3RvcmVIYW5kbGVDcmVkZW50aWFsQ2hhbmdlKHJlbW90ZVN0b3JlLCB1c2VyKSB7XG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcbiAgICByZW1vdGVTdG9yZUltcGwuYXN5bmNRdWV1ZS52ZXJpZnlPcGVyYXRpb25JblByb2dyZXNzKCk7XG4gICAgbG9nRGVidWcoTE9HX1RBRyQ1LCAnUmVtb3RlU3RvcmUgcmVjZWl2ZWQgbmV3IGNyZWRlbnRpYWxzJyk7XG4gICAgY29uc3QgdXNlc05ldHdvcmsgPSBjYW5Vc2VOZXR3b3JrKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgLy8gVGVhciBkb3duIGFuZCByZS1jcmVhdGUgb3VyIG5ldHdvcmsgc3RyZWFtcy4gVGhpcyB3aWxsIGVuc3VyZSB3ZSBnZXQgYVxuICAgIC8vIGZyZXNoIGF1dGggdG9rZW4gZm9yIHRoZSBuZXcgdXNlciBhbmQgcmUtZmlsbCB0aGUgd3JpdGUgcGlwZWxpbmUgd2l0aFxuICAgIC8vIG5ldyBtdXRhdGlvbnMgZnJvbSB0aGUgTG9jYWxTdG9yZSAoc2luY2UgbXV0YXRpb25zIGFyZSBwZXItdXNlcikuXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuYWRkKDMgLyogT2ZmbGluZUNhdXNlLkNyZWRlbnRpYWxDaGFuZ2UgKi8pO1xuICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICBpZiAodXNlc05ldHdvcmspIHtcbiAgICAgICAgLy8gRG9uJ3Qgc2V0IHRoZSBuZXR3b3JrIHN0YXR1cyB0byBVbmtub3duIGlmIHdlIGFyZSBvZmZsaW5lLlxuICAgICAgICByZW1vdGVTdG9yZUltcGwub25saW5lU3RhdGVUcmFja2VyLnNldChcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovKTtcbiAgICB9XG4gICAgYXdhaXQgcmVtb3RlU3RvcmVJbXBsLnJlbW90ZVN5bmNlci5oYW5kbGVDcmVkZW50aWFsQ2hhbmdlKHVzZXIpO1xuICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmRlbGV0ZSgzIC8qIE9mZmxpbmVDYXVzZS5DcmVkZW50aWFsQ2hhbmdlICovKTtcbiAgICBhd2FpdCBlbmFibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbn1cbi8qKlxuICogVG9nZ2xlcyB0aGUgbmV0d29yayBzdGF0ZSB3aGVuIHRoZSBjbGllbnQgZ2FpbnMgb3IgbG9zZXMgaXRzIHByaW1hcnkgbGVhc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbW90ZVN0b3JlQXBwbHlQcmltYXJ5U3RhdGUocmVtb3RlU3RvcmUsIGlzUHJpbWFyeSkge1xuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XG4gICAgaWYgKGlzUHJpbWFyeSkge1xuICAgICAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5kZWxldGUoMiAvKiBPZmZsaW5lQ2F1c2UuSXNTZWNvbmRhcnkgKi8pO1xuICAgICAgICBhd2FpdCBlbmFibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzUHJpbWFyeSkge1xuICAgICAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoMiAvKiBPZmZsaW5lQ2F1c2UuSXNTZWNvbmRhcnkgKi8pO1xuICAgICAgICBhd2FpdCBkaXNhYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIE9ubGluZVN0YXRlLlVua25vd24gKi8pO1xuICAgIH1cbn1cbi8qKlxuICogSWYgbm90IHlldCBpbml0aWFsaXplZCwgcmVnaXN0ZXJzIHRoZSBXYXRjaFN0cmVhbSBhbmQgaXRzIG5ldHdvcmsgc3RhdGVcbiAqIGNhbGxiYWNrIHdpdGggYHJlbW90ZVN0b3JlSW1wbGAuIFJldHVybnMgdGhlIGV4aXN0aW5nIHN0cmVhbSBpZiBvbmUgaXNcbiAqIGFscmVhZHkgYXZhaWxhYmxlLlxuICpcbiAqIFBPUlRJTkcgTk9URTogT24gaU9TIGFuZCBBbmRyb2lkLCB0aGUgV2F0Y2hTdHJlYW0gZ2V0cyByZWdpc3RlcmVkIG9uIHN0YXJ0dXAuXG4gKiBUaGlzIGlzIG5vdCBkb25lIG9uIFdlYiB0byBhbGxvdyBpdCB0byBiZSB0cmVlLXNoYWtlbi5cbiAqL1xuZnVuY3Rpb24gZW5zdXJlV2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSB7XG4gICAgaWYgKCFyZW1vdGVTdG9yZUltcGwud2F0Y2hTdHJlYW0pIHtcbiAgICAgICAgLy8gQ3JlYXRlIHN0cmVhbSAoYnV0IG5vdGUgdGhhdCBpdCBpcyBub3Qgc3RhcnRlZCB5ZXQpLlxuICAgICAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hTdHJlYW0gPSBuZXdQZXJzaXN0ZW50V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsLmRhdGFzdG9yZSwgcmVtb3RlU3RvcmVJbXBsLmFzeW5jUXVldWUsIHtcbiAgICAgICAgICAgIG9uQ29ubmVjdGVkOiBvbldhdGNoU3RyZWFtQ29ubmVjdGVkLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcbiAgICAgICAgICAgIG9uT3Blbjogb25XYXRjaFN0cmVhbU9wZW4uYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpLFxuICAgICAgICAgICAgb25DbG9zZTogb25XYXRjaFN0cmVhbUNsb3NlLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcbiAgICAgICAgICAgIG9uV2F0Y2hDaGFuZ2U6IG9uV2F0Y2hTdHJlYW1DaGFuZ2UuYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpXG4gICAgICAgIH0pO1xuICAgICAgICByZW1vdGVTdG9yZUltcGwub25OZXR3b3JrU3RhdHVzQ2hhbmdlLnB1c2goYXN5bmMgKGVuYWJsZWQpID0+IHtcbiAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoU3RyZWFtLmluaGliaXRCYWNrb2ZmKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVTdG9yZUltcGwub25saW5lU3RhdGVUcmFja2VyLnNldChcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZW1vdGVTdG9yZUltcGwud2F0Y2hTdHJlYW0uc3RvcCgpO1xuICAgICAgICAgICAgICAgIGNsZWFuVXBXYXRjaFN0cmVhbVN0YXRlKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVtb3RlU3RvcmVJbXBsLndhdGNoU3RyZWFtO1xufVxuLyoqXG4gKiBJZiBub3QgeWV0IGluaXRpYWxpemVkLCByZWdpc3RlcnMgdGhlIFdyaXRlU3RyZWFtIGFuZCBpdHMgbmV0d29yayBzdGF0ZVxuICogY2FsbGJhY2sgd2l0aCBgcmVtb3RlU3RvcmVJbXBsYC4gUmV0dXJucyB0aGUgZXhpc3Rpbmcgc3RyZWFtIGlmIG9uZSBpc1xuICogYWxyZWFkeSBhdmFpbGFibGUuXG4gKlxuICogUE9SVElORyBOT1RFOiBPbiBpT1MgYW5kIEFuZHJvaWQsIHRoZSBXcml0ZVN0cmVhbSBnZXRzIHJlZ2lzdGVyZWQgb24gc3RhcnR1cC5cbiAqIFRoaXMgaXMgbm90IGRvbmUgb24gV2ViIHRvIGFsbG93IGl0IHRvIGJlIHRyZWUtc2hha2VuLlxuICovXG5mdW5jdGlvbiBlbnN1cmVXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpIHtcbiAgICBpZiAoIXJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbSkge1xuICAgICAgICAvLyBDcmVhdGUgc3RyZWFtIChidXQgbm90ZSB0aGF0IGl0IGlzIG5vdCBzdGFydGVkIHlldCkuXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbSA9IG5ld1BlcnNpc3RlbnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwuZGF0YXN0b3JlLCByZW1vdGVTdG9yZUltcGwuYXN5bmNRdWV1ZSwge1xuICAgICAgICAgICAgb25Db25uZWN0ZWQ6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgICAgICAgb25PcGVuOiBvbldyaXRlU3RyZWFtT3Blbi5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbCksXG4gICAgICAgICAgICBvbkNsb3NlOiBvbldyaXRlU3RyZWFtQ2xvc2UuYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpLFxuICAgICAgICAgICAgb25IYW5kc2hha2VDb21wbGV0ZTogb25Xcml0ZUhhbmRzaGFrZUNvbXBsZXRlLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcbiAgICAgICAgICAgIG9uTXV0YXRpb25SZXN1bHQ6IG9uTXV0YXRpb25SZXN1bHQuYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpXG4gICAgICAgIH0pO1xuICAgICAgICByZW1vdGVTdG9yZUltcGwub25OZXR3b3JrU3RhdHVzQ2hhbmdlLnB1c2goYXN5bmMgKGVuYWJsZWQpID0+IHtcbiAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndyaXRlU3RyZWFtLmluaGliaXRCYWNrb2ZmKCk7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHN0YXJ0IHRoZSB3cml0ZSBzdHJlYW0gaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgICAgIGF3YWl0IGZpbGxXcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZW1vdGVTdG9yZUltcGwud3JpdGVTdHJlYW0uc3RvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNSwgYFN0b3BwaW5nIHdyaXRlIHN0cmVhbSB3aXRoICR7cmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RofSBwZW5kaW5nIHdyaXRlc2ApO1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdGVTdG9yZUltcGwud3JpdGVTdHJlYW07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJDQgPSAnQXN5bmNRdWV1ZSc7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gb3BlcmF0aW9uIHNjaGVkdWxlZCB0byBiZSBydW4gaW4gdGhlIGZ1dHVyZSBvbiBhbiBBc3luY1F1ZXVlLlxuICpcbiAqIEl0IGlzIGNyZWF0ZWQgdmlhIERlbGF5ZWRPcGVyYXRpb24uY3JlYXRlQW5kU2NoZWR1bGUoKS5cbiAqXG4gKiBTdXBwb3J0cyBjYW5jZWxsYXRpb24gKHZpYSBjYW5jZWwoKSkgYW5kIGVhcmx5IGV4ZWN1dGlvbiAodmlhIHNraXBEZWxheSgpKS5cbiAqXG4gKiBOb3RlOiBXZSBpbXBsZW1lbnQgYFByb21pc2VMaWtlYCBpbnN0ZWFkIG9mIGBQcm9taXNlYCwgYXMgdGhlIGBQcm9taXNlYCB0eXBlXG4gKiBpbiBuZXdlciB2ZXJzaW9ucyBvZiBUeXBlU2NyaXB0IGRlZmluZXMgYGZpbmFsbHlgLCB3aGljaCBpcyBub3QgYXZhaWxhYmxlIGluXG4gKiBJRS5cbiAqL1xuY2xhc3MgRGVsYXllZE9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYXN5bmNRdWV1ZSwgdGltZXJJZCwgdGFyZ2V0VGltZU1zLCBvcCwgcmVtb3ZhbENhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZSA9IGFzeW5jUXVldWU7XG4gICAgICAgIHRoaXMudGltZXJJZCA9IHRpbWVySWQ7XG4gICAgICAgIHRoaXMudGFyZ2V0VGltZU1zID0gdGFyZ2V0VGltZU1zO1xuICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgICAgIHRoaXMucmVtb3ZhbENhbGxiYWNrID0gcmVtb3ZhbENhbGxiYWNrO1xuICAgICAgICB0aGlzLmRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMudGhlbiA9IHRoaXMuZGVmZXJyZWQucHJvbWlzZS50aGVuLmJpbmQodGhpcy5kZWZlcnJlZC5wcm9taXNlKTtcbiAgICAgICAgLy8gSXQncyBub3JtYWwgZm9yIHRoZSBkZWZlcnJlZCBwcm9taXNlIHRvIGJlIGNhbmNlbGVkIChkdWUgdG8gY2FuY2VsbGF0aW9uKVxuICAgICAgICAvLyBhbmQgc28gd2UgYXR0YWNoIGEgZHVtbXkgY2F0Y2ggY2FsbGJhY2sgdG8gYXZvaWRcbiAgICAgICAgLy8gJ1VuaGFuZGxlZFByb21pc2VSZWplY3Rpb25XYXJuaW5nJyBsb2cgc3BhbS5cbiAgICAgICAgdGhpcy5kZWZlcnJlZC5wcm9taXNlLmNhdGNoKGVyciA9PiB7IH0pO1xuICAgIH1cbiAgICBnZXQgcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIERlbGF5ZWRPcGVyYXRpb24gdGhhdCBoYXMgYmVlbiBzY2hlZHVsZWQgdG8gYmVcbiAgICAgKiBleGVjdXRlZCBvbiB0aGUgcHJvdmlkZWQgYXN5bmNRdWV1ZSBhZnRlciB0aGUgcHJvdmlkZWQgZGVsYXlNcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3luY1F1ZXVlIC0gVGhlIHF1ZXVlIHRvIHNjaGVkdWxlIHRoZSBvcGVyYXRpb24gb24uXG4gICAgICogQHBhcmFtIGlkIC0gQSBUaW1lciBJRCBpZGVudGlmeWluZyB0aGUgdHlwZSBvZiBvcGVyYXRpb24gdGhpcyBpcy5cbiAgICAgKiBAcGFyYW0gZGVsYXlNcyAtIFRoZSBkZWxheSAobXMpIGJlZm9yZSB0aGUgb3BlcmF0aW9uIHNob3VsZCBiZSBzY2hlZHVsZWQuXG4gICAgICogQHBhcmFtIG9wIC0gVGhlIG9wZXJhdGlvbiB0byBydW4uXG4gICAgICogQHBhcmFtIHJlbW92YWxDYWxsYmFjayAtIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkgb25jZSB0aGVcbiAgICAgKiAgIG9wZXJhdGlvbiBpcyBleGVjdXRlZCBvciBjYW5jZWxlZCwgbm90aWZ5aW5nIHRoZSBBc3luY1F1ZXVlIHRvIHJlbW92ZSBpdFxuICAgICAqICAgZnJvbSBpdHMgZGVsYXllZE9wZXJhdGlvbnMgbGlzdC5cbiAgICAgKiAgIFBPUlRJTkcgTk9URTogVGhpcyBleGlzdHMgdG8gcHJldmVudCBtYWtpbmcgcmVtb3ZlRGVsYXllZE9wZXJhdGlvbigpIGFuZFxuICAgICAqICAgdGhlIERlbGF5ZWRPcGVyYXRpb24gY2xhc3MgcHVibGljLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVBbmRTY2hlZHVsZShhc3luY1F1ZXVlLCB0aW1lcklkLCBkZWxheU1zLCBvcCwgcmVtb3ZhbENhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBEYXRlLm5vdygpICsgZGVsYXlNcztcbiAgICAgICAgY29uc3QgZGVsYXllZE9wID0gbmV3IERlbGF5ZWRPcGVyYXRpb24oYXN5bmNRdWV1ZSwgdGltZXJJZCwgdGFyZ2V0VGltZSwgb3AsIHJlbW92YWxDYWxsYmFjayk7XG4gICAgICAgIGRlbGF5ZWRPcC5zdGFydChkZWxheU1zKTtcbiAgICAgICAgcmV0dXJuIGRlbGF5ZWRPcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSB0aW1lci4gVGhpcyBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgY29uc3RydWN0aW9uIGJ5XG4gICAgICogY3JlYXRlQW5kU2NoZWR1bGUoKS5cbiAgICAgKi9cbiAgICBzdGFydChkZWxheU1zKSB7XG4gICAgICAgIHRoaXMudGltZXJIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGFuZGxlRGVsYXlFbGFwc2VkKCksIGRlbGF5TXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWV1ZXMgdGhlIG9wZXJhdGlvbiB0byBydW4gaW1tZWRpYXRlbHkgKGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gcnVuIG9yXG4gICAgICogY2FuY2VsZWQpLlxuICAgICAqL1xuICAgIHNraXBEZWxheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRGVsYXlFbGFwc2VkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgdGhlIG9wZXJhdGlvbiBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIGV4ZWN1dGVkIG9yIGNhbmNlbGVkLiBUaGVcbiAgICAgKiBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQuXG4gICAgICpcbiAgICAgKiBBcyBsb25nIGFzIHRoZSBvcGVyYXRpb24gaGFzIG5vdCB5ZXQgYmVlbiBydW4sIGNhbGxpbmcgY2FuY2VsKCkgcHJvdmlkZXMgYVxuICAgICAqIGd1YXJhbnRlZSB0aGF0IHRoZSBvcGVyYXRpb24gd2lsbCBub3QgYmUgcnVuLlxuICAgICAqL1xuICAgIGNhbmNlbChyZWFzb24pIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXJIYW5kbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5DQU5DRUxMRUQsICdPcGVyYXRpb24gY2FuY2VsbGVkJyArIChyZWFzb24gPyAnOiAnICsgcmVhc29uIDogJycpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRGVsYXlFbGFwc2VkKCkge1xuICAgICAgICB0aGlzLmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lckhhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3AoKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsZWFyVGltZW91dCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXJIYW5kbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZhbENhbGxiYWNrKHRoaXMpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJIYW5kbGUpO1xuICAgICAgICAgICAgdGhpcy50aW1lckhhbmRsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgYSBGaXJlc3RvcmVFcnJvciB0aGF0IGNhbiBiZSBzdXJmYWNlZCB0byB0aGUgdXNlciBpZiB0aGUgcHJvdmlkZWRcbiAqIGVycm9yIGlzIGFuIEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IuIFJlLXRocm93cyB0aGUgZXJyb3Igb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiB3cmFwSW5Vc2VyRXJyb3JJZlJlY292ZXJhYmxlKGUsIG1zZykge1xuICAgIGxvZ0Vycm9yKExPR19UQUckNCwgYCR7bXNnfTogJHtlfWApO1xuICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOQVZBSUxBQkxFLCBgJHttc2d9OiAke2V9YCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRG9jdW1lbnRTZXQgaXMgYW4gaW1tdXRhYmxlIChjb3B5LW9uLXdyaXRlKSBjb2xsZWN0aW9uIHRoYXQgaG9sZHMgZG9jdW1lbnRzXG4gKiBpbiBvcmRlciBzcGVjaWZpZWQgYnkgdGhlIHByb3ZpZGVkIGNvbXBhcmF0b3IuIFdlIGFsd2F5cyBhZGQgYSBkb2N1bWVudCBrZXlcbiAqIGNvbXBhcmF0b3Igb24gdG9wIG9mIHdoYXQgaXMgcHJvdmlkZWQgdG8gZ3VhcmFudGVlIGRvY3VtZW50IGVxdWFsaXR5IGJhc2VkIG9uXG4gKiB0aGUga2V5LlxuICovXG5jbGFzcyBEb2N1bWVudFNldCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBlbXB0eSBjb3B5IG9mIHRoZSBleGlzdGluZyBEb2N1bWVudFNldCwgdXNpbmcgdGhlIHNhbWVcbiAgICAgKiBjb21wYXJhdG9yLlxuICAgICAqL1xuICAgIHN0YXRpYyBlbXB0eVNldChvbGRTZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFNldChvbGRTZXQuY29tcGFyYXRvcik7XG4gICAgfVxuICAgIC8qKiBUaGUgZGVmYXVsdCBvcmRlcmluZyBpcyBieSBrZXkgaWYgdGhlIGNvbXBhcmF0b3IgaXMgb21pdHRlZCAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbXApIHtcbiAgICAgICAgLy8gV2UgYXJlIGFkZGluZyBkb2N1bWVudCBrZXkgY29tcGFyYXRvciB0byB0aGUgZW5kIGFzIGl0J3MgdGhlIG9ubHlcbiAgICAgICAgLy8gZ3VhcmFudGVlZCB1bmlxdWUgcHJvcGVydHkgb2YgYSBkb2N1bWVudC5cbiAgICAgICAgaWYgKGNvbXApIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGFyYXRvciA9IChkMSwgZDIpID0+IGNvbXAoZDEsIGQyKSB8fCBEb2N1bWVudEtleS5jb21wYXJhdG9yKGQxLmtleSwgZDIua2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGFyYXRvciA9IChkMSwgZDIpID0+IERvY3VtZW50S2V5LmNvbXBhcmF0b3IoZDEua2V5LCBkMi5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2V5ZWRNYXAgPSBkb2N1bWVudE1hcCgpO1xuICAgICAgICB0aGlzLnNvcnRlZFNldCA9IG5ldyBTb3J0ZWRNYXAodGhpcy5jb21wYXJhdG9yKTtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXllZE1hcC5nZXQoa2V5KSAhPSBudWxsO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleWVkTWFwLmdldChrZXkpO1xuICAgIH1cbiAgICBmaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydGVkU2V0Lm1pbktleSgpO1xuICAgIH1cbiAgICBsYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRTZXQubWF4S2V5KCk7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvcnRlZFNldC5pc0VtcHR5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBwcm92aWRlZCBrZXkgaW4gdGhlIGRvY3VtZW50IHNldCwgb3IgLTEgaWYgdGhlXG4gICAgICogZG9jdW1lbnQga2V5IGlzIG5vdCBwcmVzZW50IGluIHRoZSBzZXQ7XG4gICAgICovXG4gICAgaW5kZXhPZihrZXkpIHtcbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy5rZXllZE1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRvYyA/IHRoaXMuc29ydGVkU2V0LmluZGV4T2YoZG9jKSA6IC0xO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydGVkU2V0LnNpemU7XG4gICAgfVxuICAgIC8qKiBJdGVyYXRlcyBkb2N1bWVudHMgaW4gb3JkZXIgZGVmaW5lZCBieSBcImNvbXBhcmF0b3JcIiAqL1xuICAgIGZvckVhY2goY2IpIHtcbiAgICAgICAgdGhpcy5zb3J0ZWRTZXQuaW5vcmRlclRyYXZlcnNhbCgoaywgdikgPT4ge1xuICAgICAgICAgICAgY2Ioayk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogSW5zZXJ0cyBvciB1cGRhdGVzIGEgZG9jdW1lbnQgd2l0aCB0aGUgc2FtZSBrZXkgKi9cbiAgICBhZGQoZG9jKSB7XG4gICAgICAgIC8vIEZpcnN0IHJlbW92ZSB0aGUgZWxlbWVudCBpZiB3ZSBoYXZlIGl0LlxuICAgICAgICBjb25zdCBzZXQgPSB0aGlzLmRlbGV0ZShkb2Mua2V5KTtcbiAgICAgICAgcmV0dXJuIHNldC5jb3B5KHNldC5rZXllZE1hcC5pbnNlcnQoZG9jLmtleSwgZG9jKSwgc2V0LnNvcnRlZFNldC5pbnNlcnQoZG9jLCBudWxsKSk7XG4gICAgfVxuICAgIC8qKiBEZWxldGVzIGEgZG9jdW1lbnQgd2l0aCBhIGdpdmVuIGtleSAqL1xuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFkb2MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkodGhpcy5rZXllZE1hcC5yZW1vdmUoa2V5KSwgdGhpcy5zb3J0ZWRTZXQucmVtb3ZlKGRvYykpO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgRG9jdW1lbnRTZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2l6ZSAhPT0gb3RoZXIuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRoaXNJdCA9IHRoaXMuc29ydGVkU2V0LmdldEl0ZXJhdG9yKCk7XG4gICAgICAgIGNvbnN0IG90aGVySXQgPSBvdGhlci5zb3J0ZWRTZXQuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgd2hpbGUgKHRoaXNJdC5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRoaXNEb2MgPSB0aGlzSXQuZ2V0TmV4dCgpLmtleTtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyRG9jID0gb3RoZXJJdC5nZXROZXh0KCkua2V5O1xuICAgICAgICAgICAgaWYgKCF0aGlzRG9jLmlzRXF1YWwob3RoZXJEb2MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgZG9jU3RyaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goZG9jID0+IHtcbiAgICAgICAgICAgIGRvY1N0cmluZ3MucHVzaChkb2MudG9TdHJpbmcoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZG9jU3RyaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnRG9jdW1lbnRTZXQgKCknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdEb2N1bWVudFNldCAoXFxuICAnICsgZG9jU3RyaW5ncy5qb2luKCcgIFxcbicpICsgJ1xcbiknO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvcHkoa2V5ZWRNYXAsIHNvcnRlZFNldCkge1xuICAgICAgICBjb25zdCBuZXdTZXQgPSBuZXcgRG9jdW1lbnRTZXQoKTtcbiAgICAgICAgbmV3U2V0LmNvbXBhcmF0b3IgPSB0aGlzLmNvbXBhcmF0b3I7XG4gICAgICAgIG5ld1NldC5rZXllZE1hcCA9IGtleWVkTWFwO1xuICAgICAgICBuZXdTZXQuc29ydGVkU2V0ID0gc29ydGVkU2V0O1xuICAgICAgICByZXR1cm4gbmV3U2V0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRG9jdW1lbnRDaGFuZ2VTZXQga2VlcHMgdHJhY2sgb2YgYSBzZXQgb2YgY2hhbmdlcyB0byBkb2NzIGluIGEgcXVlcnksIG1lcmdpbmdcbiAqIGR1cGxpY2F0ZSBldmVudHMgZm9yIHRoZSBzYW1lIGRvYy5cbiAqL1xuY2xhc3MgRG9jdW1lbnRDaGFuZ2VTZXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XG4gICAgfVxuICAgIHRyYWNrKGNoYW5nZSkge1xuICAgICAgICBjb25zdCBrZXkgPSBjaGFuZ2UuZG9jLmtleTtcbiAgICAgICAgY29uc3Qgb2xkQ2hhbmdlID0gdGhpcy5jaGFuZ2VNYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghb2xkQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIGNoYW5nZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWVyZ2UgdGhlIG5ldyBjaGFuZ2Ugd2l0aCB0aGUgZXhpc3RpbmcgY2hhbmdlLlxuICAgICAgICBpZiAoY2hhbmdlLnR5cGUgIT09IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLyAmJlxuICAgICAgICAgICAgb2xkQ2hhbmdlLnR5cGUgPT09IDMgLyogQ2hhbmdlVHlwZS5NZXRhZGF0YSAqLykge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSB0aGlzLmNoYW5nZU1hcC5pbnNlcnQoa2V5LCBjaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAzIC8qIENoYW5nZVR5cGUuTWV0YWRhdGEgKi8gJiZcbiAgICAgICAgICAgIG9sZENoYW5nZS50eXBlICE9PSAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLykge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSB0aGlzLmNoYW5nZU1hcC5pbnNlcnQoa2V5LCB7XG4gICAgICAgICAgICAgICAgdHlwZTogb2xkQ2hhbmdlLnR5cGUsXG4gICAgICAgICAgICAgICAgZG9jOiBjaGFuZ2UuZG9jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovICYmXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAyIC8qIENoYW5nZVR5cGUuTW9kaWZpZWQgKi8sXG4gICAgICAgICAgICAgICAgZG9jOiBjaGFuZ2UuZG9jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovICYmXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi8sXG4gICAgICAgICAgICAgICAgZG9jOiBjaGFuZ2UuZG9jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8gJiZcbiAgICAgICAgICAgIG9sZENoYW5nZS50eXBlID09PSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwID0gdGhpcy5jaGFuZ2VNYXAucmVtb3ZlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovICYmXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLyxcbiAgICAgICAgICAgICAgICBkb2M6IG9sZENoYW5nZS5kb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi8gJiZcbiAgICAgICAgICAgIG9sZENoYW5nZS50eXBlID09PSAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLykge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSB0aGlzLmNoYW5nZU1hcC5pbnNlcnQoa2V5LCB7XG4gICAgICAgICAgICAgICAgdHlwZTogMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovLFxuICAgICAgICAgICAgICAgIGRvYzogY2hhbmdlLmRvY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGluY2x1ZGVzIHRoZXNlIGNhc2VzLCB3aGljaCBkb24ndCBtYWtlIHNlbnNlOlxuICAgICAgICAgICAgLy8gQWRkZWQtPkFkZGVkXG4gICAgICAgICAgICAvLyBSZW1vdmVkLT5SZW1vdmVkXG4gICAgICAgICAgICAvLyBNb2RpZmllZC0+QWRkZWRcbiAgICAgICAgICAgIC8vIFJlbW92ZWQtPk1vZGlmaWVkXG4gICAgICAgICAgICAvLyBNZXRhZGF0YS0+QWRkZWRcbiAgICAgICAgICAgIC8vIFJlbW92ZWQtPk1ldGFkYXRhXG4gICAgICAgICAgICBmYWlsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2hhbmdlcygpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoYW5nZU1hcC5pbm9yZGVyVHJhdmVyc2FsKChrZXksIGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9XG59XG5jbGFzcyBWaWV3U25hcHNob3Qge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBkb2NzLCBvbGREb2NzLCBkb2NDaGFuZ2VzLCBtdXRhdGVkS2V5cywgZnJvbUNhY2hlLCBzeW5jU3RhdGVDaGFuZ2VkLCBleGNsdWRlc01ldGFkYXRhQ2hhbmdlcywgaGFzQ2FjaGVkUmVzdWx0cykge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuZG9jcyA9IGRvY3M7XG4gICAgICAgIHRoaXMub2xkRG9jcyA9IG9sZERvY3M7XG4gICAgICAgIHRoaXMuZG9jQ2hhbmdlcyA9IGRvY0NoYW5nZXM7XG4gICAgICAgIHRoaXMubXV0YXRlZEtleXMgPSBtdXRhdGVkS2V5cztcbiAgICAgICAgdGhpcy5mcm9tQ2FjaGUgPSBmcm9tQ2FjaGU7XG4gICAgICAgIHRoaXMuc3luY1N0YXRlQ2hhbmdlZCA9IHN5bmNTdGF0ZUNoYW5nZWQ7XG4gICAgICAgIHRoaXMuZXhjbHVkZXNNZXRhZGF0YUNoYW5nZXMgPSBleGNsdWRlc01ldGFkYXRhQ2hhbmdlcztcbiAgICAgICAgdGhpcy5oYXNDYWNoZWRSZXN1bHRzID0gaGFzQ2FjaGVkUmVzdWx0cztcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSB2aWV3IHNuYXBzaG90IGFzIGlmIGFsbCBkb2N1bWVudHMgaW4gdGhlIHNuYXBzaG90IHdlcmUgYWRkZWQuICovXG4gICAgc3RhdGljIGZyb21Jbml0aWFsRG9jdW1lbnRzKHF1ZXJ5LCBkb2N1bWVudHMsIG11dGF0ZWRLZXlzLCBmcm9tQ2FjaGUsIGhhc0NhY2hlZFJlc3VsdHMpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgICAgICBkb2N1bWVudHMuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgdHlwZTogMCAvKiBDaGFuZ2VUeXBlLkFkZGVkICovLCBkb2MgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdTbmFwc2hvdChxdWVyeSwgZG9jdW1lbnRzLCBEb2N1bWVudFNldC5lbXB0eVNldChkb2N1bWVudHMpLCBjaGFuZ2VzLCBtdXRhdGVkS2V5cywgZnJvbUNhY2hlLCBcbiAgICAgICAgLyogc3luY1N0YXRlQ2hhbmdlZD0gKi8gdHJ1ZSwgXG4gICAgICAgIC8qIGV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzPSAqLyBmYWxzZSwgaGFzQ2FjaGVkUmVzdWx0cyk7XG4gICAgfVxuICAgIGdldCBoYXNQZW5kaW5nV3JpdGVzKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMubXV0YXRlZEtleXMuaXNFbXB0eSgpO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmZyb21DYWNoZSAhPT0gb3RoZXIuZnJvbUNhY2hlIHx8XG4gICAgICAgICAgICB0aGlzLmhhc0NhY2hlZFJlc3VsdHMgIT09IG90aGVyLmhhc0NhY2hlZFJlc3VsdHMgfHxcbiAgICAgICAgICAgIHRoaXMuc3luY1N0YXRlQ2hhbmdlZCAhPT0gb3RoZXIuc3luY1N0YXRlQ2hhbmdlZCB8fFxuICAgICAgICAgICAgIXRoaXMubXV0YXRlZEtleXMuaXNFcXVhbChvdGhlci5tdXRhdGVkS2V5cykgfHxcbiAgICAgICAgICAgICFxdWVyeUVxdWFscyh0aGlzLnF1ZXJ5LCBvdGhlci5xdWVyeSkgfHxcbiAgICAgICAgICAgICF0aGlzLmRvY3MuaXNFcXVhbChvdGhlci5kb2NzKSB8fFxuICAgICAgICAgICAgIXRoaXMub2xkRG9jcy5pc0VxdWFsKG90aGVyLm9sZERvY3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuZG9jQ2hhbmdlcztcbiAgICAgICAgY29uc3Qgb3RoZXJDaGFuZ2VzID0gb3RoZXIuZG9jQ2hhbmdlcztcbiAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoICE9PSBvdGhlckNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlc1tpXS50eXBlICE9PSBvdGhlckNoYW5nZXNbaV0udHlwZSB8fFxuICAgICAgICAgICAgICAgICFjaGFuZ2VzW2ldLmRvYy5pc0VxdWFsKG90aGVyQ2hhbmdlc1tpXS5kb2MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogSG9sZHMgdGhlIGxpc3RlbmVycyBhbmQgdGhlIGxhc3QgcmVjZWl2ZWQgVmlld1NuYXBzaG90IGZvciBhIHF1ZXJ5IGJlaW5nXG4gKiB0cmFja2VkIGJ5IEV2ZW50TWFuYWdlci5cbiAqL1xuY2xhc3MgUXVlcnlMaXN0ZW5lcnNJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3U25hcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgLy8gSGVscGVyIG1ldGhvZHMgdGhhdCBjaGVja3MgaWYgdGhlIHF1ZXJ5IGhhcyBsaXN0ZW5lcnMgdGhhdCBsaXN0ZW5pbmcgdG8gcmVtb3RlIHN0b3JlXG4gICAgaGFzUmVtb3RlTGlzdGVuZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMuc29tZShsaXN0ZW5lciA9PiBsaXN0ZW5lci5saXN0ZW5zVG9SZW1vdGVTdG9yZSgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdFdmVudE1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBFdmVudE1hbmFnZXJJbXBsKCk7XG59XG5jbGFzcyBFdmVudE1hbmFnZXJJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5xdWVyaWVzID0gbmV3UXVlcmllc09iamVjdE1hcCgpO1xuICAgICAgICB0aGlzLm9ubGluZVN0YXRlID0gXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLztcbiAgICAgICAgdGhpcy5zbmFwc2hvdHNJblN5bmNMaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgZXJyb3JBbGxUYXJnZXRzKHRoaXMsIG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkFCT1JURUQsICdGaXJlc3RvcmUgc2h1dHRpbmcgZG93bicpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdRdWVyaWVzT2JqZWN0TWFwKCkge1xuICAgIHJldHVybiBuZXcgT2JqZWN0TWFwKHEgPT4gY2Fub25pZnlRdWVyeShxKSwgcXVlcnlFcXVhbHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gZXZlbnRNYW5hZ2VyTGlzdGVuKGV2ZW50TWFuYWdlciwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XG4gICAgbGV0IGxpc3RlbmVyQWN0aW9uID0gMyAvKiBMaXN0ZW5lclNldHVwQWN0aW9uLk5vQWN0aW9uUmVxdWlyZWQgKi87XG4gICAgY29uc3QgcXVlcnkgPSBsaXN0ZW5lci5xdWVyeTtcbiAgICBsZXQgcXVlcnlJbmZvID0gZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmdldChxdWVyeSk7XG4gICAgaWYgKCFxdWVyeUluZm8pIHtcbiAgICAgICAgcXVlcnlJbmZvID0gbmV3IFF1ZXJ5TGlzdGVuZXJzSW5mbygpO1xuICAgICAgICBsaXN0ZW5lckFjdGlvbiA9IGxpc3RlbmVyLmxpc3RlbnNUb1JlbW90ZVN0b3JlKClcbiAgICAgICAgICAgID8gMCAvKiBMaXN0ZW5lclNldHVwQWN0aW9uLkluaXRpYWxpemVMb2NhbExpc3RlbkFuZFJlcXVpcmVXYXRjaENvbm5lY3Rpb24gKi9cbiAgICAgICAgICAgIDogMSAvKiBMaXN0ZW5lclNldHVwQWN0aW9uLkluaXRpYWxpemVMb2NhbExpc3Rlbk9ubHkgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCFxdWVyeUluZm8uaGFzUmVtb3RlTGlzdGVuZXJzKCkgJiZcbiAgICAgICAgbGlzdGVuZXIubGlzdGVuc1RvUmVtb3RlU3RvcmUoKSkge1xuICAgICAgICAvLyBRdWVyeSBoYXMgYmVlbiBsaXN0ZW5pbmcgdG8gbG9jYWwgY2FjaGUsIGFuZCB0cmllcyB0byBhZGQgYSBuZXcgbGlzdGVuZXIgc291cmNlZCBmcm9tIHdhdGNoLlxuICAgICAgICBsaXN0ZW5lckFjdGlvbiA9IDIgLyogTGlzdGVuZXJTZXR1cEFjdGlvbi5SZXF1aXJlV2F0Y2hDb25uZWN0aW9uT25seSAqLztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgc3dpdGNoIChsaXN0ZW5lckFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAwIC8qIExpc3RlbmVyU2V0dXBBY3Rpb24uSW5pdGlhbGl6ZUxvY2FsTGlzdGVuQW5kUmVxdWlyZVdhdGNoQ29ubmVjdGlvbiAqLzpcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8udmlld1NuYXAgPSBhd2FpdCBldmVudE1hbmFnZXJJbXBsLm9uTGlzdGVuKHF1ZXJ5LCBcbiAgICAgICAgICAgICAgICAvKiogZW5hYmxlUmVtb3RlTGlzdGVuPSAqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMSAvKiBMaXN0ZW5lclNldHVwQWN0aW9uLkluaXRpYWxpemVMb2NhbExpc3Rlbk9ubHkgKi86XG4gICAgICAgICAgICAgICAgcXVlcnlJbmZvLnZpZXdTbmFwID0gYXdhaXQgZXZlbnRNYW5hZ2VySW1wbC5vbkxpc3RlbihxdWVyeSwgXG4gICAgICAgICAgICAgICAgLyoqIGVuYWJsZVJlbW90ZUxpc3Rlbj0gKi8gZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIExpc3RlbmVyU2V0dXBBY3Rpb24uUmVxdWlyZVdhdGNoQ29ubmVjdGlvbk9ubHkgKi86XG4gICAgICAgICAgICAgICAgYXdhaXQgZXZlbnRNYW5hZ2VySW1wbC5vbkZpcnN0UmVtb3RlU3RvcmVMaXN0ZW4ocXVlcnkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBmaXJlc3RvcmVFcnJvciA9IHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgYEluaXRpYWxpemF0aW9uIG9mIHF1ZXJ5ICcke3N0cmluZ2lmeVF1ZXJ5KGxpc3RlbmVyLnF1ZXJ5KX0nIGZhaWxlZGApO1xuICAgICAgICBsaXN0ZW5lci5vbkVycm9yKGZpcmVzdG9yZUVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuc2V0KHF1ZXJ5LCBxdWVyeUluZm8pO1xuICAgIHF1ZXJ5SW5mby5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgLy8gUnVuIGdsb2JhbCBzbmFwc2hvdCBsaXN0ZW5lcnMgaWYgYSBjb25zaXN0ZW50IHNuYXBzaG90IGhhcyBiZWVuIGVtaXR0ZWQuXG4gICAgbGlzdGVuZXIuYXBwbHlPbmxpbmVTdGF0ZUNoYW5nZShldmVudE1hbmFnZXJJbXBsLm9ubGluZVN0YXRlKTtcbiAgICBpZiAocXVlcnlJbmZvLnZpZXdTbmFwKSB7XG4gICAgICAgIGNvbnN0IHJhaXNlZEV2ZW50ID0gbGlzdGVuZXIub25WaWV3U25hcHNob3QocXVlcnlJbmZvLnZpZXdTbmFwKTtcbiAgICAgICAgaWYgKHJhaXNlZEV2ZW50KSB7XG4gICAgICAgICAgICByYWlzZVNuYXBzaG90c0luU3luY0V2ZW50KGV2ZW50TWFuYWdlckltcGwpO1xuICAgICAgICB9XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZXZlbnRNYW5hZ2VyVW5saXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGV2ZW50TWFuYWdlckltcGwgPSBkZWJ1Z0Nhc3QoZXZlbnRNYW5hZ2VyKTtcbiAgICBjb25zdCBxdWVyeSA9IGxpc3RlbmVyLnF1ZXJ5O1xuICAgIGxldCBsaXN0ZW5lckFjdGlvbiA9IDMgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLk5vQWN0aW9uUmVxdWlyZWQgKi87XG4gICAgY29uc3QgcXVlcnlJbmZvID0gZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmdldChxdWVyeSk7XG4gICAgaWYgKHF1ZXJ5SW5mbykge1xuICAgICAgICBjb25zdCBpID0gcXVlcnlJbmZvLmxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgcXVlcnlJbmZvLmxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpZiAocXVlcnlJbmZvLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lckFjdGlvbiA9IGxpc3RlbmVyLmxpc3RlbnNUb1JlbW90ZVN0b3JlKClcbiAgICAgICAgICAgICAgICAgICAgPyAwIC8qIExpc3RlbmVyUmVtb3ZhbEFjdGlvbi5UZXJtaW5hdGVMb2NhbExpc3RlbkFuZFJlcXVpcmVXYXRjaERpc2Nvbm5lY3Rpb24gKi9cbiAgICAgICAgICAgICAgICAgICAgOiAxIC8qIExpc3RlbmVyUmVtb3ZhbEFjdGlvbi5UZXJtaW5hdGVMb2NhbExpc3Rlbk9ubHkgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghcXVlcnlJbmZvLmhhc1JlbW90ZUxpc3RlbmVycygpICYmXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuc1RvUmVtb3RlU3RvcmUoKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSByZW1vdmVkIGxpc3RlbmVyIGlzIHRoZSBsYXN0IG9uZSB0aGF0IHNvdXJjZWQgZnJvbSB3YXRjaC5cbiAgICAgICAgICAgICAgICBsaXN0ZW5lckFjdGlvbiA9IDIgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLlJlcXVpcmVXYXRjaERpc2Nvbm5lY3Rpb25Pbmx5ICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAobGlzdGVuZXJBY3Rpb24pIHtcbiAgICAgICAgY2FzZSAwIC8qIExpc3RlbmVyUmVtb3ZhbEFjdGlvbi5UZXJtaW5hdGVMb2NhbExpc3RlbkFuZFJlcXVpcmVXYXRjaERpc2Nvbm5lY3Rpb24gKi86XG4gICAgICAgICAgICBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuZGVsZXRlKHF1ZXJ5KTtcbiAgICAgICAgICAgIHJldHVybiBldmVudE1hbmFnZXJJbXBsLm9uVW5saXN0ZW4ocXVlcnksIFxuICAgICAgICAgICAgLyoqIGRpc2FibGVSZW1vdGVMaXN0ZW49ICovIHRydWUpO1xuICAgICAgICBjYXNlIDEgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLlRlcm1pbmF0ZUxvY2FsTGlzdGVuT25seSAqLzpcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5kZWxldGUocXVlcnkpO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TWFuYWdlckltcGwub25Vbmxpc3RlbihxdWVyeSwgXG4gICAgICAgICAgICAvKiogZGlzYWJsZVJlbW90ZUxpc3Rlbj0gKi8gZmFsc2UpO1xuICAgICAgICBjYXNlIDIgLyogTGlzdGVuZXJSZW1vdmFsQWN0aW9uLlJlcXVpcmVXYXRjaERpc2Nvbm5lY3Rpb25Pbmx5ICovOlxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TWFuYWdlckltcGwub25MYXN0UmVtb3RlU3RvcmVVbmxpc3RlbihxdWVyeSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgfVxufVxuZnVuY3Rpb24gZXZlbnRNYW5hZ2VyT25XYXRjaENoYW5nZShldmVudE1hbmFnZXIsIHZpZXdTbmFwcykge1xuICAgIGNvbnN0IGV2ZW50TWFuYWdlckltcGwgPSBkZWJ1Z0Nhc3QoZXZlbnRNYW5hZ2VyKTtcbiAgICBsZXQgcmFpc2VkRXZlbnQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHZpZXdTbmFwIG9mIHZpZXdTbmFwcykge1xuICAgICAgICBjb25zdCBxdWVyeSA9IHZpZXdTbmFwLnF1ZXJ5O1xuICAgICAgICBjb25zdCBxdWVyeUluZm8gPSBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuZ2V0KHF1ZXJ5KTtcbiAgICAgICAgaWYgKHF1ZXJ5SW5mbykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBxdWVyeUluZm8ubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm9uVmlld1NuYXBzaG90KHZpZXdTbmFwKSkge1xuICAgICAgICAgICAgICAgICAgICByYWlzZWRFdmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVlcnlJbmZvLnZpZXdTbmFwID0gdmlld1NuYXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJhaXNlZEV2ZW50KSB7XG4gICAgICAgIHJhaXNlU25hcHNob3RzSW5TeW5jRXZlbnQoZXZlbnRNYW5hZ2VySW1wbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXZlbnRNYW5hZ2VyT25XYXRjaEVycm9yKGV2ZW50TWFuYWdlciwgcXVlcnksIGVycm9yKSB7XG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xuICAgIGNvbnN0IHF1ZXJ5SW5mbyA9IGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5nZXQocXVlcnkpO1xuICAgIGlmIChxdWVyeUluZm8pIHtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBxdWVyeUluZm8ubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycy4gTk9URTogV2UgZG9uJ3QgbmVlZCB0byBjYWxsIHN5bmNFbmdpbmUudW5saXN0ZW4oKVxuICAgIC8vIGFmdGVyIGFuIGVycm9yLlxuICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5kZWxldGUocXVlcnkpO1xufVxuZnVuY3Rpb24gZXZlbnRNYW5hZ2VyT25PbmxpbmVTdGF0ZUNoYW5nZShldmVudE1hbmFnZXIsIG9ubGluZVN0YXRlKSB7XG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xuICAgIGV2ZW50TWFuYWdlckltcGwub25saW5lU3RhdGUgPSBvbmxpbmVTdGF0ZTtcbiAgICBsZXQgcmFpc2VkRXZlbnQgPSBmYWxzZTtcbiAgICBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuZm9yRWFjaCgoXywgcXVlcnlJbmZvKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgcXVlcnlJbmZvLmxpc3RlbmVycykge1xuICAgICAgICAgICAgLy8gUnVuIGdsb2JhbCBzbmFwc2hvdCBsaXN0ZW5lcnMgaWYgYSBjb25zaXN0ZW50IHNuYXBzaG90IGhhcyBiZWVuIGVtaXR0ZWQuXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIuYXBwbHlPbmxpbmVTdGF0ZUNoYW5nZShvbmxpbmVTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByYWlzZWRFdmVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocmFpc2VkRXZlbnQpIHtcbiAgICAgICAgcmFpc2VTbmFwc2hvdHNJblN5bmNFdmVudChldmVudE1hbmFnZXJJbXBsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRTbmFwc2hvdHNJblN5bmNMaXN0ZW5lcihldmVudE1hbmFnZXIsIG9ic2VydmVyKSB7XG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xuICAgIGV2ZW50TWFuYWdlckltcGwuc25hcHNob3RzSW5TeW5jTGlzdGVuZXJzLmFkZChvYnNlcnZlcik7XG4gICAgLy8gSW1tZWRpYXRlbHkgZmlyZSBhbiBpbml0aWFsIGV2ZW50LCBpbmRpY2F0aW5nIGFsbCBleGlzdGluZyBsaXN0ZW5lcnNcbiAgICAvLyBhcmUgaW4tc3luYy5cbiAgICBvYnNlcnZlci5uZXh0KCk7XG59XG5mdW5jdGlvbiByZW1vdmVTbmFwc2hvdHNJblN5bmNMaXN0ZW5lcihldmVudE1hbmFnZXIsIG9ic2VydmVyKSB7XG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xuICAgIGV2ZW50TWFuYWdlckltcGwuc25hcHNob3RzSW5TeW5jTGlzdGVuZXJzLmRlbGV0ZShvYnNlcnZlcik7XG59XG5mdW5jdGlvbiBlcnJvckFsbFRhcmdldHMoZXZlbnRNYW5hZ2VyLCBlcnJvcikge1xuICAgIGNvbnN0IGV2ZW50TWFuYWdlckltcGwgPSBkZWJ1Z0Nhc3QoZXZlbnRNYW5hZ2VyKTtcbiAgICBjb25zdCBxdWVyaWVzID0gZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzO1xuICAgIC8vIFByZXZlbnQgZnVydGhlciBhY2Nlc3MgYnkgY2xlYXJpbmcgT2JqZWN0TWFwLlxuICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcyA9IG5ld1F1ZXJpZXNPYmplY3RNYXAoKTtcbiAgICBxdWVyaWVzLmZvckVhY2goKF8sIHF1ZXJ5SW5mbykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHF1ZXJ5SW5mby5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyBDYWxsIGFsbCBnbG9iYWwgc25hcHNob3QgbGlzdGVuZXJzIHRoYXQgaGF2ZSBiZWVuIHNldC5cbmZ1bmN0aW9uIHJhaXNlU25hcHNob3RzSW5TeW5jRXZlbnQoZXZlbnRNYW5hZ2VySW1wbCkge1xuICAgIGV2ZW50TWFuYWdlckltcGwuc25hcHNob3RzSW5TeW5jTGlzdGVuZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4ge1xuICAgICAgICBvYnNlcnZlci5uZXh0KCk7XG4gICAgfSk7XG59XG52YXIgTGlzdGVuZXJEYXRhU291cmNlO1xuKGZ1bmN0aW9uIChMaXN0ZW5lckRhdGFTb3VyY2UpIHtcbiAgICAvKiogTGlzdGVuIHRvIGJvdGggY2FjaGUgYW5kIHNlcnZlciBjaGFuZ2VzICovXG4gICAgTGlzdGVuZXJEYXRhU291cmNlW1wiRGVmYXVsdFwiXSA9IFwiZGVmYXVsdFwiO1xuICAgIC8qKiBMaXN0ZW4gdG8gY2hhbmdlcyBpbiBjYWNoZSBvbmx5ICovXG4gICAgTGlzdGVuZXJEYXRhU291cmNlW1wiQ2FjaGVcIl0gPSBcImNhY2hlXCI7XG59KShMaXN0ZW5lckRhdGFTb3VyY2UgfHwgKExpc3RlbmVyRGF0YVNvdXJjZSA9IHt9KSk7XG4vKipcbiAqIFF1ZXJ5TGlzdGVuZXIgdGFrZXMgYSBzZXJpZXMgb2YgaW50ZXJuYWwgdmlldyBzbmFwc2hvdHMgYW5kIGRldGVybWluZXNcbiAqIHdoZW4gdG8gcmFpc2UgdGhlIGV2ZW50LlxuICpcbiAqIEl0IHVzZXMgYW4gT2JzZXJ2ZXIgdG8gZGlzcGF0Y2ggZXZlbnRzLlxuICovXG5jbGFzcyBRdWVyeUxpc3RlbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihxdWVyeSwgcXVlcnlPYnNlcnZlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMucXVlcnlPYnNlcnZlciA9IHF1ZXJ5T2JzZXJ2ZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsIHNuYXBzaG90cyAoZS5nLiBmcm9tIGNhY2hlKSBtYXkgbm90IGJlIHByb3BhZ2F0ZWQgdG8gdGhlIHdyYXBwZWRcbiAgICAgICAgICogb2JzZXJ2ZXIuIFRoaXMgZmxhZyBpcyBzZXQgdG8gdHJ1ZSBvbmNlIHdlJ3ZlIGFjdHVhbGx5IHJhaXNlZCBhbiBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFpc2VkSW5pdGlhbEV2ZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc25hcCA9IG51bGw7XG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBcIlVua25vd25cIiAvKiBPbmxpbmVTdGF0ZS5Vbmtub3duICovO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBuZXcgVmlld1NuYXBzaG90IHRvIHRoaXMgbGlzdGVuZXIsIHJhaXNpbmcgYSB1c2VyLWZhY2luZyBldmVudFxuICAgICAqIGlmIGFwcGxpY2FibGUgKGRlcGVuZGluZyBvbiB3aGF0IGNoYW5nZWQsIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIGludG9cbiAgICAgKiBtZXRhZGF0YS1vbmx5IGNoYW5nZXMsIGV0Yy4pLiBSZXR1cm5zIHRydWUgaWYgYSB1c2VyLWZhY2luZyBldmVudCB3YXNcbiAgICAgKiBpbmRlZWQgcmFpc2VkLlxuICAgICAqL1xuICAgIG9uVmlld1NuYXBzaG90KHNuYXApIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcykge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBtZXRhZGF0YSBvbmx5IGNoYW5nZXMuXG4gICAgICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRvY0NoYW5nZSBvZiBzbmFwLmRvY0NoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jQ2hhbmdlLnR5cGUgIT09IDMgLyogQ2hhbmdlVHlwZS5NZXRhZGF0YSAqLykge1xuICAgICAgICAgICAgICAgICAgICBkb2NDaGFuZ2VzLnB1c2goZG9jQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzbmFwID0gbmV3IFZpZXdTbmFwc2hvdChzbmFwLnF1ZXJ5LCBzbmFwLmRvY3MsIHNuYXAub2xkRG9jcywgZG9jQ2hhbmdlcywgc25hcC5tdXRhdGVkS2V5cywgc25hcC5mcm9tQ2FjaGUsIHNuYXAuc3luY1N0YXRlQ2hhbmdlZCwgXG4gICAgICAgICAgICAvKiBleGNsdWRlc01ldGFkYXRhQ2hhbmdlcz0gKi8gdHJ1ZSwgc25hcC5oYXNDYWNoZWRSZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFpc2VkRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLnJhaXNlZEluaXRpYWxFdmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkUmFpc2VJbml0aWFsRXZlbnQoc25hcCwgdGhpcy5vbmxpbmVTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhaXNlSW5pdGlhbEV2ZW50KHNuYXApO1xuICAgICAgICAgICAgICAgIHJhaXNlZEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNob3VsZFJhaXNlRXZlbnQoc25hcCkpIHtcbiAgICAgICAgICAgIHRoaXMucXVlcnlPYnNlcnZlci5uZXh0KHNuYXApO1xuICAgICAgICAgICAgcmFpc2VkRXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc25hcCA9IHNuYXA7XG4gICAgICAgIHJldHVybiByYWlzZWRFdmVudDtcbiAgICB9XG4gICAgb25FcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLnF1ZXJ5T2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB3aGV0aGVyIGEgc25hcHNob3Qgd2FzIHJhaXNlZC4gKi9cbiAgICBhcHBseU9ubGluZVN0YXRlQ2hhbmdlKG9ubGluZVN0YXRlKSB7XG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBvbmxpbmVTdGF0ZTtcbiAgICAgICAgbGV0IHJhaXNlZEV2ZW50ID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnNuYXAgJiZcbiAgICAgICAgICAgICF0aGlzLnJhaXNlZEluaXRpYWxFdmVudCAmJlxuICAgICAgICAgICAgdGhpcy5zaG91bGRSYWlzZUluaXRpYWxFdmVudCh0aGlzLnNuYXAsIG9ubGluZVN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZUluaXRpYWxFdmVudCh0aGlzLnNuYXApO1xuICAgICAgICAgICAgcmFpc2VkRXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYWlzZWRFdmVudDtcbiAgICB9XG4gICAgc2hvdWxkUmFpc2VJbml0aWFsRXZlbnQoc25hcCwgb25saW5lU3RhdGUpIHtcbiAgICAgICAgLy8gQWx3YXlzIHJhaXNlIHRoZSBmaXJzdCBldmVudCB3aGVuIHdlJ3JlIHN5bmNlZFxuICAgICAgICBpZiAoIXNuYXAuZnJvbUNhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbHdheXMgcmFpc2UgZXZlbnQgaWYgbGlzdGVuaW5nIHRvIGNhY2hlXG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5zVG9SZW1vdGVTdG9yZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOT1RFOiBXZSBjb25zaWRlciBPbmxpbmVTdGF0ZS5Vbmtub3duIGFzIG9ubGluZSAoaXQgc2hvdWxkIGJlY29tZSBPZmZsaW5lXG4gICAgICAgIC8vIG9yIE9ubGluZSBpZiB3ZSB3YWl0IGxvbmcgZW5vdWdoKS5cbiAgICAgICAgY29uc3QgbWF5YmVPbmxpbmUgPSBvbmxpbmVTdGF0ZSAhPT0gXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLztcbiAgICAgICAgLy8gRG9uJ3QgcmFpc2UgdGhlIGV2ZW50IGlmIHdlJ3JlIG9ubGluZSwgYXJlbid0IHN5bmNlZCB5ZXQgKGNoZWNrZWRcbiAgICAgICAgLy8gYWJvdmUpIGFuZCBhcmUgd2FpdGluZyBmb3IgYSBzeW5jLlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLndhaXRGb3JTeW5jV2hlbk9ubGluZSAmJiBtYXliZU9ubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJhaXNlIGRhdGEgZnJvbSBjYWNoZSBpZiB3ZSBoYXZlIGFueSBkb2N1bWVudHMsIGhhdmUgY2FjaGVkIHJlc3VsdHMgYmVmb3JlLFxuICAgICAgICAvLyBvciB3ZSBhcmUgb2ZmbGluZS5cbiAgICAgICAgcmV0dXJuICghc25hcC5kb2NzLmlzRW1wdHkoKSB8fFxuICAgICAgICAgICAgc25hcC5oYXNDYWNoZWRSZXN1bHRzIHx8XG4gICAgICAgICAgICBvbmxpbmVTdGF0ZSA9PT0gXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLyk7XG4gICAgfVxuICAgIHNob3VsZFJhaXNlRXZlbnQoc25hcCkge1xuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGhhbmRsZSBpbmNsdWRlRG9jdW1lbnRNZXRhZGF0YUNoYW5nZXMgaGVyZSBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBNZXRhZGF0YSBvbmx5IGNoYW5nZXMgaGF2ZSBhbHJlYWR5IGJlZW4gc3RyaXBwZWQgb3V0IGlmIG5lZWRlZC5cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgb25seSBjaGFuZ2VzIHdlIHdpbGwgc2VlIGFyZSB0aGUgb25lcyB3ZSBzaG91bGRcbiAgICAgICAgLy8gcHJvcGFnYXRlLlxuICAgICAgICBpZiAoc25hcC5kb2NDaGFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc1BlbmRpbmdXcml0ZXNDaGFuZ2VkID0gdGhpcy5zbmFwICYmIHRoaXMuc25hcC5oYXNQZW5kaW5nV3JpdGVzICE9PSBzbmFwLmhhc1BlbmRpbmdXcml0ZXM7XG4gICAgICAgIGlmIChzbmFwLnN5bmNTdGF0ZUNoYW5nZWQgfHwgaGFzUGVuZGluZ1dyaXRlc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyA9PT0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZW5lcmFsbHkgd2Ugc2hvdWxkIGhhdmUgaGl0IG9uZSBvZiB0aGUgY2FzZXMgYWJvdmUsIGJ1dCBpdCdzIHBvc3NpYmxlXG4gICAgICAgIC8vIHRvIGdldCBoZXJlIGlmIHRoZXJlIHdlcmUgb25seSBtZXRhZGF0YSBkb2NDaGFuZ2VzIGFuZCB0aGV5IGdvdFxuICAgICAgICAvLyBzdHJpcHBlZCBvdXQuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmFpc2VJbml0aWFsRXZlbnQoc25hcCkge1xuICAgICAgICBzbmFwID0gVmlld1NuYXBzaG90LmZyb21Jbml0aWFsRG9jdW1lbnRzKHNuYXAucXVlcnksIHNuYXAuZG9jcywgc25hcC5tdXRhdGVkS2V5cywgc25hcC5mcm9tQ2FjaGUsIHNuYXAuaGFzQ2FjaGVkUmVzdWx0cyk7XG4gICAgICAgIHRoaXMucmFpc2VkSW5pdGlhbEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5xdWVyeU9ic2VydmVyLm5leHQoc25hcCk7XG4gICAgfVxuICAgIGxpc3RlbnNUb1JlbW90ZVN0b3JlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNvdXJjZSAhPT0gTGlzdGVuZXJEYXRhU291cmNlLkNhY2hlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBzZXQgb2YgY2hhbmdlcyB0byB3aGF0IGRvY3VtZW50cyBhcmUgY3VycmVudGx5IGluIHZpZXcgYW5kIG91dCBvZiB2aWV3IGZvclxuICogYSBnaXZlbiBxdWVyeS4gVGhlc2UgY2hhbmdlcyBhcmUgc2VudCB0byB0aGUgTG9jYWxTdG9yZSBieSB0aGUgVmlldyAodmlhXG4gKiB0aGUgU3luY0VuZ2luZSkgYW5kIGFyZSB1c2VkIHRvIHBpbiAvIHVucGluIGRvY3VtZW50cyBhcyBhcHByb3ByaWF0ZS5cbiAqL1xuY2xhc3MgTG9jYWxWaWV3Q2hhbmdlcyB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0SWQsIGZyb21DYWNoZSwgYWRkZWRLZXlzLCByZW1vdmVkS2V5cykge1xuICAgICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XG4gICAgICAgIHRoaXMuZnJvbUNhY2hlID0gZnJvbUNhY2hlO1xuICAgICAgICB0aGlzLmFkZGVkS2V5cyA9IGFkZGVkS2V5cztcbiAgICAgICAgdGhpcy5yZW1vdmVkS2V5cyA9IHJlbW92ZWRLZXlzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVNuYXBzaG90KHRhcmdldElkLCB2aWV3U25hcHNob3QpIHtcbiAgICAgICAgbGV0IGFkZGVkS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIGxldCByZW1vdmVkS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgZG9jQ2hhbmdlIG9mIHZpZXdTbmFwc2hvdC5kb2NDaGFuZ2VzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGRvY0NoYW5nZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi86XG4gICAgICAgICAgICAgICAgICAgIGFkZGVkS2V5cyA9IGFkZGVkS2V5cy5hZGQoZG9jQ2hhbmdlLmRvYy5rZXkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovOlxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkS2V5cyA9IHJlbW92ZWRLZXlzLmFkZChkb2NDaGFuZ2UuZG9jLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExvY2FsVmlld0NoYW5nZXModGFyZ2V0SWQsIHZpZXdTbmFwc2hvdC5mcm9tQ2FjaGUsIGFkZGVkS2V5cywgcmVtb3ZlZEtleXMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogSGVscGVyIHRvIGNvbnZlcnQgb2JqZWN0cyBmcm9tIGJ1bmRsZXMgdG8gbW9kZWwgb2JqZWN0cyBpbiB0aGUgU0RLLlxuICovXG5jbGFzcyBCdW5kbGVDb252ZXJ0ZXJJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyKSB7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgfVxuICAgIHRvRG9jdW1lbnRLZXkobmFtZSkge1xuICAgICAgICByZXR1cm4gZnJvbU5hbWUodGhpcy5zZXJpYWxpemVyLCBuYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBCdW5kbGVEb2N1bWVudCB0byBhIE11dGFibGVEb2N1bWVudC5cbiAgICAgKi9cbiAgICB0b011dGFibGVEb2N1bWVudChidW5kbGVkRG9jKSB7XG4gICAgICAgIGlmIChidW5kbGVkRG9jLm1ldGFkYXRhLmV4aXN0cykge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21Eb2N1bWVudCh0aGlzLnNlcmlhbGl6ZXIsIGJ1bmRsZWREb2MuZG9jdW1lbnQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudCh0aGlzLnRvRG9jdW1lbnRLZXkoYnVuZGxlZERvYy5tZXRhZGF0YS5uYW1lKSwgdGhpcy50b1NuYXBzaG90VmVyc2lvbihidW5kbGVkRG9jLm1ldGFkYXRhLnJlYWRUaW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TbmFwc2hvdFZlcnNpb24odGltZSkge1xuICAgICAgICByZXR1cm4gZnJvbVZlcnNpb24odGltZSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGNsYXNzIHRvIHByb2Nlc3MgdGhlIGVsZW1lbnRzIGZyb20gYSBidW5kbGUsIGxvYWQgdGhlbSBpbnRvIGxvY2FsXG4gKiBzdG9yYWdlIGFuZCBwcm92aWRlIHByb2dyZXNzIHVwZGF0ZSB3aGlsZSBsb2FkaW5nLlxuICovXG5jbGFzcyBCdW5kbGVMb2FkZXIge1xuICAgIGNvbnN0cnVjdG9yKGJ1bmRsZU1ldGFkYXRhLCBsb2NhbFN0b3JlLCBzZXJpYWxpemVyKSB7XG4gICAgICAgIHRoaXMuYnVuZGxlTWV0YWRhdGEgPSBidW5kbGVNZXRhZGF0YTtcbiAgICAgICAgdGhpcy5sb2NhbFN0b3JlID0gbG9jYWxTdG9yZTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICAgICAgLyoqIEJhdGNoZWQgcXVlcmllcyB0byBiZSBzYXZlZCBpbnRvIHN0b3JhZ2UgKi9cbiAgICAgICAgdGhpcy5xdWVyaWVzID0gW107XG4gICAgICAgIC8qKiBCYXRjaGVkIGRvY3VtZW50cyB0byBiZSBzYXZlZCBpbnRvIHN0b3JhZ2UgKi9cbiAgICAgICAgdGhpcy5kb2N1bWVudHMgPSBbXTtcbiAgICAgICAgLyoqIFRoZSBjb2xsZWN0aW9uIGdyb3VwcyBhZmZlY3RlZCBieSB0aGlzIGJ1bmRsZS4gKi9cbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXBzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gYnVuZGxlSW5pdGlhbFByb2dyZXNzKGJ1bmRsZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBlbGVtZW50IGZyb20gdGhlIGJ1bmRsZSB0byB0aGUgbG9hZGVyLlxuICAgICAqXG4gICAgICogUmV0dXJucyBhIG5ldyBwcm9ncmVzcyBpZiBhZGRpbmcgdGhlIGVsZW1lbnQgbGVhZHMgdG8gYSBuZXcgcHJvZ3Jlc3MsXG4gICAgICogb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cbiAgICAgKi9cbiAgICBhZGRTaXplZEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnByb2dyZXNzLmJ5dGVzTG9hZGVkICs9IGVsZW1lbnQuYnl0ZUxlbmd0aDtcbiAgICAgICAgbGV0IGRvY3VtZW50c0xvYWRlZCA9IHRoaXMucHJvZ3Jlc3MuZG9jdW1lbnRzTG9hZGVkO1xuICAgICAgICBpZiAoZWxlbWVudC5wYXlsb2FkLm5hbWVkUXVlcnkpIHtcbiAgICAgICAgICAgIHRoaXMucXVlcmllcy5wdXNoKGVsZW1lbnQucGF5bG9hZC5uYW1lZFF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50LnBheWxvYWQuZG9jdW1lbnRNZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudHMucHVzaCh7IG1ldGFkYXRhOiBlbGVtZW50LnBheWxvYWQuZG9jdW1lbnRNZXRhZGF0YSB9KTtcbiAgICAgICAgICAgIGlmICghZWxlbWVudC5wYXlsb2FkLmRvY3VtZW50TWV0YWRhdGEuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgKytkb2N1bWVudHNMb2FkZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcoZWxlbWVudC5wYXlsb2FkLmRvY3VtZW50TWV0YWRhdGEubmFtZSk7XG4gICAgICAgICAgICB0aGlzLmNvbGxlY3Rpb25Hcm91cHMuYWRkKHBhdGguZ2V0KHBhdGgubGVuZ3RoIC0gMikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnQucGF5bG9hZC5kb2N1bWVudCkge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudHNbdGhpcy5kb2N1bWVudHMubGVuZ3RoIC0gMV0uZG9jdW1lbnQgPVxuICAgICAgICAgICAgICAgIGVsZW1lbnQucGF5bG9hZC5kb2N1bWVudDtcbiAgICAgICAgICAgICsrZG9jdW1lbnRzTG9hZGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudHNMb2FkZWQgIT09IHRoaXMucHJvZ3Jlc3MuZG9jdW1lbnRzTG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzLmRvY3VtZW50c0xvYWRlZCA9IGRvY3VtZW50c0xvYWRlZDtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0UXVlcnlEb2N1bWVudE1hcHBpbmcoZG9jdW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5RG9jdW1lbnRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGJ1bmRsZUNvbnZlcnRlciA9IG5ldyBCdW5kbGVDb252ZXJ0ZXJJbXBsKHRoaXMuc2VyaWFsaXplcik7XG4gICAgICAgIGZvciAoY29uc3QgYnVuZGxlRG9jIG9mIGRvY3VtZW50cykge1xuICAgICAgICAgICAgaWYgKGJ1bmRsZURvYy5tZXRhZGF0YS5xdWVyaWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRLZXkgPSBidW5kbGVDb252ZXJ0ZXIudG9Eb2N1bWVudEtleShidW5kbGVEb2MubWV0YWRhdGEubmFtZSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBxdWVyeU5hbWUgb2YgYnVuZGxlRG9jLm1ldGFkYXRhLnF1ZXJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRLZXlzID0gKHF1ZXJ5RG9jdW1lbnRNYXAuZ2V0KHF1ZXJ5TmFtZSkgfHwgZG9jdW1lbnRLZXlTZXQoKSkuYWRkKGRvY3VtZW50S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlEb2N1bWVudE1hcC5zZXQocXVlcnlOYW1lLCBkb2N1bWVudEtleXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVlcnlEb2N1bWVudE1hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBwcm9ncmVzcyB0byAnU3VjY2VzcycgYW5kIHJldHVybiB0aGUgdXBkYXRlZCBwcm9ncmVzcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb21wbGV0ZSgpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlZERvY3MgPSBhd2FpdCBsb2NhbFN0b3JlQXBwbHlCdW5kbGVkRG9jdW1lbnRzKHRoaXMubG9jYWxTdG9yZSwgbmV3IEJ1bmRsZUNvbnZlcnRlckltcGwodGhpcy5zZXJpYWxpemVyKSwgdGhpcy5kb2N1bWVudHMsIHRoaXMuYnVuZGxlTWV0YWRhdGEuaWQpO1xuICAgICAgICBjb25zdCBxdWVyeURvY3VtZW50TWFwID0gdGhpcy5nZXRRdWVyeURvY3VtZW50TWFwcGluZyh0aGlzLmRvY3VtZW50cyk7XG4gICAgICAgIGZvciAoY29uc3QgcSBvZiB0aGlzLnF1ZXJpZXMpIHtcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmVTYXZlTmFtZWRRdWVyeSh0aGlzLmxvY2FsU3RvcmUsIHEsIHF1ZXJ5RG9jdW1lbnRNYXAuZ2V0KHEubmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MudGFza1N0YXRlID0gJ1N1Y2Nlc3MnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvZ3Jlc3M6IHRoaXMucHJvZ3Jlc3MsXG4gICAgICAgICAgICBjaGFuZ2VkQ29sbGVjdGlvbkdyb3VwczogdGhpcy5jb2xsZWN0aW9uR3JvdXBzLFxuICAgICAgICAgICAgY2hhbmdlZERvY3NcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgYSBgTG9hZEJ1bmRsZVRhc2tQcm9ncmVzc2AgcmVwcmVzZW50aW5nIHRoZSBpbml0aWFsIHByb2dyZXNzIG9mXG4gKiBsb2FkaW5nIGEgYnVuZGxlLlxuICovXG5mdW5jdGlvbiBidW5kbGVJbml0aWFsUHJvZ3Jlc3MobWV0YWRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0YXNrU3RhdGU6ICdSdW5uaW5nJyxcbiAgICAgICAgZG9jdW1lbnRzTG9hZGVkOiAwLFxuICAgICAgICBieXRlc0xvYWRlZDogMCxcbiAgICAgICAgdG90YWxEb2N1bWVudHM6IG1ldGFkYXRhLnRvdGFsRG9jdW1lbnRzLFxuICAgICAgICB0b3RhbEJ5dGVzOiBtZXRhZGF0YS50b3RhbEJ5dGVzXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGBMb2FkQnVuZGxlVGFza1Byb2dyZXNzYCByZXByZXNlbnRpbmcgdGhlIHByb2dyZXNzIHRoYXQgdGhlIGxvYWRpbmdcbiAqIGhhcyBzdWNjZWVkZWQuXG4gKi9cbmZ1bmN0aW9uIGJ1bmRsZVN1Y2Nlc3NQcm9ncmVzcyhtZXRhZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhc2tTdGF0ZTogJ1N1Y2Nlc3MnLFxuICAgICAgICBkb2N1bWVudHNMb2FkZWQ6IG1ldGFkYXRhLnRvdGFsRG9jdW1lbnRzLFxuICAgICAgICBieXRlc0xvYWRlZDogbWV0YWRhdGEudG90YWxCeXRlcyxcbiAgICAgICAgdG90YWxEb2N1bWVudHM6IG1ldGFkYXRhLnRvdGFsRG9jdW1lbnRzLFxuICAgICAgICB0b3RhbEJ5dGVzOiBtZXRhZGF0YS50b3RhbEJ5dGVzXG4gICAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEFkZGVkTGltYm9Eb2N1bWVudCB7XG4gICAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIH1cbn1cbmNsYXNzIFJlbW92ZWRMaW1ib0RvY3VtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxufVxuLyoqXG4gKiBWaWV3IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRpbmcgdGhlIGZpbmFsIG1lcmdlZCB0cnV0aCBvZiB3aGF0IGRvY3MgYXJlIGluXG4gKiBhIHF1ZXJ5LiBJdCBnZXRzIG5vdGlmaWVkIG9mIGxvY2FsIGFuZCByZW1vdGUgY2hhbmdlcyB0byBkb2NzLCBhbmQgYXBwbGllc1xuICogdGhlIHF1ZXJ5IGZpbHRlcnMgYW5kIGxpbWl0cyB0byBkZXRlcm1pbmUgdGhlIG1vc3QgY29ycmVjdCBwb3NzaWJsZSByZXN1bHRzLlxuICovXG5jbGFzcyBWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihxdWVyeSwgXG4gICAgLyoqIERvY3VtZW50cyBpbmNsdWRlZCBpbiB0aGUgcmVtb3RlIHRhcmdldCAqL1xuICAgIF9zeW5jZWREb2N1bWVudHMpIHtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLl9zeW5jZWREb2N1bWVudHMgPSBfc3luY2VkRG9jdW1lbnRzO1xuICAgICAgICB0aGlzLnN5bmNTdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzQ2FjaGVkUmVzdWx0cyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnIHdoZXRoZXIgdGhlIHZpZXcgaXMgY3VycmVudCB3aXRoIHRoZSBiYWNrZW5kLiBBIHZpZXcgaXMgY29uc2lkZXJlZFxuICAgICAgICAgKiBjdXJyZW50IGFmdGVyIGl0IGhhcyBzZWVuIHRoZSBjdXJyZW50IGZsYWcgZnJvbSB0aGUgYmFja2VuZCBhbmQgZGlkIG5vdFxuICAgICAgICAgKiBsb3NlIGNvbnNpc3RlbmN5IHdpdGhpbiB0aGUgd2F0Y2ggc3RyZWFtIChlLmcuIGJlY2F1c2Ugb2YgYW4gZXhpc3RlbmNlXG4gICAgICAgICAqIGZpbHRlciBtaXNtYXRjaCkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgLyoqIERvY3VtZW50cyBpbiB0aGUgdmlldyBidXQgbm90IGluIHRoZSByZW1vdGUgdGFyZ2V0ICovXG4gICAgICAgIHRoaXMubGltYm9Eb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICAvKiogRG9jdW1lbnQgS2V5cyB0aGF0IGhhdmUgbG9jYWwgY2hhbmdlcyAqL1xuICAgICAgICB0aGlzLm11dGF0ZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgdGhpcy5kb2NDb21wYXJhdG9yID0gbmV3UXVlcnlDb21wYXJhdG9yKHF1ZXJ5KTtcbiAgICAgICAgdGhpcy5kb2N1bWVudFNldCA9IG5ldyBEb2N1bWVudFNldCh0aGlzLmRvY0NvbXBhcmF0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2V0IG9mIHJlbW90ZSBkb2N1bWVudHMgdGhhdCB0aGUgc2VydmVyIGhhcyB0b2xkIHVzIGJlbG9uZ3MgdG8gdGhlIHRhcmdldCBhc3NvY2lhdGVkIHdpdGhcbiAgICAgKiB0aGlzIHZpZXcuXG4gICAgICovXG4gICAgZ2V0IHN5bmNlZERvY3VtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N5bmNlZERvY3VtZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhIHNldCBvZiBkb2MgY2hhbmdlcywgYXBwbGllcyB0aGUgcXVlcnkgbGltaXQsIGFuZCBjb21wdXRlc1xuICAgICAqIHdoYXQgdGhlIG5ldyByZXN1bHRzIHNob3VsZCBiZSwgd2hhdCB0aGUgY2hhbmdlcyB3ZXJlLCBhbmQgd2hldGhlciB3ZSBtYXlcbiAgICAgKiBuZWVkIHRvIGdvIGJhY2sgdG8gdGhlIGxvY2FsIGNhY2hlIGZvciBtb3JlIHJlc3VsdHMuIERvZXMgbm90IG1ha2UgYW55XG4gICAgICogY2hhbmdlcyB0byB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0gZG9jQ2hhbmdlcyAtIFRoZSBkb2MgY2hhbmdlcyB0byBhcHBseSB0byB0aGlzIHZpZXcuXG4gICAgICogQHBhcmFtIHByZXZpb3VzQ2hhbmdlcyAtIElmIHRoaXMgaXMgYmVpbmcgY2FsbGVkIHdpdGggYSByZWZpbGwsIHRoZW4gc3RhcnRcbiAgICAgKiAgICAgICAgd2l0aCB0aGlzIHNldCBvZiBkb2NzIGFuZCBjaGFuZ2VzIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgdmlldy5cbiAgICAgKiBAcmV0dXJucyBhIG5ldyBzZXQgb2YgZG9jcywgY2hhbmdlcywgYW5kIHJlZmlsbCBmbGFnLlxuICAgICAqL1xuICAgIGNvbXB1dGVEb2NDaGFuZ2VzKGRvY0NoYW5nZXMsIHByZXZpb3VzQ2hhbmdlcykge1xuICAgICAgICBjb25zdCBjaGFuZ2VTZXQgPSBwcmV2aW91c0NoYW5nZXNcbiAgICAgICAgICAgID8gcHJldmlvdXNDaGFuZ2VzLmNoYW5nZVNldFxuICAgICAgICAgICAgOiBuZXcgRG9jdW1lbnRDaGFuZ2VTZXQoKTtcbiAgICAgICAgY29uc3Qgb2xkRG9jdW1lbnRTZXQgPSBwcmV2aW91c0NoYW5nZXNcbiAgICAgICAgICAgID8gcHJldmlvdXNDaGFuZ2VzLmRvY3VtZW50U2V0XG4gICAgICAgICAgICA6IHRoaXMuZG9jdW1lbnRTZXQ7XG4gICAgICAgIGxldCBuZXdNdXRhdGVkS2V5cyA9IHByZXZpb3VzQ2hhbmdlc1xuICAgICAgICAgICAgPyBwcmV2aW91c0NoYW5nZXMubXV0YXRlZEtleXNcbiAgICAgICAgICAgIDogdGhpcy5tdXRhdGVkS2V5cztcbiAgICAgICAgbGV0IG5ld0RvY3VtZW50U2V0ID0gb2xkRG9jdW1lbnRTZXQ7XG4gICAgICAgIGxldCBuZWVkc1JlZmlsbCA9IGZhbHNlO1xuICAgICAgICAvLyBUcmFjayB0aGUgbGFzdCBkb2MgaW4gYSAoZnVsbCkgbGltaXQuIFRoaXMgaXMgbmVjZXNzYXJ5LCBiZWNhdXNlIHNvbWVcbiAgICAgICAgLy8gdXBkYXRlIChhIGRlbGV0ZSwgb3IgYW4gdXBkYXRlIG1vdmluZyBhIGRvYyBwYXN0IHRoZSBvbGQgbGltaXQpIG1pZ2h0XG4gICAgICAgIC8vIG1lYW4gdGhlcmUgaXMgc29tZSBvdGhlciBkb2N1bWVudCBpbiB0aGUgbG9jYWwgY2FjaGUgdGhhdCBlaXRoZXIgc2hvdWxkXG4gICAgICAgIC8vIGNvbWUgKDEpIGJldHdlZW4gdGhlIG9sZCBsYXN0IGxpbWl0IGRvYyBhbmQgdGhlIG5ldyBsYXN0IGRvY3VtZW50LCBpbiB0aGVcbiAgICAgICAgLy8gY2FzZSBvZiB1cGRhdGVzLCBvciAoMikgYWZ0ZXIgdGhlIG5ldyBsYXN0IGRvY3VtZW50LCBpbiB0aGUgY2FzZSBvZlxuICAgICAgICAvLyBkZWxldGVzLiBTbyB3ZSBrZWVwIHRoaXMgZG9jIGF0IHRoZSBvbGQgbGltaXQgdG8gY29tcGFyZSB0aGUgdXBkYXRlcyB0by5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgc2hvdWxkIG5ldmVyIGdldCB1c2VkIGluIGEgcmVmaWxsICh3aGVuIHByZXZpb3VzQ2hhbmdlcyBpc1xuICAgICAgICAvLyBzZXQpLCBiZWNhdXNlIHRoZXJlIHdpbGwgb25seSBiZSBhZGRzIC0tIG5vIGRlbGV0ZXMgb3IgdXBkYXRlcy5cbiAgICAgICAgY29uc3QgbGFzdERvY0luTGltaXQgPSB0aGlzLnF1ZXJ5LmxpbWl0VHlwZSA9PT0gXCJGXCIgLyogTGltaXRUeXBlLkZpcnN0ICovICYmXG4gICAgICAgICAgICBvbGREb2N1bWVudFNldC5zaXplID09PSB0aGlzLnF1ZXJ5LmxpbWl0XG4gICAgICAgICAgICA/IG9sZERvY3VtZW50U2V0Lmxhc3QoKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjb25zdCBmaXJzdERvY0luTGltaXQgPSB0aGlzLnF1ZXJ5LmxpbWl0VHlwZSA9PT0gXCJMXCIgLyogTGltaXRUeXBlLkxhc3QgKi8gJiZcbiAgICAgICAgICAgIG9sZERvY3VtZW50U2V0LnNpemUgPT09IHRoaXMucXVlcnkubGltaXRcbiAgICAgICAgICAgID8gb2xkRG9jdW1lbnRTZXQuZmlyc3QoKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBkb2NDaGFuZ2VzLmlub3JkZXJUcmF2ZXJzYWwoKGtleSwgZW50cnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9sZERvYyA9IG9sZERvY3VtZW50U2V0LmdldChrZXkpO1xuICAgICAgICAgICAgY29uc3QgbmV3RG9jID0gcXVlcnlNYXRjaGVzKHRoaXMucXVlcnksIGVudHJ5KSA/IGVudHJ5IDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IG9sZERvY0hhZFBlbmRpbmdNdXRhdGlvbnMgPSBvbGREb2NcbiAgICAgICAgICAgICAgICA/IHRoaXMubXV0YXRlZEtleXMuaGFzKG9sZERvYy5rZXkpXG4gICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0RvY0hhc1BlbmRpbmdNdXRhdGlvbnMgPSBuZXdEb2NcbiAgICAgICAgICAgICAgICA/IG5ld0RvYy5oYXNMb2NhbE11dGF0aW9ucyB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IGNvbnNpZGVyIGNvbW1pdHRlZCBtdXRhdGlvbnMgZm9yIGRvY3VtZW50cyB0aGF0IHdlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gbXV0YXRlZCBkdXJpbmcgdGhlIGxpZmV0aW1lIG9mIHRoZSB2aWV3LlxuICAgICAgICAgICAgICAgICAgICAodGhpcy5tdXRhdGVkS2V5cy5oYXMobmV3RG9jLmtleSkgJiYgbmV3RG9jLmhhc0NvbW1pdHRlZE11dGF0aW9ucylcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGNoYW5nZUFwcGxpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBjaGFuZ2VcbiAgICAgICAgICAgIGlmIChvbGREb2MgJiYgbmV3RG9jKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jc0VxdWFsID0gb2xkRG9jLmRhdGEuaXNFcXVhbChuZXdEb2MuZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKCFkb2NzRXF1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZFdhaXRGb3JTeW5jZWREb2N1bWVudChvbGREb2MsIG5ld0RvYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVNldC50cmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMiAvKiBDaGFuZ2VUeXBlLk1vZGlmaWVkICovLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvYzogbmV3RG9jXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUFwcGxpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChsYXN0RG9jSW5MaW1pdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jQ29tcGFyYXRvcihuZXdEb2MsIGxhc3REb2NJbkxpbWl0KSA+IDApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZpcnN0RG9jSW5MaW1pdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY0NvbXBhcmF0b3IobmV3RG9jLCBmaXJzdERvY0luTGltaXQpIDwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGRvYyBtb3ZlZCBmcm9tIGluc2lkZSB0aGUgbGltaXQgdG8gb3V0c2lkZSB0aGUgbGltaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhhdCBtZWFucyB0aGVyZSBtYXkgYmUgc29tZSBvdGhlciBkb2MgaW4gdGhlIGxvY2FsIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBzaG91bGQgYmUgaW5jbHVkZWQgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWVkc1JlZmlsbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkRG9jSGFkUGVuZGluZ011dGF0aW9ucyAhPT0gbmV3RG9jSGFzUGVuZGluZ011dGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VTZXQudHJhY2soeyB0eXBlOiAzIC8qIENoYW5nZVR5cGUuTWV0YWRhdGEgKi8sIGRvYzogbmV3RG9jIH0pO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBcHBsaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghb2xkRG9jICYmIG5ld0RvYykge1xuICAgICAgICAgICAgICAgIGNoYW5nZVNldC50cmFjayh7IHR5cGU6IDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLywgZG9jOiBuZXdEb2MgfSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlQXBwbGllZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvbGREb2MgJiYgIW5ld0RvYykge1xuICAgICAgICAgICAgICAgIGNoYW5nZVNldC50cmFjayh7IHR5cGU6IDEgLyogQ2hhbmdlVHlwZS5SZW1vdmVkICovLCBkb2M6IG9sZERvYyB9KTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VBcHBsaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdERvY0luTGltaXQgfHwgZmlyc3REb2NJbkxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgZG9jIHdhcyByZW1vdmVkIGZyb20gYSBmdWxsIGxpbWl0IHF1ZXJ5LiBXZSdsbCBuZWVkIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcXVlcnkgZnJvbSB0aGUgbG9jYWwgY2FjaGUgdG8gc2VlIGlmIHdlIGtub3cgYWJvdXQgc29tZSBvdGhlclxuICAgICAgICAgICAgICAgICAgICAvLyBkb2MgdGhhdCBzaG91bGQgYmUgaW4gdGhlIHJlc3VsdHMuXG4gICAgICAgICAgICAgICAgICAgIG5lZWRzUmVmaWxsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlQXBwbGllZCkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdEb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RG9jdW1lbnRTZXQgPSBuZXdEb2N1bWVudFNldC5hZGQobmV3RG9jKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0RvY0hhc1BlbmRpbmdNdXRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld011dGF0ZWRLZXlzID0gbmV3TXV0YXRlZEtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdNdXRhdGVkS2V5cyA9IG5ld011dGF0ZWRLZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdEb2N1bWVudFNldCA9IG5ld0RvY3VtZW50U2V0LmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICBuZXdNdXRhdGVkS2V5cyA9IG5ld011dGF0ZWRLZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERyb3AgZG9jdW1lbnRzIG91dCB0byBtZWV0IGxpbWl0L2xpbWl0VG9MYXN0IHJlcXVpcmVtZW50LlxuICAgICAgICBpZiAodGhpcy5xdWVyeS5saW1pdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgd2hpbGUgKG5ld0RvY3VtZW50U2V0LnNpemUgPiB0aGlzLnF1ZXJ5LmxpbWl0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkRG9jID0gdGhpcy5xdWVyeS5saW1pdFR5cGUgPT09IFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqL1xuICAgICAgICAgICAgICAgICAgICA/IG5ld0RvY3VtZW50U2V0Lmxhc3QoKVxuICAgICAgICAgICAgICAgICAgICA6IG5ld0RvY3VtZW50U2V0LmZpcnN0KCk7XG4gICAgICAgICAgICAgICAgbmV3RG9jdW1lbnRTZXQgPSBuZXdEb2N1bWVudFNldC5kZWxldGUob2xkRG9jLmtleSk7XG4gICAgICAgICAgICAgICAgbmV3TXV0YXRlZEtleXMgPSBuZXdNdXRhdGVkS2V5cy5kZWxldGUob2xkRG9jLmtleSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlU2V0LnRyYWNrKHsgdHlwZTogMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8sIGRvYzogb2xkRG9jIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb2N1bWVudFNldDogbmV3RG9jdW1lbnRTZXQsXG4gICAgICAgICAgICBjaGFuZ2VTZXQsXG4gICAgICAgICAgICBuZWVkc1JlZmlsbCxcbiAgICAgICAgICAgIG11dGF0ZWRLZXlzOiBuZXdNdXRhdGVkS2V5c1xuICAgICAgICB9O1xuICAgIH1cbiAgICBzaG91bGRXYWl0Rm9yU3luY2VkRG9jdW1lbnQob2xkRG9jLCBuZXdEb2MpIHtcbiAgICAgICAgLy8gV2Ugc3VwcHJlc3MgdGhlIGluaXRpYWwgY2hhbmdlIGV2ZW50IGZvciBkb2N1bWVudHMgdGhhdCB3ZXJlIG1vZGlmaWVkIGFzXG4gICAgICAgIC8vIHBhcnQgb2YgYSB3cml0ZSBhY2tub3dsZWRnbWVudCAoZS5nLiB3aGVuIHRoZSB2YWx1ZSBvZiBhIHNlcnZlciB0cmFuc2Zvcm1cbiAgICAgICAgLy8gaXMgYXBwbGllZCkgYXMgV2F0Y2ggd2lsbCBzZW5kIHVzIHRoZSBzYW1lIGRvY3VtZW50IGFnYWluLlxuICAgICAgICAvLyBCeSBzdXBwcmVzc2luZyB0aGUgZXZlbnQsIHdlIG9ubHkgcmFpc2UgdHdvIHVzZXIgdmlzaWJsZSBldmVudHMgKG9uZSB3aXRoXG4gICAgICAgIC8vIGBoYXNQZW5kaW5nV3JpdGVzYCBhbmQgdGhlIGZpbmFsIHN0YXRlIG9mIHRoZSBkb2N1bWVudCkgaW5zdGVhZCBvZiB0aHJlZVxuICAgICAgICAvLyAob25lIHdpdGggYGhhc1BlbmRpbmdXcml0ZXNgLCB0aGUgbW9kaWZpZWQgZG9jdW1lbnQgd2l0aFxuICAgICAgICAvLyBgaGFzUGVuZGluZ1dyaXRlc2AgYW5kIHRoZSBmaW5hbCBzdGF0ZSBvZiB0aGUgZG9jdW1lbnQpLlxuICAgICAgICByZXR1cm4gKG9sZERvYy5oYXNMb2NhbE11dGF0aW9ucyAmJlxuICAgICAgICAgICAgbmV3RG9jLmhhc0NvbW1pdHRlZE11dGF0aW9ucyAmJlxuICAgICAgICAgICAgIW5ld0RvYy5oYXNMb2NhbE11dGF0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHZpZXcgd2l0aCB0aGUgZ2l2ZW4gVmlld0RvY3VtZW50Q2hhbmdlcyBhbmQgb3B0aW9uYWxseSB1cGRhdGVzXG4gICAgICogbGltYm8gZG9jcyBhbmQgc3luYyBzdGF0ZSBmcm9tIHRoZSBwcm92aWRlZCB0YXJnZXQgY2hhbmdlLlxuICAgICAqIEBwYXJhbSBkb2NDaGFuZ2VzIC0gVGhlIHNldCBvZiBjaGFuZ2VzIHRvIG1ha2UgdG8gdGhlIHZpZXcncyBkb2NzLlxuICAgICAqIEBwYXJhbSBsaW1ib1Jlc29sdXRpb25FbmFibGVkIC0gV2hldGhlciB0byB1cGRhdGUgbGltYm8gZG9jdW1lbnRzIGJhc2VkIG9uXG4gICAgICogICAgICAgIHRoaXMgY2hhbmdlLlxuICAgICAqIEBwYXJhbSB0YXJnZXRDaGFuZ2UgLSBBIHRhcmdldCBjaGFuZ2UgdG8gYXBwbHkgZm9yIGNvbXB1dGluZyBsaW1ibyBkb2NzIGFuZFxuICAgICAqICAgICAgICBzeW5jIHN0YXRlLlxuICAgICAqIEBwYXJhbSB0YXJnZXRJc1BlbmRpbmdSZXNldCAtIFdoZXRoZXIgdGhlIHRhcmdldCBpcyBwZW5kaW5nIHRvIHJlc2V0IGR1ZSB0b1xuICAgICAqICAgICAgICBleGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoLiBJZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQsIGl0IGlzIHRyZWF0ZWRcbiAgICAgKiAgICAgICAgZXF1aXZhbGVudGx5IHRvIGBmYWxzZWAuXG4gICAgICogQHJldHVybnMgQSBuZXcgVmlld0NoYW5nZSB3aXRoIHRoZSBnaXZlbiBkb2NzLCBjaGFuZ2VzLCBhbmQgc3luYyBzdGF0ZS5cbiAgICAgKi9cbiAgICAvLyBQT1JUSU5HIE5PVEU6IFRoZSBpT1MvQW5kcm9pZCBjbGllbnRzIGFsd2F5cyBjb21wdXRlIGxpbWJvIGRvY3VtZW50IGNoYW5nZXMuXG4gICAgYXBwbHlDaGFuZ2VzKGRvY0NoYW5nZXMsIGxpbWJvUmVzb2x1dGlvbkVuYWJsZWQsIHRhcmdldENoYW5nZSwgdGFyZ2V0SXNQZW5kaW5nUmVzZXQpIHtcbiAgICAgICAgY29uc3Qgb2xkRG9jcyA9IHRoaXMuZG9jdW1lbnRTZXQ7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRTZXQgPSBkb2NDaGFuZ2VzLmRvY3VtZW50U2V0O1xuICAgICAgICB0aGlzLm11dGF0ZWRLZXlzID0gZG9jQ2hhbmdlcy5tdXRhdGVkS2V5cztcbiAgICAgICAgLy8gU29ydCBjaGFuZ2VzIGJhc2VkIG9uIHR5cGUgYW5kIHF1ZXJ5IGNvbXBhcmF0b3JcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGRvY0NoYW5nZXMuY2hhbmdlU2V0LmdldENoYW5nZXMoKTtcbiAgICAgICAgY2hhbmdlcy5zb3J0KChjMSwgYzIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoY29tcGFyZUNoYW5nZVR5cGUoYzEudHlwZSwgYzIudHlwZSkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmRvY0NvbXBhcmF0b3IoYzEuZG9jLCBjMi5kb2MpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBwbHlUYXJnZXRDaGFuZ2UodGFyZ2V0Q2hhbmdlKTtcbiAgICAgICAgdGFyZ2V0SXNQZW5kaW5nUmVzZXQgPSB0YXJnZXRJc1BlbmRpbmdSZXNldCAhPT0gbnVsbCAmJiB0YXJnZXRJc1BlbmRpbmdSZXNldCAhPT0gdm9pZCAwID8gdGFyZ2V0SXNQZW5kaW5nUmVzZXQgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgbGltYm9DaGFuZ2VzID0gbGltYm9SZXNvbHV0aW9uRW5hYmxlZCAmJiAhdGFyZ2V0SXNQZW5kaW5nUmVzZXRcbiAgICAgICAgICAgID8gdGhpcy51cGRhdGVMaW1ib0RvY3VtZW50cygpXG4gICAgICAgICAgICA6IFtdO1xuICAgICAgICAvLyBXZSBhcmUgYXQgc3luY2VkIHN0YXRlIGlmIHRoZXJlIGlzIG5vIGxpbWJvIGRvY3MgYXJlIHdhaXRpbmcgdG8gYmUgcmVzb2x2ZWQsIHZpZXcgaXMgY3VycmVudFxuICAgICAgICAvLyB3aXRoIHRoZSBiYWNrZW5kLCBhbmQgdGhlIHF1ZXJ5IGlzIG5vdCBwZW5kaW5nIHRvIHJlc2V0IGR1ZSB0byBleGlzdGVuY2UgZmlsdGVyIG1pc21hdGNoLlxuICAgICAgICBjb25zdCBzeW5jZWQgPSB0aGlzLmxpbWJvRG9jdW1lbnRzLnNpemUgPT09IDAgJiYgdGhpcy5jdXJyZW50ICYmICF0YXJnZXRJc1BlbmRpbmdSZXNldDtcbiAgICAgICAgY29uc3QgbmV3U3luY1N0YXRlID0gc3luY2VkID8gMSAvKiBTeW5jU3RhdGUuU3luY2VkICovIDogMCAvKiBTeW5jU3RhdGUuTG9jYWwgKi87XG4gICAgICAgIGNvbnN0IHN5bmNTdGF0ZUNoYW5nZWQgPSBuZXdTeW5jU3RhdGUgIT09IHRoaXMuc3luY1N0YXRlO1xuICAgICAgICB0aGlzLnN5bmNTdGF0ZSA9IG5ld1N5bmNTdGF0ZTtcbiAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoID09PSAwICYmICFzeW5jU3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICAvLyBubyBjaGFuZ2VzXG4gICAgICAgICAgICByZXR1cm4geyBsaW1ib0NoYW5nZXMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNuYXAgPSBuZXcgVmlld1NuYXBzaG90KHRoaXMucXVlcnksIGRvY0NoYW5nZXMuZG9jdW1lbnRTZXQsIG9sZERvY3MsIGNoYW5nZXMsIGRvY0NoYW5nZXMubXV0YXRlZEtleXMsIG5ld1N5bmNTdGF0ZSA9PT0gMCAvKiBTeW5jU3RhdGUuTG9jYWwgKi8sIHN5bmNTdGF0ZUNoYW5nZWQsIFxuICAgICAgICAgICAgLyogZXhjbHVkZXNNZXRhZGF0YUNoYW5nZXM9ICovIGZhbHNlLCB0YXJnZXRDaGFuZ2VcbiAgICAgICAgICAgICAgICA/IHRhcmdldENoYW5nZS5yZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPiAwXG4gICAgICAgICAgICAgICAgOiBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNuYXBzaG90OiBzbmFwLFxuICAgICAgICAgICAgICAgIGxpbWJvQ2hhbmdlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFuIE9ubGluZVN0YXRlIGNoYW5nZSB0byB0aGUgdmlldywgcG90ZW50aWFsbHkgZ2VuZXJhdGluZyBhXG4gICAgICogVmlld0NoYW5nZSBpZiB0aGUgdmlldydzIHN5bmNTdGF0ZSBjaGFuZ2VzIGFzIGEgcmVzdWx0LlxuICAgICAqL1xuICAgIGFwcGx5T25saW5lU3RhdGVDaGFuZ2Uob25saW5lU3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudCAmJiBvbmxpbmVTdGF0ZSA9PT0gXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLykge1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgb2ZmbGluZSwgc2V0IGBjdXJyZW50YCB0byBmYWxzZSBhbmQgdGhlbiBjYWxsIGFwcGx5Q2hhbmdlcygpXG4gICAgICAgICAgICAvLyB0byByZWZyZXNoIG91ciBzeW5jU3RhdGUgYW5kIGdlbmVyYXRlIGEgVmlld0NoYW5nZSBhcyBhcHByb3ByaWF0ZS4gV2VcbiAgICAgICAgICAgIC8vIGFyZSBndWFyYW50ZWVkIHRvIGdldCBhIG5ldyBUYXJnZXRDaGFuZ2UgdGhhdCBzZXRzIGBjdXJyZW50YCBiYWNrIHRvXG4gICAgICAgICAgICAvLyB0cnVlIG9uY2UgdGhlIGNsaWVudCBpcyBiYWNrIG9ubGluZS5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlDaGFuZ2VzKHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudFNldDogdGhpcy5kb2N1bWVudFNldCxcbiAgICAgICAgICAgICAgICBjaGFuZ2VTZXQ6IG5ldyBEb2N1bWVudENoYW5nZVNldCgpLFxuICAgICAgICAgICAgICAgIG11dGF0ZWRLZXlzOiB0aGlzLm11dGF0ZWRLZXlzLFxuICAgICAgICAgICAgICAgIG5lZWRzUmVmaWxsOiBmYWxzZVxuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKiBsaW1ib1Jlc29sdXRpb25FbmFibGVkPSAqLyBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBlZmZlY3QsIGp1c3QgcmV0dXJuIGEgbm8tb3AgVmlld0NoYW5nZS5cbiAgICAgICAgICAgIHJldHVybiB7IGxpbWJvQ2hhbmdlczogW10gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGRvYyBmb3IgdGhlIGdpdmVuIGtleSBzaG91bGQgYmUgaW4gbGltYm8uXG4gICAgICovXG4gICAgc2hvdWxkQmVJbkxpbWJvKGtleSkge1xuICAgICAgICAvLyBJZiB0aGUgcmVtb3RlIGVuZCBzYXlzIGl0J3MgcGFydCBvZiB0aGlzIHF1ZXJ5LCBpdCdzIG5vdCBpbiBsaW1iby5cbiAgICAgICAgaWYgKHRoaXMuX3N5bmNlZERvY3VtZW50cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBsb2NhbCBzdG9yZSBkb2Vzbid0IHRoaW5rIGl0J3MgYSByZXN1bHQsIHNvIGl0IHNob3VsZG4ndCBiZSBpbiBsaW1iby5cbiAgICAgICAgaWYgKCF0aGlzLmRvY3VtZW50U2V0LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGxvY2FsIGNoYW5nZXMgdG8gdGhlIGRvYywgdGhleSBtaWdodCBleHBsYWluIHdoeSB0aGUgc2VydmVyXG4gICAgICAgIC8vIGRvZXNuJ3Qga25vdyB0aGF0IGl0J3MgcGFydCBvZiB0aGUgcXVlcnkuIFNvIGRvbid0IHB1dCBpdCBpbiBsaW1iby5cbiAgICAgICAgLy8gVE9ETyhrbGltdCk6IElkZWFsbHksIHdlIHdvdWxkIG9ubHkgY29uc2lkZXIgY2hhbmdlcyB0aGF0IG1pZ2h0IGFjdHVhbGx5XG4gICAgICAgIC8vIGFmZmVjdCB0aGlzIHNwZWNpZmljIHF1ZXJ5LlxuICAgICAgICBpZiAodGhpcy5kb2N1bWVudFNldC5nZXQoa2V5KS5oYXNMb2NhbE11dGF0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpcyBpbiBsaW1iby5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgc3luY2VkRG9jdW1lbnRzLCBjdXJyZW50LCBhbmQgbGltYm8gZG9jcyBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2hhbmdlLlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgY2hhbmdlcyB0byB3aGljaCBkb2NzIGFyZSBpbiBsaW1iby5cbiAgICAgKi9cbiAgICBhcHBseVRhcmdldENoYW5nZSh0YXJnZXRDaGFuZ2UpIHtcbiAgICAgICAgaWYgKHRhcmdldENoYW5nZSkge1xuICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLmFkZGVkRG9jdW1lbnRzLmZvckVhY2goa2V5ID0+ICh0aGlzLl9zeW5jZWREb2N1bWVudHMgPSB0aGlzLl9zeW5jZWREb2N1bWVudHMuYWRkKGtleSkpKTtcbiAgICAgICAgICAgIHRhcmdldENoYW5nZS5tb2RpZmllZERvY3VtZW50cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRhcmdldENoYW5nZS5yZW1vdmVkRG9jdW1lbnRzLmZvckVhY2goa2V5ID0+ICh0aGlzLl9zeW5jZWREb2N1bWVudHMgPSB0aGlzLl9zeW5jZWREb2N1bWVudHMuZGVsZXRlKGtleSkpKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IHRhcmdldENoYW5nZS5jdXJyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUxpbWJvRG9jdW1lbnRzKCkge1xuICAgICAgICAvLyBXZSBjYW4gb25seSBkZXRlcm1pbmUgbGltYm8gZG9jdW1lbnRzIHdoZW4gd2UncmUgaW4tc3luYyB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhrbGltdCk6IERvIHRoaXMgaW5jcmVtZW50YWxseSBzbyB0aGF0IGl0J3Mgbm90IHF1YWRyYXRpYyB3aGVuXG4gICAgICAgIC8vIHVwZGF0aW5nIG1hbnkgZG9jdW1lbnRzLlxuICAgICAgICBjb25zdCBvbGRMaW1ib0RvY3VtZW50cyA9IHRoaXMubGltYm9Eb2N1bWVudHM7XG4gICAgICAgIHRoaXMubGltYm9Eb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpO1xuICAgICAgICB0aGlzLmRvY3VtZW50U2V0LmZvckVhY2goZG9jID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZEJlSW5MaW1ibyhkb2Mua2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGltYm9Eb2N1bWVudHMgPSB0aGlzLmxpbWJvRG9jdW1lbnRzLmFkZChkb2Mua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERpZmYgdGhlIG5ldyBsaW1ibyBkb2NzIHdpdGggdGhlIG9sZCBsaW1ibyBkb2NzLlxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgICAgIG9sZExpbWJvRG9jdW1lbnRzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5saW1ib0RvY3VtZW50cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChuZXcgUmVtb3ZlZExpbWJvRG9jdW1lbnQoa2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxpbWJvRG9jdW1lbnRzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmICghb2xkTGltYm9Eb2N1bWVudHMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2gobmV3IEFkZGVkTGltYm9Eb2N1bWVudChrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGluLW1lbW9yeSBzdGF0ZSBvZiB0aGUgY3VycmVudCB2aWV3IHdpdGggdGhlIHN0YXRlIHJlYWQgZnJvbVxuICAgICAqIHBlcnNpc3RlbmNlLlxuICAgICAqXG4gICAgICogV2UgdXBkYXRlIHRoZSBxdWVyeSB2aWV3IHdoZW5ldmVyIGEgY2xpZW50J3MgcHJpbWFyeSBzdGF0dXMgY2hhbmdlczpcbiAgICAgKiAtIFdoZW4gYSBjbGllbnQgdHJhbnNpdGlvbnMgZnJvbSBwcmltYXJ5IHRvIHNlY29uZGFyeSwgaXQgY2FuIG1pc3NcbiAgICAgKiAgIExvY2FsU3RvcmFnZSB1cGRhdGVzIGFuZCBpdHMgcXVlcnkgdmlld3MgbWF5IHRlbXBvcmFyaWx5IG5vdCBiZVxuICAgICAqICAgc3luY2hyb25pemVkIHdpdGggdGhlIHN0YXRlIG9uIGRpc2suXG4gICAgICogLSBGb3Igc2Vjb25kYXJ5IHRvIHByaW1hcnkgdHJhbnNpdGlvbnMsIHRoZSBjbGllbnQgbmVlZHMgdG8gdXBkYXRlIHRoZSBsaXN0XG4gICAgICogICBvZiBgc3luY2VkRG9jdW1lbnRzYCBzaW5jZSBzZWNvbmRhcnkgY2xpZW50cyB1cGRhdGUgdGhlaXIgcXVlcnkgdmlld3NcbiAgICAgKiAgIGJhc2VkIHB1cmVseSBvbiBzeW50aGVzaXplZCBSZW1vdGVFdmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcXVlcnlSZXN1bHQuZG9jdW1lbnRzIC0gVGhlIGRvY3VtZW50cyB0aGF0IG1hdGNoIHRoZSBxdWVyeSBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgTG9jYWxTdG9yZS5cbiAgICAgKiBAcGFyYW0gcXVlcnlSZXN1bHQucmVtb3RlS2V5cyAtIFRoZSBrZXlzIG9mIHRoZSBkb2N1bWVudHMgdGhhdCBtYXRjaCB0aGVcbiAgICAgKiBxdWVyeSBhY2NvcmRpbmcgdG8gdGhlIGJhY2tlbmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVmlld0NoYW5nZSB0aGF0IHJlc3VsdGVkIGZyb20gdGhpcyBzeW5jaHJvbml6YXRpb24uXG4gICAgICovXG4gICAgLy8gUE9SVElORyBOT1RFOiBNdWx0aS10YWIgb25seS5cbiAgICBzeW5jaHJvbml6ZVdpdGhQZXJzaXN0ZWRTdGF0ZShxdWVyeVJlc3VsdCkge1xuICAgICAgICB0aGlzLl9zeW5jZWREb2N1bWVudHMgPSBxdWVyeVJlc3VsdC5yZW1vdGVLZXlzO1xuICAgICAgICB0aGlzLmxpbWJvRG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKTtcbiAgICAgICAgY29uc3QgZG9jQ2hhbmdlcyA9IHRoaXMuY29tcHV0ZURvY0NoYW5nZXMocXVlcnlSZXN1bHQuZG9jdW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlDaGFuZ2VzKGRvY0NoYW5nZXMsIC8qIGxpbWJvUmVzb2x1dGlvbkVuYWJsZWQ9ICovIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdmlldyBzbmFwc2hvdCBhcyBpZiB0aGlzIHF1ZXJ5IHdhcyBqdXN0IGxpc3RlbmVkIHRvLiBDb250YWluc1xuICAgICAqIGEgZG9jdW1lbnQgYWRkIGZvciBldmVyeSBleGlzdGluZyBkb2N1bWVudCBhbmQgdGhlIGBmcm9tQ2FjaGVgIGFuZFxuICAgICAqIGBoYXNQZW5kaW5nV3JpdGVzYCBzdGF0dXMgb2YgdGhlIGFscmVhZHkgZXN0YWJsaXNoZWQgdmlldy5cbiAgICAgKi9cbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxuICAgIGNvbXB1dGVJbml0aWFsU25hcHNob3QoKSB7XG4gICAgICAgIHJldHVybiBWaWV3U25hcHNob3QuZnJvbUluaXRpYWxEb2N1bWVudHModGhpcy5xdWVyeSwgdGhpcy5kb2N1bWVudFNldCwgdGhpcy5tdXRhdGVkS2V5cywgdGhpcy5zeW5jU3RhdGUgPT09IDAgLyogU3luY1N0YXRlLkxvY2FsICovLCB0aGlzLmhhc0NhY2hlZFJlc3VsdHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmVDaGFuZ2VUeXBlKGMxLCBjMikge1xuICAgIGNvbnN0IG9yZGVyID0gKGNoYW5nZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGNoYW5nZSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBjYXNlIDIgLyogQ2hhbmdlVHlwZS5Nb2RpZmllZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBDaGFuZ2VUeXBlLk1ldGFkYXRhICovOlxuICAgICAgICAgICAgICAgIC8vIEEgbWV0YWRhdGEgY2hhbmdlIGlzIGNvbnZlcnRlZCB0byBhIG1vZGlmaWVkIGNoYW5nZSBhdCB0aGUgcHVibGljXG4gICAgICAgICAgICAgICAgLy8gYXBpIGxheWVyLiAgU2luY2Ugd2Ugc29ydCBieSBkb2N1bWVudCBrZXkgYW5kIHRoZW4gY2hhbmdlIHR5cGUsXG4gICAgICAgICAgICAgICAgLy8gbWV0YWRhdGEgYW5kIG1vZGlmaWVkIGNoYW5nZXMgbXVzdCBiZSBzb3J0ZWQgZXF1aXZhbGVudGx5LlxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgY2FzZSAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG9yZGVyKGMxKSAtIG9yZGVyKGMyKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IExPR19UQUckMyA9ICdTeW5jRW5naW5lJztcbi8qKlxuICogUXVlcnlWaWV3IGNvbnRhaW5zIGFsbCBvZiB0aGUgZGF0YSB0aGF0IFN5bmNFbmdpbmUgbmVlZHMgdG8ga2VlcCB0cmFjayBvZiBmb3JcbiAqIGEgcGFydGljdWxhciBxdWVyeS5cbiAqL1xuY2xhc3MgUXVlcnlWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgcXVlcnkgaXRzZWxmLlxuICAgICAqL1xuICAgIHF1ZXJ5LCBcbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG51bWJlciBjcmVhdGVkIGJ5IHRoZSBjbGllbnQgdGhhdCBpcyB1c2VkIGluIHRoZSB3YXRjaFxuICAgICAqIHN0cmVhbSB0byBpZGVudGlmeSB0aGlzIHF1ZXJ5LlxuICAgICAqL1xuICAgIHRhcmdldElkLCBcbiAgICAvKipcbiAgICAgKiBUaGUgdmlldyBpcyByZXNwb25zaWJsZSBmb3IgY29tcHV0aW5nIHRoZSBmaW5hbCBtZXJnZWQgdHJ1dGggb2Ygd2hhdFxuICAgICAqIGRvY3MgYXJlIGluIHRoZSBxdWVyeS4gSXQgZ2V0cyBub3RpZmllZCBvZiBsb2NhbCBhbmQgcmVtb3RlIGNoYW5nZXMsXG4gICAgICogYW5kIGFwcGxpZXMgdGhlIHF1ZXJ5IGZpbHRlcnMgYW5kIGxpbWl0cyB0byBkZXRlcm1pbmUgdGhlIG1vc3QgY29ycmVjdFxuICAgICAqIHBvc3NpYmxlIHJlc3VsdHMuXG4gICAgICovXG4gICAgdmlldykge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICB9XG59XG4vKiogVHJhY2tzIGEgbGltYm8gcmVzb2x1dGlvbi4gKi9cbmNsYXNzIExpbWJvUmVzb2x1dGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIHRydWUgb25jZSB3ZSd2ZSByZWNlaXZlZCBhIGRvY3VtZW50LiBUaGlzIGlzIHVzZWQgaW5cbiAgICAgICAgICogZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCgpIGFuZCB1bHRpbWF0ZWx5IHVzZWQgYnkgV2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yIHRvXG4gICAgICAgICAqIGRlY2lkZSB3aGV0aGVyIGl0IG5lZWRzIHRvIG1hbnVmYWN0dXJlIGEgZGVsZXRlIGV2ZW50IGZvciB0aGUgdGFyZ2V0IG9uY2VcbiAgICAgICAgICogdGhlIHRhcmdldCBpcyBDVVJSRU5ULlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWNlaXZlZERvY3VtZW50ID0gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgU3luY0VuZ2luZWAgY29vcmRpbmF0aW5nIHdpdGggb3RoZXIgcGFydHMgb2YgU0RLLlxuICpcbiAqIFRoZSBwYXJ0cyBvZiBTeW5jRW5naW5lIHRoYXQgYWN0IGFzIGEgY2FsbGJhY2sgdG8gUmVtb3RlU3RvcmUgbmVlZCB0byBiZVxuICogcmVnaXN0ZXJlZCBpbmRpdmlkdWFsbHkuIFRoaXMgaXMgZG9uZSBpbiBgc3luY0VuZ2luZVdyaXRlKClgIGFuZFxuICogYHN5bmNFbmdpbmVMaXN0ZW4oKWAgKGFzIHdlbGwgYXMgYGFwcGx5UHJpbWFyeVN0YXRlKClgKSBhcyB0aGVzZSBtZXRob2RzXG4gKiBzZXJ2ZSBhcyBlbnRyeSBwb2ludHMgdG8gUmVtb3RlU3RvcmUncyBmdW5jdGlvbmFsaXR5LlxuICpcbiAqIE5vdGU6IHNvbWUgZmllbGQgZGVmaW5lZCBpbiB0aGlzIGNsYXNzIG1pZ2h0IGhhdmUgcHVibGljIGFjY2VzcyBsZXZlbCwgYnV0XG4gKiB0aGUgY2xhc3MgaXMgbm90IGV4cG9ydGVkIHNvIHRoZXkgYXJlIG9ubHkgYWNjZXNzaWJsZSBmcm9tIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyB1c2VmdWwgdG8gaW1wbGVtZW50IG9wdGlvbmFsIGZlYXR1cmVzIChsaWtlIGJ1bmRsZXMpIGluIGZyZWVcbiAqIGZ1bmN0aW9ucywgc3VjaCB0aGF0IHRoZXkgYXJlIHRyZWUtc2hha2VhYmxlLlxuICovXG5jbGFzcyBTeW5jRW5naW5lSW1wbCB7XG4gICAgY29uc3RydWN0b3IobG9jYWxTdG9yZSwgcmVtb3RlU3RvcmUsIGV2ZW50TWFuYWdlciwgXG4gICAgLy8gUE9SVElORyBOT1RFOiBNYW5hZ2VzIHN0YXRlIHN5bmNocm9uaXphdGlvbiBpbiBtdWx0aS10YWIgZW52aXJvbm1lbnRzLlxuICAgIHNoYXJlZENsaWVudFN0YXRlLCBjdXJyZW50VXNlciwgbWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMpIHtcbiAgICAgICAgdGhpcy5sb2NhbFN0b3JlID0gbG9jYWxTdG9yZTtcbiAgICAgICAgdGhpcy5yZW1vdGVTdG9yZSA9IHJlbW90ZVN0b3JlO1xuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgICAgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZSA9IHNoYXJlZENsaWVudFN0YXRlO1xuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gY3VycmVudFVzZXI7XG4gICAgICAgIHRoaXMubWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMgPSBtYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9ucztcbiAgICAgICAgdGhpcy5zeW5jRW5naW5lTGlzdGVuZXIgPSB7fTtcbiAgICAgICAgdGhpcy5xdWVyeVZpZXdzQnlRdWVyeSA9IG5ldyBPYmplY3RNYXAocSA9PiBjYW5vbmlmeVF1ZXJ5KHEpLCBxdWVyeUVxdWFscyk7XG4gICAgICAgIHRoaXMucXVlcmllc0J5VGFyZ2V0ID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGtleXMgb2YgZG9jdW1lbnRzIHRoYXQgYXJlIGluIGxpbWJvIGZvciB3aGljaCB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFcbiAgICAgICAgICogbGltYm8gcmVzb2x1dGlvbiBxdWVyeS4gVGhlIHN0cmluZ3MgaW4gdGhpcyBzZXQgYXJlIHRoZSByZXN1bHQgb2YgY2FsbGluZ1xuICAgICAgICAgKiBga2V5LnBhdGguY2Fub25pY2FsU3RyaW5nKClgIHdoZXJlIGBrZXlgIGlzIGEgYERvY3VtZW50S2V5YCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBgU2V0YCB0eXBlIHdhcyBjaG9zZW4gYmVjYXVzZSBpdCBwcm92aWRlcyBlZmZpY2llbnQgbG9va3VwIGFuZCByZW1vdmFsXG4gICAgICAgICAqIG9mIGFyYml0cmFyeSBlbGVtZW50cyBhbmQgaXQgYWxzbyBtYWludGFpbnMgaW5zZXJ0aW9uIG9yZGVyLCBwcm92aWRpbmcgdGhlXG4gICAgICAgICAqIGRlc2lyZWQgcXVldWUtbGlrZSBGSUZPIHNlbWFudGljcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIHRhcmdldCBJRCBmb3IgZWFjaCBkb2N1bWVudCB0aGF0IGlzIGluIGxpbWJvIHdpdGggYW5cbiAgICAgICAgICogYWN0aXZlIHRhcmdldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGluZm9ybWF0aW9uIGFib3V0IGFuIGFjdGl2ZSBsaW1ibyByZXNvbHV0aW9uIGZvciBlYWNoXG4gICAgICAgICAqIGFjdGl2ZSB0YXJnZXQgSUQgdGhhdCB3YXMgc3RhcnRlZCBmb3IgdGhlIHB1cnBvc2Ugb2YgbGltYm8gcmVzb2x1dGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxpbWJvRG9jdW1lbnRSZWZzID0gbmV3IFJlZmVyZW5jZVNldCgpO1xuICAgICAgICAvKiogU3RvcmVzIHVzZXIgY29tcGxldGlvbiBoYW5kbGVycywgaW5kZXhlZCBieSBVc2VyIGFuZCBCYXRjaElkLiAqL1xuICAgICAgICB0aGlzLm11dGF0aW9uVXNlckNhbGxiYWNrcyA9IHt9O1xuICAgICAgICAvKiogU3RvcmVzIHVzZXIgY2FsbGJhY2tzIHdhaXRpbmcgZm9yIGFsbCBwZW5kaW5nIHdyaXRlcyB0byBiZSBhY2tub3dsZWRnZWQuICovXG4gICAgICAgIHRoaXMucGVuZGluZ1dyaXRlc0NhbGxiYWNrcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5saW1ib1RhcmdldElkR2VuZXJhdG9yID0gVGFyZ2V0SWRHZW5lcmF0b3IuZm9yU3luY0VuZ2luZSgpO1xuICAgICAgICB0aGlzLm9ubGluZVN0YXRlID0gXCJVbmtub3duXCIgLyogT25saW5lU3RhdGUuVW5rbm93biAqLztcbiAgICAgICAgLy8gVGhlIHByaW1hcnkgc3RhdGUgaXMgc2V0IHRvIGB0cnVlYCBvciBgZmFsc2VgIGltbWVkaWF0ZWx5IGFmdGVyIEZpcmVzdG9yZVxuICAgICAgICAvLyBzdGFydHVwLiBJbiB0aGUgaW50ZXJpbSwgYSBjbGllbnQgc2hvdWxkIG9ubHkgYmUgY29uc2lkZXJlZCBwcmltYXJ5IGlmXG4gICAgICAgIC8vIGBpc1ByaW1hcnlgIGlzIHRydWUuXG4gICAgICAgIHRoaXMuX2lzUHJpbWFyeUNsaWVudCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGlzUHJpbWFyeUNsaWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUHJpbWFyeUNsaWVudCA9PT0gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdTeW5jRW5naW5lKGxvY2FsU3RvcmUsIHJlbW90ZVN0b3JlLCBldmVudE1hbmFnZXIsIFxuLy8gUE9SVElORyBOT1RFOiBNYW5hZ2VzIHN0YXRlIHN5bmNocm9uaXphdGlvbiBpbiBtdWx0aS10YWIgZW52aXJvbm1lbnRzLlxuc2hhcmVkQ2xpZW50U3RhdGUsIGN1cnJlbnRVc2VyLCBtYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9ucywgaXNQcmltYXJ5KSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZSA9IG5ldyBTeW5jRW5naW5lSW1wbChsb2NhbFN0b3JlLCByZW1vdGVTdG9yZSwgZXZlbnRNYW5hZ2VyLCBzaGFyZWRDbGllbnRTdGF0ZSwgY3VycmVudFVzZXIsIG1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zKTtcbiAgICBpZiAoaXNQcmltYXJ5KSB7XG4gICAgICAgIHN5bmNFbmdpbmUuX2lzUHJpbWFyeUNsaWVudCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzeW5jRW5naW5lO1xufVxuLyoqXG4gKiBJbml0aWF0ZXMgdGhlIG5ldyBsaXN0ZW4sIHJlc29sdmVzIHByb21pc2Ugd2hlbiBsaXN0ZW4gZW5xdWV1ZWQgdG8gdGhlXG4gKiBzZXJ2ZXIuIEFsbCB0aGUgc3Vic2VxdWVudCB2aWV3IHNuYXBzaG90cyBvciBlcnJvcnMgYXJlIHNlbnQgdG8gdGhlXG4gKiBzdWJzY3JpYmVkIGhhbmRsZXJzLiBSZXR1cm5zIHRoZSBpbml0aWFsIHNuYXBzaG90LlxuICovXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lTGlzdGVuKHN5bmNFbmdpbmUsIHF1ZXJ5LCBzaG91bGRMaXN0ZW5Ub1JlbW90ZSA9IHRydWUpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGVuc3VyZVdhdGNoQ2FsbGJhY2tzKHN5bmNFbmdpbmUpO1xuICAgIGxldCB2aWV3U25hcHNob3Q7XG4gICAgY29uc3QgcXVlcnlWaWV3ID0gc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZ2V0KHF1ZXJ5KTtcbiAgICBpZiAocXVlcnlWaWV3KSB7XG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogV2l0aCBNdWx0aS1UYWIgV2ViLCBpdCBpcyBwb3NzaWJsZSB0aGF0IGEgcXVlcnkgdmlld1xuICAgICAgICAvLyBhbHJlYWR5IGV4aXN0cyB3aGVuIEV2ZW50TWFuYWdlciBjYWxscyB1cyBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXNcbiAgICAgICAgLy8gaGFwcGVucyB3aGVuIHRoZSBwcmltYXJ5IHRhYiBpcyBhbHJlYWR5IGxpc3RlbmluZyB0byB0aGlzIHF1ZXJ5IG9uXG4gICAgICAgIC8vIGJlaGFsZiBvZiBhbm90aGVyIHRhYiBhbmQgdGhlIHVzZXIgb2YgdGhlIHByaW1hcnkgYWxzbyBzdGFydHMgbGlzdGVuaW5nXG4gICAgICAgIC8vIHRvIHRoZSBxdWVyeS4gRXZlbnRNYW5hZ2VyIHdpbGwgbm90IGhhdmUgYW4gYXNzaWduZWQgdGFyZ2V0IElEIGluIHRoaXNcbiAgICAgICAgLy8gY2FzZSBhbmQgY2FsbHMgYGxpc3RlbmAgdG8gb2J0YWluIHRoaXMgSUQuXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmFkZExvY2FsUXVlcnlUYXJnZXQocXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICAgICAgdmlld1NuYXBzaG90ID0gcXVlcnlWaWV3LnZpZXcuY29tcHV0ZUluaXRpYWxTbmFwc2hvdCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlld1NuYXBzaG90ID0gYXdhaXQgYWxsb2NhdGVUYXJnZXRBbmRNYXliZUxpc3RlbihzeW5jRW5naW5lSW1wbCwgcXVlcnksIHNob3VsZExpc3RlblRvUmVtb3RlLCBcbiAgICAgICAgLyoqIHNob3VsZEluaXRpYWxpemVWaWV3PSAqLyB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdTbmFwc2hvdDtcbn1cbi8qKiBRdWVyeSBoYXMgYmVlbiBsaXN0ZW5pbmcgdG8gdGhlIGNhY2hlLCBhbmQgdHJpZXMgdG8gaW5pdGlhdGUgdGhlIHJlbW90ZSBzdG9yZSBsaXN0ZW4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRyaWdnZXJSZW1vdGVTdG9yZUxpc3RlbihzeW5jRW5naW5lLCBxdWVyeSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZW5zdXJlV2F0Y2hDYWxsYmFja3Moc3luY0VuZ2luZSk7XG4gICAgYXdhaXQgYWxsb2NhdGVUYXJnZXRBbmRNYXliZUxpc3RlbihzeW5jRW5naW5lSW1wbCwgcXVlcnksIFxuICAgIC8qKiBzaG91bGRMaXN0ZW5Ub1JlbW90ZT0gKi8gdHJ1ZSwgXG4gICAgLyoqIHNob3VsZEluaXRpYWxpemVWaWV3PSAqLyBmYWxzZSk7XG59XG5hc3luYyBmdW5jdGlvbiBhbGxvY2F0ZVRhcmdldEFuZE1heWJlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLCBxdWVyeSwgc2hvdWxkTGlzdGVuVG9SZW1vdGUsIHNob3VsZEluaXRpYWxpemVWaWV3KSB7XG4gICAgY29uc3QgdGFyZ2V0RGF0YSA9IGF3YWl0IGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBxdWVyeVRvVGFyZ2V0KHF1ZXJ5KSk7XG4gICAgY29uc3QgdGFyZ2V0SWQgPSB0YXJnZXREYXRhLnRhcmdldElkO1xuICAgIC8vIFBPUlRJTkcgTk9URTogV2hlbiB0aGUgcXVlcnkgaXMgbGlzdGVuaW5nIHRvIGNhY2hlIG9ubHksIHdlIHNraXAgc2VuZGluZyBpdCBvdmVyIHRvIFdhdGNoIGJ5XG4gICAgLy8gbm90IHJlZ2lzdGVyaW5nIGl0IGluIHNoYXJlZCBjbGllbnQgc3RhdGUsIGFuZCBkaXJlY3RseSBjYWxjdWxhdGUgaW5pdGlhbCBzbmFwc2hvdHMgYW5kXG4gICAgLy8gc3Vic2VxdWVudCB1cGRhdGVzIGZyb20gY2FjaGUuIE90aGVyd2lzZSwgcmVnaXN0ZXIgdGhlIHRhcmdldCBJRCB3aXRoIGxvY2FsIEZpcmVzdG9yZSBjbGllbnRcbiAgICAvLyBhcyBhY3RpdmUgd2F0Y2ggdGFyZ2V0LlxuICAgIGNvbnN0IHN0YXR1cyA9IHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmFkZExvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQsIFxuICAgIC8qIGFkZFRvQWN0aXZlVGFyZ2V0SWRzPSAqLyBzaG91bGRMaXN0ZW5Ub1JlbW90ZSk7XG4gICAgbGV0IHZpZXdTbmFwc2hvdDtcbiAgICBpZiAoc2hvdWxkSW5pdGlhbGl6ZVZpZXcpIHtcbiAgICAgICAgdmlld1NuYXBzaG90ID0gYXdhaXQgaW5pdGlhbGl6ZVZpZXdBbmRDb21wdXRlU25hcHNob3Qoc3luY0VuZ2luZUltcGwsIHF1ZXJ5LCB0YXJnZXRJZCwgc3RhdHVzID09PSAnY3VycmVudCcsIHRhcmdldERhdGEucmVzdW1lVG9rZW4pO1xuICAgIH1cbiAgICBpZiAoc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50ICYmIHNob3VsZExpc3RlblRvUmVtb3RlKSB7XG4gICAgICAgIHJlbW90ZVN0b3JlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0YXJnZXREYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdTbmFwc2hvdDtcbn1cbi8qKlxuICogUmVnaXN0ZXJzIGEgdmlldyBmb3IgYSBwcmV2aW91c2x5IHVua25vd24gcXVlcnkgYW5kIGNvbXB1dGVzIGl0cyBpbml0aWFsXG4gKiBzbmFwc2hvdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZVZpZXdBbmRDb21wdXRlU25hcHNob3Qoc3luY0VuZ2luZUltcGwsIHF1ZXJ5LCB0YXJnZXRJZCwgY3VycmVudCwgcmVzdW1lVG9rZW4pIHtcbiAgICAvLyBQT1JUSU5HIE5PVEU6IE9uIFdlYiBvbmx5LCB3ZSBpbmplY3QgdGhlIGNvZGUgdGhhdCByZWdpc3RlcnMgbmV3IExpbWJvXG4gICAgLy8gdGFyZ2V0cyBiYXNlZCBvbiB2aWV3IGNoYW5nZXMuIFRoaXMgYWxsb3dzIHVzIHRvIG9ubHkgZGVwZW5kIG9uIExpbWJvXG4gICAgLy8gY2hhbmdlcyB3aGVuIHVzZXIgY29kZSBpbmNsdWRlcyBxdWVyaWVzLlxuICAgIHN5bmNFbmdpbmVJbXBsLmFwcGx5RG9jQ2hhbmdlcyA9IChxdWVyeVZpZXcsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KSA9PiBhcHBseURvY0NoYW5nZXMoc3luY0VuZ2luZUltcGwsIHF1ZXJ5VmlldywgY2hhbmdlcywgcmVtb3RlRXZlbnQpO1xuICAgIGNvbnN0IHF1ZXJ5UmVzdWx0ID0gYXdhaXQgbG9jYWxTdG9yZUV4ZWN1dGVRdWVyeShzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBxdWVyeSwgXG4gICAgLyogdXNlUHJldmlvdXNSZXN1bHRzPSAqLyB0cnVlKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IFZpZXcocXVlcnksIHF1ZXJ5UmVzdWx0LnJlbW90ZUtleXMpO1xuICAgIGNvbnN0IHZpZXdEb2NDaGFuZ2VzID0gdmlldy5jb21wdXRlRG9jQ2hhbmdlcyhxdWVyeVJlc3VsdC5kb2N1bWVudHMpO1xuICAgIGNvbnN0IHN5bnRoZXNpemVkVGFyZ2V0Q2hhbmdlID0gVGFyZ2V0Q2hhbmdlLmNyZWF0ZVN5bnRoZXNpemVkVGFyZ2V0Q2hhbmdlRm9yQ3VycmVudENoYW5nZSh0YXJnZXRJZCwgY3VycmVudCAmJiBzeW5jRW5naW5lSW1wbC5vbmxpbmVTdGF0ZSAhPT0gXCJPZmZsaW5lXCIgLyogT25saW5lU3RhdGUuT2ZmbGluZSAqLywgcmVzdW1lVG9rZW4pO1xuICAgIGNvbnN0IHZpZXdDaGFuZ2UgPSB2aWV3LmFwcGx5Q2hhbmdlcyh2aWV3RG9jQ2hhbmdlcywgXG4gICAgLyogbGltYm9SZXNvbHV0aW9uRW5hYmxlZD0gKi8gc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50LCBzeW50aGVzaXplZFRhcmdldENoYW5nZSk7XG4gICAgdXBkYXRlVHJhY2tlZExpbWJvcyhzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQsIHZpZXdDaGFuZ2UubGltYm9DaGFuZ2VzKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFF1ZXJ5VmlldyhxdWVyeSwgdGFyZ2V0SWQsIHZpZXcpO1xuICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LnNldChxdWVyeSwgZGF0YSk7XG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5oYXModGFyZ2V0SWQpKSB7XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5nZXQodGFyZ2V0SWQpLnB1c2gocXVlcnkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LnNldCh0YXJnZXRJZCwgW3F1ZXJ5XSk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3Q2hhbmdlLnNuYXBzaG90O1xufVxuLyoqIFN0b3BzIGxpc3RlbmluZyB0byB0aGUgcXVlcnkuICovXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lVW5saXN0ZW4oc3luY0VuZ2luZSwgcXVlcnksIHNob3VsZFVubGlzdGVuVG9SZW1vdGUpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBjb25zdCBxdWVyeVZpZXcgPSBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5nZXQocXVlcnkpO1xuICAgIC8vIE9ubHkgY2xlYW4gdXAgdGhlIHF1ZXJ5IHZpZXcgYW5kIHRhcmdldCBpZiB0aGlzIGlzIHRoZSBvbmx5IHF1ZXJ5IG1hcHBlZFxuICAgIC8vIHRvIHRoZSB0YXJnZXQuXG4gICAgY29uc3QgcXVlcmllcyA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5nZXQocXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICBpZiAocXVlcmllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5zZXQocXVlcnlWaWV3LnRhcmdldElkLCBxdWVyaWVzLmZpbHRlcihxID0+ICFxdWVyeUVxdWFscyhxLCBxdWVyeSkpKTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZGVsZXRlKHF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBObyBvdGhlciBxdWVyaWVzIGFyZSBtYXBwZWQgdG8gdGhlIHRhcmdldCwgY2xlYW4gdXAgdGhlIHF1ZXJ5IGFuZCB0aGUgdGFyZ2V0LlxuICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZW1vdmUgdGhlIGxvY2FsIHF1ZXJ5IHRhcmdldCBmaXJzdCB0byBhbGxvdyB1cyB0byB2ZXJpZnlcbiAgICAgICAgLy8gd2hldGhlciBhbnkgb3RoZXIgY2xpZW50IGlzIHN0aWxsIGludGVyZXN0ZWQgaW4gdGhpcyB0YXJnZXQuXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnJlbW92ZUxvY2FsUXVlcnlUYXJnZXQocXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0UmVtYWluc0FjdGl2ZSA9IHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmlzQWN0aXZlUXVlcnlUYXJnZXQocXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICAgICAgaWYgKCF0YXJnZXRSZW1haW5zQWN0aXZlKSB7XG4gICAgICAgICAgICBhd2FpdCBsb2NhbFN0b3JlUmVsZWFzZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBxdWVyeVZpZXcudGFyZ2V0SWQsIFxuICAgICAgICAgICAgLyprZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YT0qLyBmYWxzZSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuY2xlYXJRdWVyeVN0YXRlKHF1ZXJ5Vmlldy50YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFVubGlzdGVuVG9SZW1vdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU3RvcmVVbmxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgcXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZUFuZENsZWFudXBUYXJnZXQoc3luY0VuZ2luZUltcGwsIHF1ZXJ5Vmlldy50YXJnZXRJZCk7XG4gICAgICAgIGF3YWl0IGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5Vmlldy50YXJnZXRJZCwgXG4gICAgICAgIC8qa2VlcFBlcnNpc3RlZFRhcmdldERhdGE9Ki8gdHJ1ZSk7XG4gICAgfVxufVxuLyoqIFVubGlzdGVucyB0byB0aGUgcmVtb3RlIHN0b3JlIHdoaWxlIHN0aWxsIGxpc3RlbmluZyB0byB0aGUgY2FjaGUuICovXG5hc3luYyBmdW5jdGlvbiB0cmlnZ2VyUmVtb3RlU3RvcmVVbmxpc3RlbihzeW5jRW5naW5lLCBxdWVyeSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGNvbnN0IHF1ZXJ5VmlldyA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmdldChxdWVyeSk7XG4gICAgY29uc3QgcXVlcmllcyA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5nZXQocXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICBpZiAoc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50ICYmIHF1ZXJpZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogVW5yZWdpc3RlciB0aGUgdGFyZ2V0IElEIHdpdGggbG9jYWwgRmlyZXN0b3JlIGNsaWVudCBhc1xuICAgICAgICAvLyB3YXRjaCB0YXJnZXQuXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnJlbW92ZUxvY2FsUXVlcnlUYXJnZXQocXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICAgICAgcmVtb3RlU3RvcmVVbmxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgcXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICB9XG59XG4vKipcbiAqIEluaXRpYXRlcyB0aGUgd3JpdGUgb2YgbG9jYWwgbXV0YXRpb24gYmF0Y2ggd2hpY2ggaW52b2x2ZXMgYWRkaW5nIHRoZVxuICogd3JpdGVzIHRvIHRoZSBtdXRhdGlvbiBxdWV1ZSwgbm90aWZ5aW5nIHRoZSByZW1vdGUgc3RvcmUgYWJvdXQgbmV3XG4gKiBtdXRhdGlvbnMgYW5kIHJhaXNpbmcgZXZlbnRzIGZvciBhbnkgY2hhbmdlcyB0aGlzIHdyaXRlIGNhdXNlZC5cbiAqXG4gKiBUaGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGlzIGNhbGwgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgYWJvdmUgc3RlcHNcbiAqIGhhdmUgY29tcGxldGVkLCAqbm90KiB3aGVuIHRoZSB3cml0ZSB3YXMgYWNrZWQgYnkgdGhlIGJhY2tlbmQuIFRoZVxuICogdXNlckNhbGxiYWNrIGlzIHJlc29sdmVkIG9uY2UgdGhlIHdyaXRlIHdhcyBhY2tlZC9yZWplY3RlZCBieSB0aGVcbiAqIGJhY2tlbmQgKG9yIGZhaWxlZCBsb2NhbGx5IGZvciBhbnkgb3RoZXIgcmVhc29uKS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZVdyaXRlKHN5bmNFbmdpbmUsIGJhdGNoLCB1c2VyQ2FsbGJhY2spIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IHN5bmNFbmdpbmVFbnN1cmVXcml0ZUNhbGxiYWNrcyhzeW5jRW5naW5lKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2NhbFN0b3JlV3JpdGVMb2NhbGx5KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIGJhdGNoKTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuYWRkUGVuZGluZ011dGF0aW9uKHJlc3VsdC5iYXRjaElkKTtcbiAgICAgICAgYWRkTXV0YXRpb25DYWxsYmFjayhzeW5jRW5naW5lSW1wbCwgcmVzdWx0LmJhdGNoSWQsIHVzZXJDYWxsYmFjayk7XG4gICAgICAgIGF3YWl0IHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmVJbXBsLCByZXN1bHQuY2hhbmdlcyk7XG4gICAgICAgIGF3YWl0IGZpbGxXcml0ZVBpcGVsaW5lKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWYgd2UgY2FuJ3QgcGVyc2lzdCB0aGUgbXV0YXRpb24sIHdlIHJlamVjdCB0aGUgdXNlciBjYWxsYmFjayBhbmRcbiAgICAgICAgLy8gZG9uJ3Qgc2VuZCB0aGUgbXV0YXRpb24uIFRoZSB1c2VyIGNhbiB0aGVuIHJldHJ5IHRoZSB3cml0ZS5cbiAgICAgICAgY29uc3QgZXJyb3IgPSB3cmFwSW5Vc2VyRXJyb3JJZlJlY292ZXJhYmxlKGUsIGBGYWlsZWQgdG8gcGVyc2lzdCB3cml0ZWApO1xuICAgICAgICB1c2VyQ2FsbGJhY2sucmVqZWN0KGVycm9yKTtcbiAgICB9XG59XG4vKipcbiAqIEFwcGxpZXMgb25lIHJlbW90ZSBldmVudCB0byB0aGUgc3luYyBlbmdpbmUsIG5vdGlmeWluZyBhbnkgdmlld3Mgb2YgdGhlXG4gKiBjaGFuZ2VzLCBhbmQgcmVsZWFzaW5nIGFueSBwZW5kaW5nIG11dGF0aW9uIGJhdGNoZXMgdGhhdCB3b3VsZCBiZWNvbWVcbiAqIHZpc2libGUgYmVjYXVzZSBvZiB0aGUgc25hcHNob3QgdmVyc2lvbiB0aGUgcmVtb3RlIGV2ZW50IGNvbnRhaW5zLlxuICovXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lQXBwbHlSZW1vdGVFdmVudChzeW5jRW5naW5lLCByZW1vdGVFdmVudCkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBhd2FpdCBsb2NhbFN0b3JlQXBwbHlSZW1vdGVFdmVudFRvTG9jYWxDYWNoZShzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCByZW1vdGVFdmVudCk7XG4gICAgICAgIC8vIFVwZGF0ZSBgcmVjZWl2ZWREb2N1bWVudGAgYXMgYXBwcm9wcmlhdGUgZm9yIGFueSBsaW1ibyB0YXJnZXRzLlxuICAgICAgICByZW1vdGVFdmVudC50YXJnZXRDaGFuZ2VzLmZvckVhY2goKHRhcmdldENoYW5nZSwgdGFyZ2V0SWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpbWJvUmVzb2x1dGlvbiA9IHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvUmVzb2x1dGlvbnNCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgaWYgKGxpbWJvUmVzb2x1dGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBsaW1ibyByZXNvbHV0aW9uIGxvb2t1cCwgaXQncyBmb3IgYSBzaW5nbGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyBhbmQgaXQgY291bGQgYmUgYWRkZWQsIG1vZGlmaWVkLCBvciByZW1vdmVkLCBidXQgbm90IGEgY29tYmluYXRpb24uXG4gICAgICAgICAgICAgICAgaGFyZEFzc2VydCh0YXJnZXRDaGFuZ2UuYWRkZWREb2N1bWVudHMuc2l6ZSArXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENoYW5nZS5tb2RpZmllZERvY3VtZW50cy5zaXplICtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLnJlbW92ZWREb2N1bWVudHMuc2l6ZSA8PVxuICAgICAgICAgICAgICAgICAgICAxKTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Q2hhbmdlLmFkZGVkRG9jdW1lbnRzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbWJvUmVzb2x1dGlvbi5yZWNlaXZlZERvY3VtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0Q2hhbmdlLm1vZGlmaWVkRG9jdW1lbnRzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQobGltYm9SZXNvbHV0aW9uLnJlY2VpdmVkRG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRDaGFuZ2UucmVtb3ZlZERvY3VtZW50cy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KGxpbWJvUmVzb2x1dGlvbi5yZWNlaXZlZERvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbGltYm9SZXNvbHV0aW9uLnJlY2VpdmVkRG9jdW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2FzIHByb2JhYmx5IGp1c3QgYSBDVVJSRU5UIHRhcmdldENoYW5nZSBvciBzaW1pbGFyLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmVJbXBsLCBjaGFuZ2VzLCByZW1vdGVFdmVudCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhd2FpdCBpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MoZXJyb3IpO1xuICAgIH1cbn1cbi8qKlxuICogQXBwbGllcyBhbiBPbmxpbmVTdGF0ZSBjaGFuZ2UgdG8gdGhlIHN5bmMgZW5naW5lIGFuZCBub3RpZmllcyBhbnkgdmlld3Mgb2ZcbiAqIHRoZSBjaGFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseU9ubGluZVN0YXRlQ2hhbmdlKHN5bmNFbmdpbmUsIG9ubGluZVN0YXRlLCBzb3VyY2UpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICAvLyBJZiB3ZSBhcmUgdGhlIHNlY29uZGFyeSBjbGllbnQsIHdlIGV4cGxpY2l0bHkgaWdub3JlIHRoZSByZW1vdGUgc3RvcmUnc1xuICAgIC8vIG9ubGluZSBzdGF0ZSAodGhlIGxvY2FsIGNsaWVudCBtYXkgZ28gb2ZmbGluZSwgZXZlbiB0aG91Z2ggdGhlIHByaW1hcnlcbiAgICAvLyB0YWIgcmVtYWlucyBvbmxpbmUpIGFuZCBvbmx5IGFwcGx5IHRoZSBwcmltYXJ5IHRhYidzIG9ubGluZSBzdGF0ZSBmcm9tXG4gICAgLy8gU2hhcmVkQ2xpZW50U3RhdGUuXG4gICAgaWYgKChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQgJiZcbiAgICAgICAgc291cmNlID09PSAwIC8qIE9ubGluZVN0YXRlU291cmNlLlJlbW90ZVN0b3JlICovKSB8fFxuICAgICAgICAoIXN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCAmJlxuICAgICAgICAgICAgc291cmNlID09PSAxIC8qIE9ubGluZVN0YXRlU291cmNlLlNoYXJlZENsaWVudFN0YXRlICovKSkge1xuICAgICAgICBjb25zdCBuZXdWaWV3U25hcHNob3RzID0gW107XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmZvckVhY2goKHF1ZXJ5LCBxdWVyeVZpZXcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdDaGFuZ2UgPSBxdWVyeVZpZXcudmlldy5hcHBseU9ubGluZVN0YXRlQ2hhbmdlKG9ubGluZVN0YXRlKTtcbiAgICAgICAgICAgIGlmICh2aWV3Q2hhbmdlLnNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgbmV3Vmlld1NuYXBzaG90cy5wdXNoKHZpZXdDaGFuZ2Uuc25hcHNob3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRNYW5hZ2VyT25PbmxpbmVTdGF0ZUNoYW5nZShzeW5jRW5naW5lSW1wbC5ldmVudE1hbmFnZXIsIG9ubGluZVN0YXRlKTtcbiAgICAgICAgaWYgKG5ld1ZpZXdTbmFwc2hvdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zeW5jRW5naW5lTGlzdGVuZXIub25XYXRjaENoYW5nZShuZXdWaWV3U25hcHNob3RzKTtcbiAgICAgICAgfVxuICAgICAgICBzeW5jRW5naW5lSW1wbC5vbmxpbmVTdGF0ZSA9IG9ubGluZVN0YXRlO1xuICAgICAgICBpZiAoc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50KSB7XG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5zZXRPbmxpbmVTdGF0ZShvbmxpbmVTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFJlamVjdHMgdGhlIGxpc3RlbiBmb3IgdGhlIGdpdmVuIHRhcmdldElELiBUaGlzIGNhbiBiZSB0cmlnZ2VyZWQgYnkgdGhlXG4gKiBiYWNrZW5kIGZvciBhbnkgYWN0aXZlIHRhcmdldC5cbiAqXG4gKiBAcGFyYW0gc3luY0VuZ2luZSAtIFRoZSBzeW5jIGVuZ2luZSBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSB0YXJnZXRJZCAtIFRoZSB0YXJnZXRJRCBjb3JyZXNwb25kcyB0byBvbmUgcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgdGhlXG4gKiB1c2VyIGFzIHBhcnQgb2YgVGFyZ2V0RGF0YSBwYXNzZWQgdG8gbGlzdGVuKCkgb24gUmVtb3RlU3RvcmUuXG4gKiBAcGFyYW0gZXJyIC0gQSBkZXNjcmlwdGlvbiBvZiB0aGUgY29uZGl0aW9uIHRoYXQgaGFzIGZvcmNlZCB0aGUgcmVqZWN0aW9uLlxuICogTmVhcmx5IGFsd2F5cyB0aGlzIHdpbGwgYmUgYW4gaW5kaWNhdGlvbiB0aGF0IHRoZSB1c2VyIGlzIG5vIGxvbmdlclxuICogYXV0aG9yaXplZCB0byBzZWUgdGhlIGRhdGEgbWF0Y2hpbmcgdGhlIHRhcmdldC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZVJlamVjdExpc3RlbihzeW5jRW5naW5lLCB0YXJnZXRJZCwgZXJyKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgLy8gUE9SVElORyBOT1RFOiBNdWx0aS10YWIgb25seS5cbiAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS51cGRhdGVRdWVyeVN0YXRlKHRhcmdldElkLCAncmVqZWN0ZWQnLCBlcnIpO1xuICAgIGNvbnN0IGxpbWJvUmVzb2x1dGlvbiA9IHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvUmVzb2x1dGlvbnNCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xuICAgIGNvbnN0IGxpbWJvS2V5ID0gbGltYm9SZXNvbHV0aW9uICYmIGxpbWJvUmVzb2x1dGlvbi5rZXk7XG4gICAgaWYgKGxpbWJvS2V5KSB7XG4gICAgICAgIC8vIFRPRE8oa2xpbXQpOiBXZSByZWFsbHkgb25seSBzaG91bGQgZG8gdGhlIGZvbGxvd2luZyBvbiBwZXJtaXNzaW9uXG4gICAgICAgIC8vIGRlbmllZCBlcnJvcnMsIGJ1dCB3ZSBkb24ndCBoYXZlIHRoZSBjYXVzZSBjb2RlIGhlcmUuXG4gICAgICAgIC8vIEl0J3MgYSBsaW1ibyBkb2MuIENyZWF0ZSBhIHN5bnRoZXRpYyBldmVudCBzYXlpbmcgaXQgd2FzIGRlbGV0ZWQuXG4gICAgICAgIC8vIFRoaXMgaXMga2luZCBvZiBhIGhhY2suIElkZWFsbHksIHdlIHdvdWxkIGhhdmUgYSBtZXRob2QgaW4gdGhlIGxvY2FsXG4gICAgICAgIC8vIHN0b3JlIHRvIHB1cmdlIGEgZG9jdW1lbnQuIEhvd2V2ZXIsIGl0IHdvdWxkIGJlIHRyaWNreSB0byBrZWVwIGFsbCBvZlxuICAgICAgICAvLyB0aGUgbG9jYWwgc3RvcmUncyBpbnZhcmlhbnRzIHdpdGggYW5vdGhlciBtZXRob2QuXG4gICAgICAgIGxldCBkb2N1bWVudFVwZGF0ZXMgPSBuZXcgU29ydGVkTWFwKERvY3VtZW50S2V5LmNvbXBhcmF0b3IpO1xuICAgICAgICAvLyBUT0RPKGIvMjE3MTg5MjE2KTogVGhpcyBsaW1ibyBkb2N1bWVudCBzaG91bGQgaWRlYWxseSBoYXZlIGEgcmVhZCB0aW1lLFxuICAgICAgICAvLyBzbyB0aGF0IGl0IGlzIHBpY2tlZCB1cCBieSBhbnkgcmVhZC10aW1lIGJhc2VkIHNjYW5zLiBUaGUgYmFja2VuZCxcbiAgICAgICAgLy8gaG93ZXZlciwgZG9lcyBub3Qgc2VuZCBhIHJlYWQgdGltZSBmb3IgdGFyZ2V0IHJlbW92YWxzLlxuICAgICAgICBkb2N1bWVudFVwZGF0ZXMgPSBkb2N1bWVudFVwZGF0ZXMuaW5zZXJ0KGxpbWJvS2V5LCBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudChsaW1ib0tleSwgU25hcHNob3RWZXJzaW9uLm1pbigpKSk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkTGltYm9Eb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpLmFkZChsaW1ib0tleSk7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IFJlbW90ZUV2ZW50KFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXG4gICAgICAgIC8qIHRhcmdldENoYW5nZXM9ICovIG5ldyBNYXAoKSwgXG4gICAgICAgIC8qIHRhcmdldE1pc21hdGNoZXM9ICovIG5ldyBTb3J0ZWRNYXAocHJpbWl0aXZlQ29tcGFyYXRvciksIGRvY3VtZW50VXBkYXRlcywgcmVzb2x2ZWRMaW1ib0RvY3VtZW50cyk7XG4gICAgICAgIGF3YWl0IHN5bmNFbmdpbmVBcHBseVJlbW90ZUV2ZW50KHN5bmNFbmdpbmVJbXBsLCBldmVudCk7XG4gICAgICAgIC8vIFNpbmNlIHRoaXMgcXVlcnkgZmFpbGVkLCB3ZSB3b24ndCB3YW50IHRvIG1hbnVhbGx5IHVubGlzdGVuIHRvIGl0LlxuICAgICAgICAvLyBXZSBvbmx5IHJlbW92ZSBpdCBmcm9tIGJvb2trZWVwaW5nIGFmdGVyIHdlIHN1Y2Nlc3NmdWxseSBhcHBsaWVkIHRoZVxuICAgICAgICAvLyBSZW1vdGVFdmVudC4gSWYgYGFwcGx5UmVtb3RlRXZlbnQoKWAgdGhyb3dzLCB3ZSB3YW50IHRvIHJlLWxpc3RlbiB0b1xuICAgICAgICAvLyB0aGlzIHF1ZXJ5IHdoZW4gdGhlIFJlbW90ZVN0b3JlIHJlc3RhcnRzIHRoZSBXYXRjaCBzdHJlYW0sIHdoaWNoIHNob3VsZFxuICAgICAgICAvLyByZS10cmlnZ2VyIHRoZSB0YXJnZXQgZmFpbHVyZS5cbiAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkgPVxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkucmVtb3ZlKGxpbWJvS2V5KTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmRlbGV0ZSh0YXJnZXRJZCk7XG4gICAgICAgIHB1bXBFbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMoc3luY0VuZ2luZUltcGwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXdhaXQgbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0SWQsIFxuICAgICAgICAvKiBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YSAqLyBmYWxzZSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHJlbW92ZUFuZENsZWFudXBUYXJnZXQoc3luY0VuZ2luZUltcGwsIHRhcmdldElkLCBlcnIpKVxuICAgICAgICAgICAgLmNhdGNoKGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUFwcGx5U3VjY2Vzc2Z1bFdyaXRlKHN5bmNFbmdpbmUsIG11dGF0aW9uQmF0Y2hSZXN1bHQpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBjb25zdCBiYXRjaElkID0gbXV0YXRpb25CYXRjaFJlc3VsdC5iYXRjaC5iYXRjaElkO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBhd2FpdCBsb2NhbFN0b3JlQWNrbm93bGVkZ2VCYXRjaChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBtdXRhdGlvbkJhdGNoUmVzdWx0KTtcbiAgICAgICAgLy8gVGhlIGxvY2FsIHN0b3JlIG1heSBvciBtYXkgbm90IGJlIGFibGUgdG8gYXBwbHkgdGhlIHdyaXRlIHJlc3VsdCBhbmRcbiAgICAgICAgLy8gcmFpc2UgZXZlbnRzIGltbWVkaWF0ZWx5IChkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgd2F0Y2hlciBpcyBjYXVnaHRcbiAgICAgICAgLy8gdXApLCBzbyB3ZSByYWlzZSB1c2VyIGNhbGxiYWNrcyBmaXJzdCBzbyB0aGF0IHRoZXkgY29uc2lzdGVudGx5IGhhcHBlblxuICAgICAgICAvLyBiZWZvcmUgbGlzdGVuIGV2ZW50cy5cbiAgICAgICAgcHJvY2Vzc1VzZXJDYWxsYmFjayhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCwgLyplcnJvcj0qLyBudWxsKTtcbiAgICAgICAgdHJpZ2dlclBlbmRpbmdXcml0ZXNDYWxsYmFja3Moc3luY0VuZ2luZUltcGwsIGJhdGNoSWQpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS51cGRhdGVNdXRhdGlvblN0YXRlKGJhdGNoSWQsICdhY2tub3dsZWRnZWQnKTtcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIGNoYW5nZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXdhaXQgaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKGVycm9yKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lUmVqZWN0RmFpbGVkV3JpdGUoc3luY0VuZ2luZSwgYmF0Y2hJZCwgZXJyb3IpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gYXdhaXQgbG9jYWxTdG9yZVJlamVjdEJhdGNoKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIGJhdGNoSWQpO1xuICAgICAgICAvLyBUaGUgbG9jYWwgc3RvcmUgbWF5IG9yIG1heSBub3QgYmUgYWJsZSB0byBhcHBseSB0aGUgd3JpdGUgcmVzdWx0IGFuZFxuICAgICAgICAvLyByYWlzZSBldmVudHMgaW1tZWRpYXRlbHkgKGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSB3YXRjaGVyIGlzIGNhdWdodCB1cCksXG4gICAgICAgIC8vIHNvIHdlIHJhaXNlIHVzZXIgY2FsbGJhY2tzIGZpcnN0IHNvIHRoYXQgdGhleSBjb25zaXN0ZW50bHkgaGFwcGVuIGJlZm9yZVxuICAgICAgICAvLyBsaXN0ZW4gZXZlbnRzLlxuICAgICAgICBwcm9jZXNzVXNlckNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkLCBlcnJvcik7XG4gICAgICAgIHRyaWdnZXJQZW5kaW5nV3JpdGVzQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkKTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUudXBkYXRlTXV0YXRpb25TdGF0ZShiYXRjaElkLCAncmVqZWN0ZWQnLCBlcnJvcik7XG4gICAgICAgIGF3YWl0IHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmVJbXBsLCBjaGFuZ2VzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGF3YWl0IGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlcnJvcik7XG4gICAgfVxufVxuLyoqXG4gKiBSZWdpc3RlcnMgYSB1c2VyIGNhbGxiYWNrIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgcGVuZGluZyBtdXRhdGlvbnMgYXQgdGhlIG1vbWVudCBvZiBjYWxsaW5nXG4gKiBhcmUgYWNrbm93bGVkZ2VkIC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZVJlZ2lzdGVyUGVuZGluZ1dyaXRlc0NhbGxiYWNrKHN5bmNFbmdpbmUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgaWYgKCFjYW5Vc2VOZXR3b3JrKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlKSkge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDMsICdUaGUgbmV0d29yayBpcyBkaXNhYmxlZC4gVGhlIHRhc2sgcmV0dXJuZWQgYnkgJyArXG4gICAgICAgICAgICBcIidhd2FpdFBlbmRpbmdXcml0ZXMoKScgd2lsbCBub3QgY29tcGxldGUgdW50aWwgdGhlIG5ldHdvcmsgaXMgZW5hYmxlZC5cIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGhpZ2hlc3RCYXRjaElkID0gYXdhaXQgbG9jYWxTdG9yZUdldEhpZ2hlc3RVbmFja25vd2xlZGdlZEJhdGNoSWQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSk7XG4gICAgICAgIGlmIChoaWdoZXN0QmF0Y2hJZCA9PT0gQkFUQ0hJRF9VTktOT1dOKSB7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBjYWxsYmFjayByaWdodCBhd2F5IGlmIHRoZXJlIGlzIG5vIHBlbmRpbmcgd3JpdGVzIGF0IHRoZSBtb21lbnQuXG4gICAgICAgICAgICBjYWxsYmFjay5yZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gc3luY0VuZ2luZUltcGwucGVuZGluZ1dyaXRlc0NhbGxiYWNrcy5nZXQoaGlnaGVzdEJhdGNoSWQpIHx8IFtdO1xuICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnBlbmRpbmdXcml0ZXNDYWxsYmFja3Muc2V0KGhpZ2hlc3RCYXRjaElkLCBjYWxsYmFja3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBmaXJlc3RvcmVFcnJvciA9IHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgJ0luaXRpYWxpemF0aW9uIG9mIHdhaXRGb3JQZW5kaW5nV3JpdGVzKCkgb3BlcmF0aW9uIGZhaWxlZCcpO1xuICAgICAgICBjYWxsYmFjay5yZWplY3QoZmlyZXN0b3JlRXJyb3IpO1xuICAgIH1cbn1cbi8qKlxuICogVHJpZ2dlcnMgdGhlIGNhbGxiYWNrcyB0aGF0IGFyZSB3YWl0aW5nIGZvciB0aGlzIGJhdGNoIGlkIHRvIGdldCBhY2tub3dsZWRnZWQgYnkgc2VydmVyLFxuICogaWYgdGhlcmUgYXJlIGFueS5cbiAqL1xuZnVuY3Rpb24gdHJpZ2dlclBlbmRpbmdXcml0ZXNDYWxsYmFja3Moc3luY0VuZ2luZUltcGwsIGJhdGNoSWQpIHtcbiAgICAoc3luY0VuZ2luZUltcGwucGVuZGluZ1dyaXRlc0NhbGxiYWNrcy5nZXQoYmF0Y2hJZCkgfHwgW10pLmZvckVhY2goY2FsbGJhY2sgPT4ge1xuICAgICAgICBjYWxsYmFjay5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgc3luY0VuZ2luZUltcGwucGVuZGluZ1dyaXRlc0NhbGxiYWNrcy5kZWxldGUoYmF0Y2hJZCk7XG59XG4vKiogUmVqZWN0IGFsbCBvdXRzdGFuZGluZyBjYWxsYmFja3Mgd2FpdGluZyBmb3IgcGVuZGluZyB3cml0ZXMgdG8gY29tcGxldGUuICovXG5mdW5jdGlvbiByZWplY3RPdXRzdGFuZGluZ1BlbmRpbmdXcml0ZXNDYWxsYmFja3Moc3luY0VuZ2luZUltcGwsIGVycm9yTWVzc2FnZSkge1xuICAgIHN5bmNFbmdpbmVJbXBsLnBlbmRpbmdXcml0ZXNDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFja3MgPT4ge1xuICAgICAgICBjYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjay5yZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuQ0FOQ0VMTEVELCBlcnJvck1lc3NhZ2UpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgc3luY0VuZ2luZUltcGwucGVuZGluZ1dyaXRlc0NhbGxiYWNrcy5jbGVhcigpO1xufVxuZnVuY3Rpb24gYWRkTXV0YXRpb25DYWxsYmFjayhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCwgY2FsbGJhY2spIHtcbiAgICBsZXQgbmV3Q2FsbGJhY2tzID0gc3luY0VuZ2luZUltcGwubXV0YXRpb25Vc2VyQ2FsbGJhY2tzW3N5bmNFbmdpbmVJbXBsLmN1cnJlbnRVc2VyLnRvS2V5KCldO1xuICAgIGlmICghbmV3Q2FsbGJhY2tzKSB7XG4gICAgICAgIG5ld0NhbGxiYWNrcyA9IG5ldyBTb3J0ZWRNYXAocHJpbWl0aXZlQ29tcGFyYXRvcik7XG4gICAgfVxuICAgIG5ld0NhbGxiYWNrcyA9IG5ld0NhbGxiYWNrcy5pbnNlcnQoYmF0Y2hJZCwgY2FsbGJhY2spO1xuICAgIHN5bmNFbmdpbmVJbXBsLm11dGF0aW9uVXNlckNhbGxiYWNrc1tzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlci50b0tleSgpXSA9XG4gICAgICAgIG5ld0NhbGxiYWNrcztcbn1cbi8qKlxuICogUmVzb2x2ZXMgb3IgcmVqZWN0cyB0aGUgdXNlciBjYWxsYmFjayBmb3IgdGhlIGdpdmVuIGJhdGNoIGFuZCB0aGVuIGRpc2NhcmRzXG4gKiBpdC5cbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1VzZXJDYWxsYmFjayhzeW5jRW5naW5lLCBiYXRjaElkLCBlcnJvcikge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGxldCBuZXdDYWxsYmFja3MgPSBzeW5jRW5naW5lSW1wbC5tdXRhdGlvblVzZXJDYWxsYmFja3Nbc3luY0VuZ2luZUltcGwuY3VycmVudFVzZXIudG9LZXkoKV07XG4gICAgLy8gTk9URTogTXV0YXRpb25zIHJlc3RvcmVkIGZyb20gcGVyc2lzdGVuY2Ugd29uJ3QgaGF2ZSBjYWxsYmFja3MsIHNvIGl0J3NcbiAgICAvLyBva2F5IGZvciB0aGVyZSB0byBiZSBubyBjYWxsYmFjayBmb3IgdGhpcyBJRC5cbiAgICBpZiAobmV3Q2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gbmV3Q2FsbGJhY2tzLmdldChiYXRjaElkKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3Q2FsbGJhY2tzID0gbmV3Q2FsbGJhY2tzLnJlbW92ZShiYXRjaElkKTtcbiAgICAgICAgfVxuICAgICAgICBzeW5jRW5naW5lSW1wbC5tdXRhdGlvblVzZXJDYWxsYmFja3Nbc3luY0VuZ2luZUltcGwuY3VycmVudFVzZXIudG9LZXkoKV0gPVxuICAgICAgICAgICAgbmV3Q2FsbGJhY2tzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUFuZENsZWFudXBUYXJnZXQoc3luY0VuZ2luZUltcGwsIHRhcmdldElkLCBlcnJvciA9IG51bGwpIHtcbiAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5yZW1vdmVMb2NhbFF1ZXJ5VGFyZ2V0KHRhcmdldElkKTtcbiAgICBmb3IgKGNvbnN0IHF1ZXJ5IG9mIHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5nZXQodGFyZ2V0SWQpKSB7XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmRlbGV0ZShxdWVyeSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuc3luY0VuZ2luZUxpc3RlbmVyLm9uV2F0Y2hFcnJvcihxdWVyeSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5kZWxldGUodGFyZ2V0SWQpO1xuICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQpIHtcbiAgICAgICAgY29uc3QgbGltYm9LZXlzID0gc3luY0VuZ2luZUltcGwubGltYm9Eb2N1bWVudFJlZnMucmVtb3ZlUmVmZXJlbmNlc0ZvcklkKHRhcmdldElkKTtcbiAgICAgICAgbGltYm9LZXlzLmZvckVhY2gobGltYm9LZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNSZWZlcmVuY2VkID0gc3luY0VuZ2luZUltcGwubGltYm9Eb2N1bWVudFJlZnMuY29udGFpbnNLZXkobGltYm9LZXkpO1xuICAgICAgICAgICAgaWYgKCFpc1JlZmVyZW5jZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSByZW1vdmVkIHRoZSBsYXN0IHJlZmVyZW5jZSBmb3IgdGhpcyBrZXlcbiAgICAgICAgICAgICAgICByZW1vdmVMaW1ib1RhcmdldChzeW5jRW5naW5lSW1wbCwgbGltYm9LZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW1vdmVMaW1ib1RhcmdldChzeW5jRW5naW5lSW1wbCwga2V5KSB7XG4gICAgc3luY0VuZ2luZUltcGwuZW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zLmRlbGV0ZShrZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKSk7XG4gICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHRoZSB0YXJnZXQgYWxyZWFkeSBnb3QgcmVtb3ZlZCBiZWNhdXNlIHRoZSBxdWVyeSBmYWlsZWQuIEluIHRoYXQgY2FzZSxcbiAgICAvLyB0aGUga2V5IHdvbid0IGV4aXN0IGluIGBsaW1ib1RhcmdldHNCeUtleWAuIE9ubHkgZG8gdGhlIGNsZWFudXAgaWYgd2Ugc3RpbGwgaGF2ZSB0aGUgdGFyZ2V0LlxuICAgIGNvbnN0IGxpbWJvVGFyZ2V0SWQgPSBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleS5nZXQoa2V5KTtcbiAgICBpZiAobGltYm9UYXJnZXRJZCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIHRhcmdldCBhbHJlYWR5IGdvdCByZW1vdmVkLCBiZWNhdXNlIHRoZSBxdWVyeSBmYWlsZWQuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVtb3RlU3RvcmVVbmxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgbGltYm9UYXJnZXRJZCk7XG4gICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkgPVxuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleS5yZW1vdmUoa2V5KTtcbiAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuZGVsZXRlKGxpbWJvVGFyZ2V0SWQpO1xuICAgIHB1bXBFbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMoc3luY0VuZ2luZUltcGwpO1xufVxuZnVuY3Rpb24gdXBkYXRlVHJhY2tlZExpbWJvcyhzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQsIGxpbWJvQ2hhbmdlcykge1xuICAgIGZvciAoY29uc3QgbGltYm9DaGFuZ2Ugb2YgbGltYm9DaGFuZ2VzKSB7XG4gICAgICAgIGlmIChsaW1ib0NoYW5nZSBpbnN0YW5jZW9mIEFkZGVkTGltYm9Eb2N1bWVudCkge1xuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwubGltYm9Eb2N1bWVudFJlZnMuYWRkUmVmZXJlbmNlKGxpbWJvQ2hhbmdlLmtleSwgdGFyZ2V0SWQpO1xuICAgICAgICAgICAgdHJhY2tMaW1ib0NoYW5nZShzeW5jRW5naW5lSW1wbCwgbGltYm9DaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbWJvQ2hhbmdlIGluc3RhbmNlb2YgUmVtb3ZlZExpbWJvRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ0RvY3VtZW50IG5vIGxvbmdlciBpbiBsaW1ibzogJyArIGxpbWJvQ2hhbmdlLmtleSk7XG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5yZW1vdmVSZWZlcmVuY2UobGltYm9DaGFuZ2Uua2V5LCB0YXJnZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBpc1JlZmVyZW5jZWQgPSBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5jb250YWluc0tleShsaW1ib0NoYW5nZS5rZXkpO1xuICAgICAgICAgICAgaWYgKCFpc1JlZmVyZW5jZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSByZW1vdmVkIHRoZSBsYXN0IHJlZmVyZW5jZSBmb3IgdGhpcyBrZXlcbiAgICAgICAgICAgICAgICByZW1vdmVMaW1ib1RhcmdldChzeW5jRW5naW5lSW1wbCwgbGltYm9DaGFuZ2Uua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZhaWwoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYWNrTGltYm9DaGFuZ2Uoc3luY0VuZ2luZUltcGwsIGxpbWJvQ2hhbmdlKSB7XG4gICAgY29uc3Qga2V5ID0gbGltYm9DaGFuZ2Uua2V5O1xuICAgIGNvbnN0IGtleVN0cmluZyA9IGtleS5wYXRoLmNhbm9uaWNhbFN0cmluZygpO1xuICAgIGlmICghc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkuZ2V0KGtleSkgJiZcbiAgICAgICAgIXN5bmNFbmdpbmVJbXBsLmVucXVldWVkTGltYm9SZXNvbHV0aW9ucy5oYXMoa2V5U3RyaW5nKSkge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDMsICdOZXcgZG9jdW1lbnQgaW4gbGltYm86ICcgKyBrZXkpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMuYWRkKGtleVN0cmluZyk7XG4gICAgICAgIHB1bXBFbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMoc3luY0VuZ2luZUltcGwpO1xuICAgIH1cbn1cbi8qKlxuICogU3RhcnRzIGxpc3RlbnMgZm9yIGRvY3VtZW50cyBpbiBsaW1ibyB0aGF0IGFyZSBlbnF1ZXVlZCBmb3IgcmVzb2x1dGlvbixcbiAqIHN1YmplY3QgdG8gYSBtYXhpbXVtIG51bWJlciBvZiBjb25jdXJyZW50IHJlc29sdXRpb25zLlxuICpcbiAqIFdpdGhvdXQgYm91bmRpbmcgdGhlIG51bWJlciBvZiBjb25jdXJyZW50IHJlc29sdXRpb25zLCB0aGUgc2VydmVyIGNhbiBmYWlsXG4gKiB3aXRoIFwicmVzb3VyY2UgZXhoYXVzdGVkXCIgZXJyb3JzIHdoaWNoIGNhbiBsZWFkIHRvIHBhdGhvbG9naWNhbCBjbGllbnRcbiAqIGJlaGF2aW9yIGFzIHNlZW4gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9pc3N1ZXMvMjY4My5cbiAqL1xuZnVuY3Rpb24gcHVtcEVucXVldWVkTGltYm9SZXNvbHV0aW9ucyhzeW5jRW5naW5lSW1wbCkge1xuICAgIHdoaWxlIChzeW5jRW5naW5lSW1wbC5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMuc2l6ZSA+IDAgJiZcbiAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkuc2l6ZSA8XG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5tYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9ucykge1xuICAgICAgICBjb25zdCBrZXlTdHJpbmcgPSBzeW5jRW5naW5lSW1wbC5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnNcbiAgICAgICAgICAgIC52YWx1ZXMoKVxuICAgICAgICAgICAgLm5leHQoKS52YWx1ZTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwuZW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zLmRlbGV0ZShrZXlTdHJpbmcpO1xuICAgICAgICBjb25zdCBrZXkgPSBuZXcgRG9jdW1lbnRLZXkoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcoa2V5U3RyaW5nKSk7XG4gICAgICAgIGNvbnN0IGxpbWJvVGFyZ2V0SWQgPSBzeW5jRW5naW5lSW1wbC5saW1ib1RhcmdldElkR2VuZXJhdG9yLm5leHQoKTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LnNldChsaW1ib1RhcmdldElkLCBuZXcgTGltYm9SZXNvbHV0aW9uKGtleSkpO1xuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleSA9XG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleS5pbnNlcnQoa2V5LCBsaW1ib1RhcmdldElkKTtcbiAgICAgICAgcmVtb3RlU3RvcmVMaXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIG5ldyBUYXJnZXREYXRhKHF1ZXJ5VG9UYXJnZXQobmV3UXVlcnlGb3JQYXRoKGtleS5wYXRoKSksIGxpbWJvVGFyZ2V0SWQsIFwiVGFyZ2V0UHVycG9zZUxpbWJvUmVzb2x1dGlvblwiIC8qIFRhcmdldFB1cnBvc2UuTGltYm9SZXNvbHV0aW9uICovLCBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZSwgY2hhbmdlcywgcmVtb3RlRXZlbnQpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBjb25zdCBuZXdTbmFwcyA9IFtdO1xuICAgIGNvbnN0IGRvY0NoYW5nZXNJbkFsbFZpZXdzID0gW107XG4gICAgY29uc3QgcXVlcmllc1Byb2Nlc3NlZCA9IFtdO1xuICAgIGlmIChzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5pc0VtcHR5KCkpIHtcbiAgICAgICAgLy8gUmV0dXJuIGVhcmx5IHNpbmNlIGBvbldhdGNoQ2hhbmdlKClgIG1pZ2h0IG5vdCBoYXZlIGJlZW4gYXNzaWduZWQgeWV0LlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmZvckVhY2goKF8sIHF1ZXJ5VmlldykgPT4ge1xuICAgICAgICBxdWVyaWVzUHJvY2Vzc2VkLnB1c2goc3luY0VuZ2luZUltcGxcbiAgICAgICAgICAgIC5hcHBseURvY0NoYW5nZXMocXVlcnlWaWV3LCBjaGFuZ2VzLCByZW1vdGVFdmVudClcbiAgICAgICAgICAgIC50aGVuKHZpZXdTbmFwc2hvdCA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgY2hhbmdlcywgb3Igd2UgYXJlIGhhbmRsaW5nIGEgZ2xvYmFsIHNuYXBzaG90LCBub3RpZnlcbiAgICAgICAgICAgIC8vIHNlY29uZGFyeSBjbGllbnRzIHRvIHVwZGF0ZSBxdWVyeSBzdGF0ZS5cbiAgICAgICAgICAgIGlmICh2aWV3U25hcHNob3QgfHwgcmVtb3RlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFF1ZXJ5IHN0YXRlIGlzIHNldCB0byBgY3VycmVudGAgaWY6XG4gICAgICAgICAgICAgICAgICAgIC8vIC0gVGhlcmUgaXMgYSB2aWV3IGNoYW5nZSBhbmQgaXQgaXMgdXAtdG8tZGF0ZSwgb3IsXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gVGhlcmUgaXMgYSBnbG9iYWwgc25hcHNob3QsIHRoZSBUYXJnZXQgaXMgY3VycmVudCwgYW5kIG5vIGNoYW5nZXMgdG8gYmUgcmVzb2x2ZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50ID0gdmlld1NuYXBzaG90XG4gICAgICAgICAgICAgICAgICAgICAgICA/ICF2aWV3U25hcHNob3QuZnJvbUNhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChfYSA9IHJlbW90ZUV2ZW50ID09PSBudWxsIHx8IHJlbW90ZUV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZW1vdGVFdmVudC50YXJnZXRDaGFuZ2VzLmdldChxdWVyeVZpZXcudGFyZ2V0SWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUudXBkYXRlUXVlcnlTdGF0ZShxdWVyeVZpZXcudGFyZ2V0SWQsIGlzQ3VycmVudCA/ICdjdXJyZW50JyA6ICdub3QtY3VycmVudCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB2aWV3cyBpZiB0aGVyZSBhcmUgYWN0dWFsIGNoYW5nZXMuXG4gICAgICAgICAgICBpZiAoISF2aWV3U25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICBuZXdTbmFwcy5wdXNoKHZpZXdTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jQ2hhbmdlcyA9IExvY2FsVmlld0NoYW5nZXMuZnJvbVNuYXBzaG90KHF1ZXJ5Vmlldy50YXJnZXRJZCwgdmlld1NuYXBzaG90KTtcbiAgICAgICAgICAgICAgICBkb2NDaGFuZ2VzSW5BbGxWaWV3cy5wdXNoKGRvY0NoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocXVlcmllc1Byb2Nlc3NlZCk7XG4gICAgc3luY0VuZ2luZUltcGwuc3luY0VuZ2luZUxpc3RlbmVyLm9uV2F0Y2hDaGFuZ2UobmV3U25hcHMpO1xuICAgIGF3YWl0IGxvY2FsU3RvcmVOb3RpZnlMb2NhbFZpZXdDaGFuZ2VzKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIGRvY0NoYW5nZXNJbkFsbFZpZXdzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5RG9jQ2hhbmdlcyhzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3LCBjaGFuZ2VzLCByZW1vdGVFdmVudCkge1xuICAgIGxldCB2aWV3RG9jQ2hhbmdlcyA9IHF1ZXJ5Vmlldy52aWV3LmNvbXB1dGVEb2NDaGFuZ2VzKGNoYW5nZXMpO1xuICAgIGlmICh2aWV3RG9jQ2hhbmdlcy5uZWVkc1JlZmlsbCkge1xuICAgICAgICAvLyBUaGUgcXVlcnkgaGFzIGEgbGltaXQgYW5kIHNvbWUgZG9jcyB3ZXJlIHJlbW92ZWQsIHNvIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gcmUtcnVuIHRoZSBxdWVyeSBhZ2FpbnN0IHRoZSBsb2NhbCBzdG9yZSB0byBtYWtlIHN1cmUgd2VcbiAgICAgICAgLy8gZGlkbid0IGxvc2UgYW55IGdvb2QgZG9jcyB0aGF0IGhhZCBiZWVuIHBhc3QgdGhlIGxpbWl0LlxuICAgICAgICB2aWV3RG9jQ2hhbmdlcyA9IGF3YWl0IGxvY2FsU3RvcmVFeGVjdXRlUXVlcnkoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcXVlcnlWaWV3LnF1ZXJ5LCBcbiAgICAgICAgLyogdXNlUHJldmlvdXNSZXN1bHRzPSAqLyBmYWxzZSkudGhlbigoeyBkb2N1bWVudHMgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5Vmlldy52aWV3LmNvbXB1dGVEb2NDaGFuZ2VzKGRvY3VtZW50cywgdmlld0RvY0NoYW5nZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0Q2hhbmdlID0gcmVtb3RlRXZlbnQgJiYgcmVtb3RlRXZlbnQudGFyZ2V0Q2hhbmdlcy5nZXQocXVlcnlWaWV3LnRhcmdldElkKTtcbiAgICBjb25zdCB0YXJnZXRJc1BlbmRpbmdSZXNldCA9IHJlbW90ZUV2ZW50ICYmIHJlbW90ZUV2ZW50LnRhcmdldE1pc21hdGNoZXMuZ2V0KHF1ZXJ5Vmlldy50YXJnZXRJZCkgIT0gbnVsbDtcbiAgICBjb25zdCB2aWV3Q2hhbmdlID0gcXVlcnlWaWV3LnZpZXcuYXBwbHlDaGFuZ2VzKHZpZXdEb2NDaGFuZ2VzLCBcbiAgICAvKiBsaW1ib1Jlc29sdXRpb25FbmFibGVkPSAqLyBzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQsIHRhcmdldENoYW5nZSwgdGFyZ2V0SXNQZW5kaW5nUmVzZXQpO1xuICAgIHVwZGF0ZVRyYWNrZWRMaW1ib3Moc3luY0VuZ2luZUltcGwsIHF1ZXJ5Vmlldy50YXJnZXRJZCwgdmlld0NoYW5nZS5saW1ib0NoYW5nZXMpO1xuICAgIHJldHVybiB2aWV3Q2hhbmdlLnNuYXBzaG90O1xufVxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUhhbmRsZUNyZWRlbnRpYWxDaGFuZ2Uoc3luY0VuZ2luZSwgdXNlcikge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGNvbnN0IHVzZXJDaGFuZ2VkID0gIXN5bmNFbmdpbmVJbXBsLmN1cnJlbnRVc2VyLmlzRXF1YWwodXNlcik7XG4gICAgaWYgKHVzZXJDaGFuZ2VkKSB7XG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ1VzZXIgY2hhbmdlLiBOZXcgdXNlcjonLCB1c2VyLnRvS2V5KCkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2NhbFN0b3JlSGFuZGxlVXNlckNoYW5nZShzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB1c2VyKTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwuY3VycmVudFVzZXIgPSB1c2VyO1xuICAgICAgICAvLyBGYWlscyB0YXNrcyB3YWl0aW5nIGZvciBwZW5kaW5nIHdyaXRlcyByZXF1ZXN0ZWQgYnkgcHJldmlvdXMgdXNlci5cbiAgICAgICAgcmVqZWN0T3V0c3RhbmRpbmdQZW5kaW5nV3JpdGVzQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsLCBcIid3YWl0Rm9yUGVuZGluZ1dyaXRlcycgcHJvbWlzZSBpcyByZWplY3RlZCBkdWUgdG8gYSB1c2VyIGNoYW5nZS5cIik7XG4gICAgICAgIC8vIFRPRE8oYi8xMTQyMjY0MTcpOiBDb25zaWRlciBjYWxsaW5nIHRoaXMgb25seSBpbiB0aGUgcHJpbWFyeSB0YWIuXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmhhbmRsZVVzZXJDaGFuZ2UodXNlciwgcmVzdWx0LnJlbW92ZWRCYXRjaElkcywgcmVzdWx0LmFkZGVkQmF0Y2hJZHMpO1xuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lSW1wbCwgcmVzdWx0LmFmZmVjdGVkRG9jdW1lbnRzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzeW5jRW5naW5lR2V0UmVtb3RlS2V5c0ZvclRhcmdldChzeW5jRW5naW5lLCB0YXJnZXRJZCkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIGNvbnN0IGxpbWJvUmVzb2x1dGlvbiA9IHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvUmVzb2x1dGlvbnNCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xuICAgIGlmIChsaW1ib1Jlc29sdXRpb24gJiYgbGltYm9SZXNvbHV0aW9uLnJlY2VpdmVkRG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50S2V5U2V0KCkuYWRkKGxpbWJvUmVzb2x1dGlvbi5rZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGtleVNldCA9IGRvY3VtZW50S2V5U2V0KCk7XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuZ2V0KHRhcmdldElkKTtcbiAgICAgICAgaWYgKCFxdWVyaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5U2V0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcXVlcnkgb2YgcXVlcmllcykge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlWaWV3ID0gc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuZ2V0KHF1ZXJ5KTtcbiAgICAgICAgICAgIGtleVNldCA9IGtleVNldC51bmlvbldpdGgocXVlcnlWaWV3LnZpZXcuc3luY2VkRG9jdW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5U2V0O1xuICAgIH1cbn1cbi8qKlxuICogUmVjb25jaWxlIHRoZSBsaXN0IG9mIHN5bmNlZCBkb2N1bWVudHMgaW4gYW4gZXhpc3RpbmcgdmlldyB3aXRoIHRob3NlXG4gKiBmcm9tIHBlcnNpc3RlbmNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzeW5jaHJvbml6ZVZpZXdBbmRDb21wdXRlU25hcHNob3Qoc3luY0VuZ2luZSwgcXVlcnlWaWV3KSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgY29uc3QgcXVlcnlSZXN1bHQgPSBhd2FpdCBsb2NhbFN0b3JlRXhlY3V0ZVF1ZXJ5KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5Vmlldy5xdWVyeSwgXG4gICAgLyogdXNlUHJldmlvdXNSZXN1bHRzPSAqLyB0cnVlKTtcbiAgICBjb25zdCB2aWV3U25hcHNob3QgPSBxdWVyeVZpZXcudmlldy5zeW5jaHJvbml6ZVdpdGhQZXJzaXN0ZWRTdGF0ZShxdWVyeVJlc3VsdCk7XG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCkge1xuICAgICAgICB1cGRhdGVUcmFja2VkTGltYm9zKHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcudGFyZ2V0SWQsIHZpZXdTbmFwc2hvdC5saW1ib0NoYW5nZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdmlld1NuYXBzaG90O1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgbmV3bHkgY2hhbmdlZCBkb2N1bWVudHMgZnJvbSByZW1vdGUgZG9jdW1lbnQgY2FjaGUgYW5kIHJhaXNlc1xuICogc25hcHNob3RzIGlmIG5lZWRlZC5cbiAqL1xuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVTeW5jaHJvbml6ZVdpdGhDaGFuZ2VkRG9jdW1lbnRzKHN5bmNFbmdpbmUsIGNvbGxlY3Rpb25Hcm91cCkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlR2V0TmV3RG9jdW1lbnRDaGFuZ2VzKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIGNvbGxlY3Rpb25Hcm91cCkudGhlbihjaGFuZ2VzID0+IHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmVJbXBsLCBjaGFuZ2VzKSk7XG59XG4vKiogQXBwbGllcyBhIG11dGF0aW9uIHN0YXRlIHRvIGFuIGV4aXN0aW5nIGJhdGNoLiAgKi9cbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lQXBwbHlCYXRjaFN0YXRlKHN5bmNFbmdpbmUsIGJhdGNoSWQsIGJhdGNoU3RhdGUsIGVycm9yKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgY29uc3QgZG9jdW1lbnRzID0gYXdhaXQgbG9jYWxTdG9yZUxvb2t1cE11dGF0aW9uRG9jdW1lbnRzKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIGJhdGNoSWQpO1xuICAgIGlmIChkb2N1bWVudHMgPT09IG51bGwpIHtcbiAgICAgICAgLy8gQSB0aHJvdHRsZWQgdGFiIG1heSBub3QgaGF2ZSBzZWVuIHRoZSBtdXRhdGlvbiBiZWZvcmUgaXQgd2FzIGNvbXBsZXRlZFxuICAgICAgICAvLyBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBtdXRhdGlvbiBxdWV1ZSwgaW4gd2hpY2ggY2FzZSB3ZSB3b24ndCBoYXZlIGNhY2hlZFxuICAgICAgICAvLyB0aGUgYWZmZWN0ZWQgZG9jdW1lbnRzLiBJbiB0aGlzIGNhc2Ugd2UgY2FuIHNhZmVseSBpZ25vcmUgdGhlIHVwZGF0ZVxuICAgICAgICAvLyBzaW5jZSB0aGF0IG1lYW5zIHdlIGRpZG4ndCBhcHBseSB0aGUgbXV0YXRpb24gbG9jYWxseSBhdCBhbGwgKGlmIHdlXG4gICAgICAgIC8vIGhhZCwgd2Ugd291bGQgaGF2ZSBjYWNoZWQgdGhlIGFmZmVjdGVkIGRvY3VtZW50cyksIGFuZCBzbyB3ZSB3aWxsIGp1c3RcbiAgICAgICAgLy8gc2VlIGFueSByZXN1bHRpbmcgZG9jdW1lbnQgY2hhbmdlcyB2aWEgbm9ybWFsIHJlbW90ZSBkb2N1bWVudCB1cGRhdGVzXG4gICAgICAgIC8vIGFzIGFwcGxpY2FibGUuXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ0Nhbm5vdCBhcHBseSBtdXRhdGlvbiBiYXRjaCB3aXRoIGlkOiAnICsgYmF0Y2hJZCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGJhdGNoU3RhdGUgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgdGhlIHByaW1hcnkgY2xpZW50LCB3ZSBuZWVkIHRvIHNlbmQgdGhpcyB3cml0ZSB0byB0aGVcbiAgICAgICAgLy8gYmFja2VuZC4gU2Vjb25kYXJ5IGNsaWVudHMgd2lsbCBpZ25vcmUgdGhlc2Ugd3JpdGVzIHNpbmNlIHRoZWlyIHJlbW90ZVxuICAgICAgICAvLyBjb25uZWN0aW9uIGlzIGRpc2FibGVkLlxuICAgICAgICBhd2FpdCBmaWxsV3JpdGVQaXBlbGluZShzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJhdGNoU3RhdGUgPT09ICdhY2tub3dsZWRnZWQnIHx8IGJhdGNoU3RhdGUgPT09ICdyZWplY3RlZCcpIHtcbiAgICAgICAgLy8gTk9URTogQm90aCB0aGVzZSBtZXRob2RzIGFyZSBuby1vcHMgZm9yIGJhdGNoZXMgdGhhdCBvcmlnaW5hdGVkIGZyb21cbiAgICAgICAgLy8gb3RoZXIgY2xpZW50cy5cbiAgICAgICAgcHJvY2Vzc1VzZXJDYWxsYmFjayhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCwgZXJyb3IgPyBlcnJvciA6IG51bGwpO1xuICAgICAgICB0cmlnZ2VyUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCk7XG4gICAgICAgIGxvY2FsU3RvcmVSZW1vdmVDYWNoZWRNdXRhdGlvbkJhdGNoTWV0YWRhdGEoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgYmF0Y2hJZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmYWlsKCk7XG4gICAgfVxuICAgIGF3YWl0IHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmVJbXBsLCBkb2N1bWVudHMpO1xufVxuLyoqIEFwcGxpZXMgYSBxdWVyeSB0YXJnZXQgY2hhbmdlIGZyb20gYSBkaWZmZXJlbnQgdGFiLiAqL1xuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseVByaW1hcnlTdGF0ZShzeW5jRW5naW5lLCBpc1ByaW1hcnkpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBlbnN1cmVXYXRjaENhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCk7XG4gICAgc3luY0VuZ2luZUVuc3VyZVdyaXRlQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsKTtcbiAgICBpZiAoaXNQcmltYXJ5ID09PSB0cnVlICYmIHN5bmNFbmdpbmVJbXBsLl9pc1ByaW1hcnlDbGllbnQgIT09IHRydWUpIHtcbiAgICAgICAgLy8gU2Vjb25kYXJ5IHRhYnMgb25seSBtYWludGFpbiBWaWV3cyBmb3IgdGhlaXIgbG9jYWwgbGlzdGVuZXJzIGFuZCB0aGVcbiAgICAgICAgLy8gVmlld3MgaW50ZXJuYWwgc3RhdGUgbWF5IG5vdCBiZSAxMDAlIHBvcHVsYXRlZCAoaW4gcGFydGljdWxhclxuICAgICAgICAvLyBzZWNvbmRhcnkgdGFicyBkb24ndCB0cmFjayBzeW5jZWREb2N1bWVudHMsIHRoZSBzZXQgb2YgZG9jdW1lbnRzIHRoZVxuICAgICAgICAvLyBzZXJ2ZXIgY29uc2lkZXJzIHRvIGJlIGluIHRoZSB0YXJnZXQpLiBTbyB3aGVuIGEgc2Vjb25kYXJ5IGJlY29tZXNcbiAgICAgICAgLy8gcHJpbWFyeSwgd2UgbmVlZCB0byBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCB2aWV3cyBmb3IgYWxsIHRhcmdldHNcbiAgICAgICAgLy8gbWF0Y2ggdGhlIHN0YXRlIG9uIGRpc2suXG4gICAgICAgIGNvbnN0IGFjdGl2ZVRhcmdldHMgPSBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5nZXRBbGxBY3RpdmVRdWVyeVRhcmdldHMoKTtcbiAgICAgICAgY29uc3QgYWN0aXZlUXVlcmllcyA9IGF3YWl0IHN5bmNocm9uaXplUXVlcnlWaWV3c0FuZFJhaXNlU25hcHNob3RzKHN5bmNFbmdpbmVJbXBsLCBhY3RpdmVUYXJnZXRzLnRvQXJyYXkoKSk7XG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLl9pc1ByaW1hcnlDbGllbnQgPSB0cnVlO1xuICAgICAgICBhd2FpdCByZW1vdGVTdG9yZUFwcGx5UHJpbWFyeVN0YXRlKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0cnVlKTtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXREYXRhIG9mIGFjdGl2ZVF1ZXJpZXMpIHtcbiAgICAgICAgICAgIHJlbW90ZVN0b3JlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0YXJnZXREYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1ByaW1hcnkgPT09IGZhbHNlICYmIHN5bmNFbmdpbmVJbXBsLl9pc1ByaW1hcnlDbGllbnQgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVRhcmdldHMgPSBbXTtcbiAgICAgICAgbGV0IHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmZvckVhY2goKF8sIHRhcmdldElkKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuaXNMb2NhbFF1ZXJ5VGFyZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZVRhcmdldHMucHVzaCh0YXJnZXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwID0gcC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0SWQsIFxuICAgICAgICAgICAgICAgICAgICAvKmtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhPSovIHRydWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3RlU3RvcmVVbmxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgdGFyZ2V0SWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcDtcbiAgICAgICAgYXdhaXQgc3luY2hyb25pemVRdWVyeVZpZXdzQW5kUmFpc2VTbmFwc2hvdHMoc3luY0VuZ2luZUltcGwsIGFjdGl2ZVRhcmdldHMpO1xuICAgICAgICByZXNldExpbWJvRG9jdW1lbnRzKHN5bmNFbmdpbmVJbXBsKTtcbiAgICAgICAgc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCA9IGZhbHNlO1xuICAgICAgICBhd2FpdCByZW1vdGVTdG9yZUFwcGx5UHJpbWFyeVN0YXRlKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCBmYWxzZSk7XG4gICAgfVxufVxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmZ1bmN0aW9uIHJlc2V0TGltYm9Eb2N1bWVudHMoc3luY0VuZ2luZSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvUmVzb2x1dGlvbnNCeVRhcmdldC5mb3JFYWNoKChfLCB0YXJnZXRJZCkgPT4ge1xuICAgICAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0YXJnZXRJZCk7XG4gICAgfSk7XG4gICAgc3luY0VuZ2luZUltcGwubGltYm9Eb2N1bWVudFJlZnMucmVtb3ZlQWxsUmVmZXJlbmNlcygpO1xuICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvUmVzb2x1dGlvbnNCeVRhcmdldCA9IG5ldyBNYXAoKTtcbiAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleSA9IG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XG59XG4vKipcbiAqIFJlY29uY2lsZSB0aGUgcXVlcnkgdmlld3Mgb2YgdGhlIHByb3ZpZGVkIHF1ZXJ5IHRhcmdldHMgd2l0aCB0aGUgc3RhdGUgZnJvbVxuICogcGVyc2lzdGVuY2UuIFJhaXNlcyBzbmFwc2hvdHMgZm9yIGFueSBjaGFuZ2VzIHRoYXQgYWZmZWN0IHRoZSBsb2NhbFxuICogY2xpZW50IGFuZCByZXR1cm5zIHRoZSB1cGRhdGVkIHN0YXRlIG9mIGFsbCB0YXJnZXQncyBxdWVyeSBkYXRhLlxuICpcbiAqIEBwYXJhbSBzeW5jRW5naW5lIC0gVGhlIHN5bmMgZW5naW5lIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0gdGFyZ2V0cyAtIHRoZSBsaXN0IG9mIHRhcmdldHMgd2l0aCB2aWV3cyB0aGF0IG5lZWQgdG8gYmUgcmVjb21wdXRlZFxuICogQHBhcmFtIHRyYW5zaXRpb25Ub1ByaW1hcnkgLSBgdHJ1ZWAgaWZmIHRoZSB0YWIgdHJhbnNpdGlvbnMgZnJvbSBhIHNlY29uZGFyeVxuICogdGFiIHRvIGEgcHJpbWFyeSB0YWJcbiAqL1xuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmFzeW5jIGZ1bmN0aW9uIHN5bmNocm9uaXplUXVlcnlWaWV3c0FuZFJhaXNlU25hcHNob3RzKHN5bmNFbmdpbmUsIHRhcmdldHMsIHRyYW5zaXRpb25Ub1ByaW1hcnkpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBjb25zdCBhY3RpdmVRdWVyaWVzID0gW107XG4gICAgY29uc3QgbmV3Vmlld1NuYXBzaG90cyA9IFtdO1xuICAgIGZvciAoY29uc3QgdGFyZ2V0SWQgb2YgdGFyZ2V0cykge1xuICAgICAgICBsZXQgdGFyZ2V0RGF0YTtcbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xuICAgICAgICBpZiAocXVlcmllcyAmJiBxdWVyaWVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgLy8gRm9yIHF1ZXJpZXMgdGhhdCBoYXZlIGEgbG9jYWwgVmlldywgd2UgZmV0Y2ggdGhlaXIgY3VycmVudCBzdGF0ZVxuICAgICAgICAgICAgLy8gZnJvbSBMb2NhbFN0b3JlIChhcyB0aGUgcmVzdW1lIHRva2VuIGFuZCB0aGUgc25hcHNob3QgdmVyc2lvblxuICAgICAgICAgICAgLy8gbWlnaHQgaGF2ZSBjaGFuZ2VkKSBhbmQgcmVjb25jaWxlIHRoZWlyIHZpZXdzIHdpdGggdGhlIHBlcnNpc3RlZFxuICAgICAgICAgICAgLy8gc3RhdGUgKHRoZSBsaXN0IG9mIHN5bmNlZERvY3VtZW50cyBtYXkgaGF2ZSBnb3R0ZW4gb3V0IG9mIHN5bmMpLlxuICAgICAgICAgICAgdGFyZ2V0RGF0YSA9IGF3YWl0IGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBxdWVyeVRvVGFyZ2V0KHF1ZXJpZXNbMF0pKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcXVlcnkgb2YgcXVlcmllcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXJ5VmlldyA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmdldChxdWVyeSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld0NoYW5nZSA9IGF3YWl0IHN5bmNocm9uaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3KTtcbiAgICAgICAgICAgICAgICBpZiAodmlld0NoYW5nZS5zbmFwc2hvdCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdWaWV3U25hcHNob3RzLnB1c2godmlld0NoYW5nZS5zbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIHF1ZXJpZXMgdGhhdCBuZXZlciBleGVjdXRlZCBvbiB0aGlzIGNsaWVudCwgd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gYWxsb2NhdGUgdGhlIHRhcmdldCBpbiBMb2NhbFN0b3JlIGFuZCBpbml0aWFsaXplIGEgbmV3IFZpZXcuXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBhd2FpdCBsb2NhbFN0b3JlR2V0Q2FjaGVkVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHRhcmdldElkKTtcbiAgICAgICAgICAgIHRhcmdldERhdGEgPSBhd2FpdCBsb2NhbFN0b3JlQWxsb2NhdGVUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgIGF3YWl0IGluaXRpYWxpemVWaWV3QW5kQ29tcHV0ZVNuYXBzaG90KHN5bmNFbmdpbmVJbXBsLCBzeW50aGVzaXplVGFyZ2V0VG9RdWVyeSh0YXJnZXQpLCB0YXJnZXRJZCwgXG4gICAgICAgICAgICAvKmN1cnJlbnQ9Ki8gZmFsc2UsIHRhcmdldERhdGEucmVzdW1lVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZVF1ZXJpZXMucHVzaCh0YXJnZXREYXRhKTtcbiAgICB9XG4gICAgc3luY0VuZ2luZUltcGwuc3luY0VuZ2luZUxpc3RlbmVyLm9uV2F0Y2hDaGFuZ2UobmV3Vmlld1NuYXBzaG90cyk7XG4gICAgcmV0dXJuIGFjdGl2ZVF1ZXJpZXM7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUXVlcnlgIG9iamVjdCBmcm9tIHRoZSBzcGVjaWZpZWQgYFRhcmdldGAuIFRoZXJlIGlzIG5vIHdheSB0b1xuICogb2J0YWluIHRoZSBvcmlnaW5hbCBgUXVlcnlgLCBzbyB3ZSBzeW50aGVzaXplIGEgYFF1ZXJ5YCBmcm9tIHRoZSBgVGFyZ2V0YFxuICogb2JqZWN0LlxuICpcbiAqIFRoZSBzeW50aGVzaXplZCByZXN1bHQgbWlnaHQgYmUgZGlmZmVyZW50IGZyb20gdGhlIG9yaWdpbmFsIGBRdWVyeWAsIGJ1dFxuICogc2luY2UgdGhlIHN5bnRoZXNpemVkIGBRdWVyeWAgc2hvdWxkIHJldHVybiB0aGUgc2FtZSByZXN1bHRzIGFzIHRoZVxuICogb3JpZ2luYWwgb25lIChvbmx5IHRoZSBwcmVzZW50YXRpb24gb2YgcmVzdWx0cyBtaWdodCBkaWZmZXIpLCB0aGUgcG90ZW50aWFsXG4gKiBkaWZmZXJlbmNlIHdpbGwgbm90IGNhdXNlIGlzc3Vlcy5cbiAqL1xuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cbmZ1bmN0aW9uIHN5bnRoZXNpemVUYXJnZXRUb1F1ZXJ5KHRhcmdldCkge1xuICAgIHJldHVybiBuZXdRdWVyeSh0YXJnZXQucGF0aCwgdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCwgdGFyZ2V0Lm9yZGVyQnksIHRhcmdldC5maWx0ZXJzLCB0YXJnZXQubGltaXQsIFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqLywgdGFyZ2V0LnN0YXJ0QXQsIHRhcmdldC5lbmRBdCk7XG59XG4vKiogUmV0dXJucyB0aGUgSURzIG9mIHRoZSBjbGllbnRzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUuICovXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxuZnVuY3Rpb24gc3luY0VuZ2luZUdldEFjdGl2ZUNsaWVudHMoc3luY0VuZ2luZSkge1xuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xuICAgIHJldHVybiBsb2NhbFN0b3JlR2V0QWN0aXZlQ2xpZW50cyhzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlKTtcbn1cbi8qKiBBcHBsaWVzIGEgcXVlcnkgdGFyZ2V0IGNoYW5nZSBmcm9tIGEgZGlmZmVyZW50IHRhYi4gKi9cbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lQXBwbHlUYXJnZXRTdGF0ZShzeW5jRW5naW5lLCB0YXJnZXRJZCwgc3RhdGUsIGVycm9yKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLl9pc1ByaW1hcnlDbGllbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgcmVjZWl2ZSBhIHRhcmdldCBzdGF0ZSBub3RpZmljYXRpb24gdmlhIFdlYlN0b3JhZ2UsIHdlIGFyZVxuICAgICAgICAvLyBlaXRoZXIgYWxyZWFkeSBzZWNvbmRhcnkgb3IgYW5vdGhlciB0YWIgaGFzIHRha2VuIHRoZSBwcmltYXJ5IGxlYXNlLlxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDMsICdJZ25vcmluZyB1bmV4cGVjdGVkIHF1ZXJ5IHN0YXRlIG5vdGlmaWNhdGlvbi4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeSA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5nZXQodGFyZ2V0SWQpO1xuICAgIGlmIChxdWVyeSAmJiBxdWVyeS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2N1cnJlbnQnOlxuICAgICAgICAgICAgY2FzZSAnbm90LWN1cnJlbnQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGF3YWl0IGxvY2FsU3RvcmVHZXROZXdEb2N1bWVudENoYW5nZXMoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcXVlcnlDb2xsZWN0aW9uR3JvdXAocXVlcnlbMF0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW50aGVzaXplZFJlbW90ZUV2ZW50ID0gUmVtb3RlRXZlbnQuY3JlYXRlU3ludGhlc2l6ZWRSZW1vdGVFdmVudEZvckN1cnJlbnRDaGFuZ2UodGFyZ2V0SWQsIHN0YXRlID09PSAnY3VycmVudCcsIEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmVJbXBsLCBjaGFuZ2VzLCBzeW50aGVzaXplZFJlbW90ZUV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzoge1xuICAgICAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHRhcmdldElkLCBcbiAgICAgICAgICAgICAgICAvKiBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YSAqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICByZW1vdmVBbmRDbGVhbnVwVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBmYWlsKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogQWRkcyBvciByZW1vdmVzIFdhdGNoIHRhcmdldHMgZm9yIHF1ZXJpZXMgZnJvbSBkaWZmZXJlbnQgdGFicy4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseUFjdGl2ZVRhcmdldHNDaGFuZ2Uoc3luY0VuZ2luZSwgYWRkZWQsIHJlbW92ZWQpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGVuc3VyZVdhdGNoQ2FsbGJhY2tzKHN5bmNFbmdpbmUpO1xuICAgIGlmICghc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgdGFyZ2V0SWQgb2YgYWRkZWQpIHtcbiAgICAgICAgLy8gQSB0YXJnZXQgaXMgYWxyZWFkeSBsaXN0ZW5pbmcgdG8gcmVtb3RlIHN0b3JlIGlmIGl0IGlzIGFscmVhZHkgcmVnaXN0ZXJlZCB0b1xuICAgICAgICAvLyBzaGFyZWRDbGllbnRTdGF0ZS5cbiAgICAgICAgY29uc3QgdGFyZ2V0QWxyZWFkeUxpc3RlbmluZ1RvUmVtb3RlU3RvcmUgPSBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuaGFzKHRhcmdldElkKSAmJlxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuaXNBY3RpdmVRdWVyeVRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgIGlmICh0YXJnZXRBbHJlYWR5TGlzdGVuaW5nVG9SZW1vdGVTdG9yZSkge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnQWRkaW5nIGFuIGFscmVhZHkgYWN0aXZlIHRhcmdldCAnICsgdGFyZ2V0SWQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXdhaXQgbG9jYWxTdG9yZUdldENhY2hlZFRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXRJZCk7XG4gICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSBhd2FpdCBsb2NhbFN0b3JlQWxsb2NhdGVUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0KTtcbiAgICAgICAgYXdhaXQgaW5pdGlhbGl6ZVZpZXdBbmRDb21wdXRlU25hcHNob3Qoc3luY0VuZ2luZUltcGwsIHN5bnRoZXNpemVUYXJnZXRUb1F1ZXJ5KHRhcmdldCksIHRhcmdldERhdGEudGFyZ2V0SWQsIFxuICAgICAgICAvKmN1cnJlbnQ9Ki8gZmFsc2UsIHRhcmdldERhdGEucmVzdW1lVG9rZW4pO1xuICAgICAgICByZW1vdGVTdG9yZUxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgdGFyZ2V0RGF0YSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdGFyZ2V0SWQgb2YgcmVtb3ZlZCkge1xuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSB0YXJnZXQgaXMgc3RpbGwgYWN0aXZlIHNpbmNlIHRoZSB0YXJnZXQgbWlnaHQgaGF2ZSBiZWVuXG4gICAgICAgIC8vIHJlbW92ZWQgaWYgaXQgaGFzIGJlZW4gcmVqZWN0ZWQgYnkgdGhlIGJhY2tlbmQuXG4gICAgICAgIGlmICghc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0Lmhhcyh0YXJnZXRJZCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbGVhc2UgcXVlcmllcyB0aGF0IGFyZSBzdGlsbCBhY3RpdmUuXG4gICAgICAgIGF3YWl0IGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHRhcmdldElkLCBcbiAgICAgICAgLyoga2VlcFBlcnNpc3RlZFRhcmdldERhdGEgKi8gZmFsc2UpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0YXJnZXRJZCk7XG4gICAgICAgICAgICByZW1vdmVBbmRDbGVhbnVwVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnN1cmVXYXRjaENhbGxiYWNrcyhzeW5jRW5naW5lKSB7XG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XG4gICAgc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUucmVtb3RlU3luY2VyLmFwcGx5UmVtb3RlRXZlbnQgPVxuICAgICAgICBzeW5jRW5naW5lQXBwbHlSZW1vdGVFdmVudC5iaW5kKG51bGwsIHN5bmNFbmdpbmVJbXBsKTtcbiAgICBzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCA9XG4gICAgICAgIHN5bmNFbmdpbmVHZXRSZW1vdGVLZXlzRm9yVGFyZ2V0LmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwpO1xuICAgIHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLnJlbW90ZVN5bmNlci5yZWplY3RMaXN0ZW4gPVxuICAgICAgICBzeW5jRW5naW5lUmVqZWN0TGlzdGVuLmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwpO1xuICAgIHN5bmNFbmdpbmVJbXBsLnN5bmNFbmdpbmVMaXN0ZW5lci5vbldhdGNoQ2hhbmdlID1cbiAgICAgICAgZXZlbnRNYW5hZ2VyT25XYXRjaENoYW5nZS5iaW5kKG51bGwsIHN5bmNFbmdpbmVJbXBsLmV2ZW50TWFuYWdlcik7XG4gICAgc3luY0VuZ2luZUltcGwuc3luY0VuZ2luZUxpc3RlbmVyLm9uV2F0Y2hFcnJvciA9XG4gICAgICAgIGV2ZW50TWFuYWdlck9uV2F0Y2hFcnJvci5iaW5kKG51bGwsIHN5bmNFbmdpbmVJbXBsLmV2ZW50TWFuYWdlcik7XG4gICAgcmV0dXJuIHN5bmNFbmdpbmVJbXBsO1xufVxuZnVuY3Rpb24gc3luY0VuZ2luZUVuc3VyZVdyaXRlQ2FsbGJhY2tzKHN5bmNFbmdpbmUpIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICBzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIuYXBwbHlTdWNjZXNzZnVsV3JpdGUgPVxuICAgICAgICBzeW5jRW5naW5lQXBwbHlTdWNjZXNzZnVsV3JpdGUuYmluZChudWxsLCBzeW5jRW5naW5lSW1wbCk7XG4gICAgc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUucmVtb3RlU3luY2VyLnJlamVjdEZhaWxlZFdyaXRlID1cbiAgICAgICAgc3luY0VuZ2luZVJlamVjdEZhaWxlZFdyaXRlLmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwpO1xuICAgIHJldHVybiBzeW5jRW5naW5lSW1wbDtcbn1cbi8qKlxuICogTG9hZHMgYSBGaXJlc3RvcmUgYnVuZGxlIGludG8gdGhlIFNESy4gVGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMgd2hlblxuICogdGhlIGJ1bmRsZSBmaW5pc2hlZCBsb2FkaW5nLlxuICpcbiAqIEBwYXJhbSBzeW5jRW5naW5lIC0gU3luY0VuZ2luZSB0byB1c2UuXG4gKiBAcGFyYW0gYnVuZGxlUmVhZGVyIC0gQnVuZGxlIHRvIGxvYWQgaW50byB0aGUgU0RLLlxuICogQHBhcmFtIHRhc2sgLSBMb2FkQnVuZGxlVGFzayB1c2VkIHRvIHVwZGF0ZSB0aGUgbG9hZGluZyBwcm9ncmVzcyB0byBwdWJsaWMgQVBJLlxuICovXG5mdW5jdGlvbiBzeW5jRW5naW5lTG9hZEJ1bmRsZShzeW5jRW5naW5lLCBidW5kbGVSZWFkZXIsIHRhc2spIHtcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgbG9hZEJ1bmRsZUltcGwoc3luY0VuZ2luZUltcGwsIGJ1bmRsZVJlYWRlciwgdGFzaykudGhlbihjb2xsZWN0aW9uR3JvdXBzID0+IHtcbiAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUubm90aWZ5QnVuZGxlTG9hZGVkKGNvbGxlY3Rpb25Hcm91cHMpO1xuICAgIH0pO1xufVxuLyoqIExvYWRzIGEgYnVuZGxlIGFuZCByZXR1cm5zIHRoZSBsaXN0IG9mIGFmZmVjdGVkIGNvbGxlY3Rpb24gZ3JvdXBzLiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZEJ1bmRsZUltcGwoc3luY0VuZ2luZSwgcmVhZGVyLCB0YXNrKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCByZWFkZXIuZ2V0TWV0YWRhdGEoKTtcbiAgICAgICAgY29uc3Qgc2tpcCA9IGF3YWl0IGxvY2FsU3RvcmVIYXNOZXdlckJ1bmRsZShzeW5jRW5naW5lLmxvY2FsU3RvcmUsIG1ldGFkYXRhKTtcbiAgICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgICAgIGF3YWl0IHJlYWRlci5jbG9zZSgpO1xuICAgICAgICAgICAgdGFzay5fY29tcGxldGVXaXRoKGJ1bmRsZVN1Y2Nlc3NQcm9ncmVzcyhtZXRhZGF0YSkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgU2V0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRhc2suX3VwZGF0ZVByb2dyZXNzKGJ1bmRsZUluaXRpYWxQcm9ncmVzcyhtZXRhZGF0YSkpO1xuICAgICAgICBjb25zdCBsb2FkZXIgPSBuZXcgQnVuZGxlTG9hZGVyKG1ldGFkYXRhLCBzeW5jRW5naW5lLmxvY2FsU3RvcmUsIHJlYWRlci5zZXJpYWxpemVyKTtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBhd2FpdCByZWFkZXIubmV4dEVsZW1lbnQoKTtcbiAgICAgICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0gYXdhaXQgbG9hZGVyLmFkZFNpemVkRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHRhc2suX3VwZGF0ZVByb2dyZXNzKHByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQgPSBhd2FpdCByZWFkZXIubmV4dEVsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2FkZXIuY29tcGxldGUoKTtcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZSwgcmVzdWx0LmNoYW5nZWREb2NzLCBcbiAgICAgICAgLyogcmVtb3RlRXZlbnQgKi8gdW5kZWZpbmVkKTtcbiAgICAgICAgLy8gU2F2ZSBtZXRhZGF0YSwgc28gbG9hZGluZyB0aGUgc2FtZSBidW5kbGUgd2lsbCBza2lwLlxuICAgICAgICBhd2FpdCBsb2NhbFN0b3JlU2F2ZUJ1bmRsZShzeW5jRW5naW5lLmxvY2FsU3RvcmUsIG1ldGFkYXRhKTtcbiAgICAgICAgdGFzay5fY29tcGxldGVXaXRoKHJlc3VsdC5wcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0LmNoYW5nZWRDb2xsZWN0aW9uR3JvdXBzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nV2FybihMT0dfVEFHJDMsIGBMb2FkaW5nIGJ1bmRsZSBmYWlsZWQgd2l0aCAke2V9YCk7XG4gICAgICAgIHRhc2suX2ZhaWxXaXRoKGUpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBTZXQoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlcyBhbGwgY29tcG9uZW50cyBuZWVkZWQgZm9yIEZpcmVzdG9yZSB3aXRoIGluLW1lbW9yeSBwZXJzaXN0ZW5jZS5cbiAqIFVzZXMgRWFnZXJHQyBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gKi9cbmNsYXNzIE1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdtZW1vcnknO1xuICAgICAgICB0aGlzLnN5bmNocm9uaXplVGFicyA9IGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplKGNmZykge1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBuZXdTZXJpYWxpemVyKGNmZy5kYXRhYmFzZUluZm8uZGF0YWJhc2VJZCk7XG4gICAgICAgIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUgPSB0aGlzLmNyZWF0ZVNoYXJlZENsaWVudFN0YXRlKGNmZyk7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSB0aGlzLmNyZWF0ZVBlcnNpc3RlbmNlKGNmZyk7XG4gICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2Uuc3RhcnQoKTtcbiAgICAgICAgdGhpcy5sb2NhbFN0b3JlID0gdGhpcy5jcmVhdGVMb2NhbFN0b3JlKGNmZyk7XG4gICAgICAgIHRoaXMuZ2NTY2hlZHVsZXIgPSB0aGlzLmNyZWF0ZUdhcmJhZ2VDb2xsZWN0aW9uU2NoZWR1bGVyKGNmZywgdGhpcy5sb2NhbFN0b3JlKTtcbiAgICAgICAgdGhpcy5pbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIgPSB0aGlzLmNyZWF0ZUluZGV4QmFja2ZpbGxlclNjaGVkdWxlcihjZmcsIHRoaXMubG9jYWxTdG9yZSk7XG4gICAgfVxuICAgIGNyZWF0ZUdhcmJhZ2VDb2xsZWN0aW9uU2NoZWR1bGVyKGNmZywgbG9jYWxTdG9yZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY3JlYXRlSW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyKGNmZywgbG9jYWxTdG9yZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY3JlYXRlTG9jYWxTdG9yZShjZmcpIHtcbiAgICAgICAgcmV0dXJuIG5ld0xvY2FsU3RvcmUodGhpcy5wZXJzaXN0ZW5jZSwgbmV3IFF1ZXJ5RW5naW5lKCksIGNmZy5pbml0aWFsVXNlciwgdGhpcy5zZXJpYWxpemVyKTtcbiAgICB9XG4gICAgY3JlYXRlUGVyc2lzdGVuY2UoY2ZnKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5UGVyc2lzdGVuY2UoTWVtb3J5RWFnZXJEZWxlZ2F0ZS5mYWN0b3J5LCB0aGlzLnNlcmlhbGl6ZXIpO1xuICAgIH1cbiAgICBjcmVhdGVTaGFyZWRDbGllbnRTdGF0ZShjZmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlTaGFyZWRDbGllbnRTdGF0ZSgpO1xuICAgIH1cbiAgICBhc3luYyB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIChfYSA9IHRoaXMuZ2NTY2hlZHVsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wKCk7XG4gICAgICAgIChfYiA9IHRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RvcCgpO1xuICAgICAgICB0aGlzLnNoYXJlZENsaWVudFN0YXRlLnNodXRkb3duKCk7XG4gICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2Uuc2h1dGRvd24oKTtcbiAgICB9XG59XG5NZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIucHJvdmlkZXIgPSB7XG4gICAgYnVpbGQ6ICgpID0+IG5ldyBNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIoKVxufTtcbmNsYXNzIExydUdjTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIGV4dGVuZHMgTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWNoZVNpemVCeXRlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNhY2hlU2l6ZUJ5dGVzID0gY2FjaGVTaXplQnl0ZXM7XG4gICAgfVxuICAgIGNyZWF0ZUdhcmJhZ2VDb2xsZWN0aW9uU2NoZWR1bGVyKGNmZywgbG9jYWxTdG9yZSkge1xuICAgICAgICBoYXJkQXNzZXJ0KHRoaXMucGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGUgaW5zdGFuY2VvZiBNZW1vcnlMcnVEZWxlZ2F0ZSk7XG4gICAgICAgIGNvbnN0IGdhcmJhZ2VDb2xsZWN0b3IgPSB0aGlzLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlLmdhcmJhZ2VDb2xsZWN0b3I7XG4gICAgICAgIHJldHVybiBuZXcgTHJ1U2NoZWR1bGVyKGdhcmJhZ2VDb2xsZWN0b3IsIGNmZy5hc3luY1F1ZXVlLCBsb2NhbFN0b3JlKTtcbiAgICB9XG4gICAgY3JlYXRlUGVyc2lzdGVuY2UoY2ZnKSB7XG4gICAgICAgIGNvbnN0IGxydVBhcmFtcyA9IHRoaXMuY2FjaGVTaXplQnl0ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBMcnVQYXJhbXMud2l0aENhY2hlU2l6ZSh0aGlzLmNhY2hlU2l6ZUJ5dGVzKVxuICAgICAgICAgICAgOiBMcnVQYXJhbXMuREVGQVVMVDtcbiAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlQZXJzaXN0ZW5jZShwID0+IE1lbW9yeUxydURlbGVnYXRlLmZhY3RvcnkocCwgbHJ1UGFyYW1zKSwgdGhpcy5zZXJpYWxpemVyKTtcbiAgICB9XG59XG4vKipcbiAqIFByb3ZpZGVzIGFsbCBjb21wb25lbnRzIG5lZWRlZCBmb3IgRmlyZXN0b3JlIHdpdGggSW5kZXhlZERCIHBlcnNpc3RlbmNlLlxuICovXG5jbGFzcyBJbmRleGVkRGJPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgZXh0ZW5kcyBNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLCBjYWNoZVNpemVCeXRlcywgZm9yY2VPd25lcnNoaXApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyO1xuICAgICAgICB0aGlzLmNhY2hlU2l6ZUJ5dGVzID0gY2FjaGVTaXplQnl0ZXM7XG4gICAgICAgIHRoaXMuZm9yY2VPd25lcnNoaXAgPSBmb3JjZU93bmVyc2hpcDtcbiAgICAgICAgdGhpcy5raW5kID0gJ3BlcnNpc3RlbnQnO1xuICAgICAgICB0aGlzLnN5bmNocm9uaXplVGFicyA9IGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplKGNmZykge1xuICAgICAgICBhd2FpdCBzdXBlci5pbml0aWFsaXplKGNmZyk7XG4gICAgICAgIGF3YWl0IHRoaXMub25saW5lQ29tcG9uZW50UHJvdmlkZXIuaW5pdGlhbGl6ZSh0aGlzLCBjZmcpO1xuICAgICAgICAvLyBFbnF1ZXVlIHdyaXRlcyBmcm9tIGEgcHJldmlvdXMgc2Vzc2lvblxuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW5zdXJlV3JpdGVDYWxsYmFja3ModGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlci5zeW5jRW5naW5lKTtcbiAgICAgICAgYXdhaXQgZmlsbFdyaXRlUGlwZWxpbmUodGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlci5yZW1vdGVTdG9yZSk7XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgd2lsbCBpbW1lZGlhdGVseSBjYWxsIHRoZSBsaXN0ZW5lciwgc28gd2UgbWFrZSBzdXJlIHRvXG4gICAgICAgIC8vIHNldCBpdCBhZnRlciBsb2NhbFN0b3JlIC8gcmVtb3RlU3RvcmUgYXJlIHN0YXJ0ZWQuXG4gICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2Uuc2V0UHJpbWFyeVN0YXRlTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2NTY2hlZHVsZXIgJiYgIXRoaXMuZ2NTY2hlZHVsZXIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2NTY2hlZHVsZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlciAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlci5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZUxvY2FsU3RvcmUoY2ZnKSB7XG4gICAgICAgIHJldHVybiBuZXdMb2NhbFN0b3JlKHRoaXMucGVyc2lzdGVuY2UsIG5ldyBRdWVyeUVuZ2luZSgpLCBjZmcuaW5pdGlhbFVzZXIsIHRoaXMuc2VyaWFsaXplcik7XG4gICAgfVxuICAgIGNyZWF0ZUdhcmJhZ2VDb2xsZWN0aW9uU2NoZWR1bGVyKGNmZywgbG9jYWxTdG9yZSkge1xuICAgICAgICBjb25zdCBnYXJiYWdlQ29sbGVjdG9yID0gdGhpcy5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZS5nYXJiYWdlQ29sbGVjdG9yO1xuICAgICAgICByZXR1cm4gbmV3IExydVNjaGVkdWxlcihnYXJiYWdlQ29sbGVjdG9yLCBjZmcuYXN5bmNRdWV1ZSwgbG9jYWxTdG9yZSk7XG4gICAgfVxuICAgIGNyZWF0ZUluZGV4QmFja2ZpbGxlclNjaGVkdWxlcihjZmcsIGxvY2FsU3RvcmUpIHtcbiAgICAgICAgY29uc3QgaW5kZXhCYWNrZmlsbGVyID0gbmV3IEluZGV4QmFja2ZpbGxlcihsb2NhbFN0b3JlLCB0aGlzLnBlcnNpc3RlbmNlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIoY2ZnLmFzeW5jUXVldWUsIGluZGV4QmFja2ZpbGxlcik7XG4gICAgfVxuICAgIGNyZWF0ZVBlcnNpc3RlbmNlKGNmZykge1xuICAgICAgICBjb25zdCBwZXJzaXN0ZW5jZUtleSA9IGluZGV4ZWREYlN0b3JhZ2VQcmVmaXgoY2ZnLmRhdGFiYXNlSW5mby5kYXRhYmFzZUlkLCBjZmcuZGF0YWJhc2VJbmZvLnBlcnNpc3RlbmNlS2V5KTtcbiAgICAgICAgY29uc3QgbHJ1UGFyYW1zID0gdGhpcy5jYWNoZVNpemVCeXRlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IExydVBhcmFtcy53aXRoQ2FjaGVTaXplKHRoaXMuY2FjaGVTaXplQnl0ZXMpXG4gICAgICAgICAgICA6IExydVBhcmFtcy5ERUZBVUxUO1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4ZWREYlBlcnNpc3RlbmNlKHRoaXMuc3luY2hyb25pemVUYWJzLCBwZXJzaXN0ZW5jZUtleSwgY2ZnLmNsaWVudElkLCBscnVQYXJhbXMsIGNmZy5hc3luY1F1ZXVlLCBnZXRXaW5kb3coKSwgZ2V0RG9jdW1lbnQoKSwgdGhpcy5zZXJpYWxpemVyLCB0aGlzLnNoYXJlZENsaWVudFN0YXRlLCAhIXRoaXMuZm9yY2VPd25lcnNoaXApO1xuICAgIH1cbiAgICBjcmVhdGVTaGFyZWRDbGllbnRTdGF0ZShjZmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlTaGFyZWRDbGllbnRTdGF0ZSgpO1xuICAgIH1cbn1cbi8qKlxuICogUHJvdmlkZXMgYWxsIGNvbXBvbmVudHMgbmVlZGVkIGZvciBGaXJlc3RvcmUgd2l0aCBtdWx0aS10YWIgSW5kZXhlZERCXG4gKiBwZXJzaXN0ZW5jZS5cbiAqXG4gKiBJbiB0aGUgbGVnYWN5IGNsaWVudCwgdGhpcyBwcm92aWRlciBpcyB1c2VkIHRvIHByb3ZpZGUgYm90aCBtdWx0aS10YWIgYW5kXG4gKiBub24tbXVsdGktdGFiIHBlcnNpc3RlbmNlIHNpbmNlIHdlIGNhbm5vdCB0ZWxsIGF0IGJ1aWxkIHRpbWUgd2hldGhlclxuICogYHN5bmNocm9uaXplVGFic2Agd2lsbCBiZSBlbmFibGVkLlxuICovXG5jbGFzcyBNdWx0aVRhYk9mZmxpbmVDb21wb25lbnRQcm92aWRlciBleHRlbmRzIEluZGV4ZWREYk9mZmxpbmVDb21wb25lbnRQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Iob25saW5lQ29tcG9uZW50UHJvdmlkZXIsIGNhY2hlU2l6ZUJ5dGVzKSB7XG4gICAgICAgIHN1cGVyKG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLCBjYWNoZVNpemVCeXRlcywgLyogZm9yY2VPd25lcnNoaXA9ICovIGZhbHNlKTtcbiAgICAgICAgdGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyO1xuICAgICAgICB0aGlzLmNhY2hlU2l6ZUJ5dGVzID0gY2FjaGVTaXplQnl0ZXM7XG4gICAgICAgIHRoaXMuc3luY2hyb25pemVUYWJzID0gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgaW5pdGlhbGl6ZShjZmcpIHtcbiAgICAgICAgYXdhaXQgc3VwZXIuaW5pdGlhbGl6ZShjZmcpO1xuICAgICAgICBjb25zdCBzeW5jRW5naW5lID0gdGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlci5zeW5jRW5naW5lO1xuICAgICAgICBpZiAodGhpcy5zaGFyZWRDbGllbnRTdGF0ZSBpbnN0YW5jZW9mIFdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZS5zeW5jRW5naW5lID0ge1xuICAgICAgICAgICAgICAgIGFwcGx5QmF0Y2hTdGF0ZTogc3luY0VuZ2luZUFwcGx5QmF0Y2hTdGF0ZS5iaW5kKG51bGwsIHN5bmNFbmdpbmUpLFxuICAgICAgICAgICAgICAgIGFwcGx5VGFyZ2V0U3RhdGU6IHN5bmNFbmdpbmVBcHBseVRhcmdldFN0YXRlLmJpbmQobnVsbCwgc3luY0VuZ2luZSksXG4gICAgICAgICAgICAgICAgYXBwbHlBY3RpdmVUYXJnZXRzQ2hhbmdlOiBzeW5jRW5naW5lQXBwbHlBY3RpdmVUYXJnZXRzQ2hhbmdlLmJpbmQobnVsbCwgc3luY0VuZ2luZSksXG4gICAgICAgICAgICAgICAgZ2V0QWN0aXZlQ2xpZW50czogc3luY0VuZ2luZUdldEFjdGl2ZUNsaWVudHMuYmluZChudWxsLCBzeW5jRW5naW5lKSxcbiAgICAgICAgICAgICAgICBzeW5jaHJvbml6ZVdpdGhDaGFuZ2VkRG9jdW1lbnRzOiBzeW5jRW5naW5lU3luY2hyb25pemVXaXRoQ2hhbmdlZERvY3VtZW50cy5iaW5kKG51bGwsIHN5bmNFbmdpbmUpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZS5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgd2lsbCBpbW1lZGlhdGVseSBjYWxsIHRoZSBsaXN0ZW5lciwgc28gd2UgbWFrZSBzdXJlIHRvXG4gICAgICAgIC8vIHNldCBpdCBhZnRlciBsb2NhbFN0b3JlIC8gcmVtb3RlU3RvcmUgYXJlIHN0YXJ0ZWQuXG4gICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2Uuc2V0UHJpbWFyeVN0YXRlTGlzdGVuZXIoYXN5bmMgKGlzUHJpbWFyeSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgc3luY0VuZ2luZUFwcGx5UHJpbWFyeVN0YXRlKHRoaXMub25saW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY0VuZ2luZSwgaXNQcmltYXJ5KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdjU2NoZWR1bGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJpbWFyeSAmJiAhdGhpcy5nY1NjaGVkdWxlci5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2NTY2hlZHVsZXIuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzUHJpbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdjU2NoZWR1bGVyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmltYXJ5ICYmICF0aGlzLmluZGV4QmFja2ZpbGxlclNjaGVkdWxlci5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhCYWNrZmlsbGVyU2NoZWR1bGVyLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1ByaW1hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleEJhY2tmaWxsZXJTY2hlZHVsZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVNoYXJlZENsaWVudFN0YXRlKGNmZykge1xuICAgICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICAgICAgaWYgKCFXZWJTdG9yYWdlU2hhcmVkQ2xpZW50U3RhdGUuaXNBdmFpbGFibGUod2luZG93KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5JTVBMRU1FTlRFRCwgJ0luZGV4ZWREQiBwZXJzaXN0ZW5jZSBpcyBvbmx5IGF2YWlsYWJsZSBvbiBwbGF0Zm9ybXMgdGhhdCBzdXBwb3J0IExvY2FsU3RvcmFnZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwZXJzaXN0ZW5jZUtleSA9IGluZGV4ZWREYlN0b3JhZ2VQcmVmaXgoY2ZnLmRhdGFiYXNlSW5mby5kYXRhYmFzZUlkLCBjZmcuZGF0YWJhc2VJbmZvLnBlcnNpc3RlbmNlS2V5KTtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJTdG9yYWdlU2hhcmVkQ2xpZW50U3RhdGUod2luZG93LCBjZmcuYXN5bmNRdWV1ZSwgcGVyc2lzdGVuY2VLZXksIGNmZy5jbGllbnRJZCwgY2ZnLmluaXRpYWxVc2VyKTtcbiAgICB9XG59XG4vKipcbiAqIEluaXRpYWxpemVzIGFuZCB3aXJlcyB0aGUgY29tcG9uZW50cyB0aGF0IGFyZSBuZWVkZWQgdG8gaW50ZXJmYWNlIHdpdGggdGhlXG4gKiBuZXR3b3JrLlxuICovXG5jbGFzcyBPbmxpbmVDb21wb25lbnRQcm92aWRlciB7XG4gICAgYXN5bmMgaW5pdGlhbGl6ZShvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIsIGNmZykge1xuICAgICAgICBpZiAodGhpcy5sb2NhbFN0b3JlKSB7XG4gICAgICAgICAgICAvLyBPbmxpbmVDb21wb25lbnRQcm92aWRlciBtYXkgZ2V0IGluaXRpYWxpemVkIG11bHRpcGxlIHRpbWVzIGlmXG4gICAgICAgICAgICAvLyBtdWx0aS10YWIgcGVyc2lzdGVuY2UgaXMgdXNlZC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIubG9jYWxTdG9yZTtcbiAgICAgICAgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZSA9IG9mZmxpbmVDb21wb25lbnRQcm92aWRlci5zaGFyZWRDbGllbnRTdGF0ZTtcbiAgICAgICAgdGhpcy5kYXRhc3RvcmUgPSB0aGlzLmNyZWF0ZURhdGFzdG9yZShjZmcpO1xuICAgICAgICB0aGlzLnJlbW90ZVN0b3JlID0gdGhpcy5jcmVhdGVSZW1vdGVTdG9yZShjZmcpO1xuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IHRoaXMuY3JlYXRlRXZlbnRNYW5hZ2VyKGNmZyk7XG4gICAgICAgIHRoaXMuc3luY0VuZ2luZSA9IHRoaXMuY3JlYXRlU3luY0VuZ2luZShjZmcsIFxuICAgICAgICAvKiBzdGFydEFzUHJpbWFyeT0qLyAhb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNocm9uaXplVGFicyk7XG4gICAgICAgIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUub25saW5lU3RhdGVIYW5kbGVyID0gb25saW5lU3RhdGUgPT4gc3luY0VuZ2luZUFwcGx5T25saW5lU3RhdGVDaGFuZ2UodGhpcy5zeW5jRW5naW5lLCBvbmxpbmVTdGF0ZSwgMSAvKiBPbmxpbmVTdGF0ZVNvdXJjZS5TaGFyZWRDbGllbnRTdGF0ZSAqLyk7XG4gICAgICAgIHRoaXMucmVtb3RlU3RvcmUucmVtb3RlU3luY2VyLmhhbmRsZUNyZWRlbnRpYWxDaGFuZ2UgPVxuICAgICAgICAgICAgc3luY0VuZ2luZUhhbmRsZUNyZWRlbnRpYWxDaGFuZ2UuYmluZChudWxsLCB0aGlzLnN5bmNFbmdpbmUpO1xuICAgICAgICBhd2FpdCByZW1vdGVTdG9yZUFwcGx5UHJpbWFyeVN0YXRlKHRoaXMucmVtb3RlU3RvcmUsIHRoaXMuc3luY0VuZ2luZS5pc1ByaW1hcnlDbGllbnQpO1xuICAgIH1cbiAgICBjcmVhdGVFdmVudE1hbmFnZXIoY2ZnKSB7XG4gICAgICAgIHJldHVybiBuZXdFdmVudE1hbmFnZXIoKTtcbiAgICB9XG4gICAgY3JlYXRlRGF0YXN0b3JlKGNmZykge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVyID0gbmV3U2VyaWFsaXplcihjZmcuZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQpO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3Q29ubmVjdGlvbihjZmcuZGF0YWJhc2VJbmZvKTtcbiAgICAgICAgcmV0dXJuIG5ld0RhdGFzdG9yZShjZmcuYXV0aENyZWRlbnRpYWxzLCBjZmcuYXBwQ2hlY2tDcmVkZW50aWFscywgY29ubmVjdGlvbiwgc2VyaWFsaXplcik7XG4gICAgfVxuICAgIGNyZWF0ZVJlbW90ZVN0b3JlKGNmZykge1xuICAgICAgICByZXR1cm4gbmV3UmVtb3RlU3RvcmUodGhpcy5sb2NhbFN0b3JlLCB0aGlzLmRhdGFzdG9yZSwgY2ZnLmFzeW5jUXVldWUsIG9ubGluZVN0YXRlID0+IHN5bmNFbmdpbmVBcHBseU9ubGluZVN0YXRlQ2hhbmdlKHRoaXMuc3luY0VuZ2luZSwgb25saW5lU3RhdGUsIDAgLyogT25saW5lU3RhdGVTb3VyY2UuUmVtb3RlU3RvcmUgKi8pLCBuZXdDb25uZWN0aXZpdHlNb25pdG9yKCkpO1xuICAgIH1cbiAgICBjcmVhdGVTeW5jRW5naW5lKGNmZywgc3RhcnRBc1ByaW1hcnkpIHtcbiAgICAgICAgcmV0dXJuIG5ld1N5bmNFbmdpbmUodGhpcy5sb2NhbFN0b3JlLCB0aGlzLnJlbW90ZVN0b3JlLCB0aGlzLmV2ZW50TWFuYWdlciwgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZSwgY2ZnLmluaXRpYWxVc2VyLCBjZmcubWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMsIHN0YXJ0QXNQcmltYXJ5KTtcbiAgICB9XG4gICAgYXN5bmMgdGVybWluYXRlKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBhd2FpdCByZW1vdGVTdG9yZVNodXRkb3duKHRoaXMucmVtb3RlU3RvcmUpO1xuICAgICAgICAoX2EgPSB0aGlzLmRhdGFzdG9yZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRlcm1pbmF0ZSgpO1xuICAgICAgICAoX2IgPSB0aGlzLmV2ZW50TWFuYWdlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRlcm1pbmF0ZSgpO1xuICAgIH1cbn1cbk9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnByb3ZpZGVyID0ge1xuICAgIGJ1aWxkOiAoKSA9PiBuZXcgT25saW5lQ29tcG9uZW50UHJvdmlkZXIoKVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogSG93IG1hbnkgYnl0ZXMgdG8gcmVhZCBlYWNoIHRpbWUgd2hlbiBgUmVhZGFibGVTdHJlYW1SZWFkZXIucmVhZCgpYCBpc1xuICogY2FsbGVkLiBPbmx5IGFwcGxpY2FibGUgZm9yIGJ5dGUgc3RyZWFtcyB0aGF0IHdlIGNvbnRyb2wgKGUuZy4gdGhvc2UgYmFja2VkXG4gKiBieSBhbiBVSW50OEFycmF5KS5cbiAqL1xuY29uc3QgREVGQVVMVF9CWVRFU19QRVJfUkVBRCA9IDEwMjQwO1xuLyoqXG4gKiBCdWlsZHMgYSBgQnl0ZVN0cmVhbVJlYWRlcmAgZnJvbSBhIFVJbnQ4QXJyYXkuXG4gKiBAcGFyYW0gc291cmNlIC0gVGhlIGRhdGEgc291cmNlIHRvIHVzZS5cbiAqIEBwYXJhbSBieXRlc1BlclJlYWQgLSBIb3cgbWFueSBieXRlcyBlYWNoIGByZWFkKClgIGZyb20gdGhlIHJldHVybmVkIHJlYWRlclxuICogICAgICAgIHdpbGwgcmVhZC5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlU3RyZWFtUmVhZGVySGVscGVyKHNvdXJjZSwgYnl0ZXNQZXJSZWFkID0gREVGQVVMVF9CWVRFU19QRVJfUkVBRCkge1xuICAgIGxldCByZWFkRnJvbSA9IDA7XG4gICAgLy8gVGhlIFR5cGVTY3JpcHQgZGVmaW5pdGlvbiBmb3IgUmVhZGFibGVTdHJlYW1SZWFkZXIgY2hhbmdlZC4gV2UgdXNlXG4gICAgLy8gYGFueWAgaGVyZSB0byBhbGxvdyB0aGlzIGNvZGUgdG8gY29tcGlsZSB3aXRoIGRpZmZlcmVudCB2ZXJzaW9ucy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy80Mjk3MFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3QgcmVhZGVyID0ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBhc3luYyByZWFkKCkge1xuICAgICAgICAgICAgaWYgKHJlYWRGcm9tIDwgc291cmNlLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzb3VyY2Uuc2xpY2UocmVhZEZyb20sIHJlYWRGcm9tICsgYnl0ZXNQZXJSZWFkKSxcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWRGcm9tICs9IGJ5dGVzUGVyUmVhZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBjYW5jZWwoKSB7IH0sXG4gICAgICAgIHJlbGVhc2VMb2NrKCkgeyB9LFxuICAgICAgICBjbG9zZWQ6IFByb21pc2UucmVzb2x2ZSgpXG4gICAgfTtcbiAgICByZXR1cm4gcmVhZGVyO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVOb25FbXB0eUFyZ3VtZW50KGZ1bmN0aW9uTmFtZSwgYXJndW1lbnROYW1lLCBhcmd1bWVudCkge1xuICAgIGlmICghYXJndW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfSgpIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSAke2FyZ3VtZW50TmFtZX0uYCk7XG4gICAgfVxufVxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCB0d28gYm9vbGVhbiBvcHRpb25zIGFyZSBub3Qgc2V0IGF0IHRoZSBzYW1lIHRpbWUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVJc05vdFVzZWRUb2dldGhlcihvcHRpb25OYW1lMSwgYXJndW1lbnQxLCBvcHRpb25OYW1lMiwgYXJndW1lbnQyKSB7XG4gICAgaWYgKGFyZ3VtZW50MSA9PT0gdHJ1ZSAmJiBhcmd1bWVudDIgPT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYCR7b3B0aW9uTmFtZTF9IGFuZCAke29wdGlvbk5hbWUyfSBjYW5ub3QgYmUgdXNlZCB0b2dldGhlci5gKTtcbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IGBwYXRoYCByZWZlcnMgdG8gYSBkb2N1bWVudCAoaW5kaWNhdGVkIGJ5IHRoZSBmYWN0IGl0IGNvbnRhaW5zXG4gKiBhbiBldmVuIG51bWJlcnMgb2Ygc2VnbWVudHMpLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZURvY3VtZW50UGF0aChwYXRoKSB7XG4gICAgaWYgKCFEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHBhdGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIGRvY3VtZW50IHJlZmVyZW5jZS4gRG9jdW1lbnQgcmVmZXJlbmNlcyBtdXN0IGhhdmUgYW4gZXZlbiBudW1iZXIgb2Ygc2VnbWVudHMsIGJ1dCAke3BhdGh9IGhhcyAke3BhdGgubGVuZ3RofS5gKTtcbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IGBwYXRoYCByZWZlcnMgdG8gYSBjb2xsZWN0aW9uIChpbmRpY2F0ZWQgYnkgdGhlIGZhY3QgaXRcbiAqIGNvbnRhaW5zIGFuIG9kZCBudW1iZXJzIG9mIHNlZ21lbnRzKS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb2xsZWN0aW9uUGF0aChwYXRoKSB7XG4gICAgaWYgKERvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkocGF0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgY29sbGVjdGlvbiByZWZlcmVuY2UuIENvbGxlY3Rpb24gcmVmZXJlbmNlcyBtdXN0IGhhdmUgYW4gb2RkIG51bWJlciBvZiBzZWdtZW50cywgYnV0ICR7cGF0aH0gaGFzICR7cGF0aC5sZW5ndGh9LmApO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGl0J3MgYSBub24tbnVsbCBvYmplY3Qgd2l0aG91dCBhIGN1c3RvbSBwcm90b3R5cGVcbiAqIChpLmUuIGV4Y2x1ZGVzIEFycmF5LCBEYXRlLCBldGMuKS5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChpbnB1dCkge1xuICAgIHJldHVybiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBpbnB1dCAhPT0gbnVsbCAmJlxuICAgICAgICAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGlucHV0KSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fFxuICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKGlucHV0KSA9PT0gbnVsbCkpO1xufVxuLyoqIFJldHVybnMgYSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgdHlwZSAvIHZhbHVlIG9mIHRoZSBwcm92aWRlZCBpbnB1dC4gKi9cbmZ1bmN0aW9uIHZhbHVlRGVzY3JpcHRpb24oaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IDIwKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGAke2lucHV0LnN1YnN0cmluZygwLCAyMCl9Li4uYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBpbnB1dCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiAnJyArIGlucHV0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gJ2FuIGFycmF5JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbU9iamVjdE5hbWUgPSB0cnlHZXRDdXN0b21PYmplY3RUeXBlKGlucHV0KTtcbiAgICAgICAgICAgIGlmIChjdXN0b21PYmplY3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBhIGN1c3RvbSAke2N1c3RvbU9iamVjdE5hbWV9IG9iamVjdGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FuIG9iamVjdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiAnYSBmdW5jdGlvbic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbi8qKiB0cnkgdG8gZ2V0IHRoZSBjb25zdHJ1Y3RvciBuYW1lIGZvciBhbiBvYmplY3QuICovXG5mdW5jdGlvbiB0cnlHZXRDdXN0b21PYmplY3RUeXBlKGlucHV0KSB7XG4gICAgaWYgKGlucHV0LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQ2FzdHMgYG9iamAgdG8gYFRgLCBvcHRpb25hbGx5IHVud3JhcHBpbmcgQ29tcGF0IHR5cGVzIHRvIGV4cG9zZSB0aGVcbiAqIHVuZGVybHlpbmcgaW5zdGFuY2UuIFRocm93cyBpZiAgYG9iamAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGBUYC5cbiAqXG4gKiBUaGlzIGNhc3QgaXMgdXNlZCBpbiB0aGUgTGl0ZSBhbmQgRnVsbCBTREsgdG8gdmVyaWZ5IGluc3RhbmNlIHR5cGVzIGZvclxuICogYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcHVibGljIEFQSS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBjYXN0KG9iaiwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3RydWN0b3IpIHtcbiAgICBpZiAoJ19kZWxlZ2F0ZScgaW4gb2JqKSB7XG4gICAgICAgIC8vIFVud3JhcCBDb21wYXQgdHlwZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgb2JqID0gb2JqLl9kZWxlZ2F0ZTtcbiAgICB9XG4gICAgaWYgKCEob2JqIGluc3RhbmNlb2YgY29uc3RydWN0b3IpKSB7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvci5uYW1lID09PSBvYmouY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1R5cGUgZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIGluc3RhbmNlLiBEaWQgeW91IHBhc3MgYSAnICtcbiAgICAgICAgICAgICAgICBgcmVmZXJlbmNlIGZyb20gYSBkaWZmZXJlbnQgRmlyZXN0b3JlIFNESz9gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsdWVEZXNjcmlwdGlvbihvYmopO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEV4cGVjdGVkIHR5cGUgJyR7Y29uc3RydWN0b3IubmFtZX0nLCBidXQgaXQgd2FzOiAke2Rlc2NyaXB0aW9ufWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBvc2l0aXZlTnVtYmVyKGZ1bmN0aW9uTmFtZSwgbikge1xuICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfSgpIHJlcXVpcmVzIGEgcG9zaXRpdmUgbnVtYmVyLCBidXQgaXQgd2FzOiAke259LmApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogT24gTm9kZSwgb25seSBzdXBwb3J0ZWQgZGF0YSBzb3VyY2UgaXMgYSBgVWludDhBcnJheWAgZm9yIG5vdy5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlU3RyZWFtUmVhZGVyKHNvdXJjZSwgYnl0ZXNQZXJSZWFkKSB7XG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYE5vZGVQbGF0Zm9ybS50b0J5dGVTdHJlYW1SZWFkZXIgZXhwZWN0cyBzb3VyY2UgdG8gYmUgVWludDhBcnJheSwgZ290ICR7dmFsdWVEZXNjcmlwdGlvbihzb3VyY2UpfWApO1xuICAgIH1cbiAgICByZXR1cm4gdG9CeXRlU3RyZWFtUmVhZGVySGVscGVyKHNvdXJjZSwgYnl0ZXNQZXJSZWFkKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qXG4gKiBBIHdyYXBwZXIgaW1wbGVtZW50YXRpb24gb2YgT2JzZXJ2ZXI8VD4gdGhhdCB3aWxsIGRpc3BhdGNoIGV2ZW50c1xuICogYXN5bmNocm9ub3VzbHkuIFRvIGFsbG93IGltbWVkaWF0ZSBzaWxlbmNpbmcsIGEgbXV0ZSBjYWxsIGlzIGFkZGVkIHdoaWNoXG4gKiBjYXVzZXMgZXZlbnRzIHNjaGVkdWxlZCB0byBubyBsb25nZXIgYmUgcmFpc2VkLlxuICovXG5jbGFzcyBBc3luY09ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihvYnNlcnZlcikge1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHNldCB0byB0cnVlLCB3aWxsIG5vdCByYWlzZSBmdXR1cmUgZXZlbnRzLiBOZWNlc3NhcnkgdG8gZGVhbCB3aXRoXG4gICAgICAgICAqIGFzeW5jIGRldGFjaG1lbnQgb2YgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm11dGVkID0gZmFsc2U7XG4gICAgfVxuICAgIG5leHQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMubXV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlRXZlbnQodGhpcy5vYnNlcnZlci5uZXh0LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXJyb3IoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMubXV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vYnNlcnZlci5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUV2ZW50KHRoaXMub2JzZXJ2ZXIuZXJyb3IsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKCdVbmNhdWdodCBFcnJvciBpbiBzbmFwc2hvdCBsaXN0ZW5lcjonLCBlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtdXRlKCkge1xuICAgICAgICB0aGlzLm11dGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgc2NoZWR1bGVFdmVudChldmVudEhhbmRsZXIsIGV2ZW50KSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm11dGVkKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGNvbXBsZXRlIGVsZW1lbnQgaW4gdGhlIGJ1bmRsZSBzdHJlYW0sIHRvZ2V0aGVyIHdpdGggdGhlIGJ5dGUgbGVuZ3RoIGl0XG4gKiBvY2N1cGllcyBpbiB0aGUgc3RyZWFtLlxuICovXG5jbGFzcyBTaXplZEJ1bmRsZUVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHBheWxvYWQsIFxuICAgIC8vIEhvdyBtYW55IGJ5dGVzIHRoaXMgZWxlbWVudCB0YWtlcyB0byBzdG9yZSBpbiB0aGUgYnVuZGxlLlxuICAgIGJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgaXNCdW5kbGVNZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuICdtZXRhZGF0YScgaW4gdGhpcy5wYXlsb2FkO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSBidW5kbGUuXG4gKlxuICogVGFrZXMgYSBidW5kbGUgc3RyZWFtIG9yIGJ1ZmZlciwgYW5kIHByZXNlbnRzIGFic3RyYWN0aW9ucyB0byByZWFkIGJ1bmRsZWRcbiAqIGVsZW1lbnRzIG91dCBvZiB0aGUgdW5kZXJseWluZyBjb250ZW50LlxuICovXG5jbGFzcyBCdW5kbGVSZWFkZXJJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVGhlIHJlYWRlciB0byByZWFkIGZyb20gdW5kZXJseWluZyBiaW5hcnkgYnVuZGxlIGRhdGEgc291cmNlLiAqL1xuICAgIHJlYWRlciwgc2VyaWFsaXplcikge1xuICAgICAgICB0aGlzLnJlYWRlciA9IHJlYWRlcjtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICAgICAgLyoqIENhY2hlZCBidW5kbGUgbWV0YWRhdGEuICovXG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGJ1ZmZlciB0byBob2xkIGJ1bmRsZSBjb250ZW50LCBhY2N1bXVsYXRpbmcgaW5jb21wbGV0ZSBlbGVtZW50XG4gICAgICAgICAqIGNvbnRlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHRoaXMudGV4dERlY29kZXIgPSBuZXdUZXh0RGVjb2RlcigpO1xuICAgICAgICAvLyBSZWFkIHRoZSBtZXRhZGF0YSAod2hpY2ggaXMgdGhlIGZpcnN0IGVsZW1lbnQpLlxuICAgICAgICB0aGlzLm5leHRFbGVtZW50SW1wbCgpLnRoZW4oZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LmlzQnVuZGxlTWV0YWRhdGEoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEucmVzb2x2ZShlbGVtZW50LnBheWxvYWQubWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5yZWplY3QobmV3IEVycm9yKGBUaGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgYnVuZGxlIGlzIG5vdCBhIG1ldGFkYXRhLCBpdCBpc1xuICAgICAgICAgICAgICR7SlNPTi5zdHJpbmdpZnkoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50LnBheWxvYWQpfWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZXJyb3IgPT4gdGhpcy5tZXRhZGF0YS5yZWplY3QoZXJyb3IpKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRlci5jYW5jZWwoKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhLnByb21pc2U7XG4gICAgfVxuICAgIGFzeW5jIG5leHRFbGVtZW50KCkge1xuICAgICAgICAvLyBNYWtlcyBzdXJlIG1ldGFkYXRhIGlzIHJlYWQgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dEVsZW1lbnRJbXBsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGZyb20gdGhlIGhlYWQgb2YgaW50ZXJuYWwgYnVmZmVyLCBhbmQgcHVsbGluZyBtb3JlIGRhdGEgZnJvbVxuICAgICAqIHVuZGVybHlpbmcgc3RyZWFtIGlmIGEgY29tcGxldGUgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQsIHVudGlsIGFuXG4gICAgICogZWxlbWVudChpbmNsdWRpbmcgdGhlIHByZWZpeGVkIGxlbmd0aCBhbmQgdGhlIEpTT04gc3RyaW5nKSBpcyBmb3VuZC5cbiAgICAgKlxuICAgICAqIE9uY2UgYSBjb21wbGV0ZSBlbGVtZW50IGlzIHJlYWQsIGl0IGlzIGRyb3BwZWQgZnJvbSBpbnRlcm5hbCBidWZmZXIuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGVpdGhlciB0aGUgYnVuZGxlZCBlbGVtZW50LCBvciBudWxsIGlmIHdlIGhhdmUgcmVhY2hlZCB0aGUgZW5kIG9mXG4gICAgICogdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBhc3luYyBuZXh0RWxlbWVudEltcGwoKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aEJ1ZmZlciA9IGF3YWl0IHRoaXMucmVhZExlbmd0aCgpO1xuICAgICAgICBpZiAobGVuZ3RoQnVmZmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGhTdHJpbmcgPSB0aGlzLnRleHREZWNvZGVyLmRlY29kZShsZW5ndGhCdWZmZXIpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBOdW1iZXIobGVuZ3RoU3RyaW5nKTtcbiAgICAgICAgaWYgKGlzTmFOKGxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2VFcnJvcihgbGVuZ3RoIHN0cmluZyAoJHtsZW5ndGhTdHJpbmd9KSBpcyBub3QgdmFsaWQgbnVtYmVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QganNvblN0cmluZyA9IGF3YWl0IHRoaXMucmVhZEpzb25TdHJpbmcobGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaXplZEJ1bmRsZUVsZW1lbnQoSlNPTi5wYXJzZShqc29uU3RyaW5nKSwgbGVuZ3RoQnVmZmVyLmxlbmd0aCArIGxlbmd0aCk7XG4gICAgfVxuICAgIC8qKiBGaXJzdCBpbmRleCBvZiAneycgZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXIuICovXG4gICAgaW5kZXhPZk9wZW5CcmFja2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuZmluZEluZGV4KHYgPT4gdiA9PT0gJ3snLmNoYXJDb2RlQXQoMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGludGVybmFsIGJ1ZmZlciwgdW50aWwgdGhlIGZpcnN0ICd7JywgYW5kXG4gICAgICogcmV0dXJuIHRoZSBjb250ZW50LlxuICAgICAqXG4gICAgICogSWYgcmVhY2hlZCBlbmQgb2YgdGhlIHN0cmVhbSwgcmV0dXJucyBhIG51bGwuXG4gICAgICovXG4gICAgYXN5bmMgcmVhZExlbmd0aCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXhPZk9wZW5CcmFja2V0KCkgPCAwKSB7XG4gICAgICAgICAgICBjb25zdCBkb25lID0gYXdhaXQgdGhpcy5wdWxsTW9yZURhdGFUb0J1ZmZlcigpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCcm9rZSBvdXQgb2YgdGhlIGxvb3AgYmVjYXVzZSB1bmRlcmx5aW5nIHN0cmVhbSBpcyBjbG9zZWQsIGFuZCB0aGVyZVxuICAgICAgICAvLyBoYXBwZW5zIHRvIGJlIG5vIG1vcmUgZGF0YSB0byBwcm9jZXNzLlxuICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuaW5kZXhPZk9wZW5CcmFja2V0KCk7XG4gICAgICAgIC8vIEJyb2tlIG91dCBvZiB0aGUgbG9vcCBiZWNhdXNlIHVuZGVybHlpbmcgc3RyZWFtIGlzIGNsb3NlZCwgYnV0IHN0aWxsXG4gICAgICAgIC8vIGNhbm5vdCBmaW5kIGFuIG9wZW4gYnJhY2tldC5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZUVycm9yKCdSZWFjaGVkIHRoZSBlbmQgb2YgYnVuZGxlIHdoZW4gYSBsZW5ndGggc3RyaW5nIGlzIGV4cGVjdGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYnVmZmVyLnNsaWNlKDAsIHBvc2l0aW9uKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBidWZmZXIgdG8gZHJvcCB0aGUgcmVhZCBsZW5ndGguXG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc2xpY2UocG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBmcm9tIGEgc3BlY2lmaWVkIHBvc2l0aW9uIGZyb20gdGhlIGludGVybmFsIGJ1ZmZlciwgZm9yIGEgc3BlY2lmaWVkXG4gICAgICogbnVtYmVyIG9mIGJ5dGVzLCBwdWxsaW5nIG1vcmUgZGF0YSBmcm9tIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIGRlY29kZWQgZnJvbSB0aGUgcmVhZCBieXRlcy5cbiAgICAgKi9cbiAgICBhc3luYyByZWFkSnNvblN0cmluZyhsZW5ndGgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuYnVmZmVyLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZG9uZSA9IGF3YWl0IHRoaXMucHVsbE1vcmVEYXRhVG9CdWZmZXIoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYWlzZUVycm9yKCdSZWFjaGVkIHRoZSBlbmQgb2YgYnVuZGxlIHdoZW4gbW9yZSBpcyBleHBlY3RlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRleHREZWNvZGVyLmRlY29kZSh0aGlzLmJ1ZmZlci5zbGljZSgwLCBsZW5ndGgpKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBidWZmZXIgdG8gZHJvcCB0aGUgcmVhZCBqc29uIHN0cmluZy5cbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zbGljZShsZW5ndGgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByYWlzZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICB0aGlzLnJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJ1bmRsZSBmb3JtYXQ6ICR7bWVzc2FnZX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVsbHMgbW9yZSBkYXRhIGZyb20gdW5kZXJseWluZyBzdHJlYW0gdG8gaW50ZXJuYWwgYnVmZmVyLlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHB1bGxNb3JlRGF0YVRvQnVmZmVyKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyLmxlbmd0aCArIHJlc3VsdC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgbmV3QnVmZmVyLnNldCh0aGlzLmJ1ZmZlcik7XG4gICAgICAgICAgICBuZXdCdWZmZXIuc2V0KHJlc3VsdC52YWx1ZSwgdGhpcy5idWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3QnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuZG9uZTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdCdW5kbGVSZWFkZXIocmVhZGVyLCBzZXJpYWxpemVyKSB7XG4gICAgcmV0dXJuIG5ldyBCdW5kbGVSZWFkZXJJbXBsKHJlYWRlciwgc2VyaWFsaXplcik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEludGVybmFsIHRyYW5zYWN0aW9uIG9iamVjdCByZXNwb25zaWJsZSBmb3IgYWNjdW11bGF0aW5nIHRoZSBtdXRhdGlvbnMgdG9cbiAqIHBlcmZvcm0gYW5kIHRoZSBiYXNlIHZlcnNpb25zIGZvciBhbnkgZG9jdW1lbnRzIHJlYWQuXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uJDIge1xuICAgIGNvbnN0cnVjdG9yKGRhdGFzdG9yZSkge1xuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IGRhdGFzdG9yZTtcbiAgICAgICAgLy8gVGhlIHZlcnNpb24gb2YgZWFjaCBkb2N1bWVudCB0aGF0IHdhcyByZWFkIGR1cmluZyB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAgICB0aGlzLnJlYWRWZXJzaW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5jb21taXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZGVmZXJyZWQgdXNhZ2UgZXJyb3IgdGhhdCBvY2N1cnJlZCBwcmV2aW91c2x5IGluIHRoaXMgdHJhbnNhY3Rpb24gdGhhdFxuICAgICAgICAgKiB3aWxsIGNhdXNlIHRoZSB0cmFuc2FjdGlvbiB0byBmYWlsIG9uY2UgaXQgYWN0dWFsbHkgY29tbWl0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uRXJyb3IgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IG9mIGRvY3VtZW50cyB0aGF0IGhhdmUgYmVlbiB3cml0dGVuIGluIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiB0aGVyZSdzIG1vcmUgdGhhbiBvbmUgd3JpdGUgdG8gdGhlIHNhbWUga2V5IGluIGEgdHJhbnNhY3Rpb24sIGFueVxuICAgICAgICAgKiB3cml0ZXMgYWZ0ZXIgdGhlIGZpcnN0IGFyZSBoYW5kbGVkIGRpZmZlcmVudGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cml0dGVuRG9jcyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgYXN5bmMgbG9va3VwKGtleXMpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVDb21taXROb3RDYWxsZWQoKTtcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uRXJyb3IgPSBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnRmlyZXN0b3JlIHRyYW5zYWN0aW9ucyByZXF1aXJlIGFsbCByZWFkcyB0byBiZSBleGVjdXRlZCBiZWZvcmUgYWxsIHdyaXRlcy4nKTtcbiAgICAgICAgICAgIHRocm93IHRoaXMubGFzdFRyYW5zYWN0aW9uRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9jcyA9IGF3YWl0IGludm9rZUJhdGNoR2V0RG9jdW1lbnRzUnBjKHRoaXMuZGF0YXN0b3JlLCBrZXlzKTtcbiAgICAgICAgZG9jcy5mb3JFYWNoKGRvYyA9PiB0aGlzLnJlY29yZFZlcnNpb24oZG9jKSk7XG4gICAgICAgIHJldHVybiBkb2NzO1xuICAgIH1cbiAgICBzZXQoa2V5LCBkYXRhKSB7XG4gICAgICAgIHRoaXMud3JpdGUoZGF0YS50b011dGF0aW9uKGtleSwgdGhpcy5wcmVjb25kaXRpb24oa2V5KSkpO1xuICAgICAgICB0aGlzLndyaXR0ZW5Eb2NzLmFkZChrZXkudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHVwZGF0ZShrZXksIGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMud3JpdGUoZGF0YS50b011dGF0aW9uKGtleSwgdGhpcy5wcmVjb25kaXRpb25Gb3JVcGRhdGUoa2V5KSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbkVycm9yID0gZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXR0ZW5Eb2NzLmFkZChrZXkudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgdGhpcy53cml0ZShuZXcgRGVsZXRlTXV0YXRpb24oa2V5LCB0aGlzLnByZWNvbmRpdGlvbihrZXkpKSk7XG4gICAgICAgIHRoaXMud3JpdHRlbkRvY3MuYWRkKGtleS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgYXN5bmMgY29tbWl0KCkge1xuICAgICAgICB0aGlzLmVuc3VyZUNvbW1pdE5vdENhbGxlZCgpO1xuICAgICAgICBpZiAodGhpcy5sYXN0VHJhbnNhY3Rpb25FcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5sYXN0VHJhbnNhY3Rpb25FcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bndyaXR0ZW4gPSB0aGlzLnJlYWRWZXJzaW9ucztcbiAgICAgICAgLy8gRm9yIGVhY2ggbXV0YXRpb24sIG5vdGUgdGhhdCB0aGUgZG9jIHdhcyB3cml0dGVuLlxuICAgICAgICB0aGlzLm11dGF0aW9ucy5mb3JFYWNoKG11dGF0aW9uID0+IHtcbiAgICAgICAgICAgIHVud3JpdHRlbi5kZWxldGUobXV0YXRpb24ua2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRm9yIGVhY2ggZG9jdW1lbnQgdGhhdCB3YXMgcmVhZCBidXQgbm90IHdyaXR0ZW4gdG8sIHdlIHdhbnQgdG8gcGVyZm9ybVxuICAgICAgICAvLyBhIGB2ZXJpZnlgIG9wZXJhdGlvbi5cbiAgICAgICAgdW53cml0dGVuLmZvckVhY2goKF8sIHBhdGgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IERvY3VtZW50S2V5LmZyb21QYXRoKHBhdGgpO1xuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnMucHVzaChuZXcgVmVyaWZ5TXV0YXRpb24oa2V5LCB0aGlzLnByZWNvbmRpdGlvbihrZXkpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBpbnZva2VDb21taXRScGModGhpcy5kYXRhc3RvcmUsIHRoaXMubXV0YXRpb25zKTtcbiAgICAgICAgdGhpcy5jb21taXR0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZWNvcmRWZXJzaW9uKGRvYykge1xuICAgICAgICBsZXQgZG9jVmVyc2lvbjtcbiAgICAgICAgaWYgKGRvYy5pc0ZvdW5kRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgZG9jVmVyc2lvbiA9IGRvYy52ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvYy5pc05vRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgLy8gUmVwcmVzZW50IGEgZGVsZXRlZCBkb2MgdXNpbmcgU25hcHNob3RWZXJzaW9uLm1pbigpLlxuICAgICAgICAgICAgZG9jVmVyc2lvbiA9IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGlzdGluZ1ZlcnNpb24gPSB0aGlzLnJlYWRWZXJzaW9ucy5nZXQoZG9jLmtleS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nVmVyc2lvbikge1xuICAgICAgICAgICAgaWYgKCFkb2NWZXJzaW9uLmlzRXF1YWwoZXhpc3RpbmdWZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgdHJhbnNhY3Rpb24gd2lsbCBmYWlsIG5vIG1hdHRlciB3aGF0LlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkFCT1JURUQsICdEb2N1bWVudCB2ZXJzaW9uIGNoYW5nZWQgYmV0d2VlbiB0d28gcmVhZHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRWZXJzaW9ucy5zZXQoZG9jLmtleS50b1N0cmluZygpLCBkb2NWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2ZXJzaW9uIG9mIHRoaXMgZG9jdW1lbnQgd2hlbiBpdCB3YXMgcmVhZCBpbiB0aGlzIHRyYW5zYWN0aW9uLFxuICAgICAqIGFzIGEgcHJlY29uZGl0aW9uLCBvciBubyBwcmVjb25kaXRpb24gaWYgaXQgd2FzIG5vdCByZWFkLlxuICAgICAqL1xuICAgIHByZWNvbmRpdGlvbihrZXkpIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRoaXMucmVhZFZlcnNpb25zLmdldChrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmICghdGhpcy53cml0dGVuRG9jcy5oYXMoa2V5LnRvU3RyaW5nKCkpICYmIHZlcnNpb24pIHtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcmVjb25kaXRpb24uZXhpc3RzKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcmVjb25kaXRpb24udXBkYXRlVGltZSh2ZXJzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcmVjb25kaXRpb24ubm9uZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByZWNvbmRpdGlvbiBmb3IgYSBkb2N1bWVudCBpZiB0aGUgb3BlcmF0aW9uIGlzIGFuIHVwZGF0ZS5cbiAgICAgKi9cbiAgICBwcmVjb25kaXRpb25Gb3JVcGRhdGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLnJlYWRWZXJzaW9ucy5nZXQoa2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICAvLyBUaGUgZmlyc3QgdGltZSBhIGRvY3VtZW50IGlzIHdyaXR0ZW4sIHdlIHdhbnQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlXG4gICAgICAgIC8vIHJlYWQgdGltZSBhbmQgZXhpc3RlbmNlXG4gICAgICAgIGlmICghdGhpcy53cml0dGVuRG9jcy5oYXMoa2V5LnRvU3RyaW5nKCkpICYmIHZlcnNpb24pIHtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LCBzbyBmYWlsIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGhhcyB0byBiZSB2YWxpZGF0ZWQgbG9jYWxseSBiZWNhdXNlIHlvdSBjYW4ndCBzZW5kIGFcbiAgICAgICAgICAgICAgICAvLyBwcmVjb25kaXRpb24gdGhhdCBhIGRvY3VtZW50IGRvZXMgbm90IGV4aXN0IHdpdGhvdXQgY2hhbmdpbmcgdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBiYWNrZW5kIHdyaXRlIHRvIGJlIGFuIGluc2VydC4gVGhpcyBpcyB0aGUgcmV2ZXJzZVxuICAgICAgICAgICAgICAgIC8vIG9mIHdoYXQgd2Ugd2FudCwgc2luY2Ugd2Ugd2FudCB0byBhc3NlcnQgdGhhdCB0aGUgZG9jdW1lbnQgZG9lc24ndFxuICAgICAgICAgICAgICAgIC8vIGV4aXN0IGJ1dCB0aGVuIHNlbmQgdGhlIHVwZGF0ZSBhbmQgaGF2ZSBpdCBmYWlsLiBTaW5jZSB3ZSBjYW4ndFxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3MgdGhhdCB0byB0aGUgYmFja2VuZCwgd2UgaGF2ZSB0byB2YWxpZGF0ZSBsb2NhbGx5LlxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgY2FuIGNoYW5nZSBvbmNlIHdlIGNhbiBzZW5kIHNlcGFyYXRlIHZlcmlmeSB3cml0ZXMgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgXCJDYW4ndCB1cGRhdGUgYSBkb2N1bWVudCB0aGF0IGRvZXNuJ3QgZXhpc3QuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG9jdW1lbnQgZXhpc3RzLCBiYXNlIHByZWNvbmRpdGlvbiBvbiBkb2N1bWVudCB1cGRhdGUgdGltZS5cbiAgICAgICAgICAgIHJldHVybiBQcmVjb25kaXRpb24udXBkYXRlVGltZSh2ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIERvY3VtZW50IHdhcyBub3QgcmVhZCwgc28gd2UganVzdCB1c2UgdGhlIHByZWNvbmRpdGlvbnMgZm9yIGEgYmxpbmRcbiAgICAgICAgICAgIC8vIHVwZGF0ZS5cbiAgICAgICAgICAgIHJldHVybiBQcmVjb25kaXRpb24uZXhpc3RzKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdyaXRlKG11dGF0aW9uKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQ29tbWl0Tm90Q2FsbGVkKCk7XG4gICAgICAgIHRoaXMubXV0YXRpb25zLnB1c2gobXV0YXRpb24pO1xuICAgIH1cbiAgICBlbnN1cmVDb21taXROb3RDYWxsZWQoKSB7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUcmFuc2FjdGlvblJ1bm5lciBlbmNhcHN1bGF0ZXMgdGhlIGxvZ2ljIG5lZWRlZCB0byBydW4gYW5kIHJldHJ5IHRyYW5zYWN0aW9uc1xuICogd2l0aCBiYWNrb2ZmLlxuICovXG5jbGFzcyBUcmFuc2FjdGlvblJ1bm5lciB7XG4gICAgY29uc3RydWN0b3IoYXN5bmNRdWV1ZSwgZGF0YXN0b3JlLCBvcHRpb25zLCB1cGRhdGVGdW5jdGlvbiwgZGVmZXJyZWQpIHtcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcbiAgICAgICAgdGhpcy5kYXRhc3RvcmUgPSBkYXRhc3RvcmU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudXBkYXRlRnVuY3Rpb24gPSB1cGRhdGVGdW5jdGlvbjtcbiAgICAgICAgdGhpcy5kZWZlcnJlZCA9IGRlZmVycmVkO1xuICAgICAgICB0aGlzLmF0dGVtcHRzUmVtYWluaW5nID0gb3B0aW9ucy5tYXhBdHRlbXB0cztcbiAgICAgICAgdGhpcy5iYWNrb2ZmID0gbmV3IEV4cG9uZW50aWFsQmFja29mZih0aGlzLmFzeW5jUXVldWUsIFwidHJhbnNhY3Rpb25fcmV0cnlcIiAvKiBUaW1lcklkLlRyYW5zYWN0aW9uUmV0cnkgKi8pO1xuICAgIH1cbiAgICAvKiogUnVucyB0aGUgdHJhbnNhY3Rpb24gYW5kIHNldHMgdGhlIHJlc3VsdCBvbiBkZWZlcnJlZC4gKi9cbiAgICBydW4oKSB7XG4gICAgICAgIHRoaXMuYXR0ZW1wdHNSZW1haW5pbmcgLT0gMTtcbiAgICAgICAgdGhpcy5ydW5XaXRoQmFja09mZigpO1xuICAgIH1cbiAgICBydW5XaXRoQmFja09mZigpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmLmJhY2tvZmZBbmRSdW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24kMih0aGlzLmRhdGFzdG9yZSk7XG4gICAgICAgICAgICBjb25zdCB1c2VyUHJvbWlzZSA9IHRoaXMudHJ5UnVuVXBkYXRlRnVuY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHVzZXJQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgdXNlclByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbW1pdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goY29tbWl0RXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNhY3Rpb25FcnJvcihjb21taXRFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHVzZXJQcm9taXNlRXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRyYW5zYWN0aW9uRXJyb3IodXNlclByb21pc2VFcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0cnlSdW5VcGRhdGVGdW5jdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXNlclByb21pc2UgPSB0aGlzLnVwZGF0ZUZ1bmN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh1c2VyUHJvbWlzZSkgfHxcbiAgICAgICAgICAgICAgICAhdXNlclByb21pc2UuY2F0Y2ggfHxcbiAgICAgICAgICAgICAgICAhdXNlclByb21pc2UudGhlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KEVycm9yKCdUcmFuc2FjdGlvbiBjYWxsYmFjayBtdXN0IHJldHVybiBhIFByb21pc2UnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXNlclByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgcmV0cnkgZXJyb3JzIHRocm93biBieSB1c2VyIHByb3ZpZGVkIHVwZGF0ZUZ1bmN0aW9uLlxuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlVHJhbnNhY3Rpb25FcnJvcihlcnJvcikge1xuICAgICAgICBpZiAodGhpcy5hdHRlbXB0c1JlbWFpbmluZyA+IDAgJiYgdGhpcy5pc1JldHJ5YWJsZVRyYW5zYWN0aW9uRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRzUmVtYWluaW5nIC09IDE7XG4gICAgICAgICAgICB0aGlzLmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5XaXRoQmFja09mZigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzUmV0cnlhYmxlVHJhbnNhY3Rpb25FcnJvcihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0ZpcmViYXNlRXJyb3InKSB7XG4gICAgICAgICAgICAvLyBJbiB0cmFuc2FjdGlvbnMsIHRoZSBiYWNrZW5kIHdpbGwgZmFpbCBvdXRkYXRlZCByZWFkcyB3aXRoIEZBSUxFRF9QUkVDT05ESVRJT04gYW5kXG4gICAgICAgICAgICAvLyBub24tbWF0Y2hpbmcgZG9jdW1lbnQgdmVyc2lvbnMgd2l0aCBBQk9SVEVELiBUaGVzZSBlcnJvcnMgc2hvdWxkIGJlIHJldHJpZWQuXG4gICAgICAgICAgICBjb25zdCBjb2RlID0gZXJyb3IuY29kZTtcbiAgICAgICAgICAgIHJldHVybiAoY29kZSA9PT0gJ2Fib3J0ZWQnIHx8XG4gICAgICAgICAgICAgICAgY29kZSA9PT0gJ2ZhaWxlZC1wcmVjb25kaXRpb24nIHx8XG4gICAgICAgICAgICAgICAgY29kZSA9PT0gJ2FscmVhZHktZXhpc3RzJyB8fFxuICAgICAgICAgICAgICAgICFpc1Blcm1hbmVudEVycm9yKGNvZGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgTE9HX1RBRyQyID0gJ0ZpcmVzdG9yZUNsaWVudCc7XG5jb25zdCBNQVhfQ09OQ1VSUkVOVF9MSU1CT19SRVNPTFVUSU9OUyA9IDEwMDtcbi8qKiBET01FeGNlcHRpb24gZXJyb3IgY29kZSBjb25zdGFudHMuICovXG5jb25zdCBET01fRVhDRVBUSU9OX0lOVkFMSURfU1RBVEUgPSAxMTtcbmNvbnN0IERPTV9FWENFUFRJT05fQUJPUlRFRCA9IDIwO1xuY29uc3QgRE9NX0VYQ0VQVElPTl9RVU9UQV9FWENFRURFRCA9IDIyO1xuLyoqXG4gKiBGaXJlc3RvcmVDbGllbnQgaXMgYSB0b3AtbGV2ZWwgY2xhc3MgdGhhdCBjb25zdHJ1Y3RzIGFuZCBvd25zIGFsbCBvZiB0aGUgLy9cbiAqIHBpZWNlcyBvZiB0aGUgY2xpZW50IFNESyBhcmNoaXRlY3R1cmUuIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgLy9cbiAqIGFzeW5jIHF1ZXVlIHRoYXQgaXMgc2hhcmVkIGJ5IGFsbCBvZiB0aGUgb3RoZXIgY29tcG9uZW50cyBpbiB0aGUgc3lzdGVtLiAvL1xuICovXG5jbGFzcyBGaXJlc3RvcmVDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgXG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzIHF1ZXVlIHJlc3BvbnNpYmxlIGZvciBhbGwgb2Ygb3VyIGludGVybmFsIHByb2Nlc3NpbmcuIFdoZW5cbiAgICAgKiB3ZSBnZXQgaW5jb21pbmcgd29yayBmcm9tIHRoZSB1c2VyICh2aWEgcHVibGljIEFQSSkgb3IgdGhlIG5ldHdvcmtcbiAgICAgKiAoaW5jb21pbmcgR1JQQyBtZXNzYWdlcyksIHdlIHNob3VsZCBhbHdheXMgc2NoZWR1bGUgb250byB0aGlzIHF1ZXVlLlxuICAgICAqIFRoaXMgZW5zdXJlcyBhbGwgb2Ygb3VyIHdvcmsgaXMgcHJvcGVybHkgc2VyaWFsaXplZCAoZS5nLiB3ZSBkb24ndFxuICAgICAqIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgb3BlcmF0aW9uIHdoaWxlIHRoZSBwcmV2aW91cyBvbmUgaXMgd2FpdGluZyBmb3JcbiAgICAgKiBhbiBhc3luYyBJL08gdG8gY29tcGxldGUpLlxuICAgICAqL1xuICAgIGFzeW5jUXVldWUsIGRhdGFiYXNlSW5mbywgY29tcG9uZW50UHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMgPSBhdXRoQ3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscyA9IGFwcENoZWNrQ3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZSA9IGFzeW5jUXVldWU7XG4gICAgICAgIHRoaXMuZGF0YWJhc2VJbmZvID0gZGF0YWJhc2VJbmZvO1xuICAgICAgICB0aGlzLnVzZXIgPSBVc2VyLlVOQVVUSEVOVElDQVRFRDtcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IEF1dG9JZC5uZXdJZCgpO1xuICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFsTGlzdGVuZXIgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxMaXN0ZW5lciA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLl91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyID0gY29tcG9uZW50UHJvdmlkZXI7XG4gICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxzLnN0YXJ0KGFzeW5jUXVldWUsIGFzeW5jICh1c2VyKSA9PiB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdSZWNlaXZlZCB1c2VyPScsIHVzZXIudWlkKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0aENyZWRlbnRpYWxMaXN0ZW5lcih1c2VyKTtcbiAgICAgICAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuc3RhcnQoYXN5bmNRdWV1ZSwgbmV3QXBwQ2hlY2tUb2tlbiA9PiB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdSZWNlaXZlZCBuZXcgYXBwIGNoZWNrIHRva2VuPScsIG5ld0FwcENoZWNrVG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFsTGlzdGVuZXIobmV3QXBwQ2hlY2tUb2tlbiwgdGhpcy51c2VyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBjb25maWd1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXN5bmNRdWV1ZTogdGhpcy5hc3luY1F1ZXVlLFxuICAgICAgICAgICAgZGF0YWJhc2VJbmZvOiB0aGlzLmRhdGFiYXNlSW5mbyxcbiAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgICAgICAgYXV0aENyZWRlbnRpYWxzOiB0aGlzLmF1dGhDcmVkZW50aWFscyxcbiAgICAgICAgICAgIGFwcENoZWNrQ3JlZGVudGlhbHM6IHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscyxcbiAgICAgICAgICAgIGluaXRpYWxVc2VyOiB0aGlzLnVzZXIsXG4gICAgICAgICAgICBtYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9uczogTUFYX0NPTkNVUlJFTlRfTElNQk9fUkVTT0xVVElPTlNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0Q3JlZGVudGlhbENoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIH1cbiAgICBzZXRBcHBDaGVja1Rva2VuQ2hhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIH1cbiAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZS5lbnRlclJlc3RyaWN0ZWRNb2RlKCk7XG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0RXZlbldoaWxlUmVzdHJpY3RlZChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbmxpbmVDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX29ubGluZUNvbXBvbmVudHMudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vZmZsaW5lQ29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9vZmZsaW5lQ29tcG9uZW50cy50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNyZWRlbnRpYWxzIHByb3ZpZGVyIG11c3QgYmUgdGVybWluYXRlZCBhZnRlciBzaHV0dGluZyBkb3duIHRoZVxuICAgICAgICAgICAgICAgIC8vIFJlbW90ZVN0b3JlIGFzIGl0IHdpbGwgcHJldmVudCB0aGUgUmVtb3RlU3RvcmUgZnJvbSByZXRyaWV2aW5nIGF1dGhcbiAgICAgICAgICAgICAgICAvLyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuc2h1dGRvd24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuc2h1dGRvd24oKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcmVzdG9yZUVycm9yID0gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCBgRmFpbGVkIHRvIHNodXRkb3duIHBlcnNpc3RlbmNlYCk7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGZpcmVzdG9yZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNldE9mZmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIG9mZmxpbmVDb21wb25lbnRQcm92aWRlcikge1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLnZlcmlmeU9wZXJhdGlvbkluUHJvZ3Jlc3MoKTtcbiAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdJbml0aWFsaXppbmcgT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XG4gICAgY29uc3QgY29uZmlndXJhdGlvbiA9IGNsaWVudC5jb25maWd1cmF0aW9uO1xuICAgIGF3YWl0IG9mZmxpbmVDb21wb25lbnRQcm92aWRlci5pbml0aWFsaXplKGNvbmZpZ3VyYXRpb24pO1xuICAgIGxldCBjdXJyZW50VXNlciA9IGNvbmZpZ3VyYXRpb24uaW5pdGlhbFVzZXI7XG4gICAgY2xpZW50LnNldENyZWRlbnRpYWxDaGFuZ2VMaXN0ZW5lcihhc3luYyAodXNlcikgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRVc2VyLmlzRXF1YWwodXNlcikpIHtcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmVIYW5kbGVVc2VyQ2hhbmdlKG9mZmxpbmVDb21wb25lbnRQcm92aWRlci5sb2NhbFN0b3JlLCB1c2VyKTtcbiAgICAgICAgICAgIGN1cnJlbnRVc2VyID0gdXNlcjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFdoZW4gYSB1c2VyIGNhbGxzIGNsZWFyUGVyc2lzdGVuY2UoKSBpbiBvbmUgY2xpZW50LCBhbGwgb3RoZXIgY2xpZW50c1xuICAgIC8vIG5lZWQgdG8gYmUgdGVybWluYXRlZCB0byBhbGxvdyB0aGUgZGVsZXRlIHRvIHN1Y2NlZWQuXG4gICAgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLnBlcnNpc3RlbmNlLnNldERhdGFiYXNlRGVsZXRlZExpc3RlbmVyKCgpID0+IGNsaWVudC50ZXJtaW5hdGUoKSk7XG4gICAgY2xpZW50Ll9vZmZsaW5lQ29tcG9uZW50cyA9IG9mZmxpbmVDb21wb25lbnRQcm92aWRlcjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNldE9ubGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIpIHtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS52ZXJpZnlPcGVyYXRpb25JblByb2dyZXNzKCk7XG4gICAgY29uc3Qgb2ZmbGluZUNvbXBvbmVudHMgPSBhd2FpdCBlbnN1cmVPZmZsaW5lQ29tcG9uZW50cyhjbGllbnQpO1xuICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ0luaXRpYWxpemluZyBPbmxpbmVDb21wb25lbnRQcm92aWRlcicpO1xuICAgIGF3YWl0IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLmluaXRpYWxpemUob2ZmbGluZUNvbXBvbmVudHMsIGNsaWVudC5jb25maWd1cmF0aW9uKTtcbiAgICAvLyBUaGUgQ3JlZGVudGlhbENoYW5nZUxpc3RlbmVyIG9mIHRoZSBvbmxpbmUgY29tcG9uZW50IHByb3ZpZGVyIHRha2VzXG4gICAgLy8gcHJlY2VkZW5jZSBvdmVyIHRoZSBvZmZsaW5lIGNvbXBvbmVudCBwcm92aWRlci5cbiAgICBjbGllbnQuc2V0Q3JlZGVudGlhbENoYW5nZUxpc3RlbmVyKHVzZXIgPT4gcmVtb3RlU3RvcmVIYW5kbGVDcmVkZW50aWFsQ2hhbmdlKG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnJlbW90ZVN0b3JlLCB1c2VyKSk7XG4gICAgY2xpZW50LnNldEFwcENoZWNrVG9rZW5DaGFuZ2VMaXN0ZW5lcigoXywgdXNlcikgPT4gcmVtb3RlU3RvcmVIYW5kbGVDcmVkZW50aWFsQ2hhbmdlKG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnJlbW90ZVN0b3JlLCB1c2VyKSk7XG4gICAgY2xpZW50Ll9vbmxpbmVDb21wb25lbnRzID0gb25saW5lQ29tcG9uZW50UHJvdmlkZXI7XG59XG4vKipcbiAqIERlY2lkZXMgd2hldGhlciB0aGUgcHJvdmlkZWQgZXJyb3IgYWxsb3dzIHVzIHRvIGdyYWNlZnVsbHkgZGlzYWJsZVxuICogcGVyc2lzdGVuY2UgKGFzIG9wcG9zZWQgdG8gY3Jhc2hpbmcgdGhlIGNsaWVudCkuXG4gKi9cbmZ1bmN0aW9uIGNhbkZhbGxiYWNrRnJvbUluZGV4ZWREYkVycm9yKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLm5hbWUgPT09ICdGaXJlYmFzZUVycm9yJykge1xuICAgICAgICByZXR1cm4gKGVycm9yLmNvZGUgPT09IENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiB8fFxuICAgICAgICAgICAgZXJyb3IuY29kZSA9PT0gQ29kZS5VTklNUExFTUVOVEVEKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIERPTUV4Y2VwdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBET01FeGNlcHRpb24pIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIGEgZmV3IGtub3duIGNpcmN1bXN0YW5jZXMgd2hlcmUgd2UgY2FuIG9wZW4gSW5kZXhlZERiIGJ1dFxuICAgICAgICAvLyB0cnlpbmcgdG8gcmVhZC93cml0ZSB3aWxsIGZhaWwgKGUuZy4gcXVvdGEgZXhjZWVkZWQpLiBGb3JcbiAgICAgICAgLy8gd2VsbC11bmRlcnN0b29kIGNhc2VzLCB3ZSBhdHRlbXB0IHRvIGRldGVjdCB0aGVzZSBhbmQgdGhlbiBncmFjZWZ1bGx5XG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBtZW1vcnkgcGVyc2lzdGVuY2UuXG4gICAgICAgIC8vIE5PVEU6IFJhdGhlciB0aGFuIGNvbnRpbnVlIHRvIGFkZCB0byB0aGlzIGxpc3QsIHdlIGNvdWxkIGRlY2lkZSB0b1xuICAgICAgICAvLyBhbHdheXMgZmFsbCBiYWNrLCB3aXRoIHRoZSByaXNrIHRoYXQgd2UgbWlnaHQgYWNjaWRlbnRhbGx5IGhpZGUgZXJyb3JzXG4gICAgICAgIC8vIHJlcHJlc2VudGluZyBhY3R1YWwgU0RLIGJ1Z3MuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIFdoZW4gdGhlIGJyb3dzZXIgaXMgb3V0IG9mIHF1b3RhIHdlIGNvdWxkIGdldCBlaXRoZXIgcXVvdGEgZXhjZWVkZWRcbiAgICAgICAgLy8gb3IgYW4gYWJvcnRlZCBlcnJvciBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZXJyb3IgaGFwcGVuZWQgZHVyaW5nXG4gICAgICAgIC8vIHNjaGVtYSBtaWdyYXRpb24uXG4gICAgICAgIGVycm9yLmNvZGUgPT09IERPTV9FWENFUFRJT05fUVVPVEFfRVhDRUVERUQgfHxcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPT09IERPTV9FWENFUFRJT05fQUJPUlRFRCB8fFxuICAgICAgICAgICAgLy8gRmlyZWZveCBQcml2YXRlIEJyb3dzaW5nIG1vZGUgZGlzYWJsZXMgSW5kZXhlZERiIGFuZCByZXR1cm5zXG4gICAgICAgICAgICAvLyBJTlZBTElEX1NUQVRFIGZvciBhbnkgdXNhZ2UuXG4gICAgICAgICAgICBlcnJvci5jb2RlID09PSBET01fRVhDRVBUSU9OX0lOVkFMSURfU1RBVEUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZU9mZmxpbmVDb21wb25lbnRzKGNsaWVudCkge1xuICAgIGlmICghY2xpZW50Ll9vZmZsaW5lQ29tcG9uZW50cykge1xuICAgICAgICBpZiAoY2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdVc2luZyB1c2VyIHByb3ZpZGVkIE9mZmxpbmVDb21wb25lbnRQcm92aWRlcicpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzZXRPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIuX29mZmxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5GYWxsYmFja0Zyb21JbmRleGVkRGJFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZ1dhcm4oJ0Vycm9yIHVzaW5nIHVzZXIgcHJvdmlkZWQgY2FjaGUuIEZhbGxpbmcgYmFjayB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgJ21lbW9yeSBjYWNoZTogJyArXG4gICAgICAgICAgICAgICAgICAgIGVycm9yKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzZXRPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBuZXcgTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQyLCAnVXNpbmcgZGVmYXVsdCBPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXInKTtcbiAgICAgICAgICAgIGF3YWl0IHNldE9mZmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIG5ldyBMcnVHY01lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlcih1bmRlZmluZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xpZW50Ll9vZmZsaW5lQ29tcG9uZW50cztcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZU9ubGluZUNvbXBvbmVudHMoY2xpZW50KSB7XG4gICAgaWYgKCFjbGllbnQuX29ubGluZUNvbXBvbmVudHMpIHtcbiAgICAgICAgaWYgKGNsaWVudC5fdW5pbml0aWFsaXplZENvbXBvbmVudHNQcm92aWRlcikge1xuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQyLCAnVXNpbmcgdXNlciBwcm92aWRlZCBPbmxpbmVDb21wb25lbnRQcm92aWRlcicpO1xuICAgICAgICAgICAgYXdhaXQgc2V0T25saW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIuX29ubGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdVc2luZyBkZWZhdWx0IE9ubGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XG4gICAgICAgICAgICBhd2FpdCBzZXRPbmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIG5ldyBPbmxpbmVDb21wb25lbnRQcm92aWRlcigpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xpZW50Ll9vbmxpbmVDb21wb25lbnRzO1xufVxuZnVuY3Rpb24gZ2V0UGVyc2lzdGVuY2UoY2xpZW50KSB7XG4gICAgcmV0dXJuIGVuc3VyZU9mZmxpbmVDb21wb25lbnRzKGNsaWVudCkudGhlbihjID0+IGMucGVyc2lzdGVuY2UpO1xufVxuZnVuY3Rpb24gZ2V0TG9jYWxTdG9yZShjbGllbnQpIHtcbiAgICByZXR1cm4gZW5zdXJlT2ZmbGluZUNvbXBvbmVudHMoY2xpZW50KS50aGVuKGMgPT4gYy5sb2NhbFN0b3JlKTtcbn1cbmZ1bmN0aW9uIGdldFJlbW90ZVN0b3JlKGNsaWVudCkge1xuICAgIHJldHVybiBlbnN1cmVPbmxpbmVDb21wb25lbnRzKGNsaWVudCkudGhlbihjID0+IGMucmVtb3RlU3RvcmUpO1xufVxuZnVuY3Rpb24gZ2V0U3luY0VuZ2luZShjbGllbnQpIHtcbiAgICByZXR1cm4gZW5zdXJlT25saW5lQ29tcG9uZW50cyhjbGllbnQpLnRoZW4oYyA9PiBjLnN5bmNFbmdpbmUpO1xufVxuZnVuY3Rpb24gZ2V0RGF0YXN0b3JlKGNsaWVudCkge1xuICAgIHJldHVybiBlbnN1cmVPbmxpbmVDb21wb25lbnRzKGNsaWVudCkudGhlbihjID0+IGMuZGF0YXN0b3JlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEV2ZW50TWFuYWdlcihjbGllbnQpIHtcbiAgICBjb25zdCBvbmxpbmVDb21wb25lbnRQcm92aWRlciA9IGF3YWl0IGVuc3VyZU9ubGluZUNvbXBvbmVudHMoY2xpZW50KTtcbiAgICBjb25zdCBldmVudE1hbmFnZXIgPSBvbmxpbmVDb21wb25lbnRQcm92aWRlci5ldmVudE1hbmFnZXI7XG4gICAgZXZlbnRNYW5hZ2VyLm9uTGlzdGVuID0gc3luY0VuZ2luZUxpc3Rlbi5iaW5kKG51bGwsIG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmUpO1xuICAgIGV2ZW50TWFuYWdlci5vblVubGlzdGVuID0gc3luY0VuZ2luZVVubGlzdGVuLmJpbmQobnVsbCwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY0VuZ2luZSk7XG4gICAgZXZlbnRNYW5hZ2VyLm9uRmlyc3RSZW1vdGVTdG9yZUxpc3RlbiA9IHRyaWdnZXJSZW1vdGVTdG9yZUxpc3Rlbi5iaW5kKG51bGwsIG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmUpO1xuICAgIGV2ZW50TWFuYWdlci5vbkxhc3RSZW1vdGVTdG9yZVVubGlzdGVuID0gdHJpZ2dlclJlbW90ZVN0b3JlVW5saXN0ZW4uYmluZChudWxsLCBvbmxpbmVDb21wb25lbnRQcm92aWRlci5zeW5jRW5naW5lKTtcbiAgICByZXR1cm4gZXZlbnRNYW5hZ2VyO1xufVxuLyoqIEVuYWJsZXMgdGhlIG5ldHdvcmsgY29ubmVjdGlvbiBhbmQgcmUtZW5xdWV1ZXMgYWxsIHBlbmRpbmcgb3BlcmF0aW9ucy4gKi9cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudEVuYWJsZU5ldHdvcmsoY2xpZW50KSB7XG4gICAgcmV0dXJuIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBwZXJzaXN0ZW5jZSA9IGF3YWl0IGdldFBlcnNpc3RlbmNlKGNsaWVudCk7XG4gICAgICAgIGNvbnN0IHJlbW90ZVN0b3JlID0gYXdhaXQgZ2V0UmVtb3RlU3RvcmUoY2xpZW50KTtcbiAgICAgICAgcGVyc2lzdGVuY2Uuc2V0TmV0d29ya0VuYWJsZWQodHJ1ZSk7XG4gICAgICAgIHJldHVybiByZW1vdGVTdG9yZUVuYWJsZU5ldHdvcmsocmVtb3RlU3RvcmUpO1xuICAgIH0pO1xufVxuLyoqIERpc2FibGVzIHRoZSBuZXR3b3JrIGNvbm5lY3Rpb24uIFBlbmRpbmcgb3BlcmF0aW9ucyB3aWxsIG5vdCBjb21wbGV0ZS4gKi9cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudERpc2FibGVOZXR3b3JrKGNsaWVudCkge1xuICAgIHJldHVybiBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcGVyc2lzdGVuY2UgPSBhd2FpdCBnZXRQZXJzaXN0ZW5jZShjbGllbnQpO1xuICAgICAgICBjb25zdCByZW1vdGVTdG9yZSA9IGF3YWl0IGdldFJlbW90ZVN0b3JlKGNsaWVudCk7XG4gICAgICAgIHBlcnNpc3RlbmNlLnNldE5ldHdvcmtFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHJlbW90ZVN0b3JlRGlzYWJsZU5ldHdvcmsocmVtb3RlU3RvcmUpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIHdyaXRlcyB0aGF0IHdlcmUgcGVuZGluZyBhdCB0aGUgdGltZVxuICogdGhpcyBtZXRob2Qgd2FzIGNhbGxlZCByZWNlaXZlZCBzZXJ2ZXIgYWNrbm93bGVkZ2VtZW50LiBBbiBhY2tub3dsZWRnZW1lbnRcbiAqIGNhbiBiZSBlaXRoZXIgYWNjZXB0YW5jZSBvciByZWplY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudFdhaXRGb3JQZW5kaW5nV3JpdGVzKGNsaWVudCkge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bmNFbmdpbmUgPSBhd2FpdCBnZXRTeW5jRW5naW5lKGNsaWVudCk7XG4gICAgICAgIHJldHVybiBzeW5jRW5naW5lUmVnaXN0ZXJQZW5kaW5nV3JpdGVzQ2FsbGJhY2soc3luY0VuZ2luZSwgZGVmZXJyZWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50TGlzdGVuKGNsaWVudCwgcXVlcnksIG9wdGlvbnMsIG9ic2VydmVyKSB7XG4gICAgY29uc3Qgd3JhcHBlZE9ic2VydmVyID0gbmV3IEFzeW5jT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gbmV3IFF1ZXJ5TGlzdGVuZXIocXVlcnksIHdyYXBwZWRPYnNlcnZlciwgb3B0aW9ucyk7XG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IGF3YWl0IGdldEV2ZW50TWFuYWdlcihjbGllbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnRNYW5hZ2VyTGlzdGVuKGV2ZW50TWFuYWdlciwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdyYXBwZWRPYnNlcnZlci5tdXRlKCk7XG4gICAgICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gYXdhaXQgZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCk7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRNYW5hZ2VyVW5saXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudEZyb21Mb2NhbENhY2hlKGNsaWVudCwgZG9jS2V5KSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbG9jYWxTdG9yZSA9IGF3YWl0IGdldExvY2FsU3RvcmUoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIHJlYWREb2N1bWVudEZyb21DYWNoZShsb2NhbFN0b3JlLCBkb2NLZXksIGRlZmVycmVkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50VmlhU25hcHNob3RMaXN0ZW5lcihjbGllbnQsIGtleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gYXdhaXQgZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCk7XG4gICAgICAgIHJldHVybiByZWFkRG9jdW1lbnRWaWFTbmFwc2hvdExpc3RlbmVyKGV2ZW50TWFuYWdlciwgY2xpZW50LmFzeW5jUXVldWUsIGtleSwgb3B0aW9ucywgZGVmZXJyZWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRzRnJvbUxvY2FsQ2FjaGUoY2xpZW50LCBxdWVyeSkge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxvY2FsU3RvcmUgPSBhd2FpdCBnZXRMb2NhbFN0b3JlKGNsaWVudCk7XG4gICAgICAgIHJldHVybiBleGVjdXRlUXVlcnlGcm9tQ2FjaGUobG9jYWxTdG9yZSwgcXVlcnksIGRlZmVycmVkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50c1ZpYVNuYXBzaG90TGlzdGVuZXIoY2xpZW50LCBxdWVyeSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gYXdhaXQgZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCk7XG4gICAgICAgIHJldHVybiBleGVjdXRlUXVlcnlWaWFTbmFwc2hvdExpc3RlbmVyKGV2ZW50TWFuYWdlciwgY2xpZW50LmFzeW5jUXVldWUsIHF1ZXJ5LCBvcHRpb25zLCBkZWZlcnJlZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRSdW5BZ2dyZWdhdGVRdWVyeShjbGllbnQsIHF1ZXJ5LCBhZ2dyZWdhdGVzKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gSW1wbGVtZW50IGFuZCBjYWxsIGV4ZWN1dGVBZ2dyZWdhdGVRdWVyeVZpYVNuYXBzaG90TGlzdGVuZXIsIHNpbWlsYXJcbiAgICAgICAgLy8gdG8gdGhlIGltcGxlbWVudGF0aW9uIGluIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50c1ZpYVNuYXBzaG90TGlzdGVuZXJcbiAgICAgICAgLy8gYWJvdmVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRPRE8oYi8yNzc2MjgzODQpOiBjaGVjayBgY2FuVXNlTmV0d29yaygpYCBhbmQgaGFuZGxlIG11bHRpLXRhYi5cbiAgICAgICAgICAgIGNvbnN0IGRhdGFzdG9yZSA9IGF3YWl0IGdldERhdGFzdG9yZShjbGllbnQpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShpbnZva2VSdW5BZ2dyZWdhdGlvblF1ZXJ5UnBjKGRhdGFzdG9yZSwgcXVlcnksIGFnZ3JlZ2F0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRXcml0ZShjbGllbnQsIG11dGF0aW9ucykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bmNFbmdpbmUgPSBhd2FpdCBnZXRTeW5jRW5naW5lKGNsaWVudCk7XG4gICAgICAgIHJldHVybiBzeW5jRW5naW5lV3JpdGUoc3luY0VuZ2luZSwgbXV0YXRpb25zLCBkZWZlcnJlZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRBZGRTbmFwc2hvdHNJblN5bmNMaXN0ZW5lcihjbGllbnQsIG9ic2VydmVyKSB7XG4gICAgY29uc3Qgd3JhcHBlZE9ic2VydmVyID0gbmV3IEFzeW5jT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIGFkZFNuYXBzaG90c0luU3luY0xpc3RlbmVyKGV2ZW50TWFuYWdlciwgd3JhcHBlZE9ic2VydmVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3cmFwcGVkT2JzZXJ2ZXIubXV0ZSgpO1xuICAgICAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IGF3YWl0IGdldEV2ZW50TWFuYWdlcihjbGllbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVNuYXBzaG90c0luU3luY0xpc3RlbmVyKGV2ZW50TWFuYWdlciwgd3JhcHBlZE9ic2VydmVyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogVGFrZXMgYW4gdXBkYXRlRnVuY3Rpb24gaW4gd2hpY2ggYSBzZXQgb2YgcmVhZHMgYW5kIHdyaXRlcyBjYW4gYmUgcGVyZm9ybWVkXG4gKiBhdG9taWNhbGx5LiBJbiB0aGUgdXBkYXRlRnVuY3Rpb24sIHRoZSBjbGllbnQgY2FuIHJlYWQgYW5kIHdyaXRlIHZhbHVlc1xuICogdXNpbmcgdGhlIHN1cHBsaWVkIHRyYW5zYWN0aW9uIG9iamVjdC4gQWZ0ZXIgdGhlIHVwZGF0ZUZ1bmN0aW9uLCBhbGxcbiAqIGNoYW5nZXMgd2lsbCBiZSBjb21taXR0ZWQuIElmIGEgcmV0cnlhYmxlIGVycm9yIG9jY3VycyAoZXg6IHNvbWUgb3RoZXJcbiAqIGNsaWVudCBoYXMgY2hhbmdlZCBhbnkgb2YgdGhlIGRhdGEgcmVmZXJlbmNlZCksIHRoZW4gdGhlIHVwZGF0ZUZ1bmN0aW9uXG4gKiB3aWxsIGJlIGNhbGxlZCBhZ2FpbiBhZnRlciBhIGJhY2tvZmYuIElmIHRoZSB1cGRhdGVGdW5jdGlvbiBzdGlsbCBmYWlsc1xuICogYWZ0ZXIgYWxsIHJldHJpZXMsIHRoZW4gdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgcmVqZWN0ZWQuXG4gKlxuICogVGhlIHRyYW5zYWN0aW9uIG9iamVjdCBwYXNzZWQgdG8gdGhlIHVwZGF0ZUZ1bmN0aW9uIGNvbnRhaW5zIG1ldGhvZHMgZm9yXG4gKiBhY2Nlc3NpbmcgZG9jdW1lbnRzIGFuZCBjb2xsZWN0aW9ucy4gVW5saWtlIG90aGVyIGRhdGFzdG9yZSBhY2Nlc3MsIGRhdGFcbiAqIGFjY2Vzc2VkIHdpdGggdGhlIHRyYW5zYWN0aW9uIHdpbGwgbm90IHJlZmxlY3QgbG9jYWwgY2hhbmdlcyB0aGF0IGhhdmUgbm90XG4gKiBiZWVuIGNvbW1pdHRlZC4gRm9yIHRoaXMgcmVhc29uLCBpdCBpcyByZXF1aXJlZCB0aGF0IGFsbCByZWFkcyBhcmVcbiAqIHBlcmZvcm1lZCBiZWZvcmUgYW55IHdyaXRlcy4gVHJhbnNhY3Rpb25zIG11c3QgYmUgcGVyZm9ybWVkIHdoaWxlIG9ubGluZS5cbiAqL1xuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50VHJhbnNhY3Rpb24oY2xpZW50LCB1cGRhdGVGdW5jdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGFzdG9yZSA9IGF3YWl0IGdldERhdGFzdG9yZShjbGllbnQpO1xuICAgICAgICBuZXcgVHJhbnNhY3Rpb25SdW5uZXIoY2xpZW50LmFzeW5jUXVldWUsIGRhdGFzdG9yZSwgb3B0aW9ucywgdXBkYXRlRnVuY3Rpb24sIGRlZmVycmVkKS5ydW4oKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlYWREb2N1bWVudEZyb21DYWNoZShsb2NhbFN0b3JlLCBkb2NLZXksIHJlc3VsdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gYXdhaXQgbG9jYWxTdG9yZVJlYWREb2N1bWVudChsb2NhbFN0b3JlLCBkb2NLZXkpO1xuICAgICAgICBpZiAoZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKGRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb2N1bWVudC5pc05vRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOQVZBSUxBQkxFLCAnRmFpbGVkIHRvIGdldCBkb2N1bWVudCBmcm9tIGNhY2hlLiAoSG93ZXZlciwgdGhpcyBkb2N1bWVudCBtYXkgJyArXG4gICAgICAgICAgICAgICAgXCJleGlzdCBvbiB0aGUgc2VydmVyLiBSdW4gYWdhaW4gd2l0aG91dCBzZXR0aW5nICdzb3VyY2UnIGluIFwiICtcbiAgICAgICAgICAgICAgICAndGhlIEdldE9wdGlvbnMgdG8gYXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgZG9jdW1lbnQgZnJvbSB0aGUgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci4pJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGZpcmVzdG9yZUVycm9yID0gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCBgRmFpbGVkIHRvIGdldCBkb2N1bWVudCAnJHtkb2NLZXl9IGZyb20gY2FjaGVgKTtcbiAgICAgICAgcmVzdWx0LnJlamVjdChmaXJlc3RvcmVFcnJvcik7XG4gICAgfVxufVxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBsYXRlbmN5LWNvbXBlbnNhdGVkIGRvY3VtZW50IGZyb20gdGhlIGJhY2tlbmQgdmlhIGFcbiAqIFNuYXBzaG90TGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIHJlYWREb2N1bWVudFZpYVNuYXBzaG90TGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCBhc3luY1F1ZXVlLCBrZXksIG9wdGlvbnMsIHJlc3VsdCkge1xuICAgIGNvbnN0IHdyYXBwZWRPYnNlcnZlciA9IG5ldyBBc3luY09ic2VydmVyKHtcbiAgICAgICAgbmV4dDogKHNuYXApID0+IHtcbiAgICAgICAgICAgIC8vIE11dGUgYW5kIHJlbW92ZSBxdWVyeSBmaXJzdCBiZWZvcmUgcGFzc2luZyBldmVudCB0byB1c2VyIHRvIGF2b2lkXG4gICAgICAgICAgICAvLyB1c2VyIGFjdGlvbnMgYWZmZWN0aW5nIHRoZSBub3cgc3RhbGUgcXVlcnkuXG4gICAgICAgICAgICB3cmFwcGVkT2JzZXJ2ZXIubXV0ZSgpO1xuICAgICAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IGV2ZW50TWFuYWdlclVubGlzdGVuKGV2ZW50TWFuYWdlciwgbGlzdGVuZXIpKTtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0cyA9IHNuYXAuZG9jcy5oYXMoa2V5KTtcbiAgICAgICAgICAgIGlmICghZXhpc3RzICYmIHNuYXAuZnJvbUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiBJZiB3ZSdyZSBvbmxpbmUgYW5kIHRoZSBkb2N1bWVudCBkb2Vzbid0XG4gICAgICAgICAgICAgICAgLy8gZXhpc3QgdGhlbiB3ZSByZXNvbHZlIHdpdGggYSBkb2MuZXhpc3RzIHNldCB0byBmYWxzZS4gSWZcbiAgICAgICAgICAgICAgICAvLyB3ZSdyZSBvZmZsaW5lIGhvd2V2ZXIsIHdlIHJlamVjdCB0aGUgUHJvbWlzZSBpbiB0aGlzXG4gICAgICAgICAgICAgICAgLy8gY2FzZS4gVHdvIG9wdGlvbnM6IDEpIENhY2hlIHRoZSBuZWdhdGl2ZSByZXNwb25zZSBmcm9tXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNlcnZlciBzbyB3ZSBjYW4gZGVsaXZlciB0aGF0IGV2ZW4gd2hlbiB5b3UncmVcbiAgICAgICAgICAgICAgICAvLyBvZmZsaW5lIDIpIEFjdHVhbGx5IHJlamVjdCB0aGUgUHJvbWlzZSBpbiB0aGUgb25saW5lIGNhc2VcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdC5cbiAgICAgICAgICAgICAgICByZXN1bHQucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOQVZBSUxBQkxFLCAnRmFpbGVkIHRvIGdldCBkb2N1bWVudCBiZWNhdXNlIHRoZSBjbGllbnQgaXMgb2ZmbGluZS4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChleGlzdHMgJiZcbiAgICAgICAgICAgICAgICBzbmFwLmZyb21DYWNoZSAmJlxuICAgICAgICAgICAgICAgIG9wdGlvbnMgJiZcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNvdXJjZSA9PT0gJ3NlcnZlcicpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLlVOQVZBSUxBQkxFLCAnRmFpbGVkIHRvIGdldCBkb2N1bWVudCBmcm9tIHNlcnZlci4gKEhvd2V2ZXIsIHRoaXMgJyArXG4gICAgICAgICAgICAgICAgICAgICdkb2N1bWVudCBkb2VzIGV4aXN0IGluIHRoZSBsb2NhbCBjYWNoZS4gUnVuIGFnYWluICcgK1xuICAgICAgICAgICAgICAgICAgICAnd2l0aG91dCBzZXR0aW5nIHNvdXJjZSB0byBcInNlcnZlclwiIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAncmV0cmlldmUgdGhlIGNhY2hlZCBkb2N1bWVudC4pJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoc25hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBlID0+IHJlc3VsdC5yZWplY3QoZSlcbiAgICB9KTtcbiAgICBjb25zdCBsaXN0ZW5lciA9IG5ldyBRdWVyeUxpc3RlbmVyKG5ld1F1ZXJ5Rm9yUGF0aChrZXkucGF0aCksIHdyYXBwZWRPYnNlcnZlciwge1xuICAgICAgICBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzOiB0cnVlLFxuICAgICAgICB3YWl0Rm9yU3luY1doZW5PbmxpbmU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnRNYW5hZ2VyTGlzdGVuKGV2ZW50TWFuYWdlciwgbGlzdGVuZXIpO1xufVxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVF1ZXJ5RnJvbUNhY2hlKGxvY2FsU3RvcmUsIHF1ZXJ5LCByZXN1bHQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBxdWVyeVJlc3VsdCA9IGF3YWl0IGxvY2FsU3RvcmVFeGVjdXRlUXVlcnkobG9jYWxTdG9yZSwgcXVlcnksIFxuICAgICAgICAvKiB1c2VQcmV2aW91c1Jlc3VsdHM9ICovIHRydWUpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFZpZXcocXVlcnksIHF1ZXJ5UmVzdWx0LnJlbW90ZUtleXMpO1xuICAgICAgICBjb25zdCB2aWV3RG9jQ2hhbmdlcyA9IHZpZXcuY29tcHV0ZURvY0NoYW5nZXMocXVlcnlSZXN1bHQuZG9jdW1lbnRzKTtcbiAgICAgICAgY29uc3Qgdmlld0NoYW5nZSA9IHZpZXcuYXBwbHlDaGFuZ2VzKHZpZXdEb2NDaGFuZ2VzLCBcbiAgICAgICAgLyogbGltYm9SZXNvbHV0aW9uRW5hYmxlZD0gKi8gZmFsc2UpO1xuICAgICAgICByZXN1bHQucmVzb2x2ZSh2aWV3Q2hhbmdlLnNuYXBzaG90KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZmlyZXN0b3JlRXJyb3IgPSB3cmFwSW5Vc2VyRXJyb3JJZlJlY292ZXJhYmxlKGUsIGBGYWlsZWQgdG8gZXhlY3V0ZSBxdWVyeSAnJHtxdWVyeX0gYWdhaW5zdCBjYWNoZWApO1xuICAgICAgICByZXN1bHQucmVqZWN0KGZpcmVzdG9yZUVycm9yKTtcbiAgICB9XG59XG4vKipcbiAqIFJldHJpZXZlcyBhIGxhdGVuY3ktY29tcGVuc2F0ZWQgcXVlcnkgc25hcHNob3QgZnJvbSB0aGUgYmFja2VuZCB2aWEgYVxuICogU25hcHNob3RMaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZVF1ZXJ5VmlhU25hcHNob3RMaXN0ZW5lcihldmVudE1hbmFnZXIsIGFzeW5jUXVldWUsIHF1ZXJ5LCBvcHRpb25zLCByZXN1bHQpIHtcbiAgICBjb25zdCB3cmFwcGVkT2JzZXJ2ZXIgPSBuZXcgQXN5bmNPYnNlcnZlcih7XG4gICAgICAgIG5leHQ6IHNuYXBzaG90ID0+IHtcbiAgICAgICAgICAgIC8vIE11dGUgYW5kIHJlbW92ZSBxdWVyeSBmaXJzdCBiZWZvcmUgcGFzc2luZyBldmVudCB0byB1c2VyIHRvIGF2b2lkXG4gICAgICAgICAgICAvLyB1c2VyIGFjdGlvbnMgYWZmZWN0aW5nIHRoZSBub3cgc3RhbGUgcXVlcnkuXG4gICAgICAgICAgICB3cmFwcGVkT2JzZXJ2ZXIubXV0ZSgpO1xuICAgICAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IGV2ZW50TWFuYWdlclVubGlzdGVuKGV2ZW50TWFuYWdlciwgbGlzdGVuZXIpKTtcbiAgICAgICAgICAgIGlmIChzbmFwc2hvdC5mcm9tQ2FjaGUgJiYgb3B0aW9ucy5zb3VyY2UgPT09ICdzZXJ2ZXInKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTkFWQUlMQUJMRSwgJ0ZhaWxlZCB0byBnZXQgZG9jdW1lbnRzIGZyb20gc2VydmVyLiAoSG93ZXZlciwgdGhlc2UgJyArXG4gICAgICAgICAgICAgICAgICAgICdkb2N1bWVudHMgbWF5IGV4aXN0IGluIHRoZSBsb2NhbCBjYWNoZS4gUnVuIGFnYWluICcgK1xuICAgICAgICAgICAgICAgICAgICAnd2l0aG91dCBzZXR0aW5nIHNvdXJjZSB0byBcInNlcnZlclwiIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAncmV0cmlldmUgdGhlIGNhY2hlZCBkb2N1bWVudHMuKScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKHNuYXBzaG90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGUgPT4gcmVzdWx0LnJlamVjdChlKVxuICAgIH0pO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gbmV3IFF1ZXJ5TGlzdGVuZXIocXVlcnksIHdyYXBwZWRPYnNlcnZlciwge1xuICAgICAgICBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzOiB0cnVlLFxuICAgICAgICB3YWl0Rm9yU3luY1doZW5PbmxpbmU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnRNYW5hZ2VyTGlzdGVuKGV2ZW50TWFuYWdlciwgbGlzdGVuZXIpO1xufVxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50TG9hZEJ1bmRsZShjbGllbnQsIGRhdGFiYXNlSWQsIGRhdGEsIHJlc3VsdFRhc2spIHtcbiAgICBjb25zdCByZWFkZXIgPSBjcmVhdGVCdW5kbGVSZWFkZXIoZGF0YSwgbmV3U2VyaWFsaXplcihkYXRhYmFzZUlkKSk7XG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XG4gICAgICAgIHN5bmNFbmdpbmVMb2FkQnVuZGxlKGF3YWl0IGdldFN5bmNFbmdpbmUoY2xpZW50KSwgcmVhZGVyLCByZXN1bHRUYXNrKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudEdldE5hbWVkUXVlcnkoY2xpZW50LCBxdWVyeU5hbWUpIHtcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiBsb2NhbFN0b3JlR2V0TmFtZWRRdWVyeShhd2FpdCBnZXRMb2NhbFN0b3JlKGNsaWVudCksIHF1ZXJ5TmFtZSkpO1xufVxuZnVuY3Rpb24gY3JlYXRlQnVuZGxlUmVhZGVyKGRhdGEsIHNlcmlhbGl6ZXIpIHtcbiAgICBsZXQgY29udGVudDtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnRlbnQgPSBuZXdUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnRlbnQgPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QnVuZGxlUmVhZGVyKHRvQnl0ZVN0cmVhbVJlYWRlcihjb250ZW50KSwgc2VyaWFsaXplcik7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRTZXRJbmRleENvbmZpZ3VyYXRpb24oY2xpZW50LCBpbmRleGVzKSB7XG4gICAgcmV0dXJuIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUNvbmZpZ3VyZUZpZWxkSW5kZXhlcyhhd2FpdCBnZXRMb2NhbFN0b3JlKGNsaWVudCksIGluZGV4ZXMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50U2V0UGVyc2lzdGVudENhY2hlSW5kZXhBdXRvQ3JlYXRpb25FbmFibGVkKGNsaWVudCwgaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZVNldEluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZChhd2FpdCBnZXRMb2NhbFN0b3JlKGNsaWVudCksIGlzRW5hYmxlZCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnREZWxldGVBbGxGaWVsZEluZGV4ZXMoY2xpZW50KSB7XG4gICAgcmV0dXJuIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZURlbGV0ZUFsbEZpZWxkSW5kZXhlcyhhd2FpdCBnZXRMb2NhbFN0b3JlKGNsaWVudCkpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDb21wYXJlcyB0d28gYEV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9uc2Agb2JqZWN0cyBmb3IgZXF1YWxpdHkuXG4gKi9cbmZ1bmN0aW9uIGxvbmdQb2xsaW5nT3B0aW9uc0VxdWFsKG9wdGlvbnMxLCBvcHRpb25zMikge1xuICAgIHJldHVybiBvcHRpb25zMS50aW1lb3V0U2Vjb25kcyA9PT0gb3B0aW9uczIudGltZW91dFNlY29uZHM7XG59XG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgYEV4cGVyaW1lbnRhbExvbmdQb2xsaW5nT3B0aW9uc2Agd2l0aCB0aGUgc2FtZVxuICogb3B0aW9uIHZhbHVlcyBhcyB0aGUgZ2l2ZW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGNsb25lTG9uZ1BvbGxpbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBjbG9uZSA9IHt9O1xuICAgIGlmIChvcHRpb25zLnRpbWVvdXRTZWNvbmRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2xvbmUudGltZW91dFNlY29uZHMgPSBvcHRpb25zLnRpbWVvdXRTZWNvbmRzO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHJDEgPSAnQ29tcG9uZW50UHJvdmlkZXInO1xuLyoqXG4gKiBBbiBpbnN0YW5jZSBtYXAgdGhhdCBlbnN1cmVzIG9ubHkgb25lIERhdGFzdG9yZSBleGlzdHMgcGVyIEZpcmVzdG9yZVxuICogaW5zdGFuY2UuXG4gKi9cbmNvbnN0IGRhdGFzdG9yZUluc3RhbmNlcyA9IG5ldyBNYXAoKTtcbi8qKlxuICogUmVtb3ZlcyBhbGwgY29tcG9uZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIGluc3RhbmNlLiBNdXN0IGJlIGNhbGxlZFxuICogd2hlbiB0aGUgYEZpcmVzdG9yZWAgaW5zdGFuY2UgaXMgdGVybWluYXRlZC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ29tcG9uZW50cyhmaXJlc3RvcmUpIHtcbiAgICBjb25zdCBkYXRhc3RvcmUgPSBkYXRhc3RvcmVJbnN0YW5jZXMuZ2V0KGZpcmVzdG9yZSk7XG4gICAgaWYgKGRhdGFzdG9yZSkge1xuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDEsICdSZW1vdmluZyBEYXRhc3RvcmUnKTtcbiAgICAgICAgZGF0YXN0b3JlSW5zdGFuY2VzLmRlbGV0ZShmaXJlc3RvcmUpO1xuICAgICAgICBkYXRhc3RvcmUudGVybWluYXRlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZURhdGFiYXNlSW5mbyhkYXRhYmFzZUlkLCBhcHBJZCwgcGVyc2lzdGVuY2VLZXksIHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhYmFzZUluZm8oZGF0YWJhc2VJZCwgYXBwSWQsIHBlcnNpc3RlbmNlS2V5LCBzZXR0aW5ncy5ob3N0LCBzZXR0aW5ncy5zc2wsIHNldHRpbmdzLmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmcsIHNldHRpbmdzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZywgY2xvbmVMb25nUG9sbGluZ09wdGlvbnMoc2V0dGluZ3MuZXhwZXJpbWVudGFsTG9uZ1BvbGxpbmdPcHRpb25zKSwgc2V0dGluZ3MudXNlRmV0Y2hTdHJlYW1zKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIHNldHRpbmdzKCkgZGVmYXVsdHM6XG5jb25zdCBERUZBVUxUX0hPU1QgPSAnZmlyZXN0b3JlLmdvb2dsZWFwaXMuY29tJztcbmNvbnN0IERFRkFVTFRfU1NMID0gdHJ1ZTtcbi8vIFRoZSBtaW5pbXVtIGxvbmctcG9sbGluZyB0aW1lb3V0IGlzIGhhcmRjb2RlZCBvbiB0aGUgc2VydmVyLiBUaGUgdmFsdWUgaGVyZVxuLy8gc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSB2YWx1ZSB1c2VkIGJ5IHRoZSBzZXJ2ZXIsIGFzIHRoZSBzZXJ2ZXIgd2lsbFxuLy8gc2lsZW50bHkgaWdub3JlIGEgdmFsdWUgYmVsb3cgdGhlIG1pbmltdW0gYW5kIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdC5cbi8vIEdvb2dsZXJzIHNlZSBiLzI2Njg2ODg3MSBmb3IgcmVsZXZhbnQgZGlzY3Vzc2lvbi5cbmNvbnN0IE1JTl9MT05HX1BPTExJTkdfVElNRU9VVF9TRUNPTkRTID0gNTtcbi8vIE5vIG1heGltdW0gbG9uZy1wb2xsaW5nIHRpbWVvdXQgaXMgY29uZmlndXJlZCBpbiB0aGUgc2VydmVyLCBhbmQgZGVmYXVsdHMgdG9cbi8vIDMwIHNlY29uZHMsIHdoaWNoIGlzIHdoYXQgV2F0Y2ggYXBwZWFycyB0byB1c2UuXG4vLyBHb29nbGVycyBzZWUgYi8yNjY4Njg4NzEgZm9yIHJlbGV2YW50IGRpc2N1c3Npb24uXG5jb25zdCBNQVhfTE9OR19QT0xMSU5HX1RJTUVPVVRfU0VDT05EUyA9IDMwO1xuLy8gV2hldGhlciBsb25nLXBvbGxpbmcgYXV0by1kZXRlY3RlZCBpcyBlbmFibGVkIGJ5IGRlZmF1bHQuXG5jb25zdCBERUZBVUxUX0FVVE9fREVURUNUX0xPTkdfUE9MTElORyA9IHRydWU7XG4vKipcbiAqIEEgY29uY3JldGUgdHlwZSBkZXNjcmliaW5nIGFsbCB0aGUgdmFsdWVzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdmlhIGFcbiAqIHVzZXItc3VwcGxpZWQgYEZpcmVzdG9yZVNldHRpbmdzYCBvYmplY3QuIFRoaXMgaXMgYSBzZXBhcmF0ZSB0eXBlIHNvIHRoYXRcbiAqIGRlZmF1bHRzIGNhbiBiZSBzdXBwbGllZCBhbmQgdGhlIHZhbHVlIGNhbiBiZSBjaGVja2VkIGZvciBlcXVhbGl0eS5cbiAqL1xuY2xhc3MgRmlyZXN0b3JlU2V0dGluZ3NJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoc2V0dGluZ3MuaG9zdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Muc3NsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBcIkNhbid0IHByb3ZpZGUgc3NsIG9wdGlvbiBpZiBob3N0IG9wdGlvbiBpcyBub3Qgc2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0ID0gREVGQVVMVF9IT1NUO1xuICAgICAgICAgICAgdGhpcy5zc2wgPSBERUZBVUxUX1NTTDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaG9zdCA9IHNldHRpbmdzLmhvc3Q7XG4gICAgICAgICAgICB0aGlzLnNzbCA9IChfYSA9IHNldHRpbmdzLnNzbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogREVGQVVMVF9TU0w7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHNldHRpbmdzLmNyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgPSAhIXNldHRpbmdzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMubG9jYWxDYWNoZSA9IHNldHRpbmdzLmxvY2FsQ2FjaGU7XG4gICAgICAgIGlmIChzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlU2l6ZUJ5dGVzID0gTFJVX0RFRkFVTFRfQ0FDSEVfU0laRV9CWVRFUztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyAhPT0gTFJVX0NPTExFQ1RJT05fRElTQUJMRUQgJiZcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyA8IExSVV9NSU5JTVVNX0NBQ0hFX1NJWkVfQllURVMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgY2FjaGVTaXplQnl0ZXMgbXVzdCBiZSBhdCBsZWFzdCAke0xSVV9NSU5JTVVNX0NBQ0hFX1NJWkVfQllURVN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlU2l6ZUJ5dGVzID0gc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVJc05vdFVzZWRUb2dldGhlcignZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZycsIHNldHRpbmdzLmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmcsICdleHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcnLCBzZXR0aW5ncy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcpO1xuICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmcgPSAhIXNldHRpbmdzLmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmc7XG4gICAgICAgIGlmICh0aGlzLmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3MuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nID0gREVGQVVMVF9BVVRPX0RFVEVDVF9MT05HX1BPTExJTkc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGNvZXJjZSB0aGUgdmFsdWUgdG8gYm9vbGVhbiBldmVuIHRob3VnaFxuICAgICAgICAgICAgLy8gdGhlIFR5cGVTY3JpcHQgY29tcGlsZXIgaGFzIG5hcnJvd2VkIHRoZSB0eXBlIHRvIGJvb2xlYW4gYWxyZWFkeS5cbiAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBQb2ludGxlc3NCb29sZWFuRXhwcmVzc2lvbkpTXG4gICAgICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyA9XG4gICAgICAgICAgICAgICAgISFzZXR0aW5ncy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMgPSBjbG9uZUxvbmdQb2xsaW5nT3B0aW9ucygoX2IgPSBzZXR0aW5ncy5leHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9KTtcbiAgICAgICAgdmFsaWRhdGVMb25nUG9sbGluZ09wdGlvbnModGhpcy5leHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMpO1xuICAgICAgICB0aGlzLnVzZUZldGNoU3RyZWFtcyA9ICEhc2V0dGluZ3MudXNlRmV0Y2hTdHJlYW1zO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5ob3N0ID09PSBvdGhlci5ob3N0ICYmXG4gICAgICAgICAgICB0aGlzLnNzbCA9PT0gb3RoZXIuc3NsICYmXG4gICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID09PSBvdGhlci5jcmVkZW50aWFscyAmJlxuICAgICAgICAgICAgdGhpcy5jYWNoZVNpemVCeXRlcyA9PT0gb3RoZXIuY2FjaGVTaXplQnl0ZXMgJiZcbiAgICAgICAgICAgIHRoaXMuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZyA9PT1cbiAgICAgICAgICAgICAgICBvdGhlci5leHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nICYmXG4gICAgICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyA9PT1cbiAgICAgICAgICAgICAgICBvdGhlci5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcgJiZcbiAgICAgICAgICAgIGxvbmdQb2xsaW5nT3B0aW9uc0VxdWFsKHRoaXMuZXhwZXJpbWVudGFsTG9uZ1BvbGxpbmdPcHRpb25zLCBvdGhlci5leHBlcmltZW50YWxMb25nUG9sbGluZ09wdGlvbnMpICYmXG4gICAgICAgICAgICB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgPT09IG90aGVyLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgJiZcbiAgICAgICAgICAgIHRoaXMudXNlRmV0Y2hTdHJlYW1zID09PSBvdGhlci51c2VGZXRjaFN0cmVhbXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTG9uZ1BvbGxpbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy50aW1lb3V0U2Vjb25kcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc05hTihvcHRpb25zLnRpbWVvdXRTZWNvbmRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYGludmFsaWQgbG9uZyBwb2xsaW5nIHRpbWVvdXQ6IGAgK1xuICAgICAgICAgICAgICAgIGAke29wdGlvbnMudGltZW91dFNlY29uZHN9IChtdXN0IG5vdCBiZSBOYU4pYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dFNlY29uZHMgPCBNSU5fTE9OR19QT0xMSU5HX1RJTUVPVVRfU0VDT05EUykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYGludmFsaWQgbG9uZyBwb2xsaW5nIHRpbWVvdXQ6ICR7b3B0aW9ucy50aW1lb3V0U2Vjb25kc30gYCArXG4gICAgICAgICAgICAgICAgYChtaW5pbXVtIGFsbG93ZWQgdmFsdWUgaXMgJHtNSU5fTE9OR19QT0xMSU5HX1RJTUVPVVRfU0VDT05EU30pYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dFNlY29uZHMgPiBNQVhfTE9OR19QT0xMSU5HX1RJTUVPVVRfU0VDT05EUykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYGludmFsaWQgbG9uZyBwb2xsaW5nIHRpbWVvdXQ6ICR7b3B0aW9ucy50aW1lb3V0U2Vjb25kc30gYCArXG4gICAgICAgICAgICAgICAgYChtYXhpbXVtIGFsbG93ZWQgdmFsdWUgaXMgJHtNQVhfTE9OR19QT0xMSU5HX1RJTUVPVVRfU0VDT05EU30pYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBDbG91ZCBGaXJlc3RvcmUgc2VydmljZSBpbnRlcmZhY2UuXG4gKlxuICogRG8gbm90IGNhbGwgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gSW5zdGVhZCwgdXNlIHtAbGluayAoZ2V0RmlyZXN0b3JlOjEpfS5cbiAqL1xuY2xhc3MgRmlyZXN0b3JlJDEge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoX2F1dGhDcmVkZW50aWFscywgX2FwcENoZWNrQ3JlZGVudGlhbHMsIF9kYXRhYmFzZUlkLCBfYXBwKSB7XG4gICAgICAgIHRoaXMuX2F1dGhDcmVkZW50aWFscyA9IF9hdXRoQ3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuX2FwcENoZWNrQ3JlZGVudGlhbHMgPSBfYXBwQ2hlY2tDcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5fZGF0YWJhc2VJZCA9IF9kYXRhYmFzZUlkO1xuICAgICAgICB0aGlzLl9hcHAgPSBfYXBwO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBpdCdzIGEgRmlyZXN0b3JlIG9yIEZpcmVzdG9yZSBMaXRlIGluc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gJ2ZpcmVzdG9yZS1saXRlJztcbiAgICAgICAgdGhpcy5fcGVyc2lzdGVuY2VLZXkgPSAnKGxpdGUpJztcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBuZXcgRmlyZXN0b3JlU2V0dGluZ3NJbXBsKHt9KTtcbiAgICAgICAgdGhpcy5fc2V0dGluZ3NGcm96ZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZW11bGF0b3JPcHRpb25zID0ge307XG4gICAgICAgIC8vIEEgdGFzayB0aGF0IGlzIGFzc2lnbmVkIHdoZW4gdGhlIHRlcm1pbmF0ZSgpIGlzIGludm9rZWQgYW5kIHJlc29sdmVkIHdoZW5cbiAgICAgICAgLy8gYWxsIGNvbXBvbmVudHMgaGF2ZSBzaHV0IGRvd24uIE90aGVyd2lzZSwgRmlyZXN0b3JlIGlzIG5vdCB0ZXJtaW5hdGVkLFxuICAgICAgICAvLyB3aGljaCBjYW4gbWVhbiBlaXRoZXIgdGhlIEZpcmVzdG9yZUNsaWVudCBpcyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyxcbiAgICAgICAgLy8gb3IgcmVzdGFydGluZy5cbiAgICAgICAgdGhpcy5fdGVybWluYXRlVGFzayA9ICdub3RUZXJtaW5hdGVkJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSBhc3NvY2lhdGVkIHdpdGggdGhpcyBgRmlyZXN0b3JlYCBzZXJ2aWNlXG4gICAgICogaW5zdGFuY2UuXG4gICAgICovXG4gICAgZ2V0IGFwcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hcHApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sIFwiRmlyZXN0b3JlIHdhcyBub3QgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlIEZpcmViYXNlIFNESy4gJ2FwcCcgaXMgXCIgK1xuICAgICAgICAgICAgICAgICdub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcDtcbiAgICB9XG4gICAgZ2V0IF9pbml0aWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzRnJvemVuO1xuICAgIH1cbiAgICBnZXQgX3Rlcm1pbmF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXJtaW5hdGVUYXNrICE9PSAnbm90VGVybWluYXRlZCc7XG4gICAgfVxuICAgIF9zZXRTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3NGcm96ZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdGaXJlc3RvcmUgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkIGFuZCBpdHMgc2V0dGluZ3MgY2FuIG5vIGxvbmdlciAnICtcbiAgICAgICAgICAgICAgICAnYmUgY2hhbmdlZC4gWW91IGNhbiBvbmx5IG1vZGlmeSBzZXR0aW5ncyBiZWZvcmUgY2FsbGluZyBhbnkgb3RoZXIgJyArXG4gICAgICAgICAgICAgICAgJ21ldGhvZHMgb24gYSBGaXJlc3RvcmUgb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldHRpbmdzID0gbmV3IEZpcmVzdG9yZVNldHRpbmdzSW1wbChzZXR0aW5ncyk7XG4gICAgICAgIHRoaXMuX2VtdWxhdG9yT3B0aW9ucyA9IHNldHRpbmdzLmVtdWxhdG9yT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmNyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1dGhDcmVkZW50aWFscyA9IG1ha2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlcihzZXR0aW5ncy5jcmVkZW50aWFscyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3M7XG4gICAgfVxuICAgIF9nZXRFbXVsYXRvck9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbXVsYXRvck9wdGlvbnM7XG4gICAgfVxuICAgIF9mcmVlemVTZXR0aW5ncygpIHtcbiAgICAgICAgdGhpcy5fc2V0dGluZ3NGcm96ZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3M7XG4gICAgfVxuICAgIF9kZWxldGUoKSB7XG4gICAgICAgIC8vIFRoZSBgX3Rlcm1pbmF0ZVRhc2tgIG11c3QgYmUgYXNzaWduZWQgZnV0dXJlIHRoYXQgY29tcGxldGVzIHdoZW5cbiAgICAgICAgLy8gdGVybWluYXRlIGlzIGNvbXBsZXRlLiBUaGUgZXhpc3RlbmNlIG9mIHRoaXMgZnV0dXJlIHB1dHMgU0RLIGluIHN0YXRlXG4gICAgICAgIC8vIHRoYXQgd2lsbCBub3QgYWNjZXB0IGZ1cnRoZXIgQVBJIGludGVyYWN0aW9uLlxuICAgICAgICBpZiAodGhpcy5fdGVybWluYXRlVGFzayA9PT0gJ25vdFRlcm1pbmF0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hdGVUYXNrID0gdGhpcy5fdGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlcm1pbmF0ZVRhc2s7XG4gICAgfVxuICAgIGFzeW5jIF9yZXN0YXJ0KCkge1xuICAgICAgICAvLyBUaGUgYF90ZXJtaW5hdGVUYXNrYCBtdXN0IGVxdWFsICdub3RUZXJtaW5hdGVkJyBhZnRlciByZXN0YXJ0IHRvXG4gICAgICAgIC8vIHNpZ25hbCB0aGF0IGNsaWVudCBpcyBpbiBhIHN0YXRlIHRoYXQgYWNjZXB0cyBBUEkgY2FsbHMuXG4gICAgICAgIGlmICh0aGlzLl90ZXJtaW5hdGVUYXNrID09PSAnbm90VGVybWluYXRlZCcpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Rlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYXRlVGFzayA9ICdub3RUZXJtaW5hdGVkJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgYEZpcmVzdG9yZWAgaW5zdGFuY2UuICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXBwOiB0aGlzLl9hcHAsXG4gICAgICAgICAgICBkYXRhYmFzZUlkOiB0aGlzLl9kYXRhYmFzZUlkLFxuICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuX3NldHRpbmdzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlcm1pbmF0ZXMgYWxsIGNvbXBvbmVudHMgdXNlZCBieSB0aGlzIGNsaWVudC4gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGVcbiAgICAgKiB0aGlzIG1ldGhvZCB0byBjbGVhbiB1cCB0aGVpciBvd24gZGVwZW5kZW5jaWVzLCBidXQgbXVzdCBhbHNvIGNhbGwgdGhpc1xuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIE9ubHkgZXZlciBjYWxsZWQgb25jZS5cbiAgICAgKi9cbiAgICBfdGVybWluYXRlKCkge1xuICAgICAgICByZW1vdmVDb21wb25lbnRzKHRoaXMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxufVxuLyoqXG4gKiBNb2RpZnkgdGhpcyBpbnN0YW5jZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBDbG91ZCBGaXJlc3RvcmUgZW11bGF0b3IuXG4gKlxuICogTm90ZTogVGhpcyBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgdGhpcyBpbnN0YW5jZSBoYXMgYmVlbiB1c2VkIHRvIGRvIGFueVxuICogb3BlcmF0aW9ucy5cbiAqXG4gKiBAcGFyYW0gZmlyZXN0b3JlIC0gVGhlIGBGaXJlc3RvcmVgIGluc3RhbmNlIHRvIGNvbmZpZ3VyZSB0byBjb25uZWN0IHRvIHRoZVxuICogZW11bGF0b3IuXG4gKiBAcGFyYW0gaG9zdCAtIHRoZSBlbXVsYXRvciBob3N0IChleDogbG9jYWxob3N0KS5cbiAqIEBwYXJhbSBwb3J0IC0gdGhlIGVtdWxhdG9yIHBvcnQgKGV4OiA5MDAwKS5cbiAqIEBwYXJhbSBvcHRpb25zLm1vY2tVc2VyVG9rZW4gLSB0aGUgbW9jayBhdXRoIHRva2VuIHRvIHVzZSBmb3IgdW5pdCB0ZXN0aW5nXG4gKiBTZWN1cml0eSBSdWxlcy5cbiAqL1xuZnVuY3Rpb24gY29ubmVjdEZpcmVzdG9yZUVtdWxhdG9yKGZpcmVzdG9yZSwgaG9zdCwgcG9ydCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9hO1xuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUkMSk7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBmaXJlc3RvcmUuX2dldFNldHRpbmdzKCk7XG4gICAgY29uc3QgZXhpc3RpbmdDb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzKSwgeyBlbXVsYXRvck9wdGlvbnM6IGZpcmVzdG9yZS5fZ2V0RW11bGF0b3JPcHRpb25zKCkgfSk7XG4gICAgY29uc3QgbmV3SG9zdFNldHRpbmcgPSBgJHtob3N0fToke3BvcnR9YDtcbiAgICBpZiAoc2V0dGluZ3MuaG9zdCAhPT0gREVGQVVMVF9IT1NUICYmIHNldHRpbmdzLmhvc3QgIT09IG5ld0hvc3RTZXR0aW5nKSB7XG4gICAgICAgIGxvZ1dhcm4oJ0hvc3QgaGFzIGJlZW4gc2V0IGluIGJvdGggc2V0dGluZ3MoKSBhbmQgY29ubmVjdEZpcmVzdG9yZUVtdWxhdG9yKCksIGVtdWxhdG9yIGhvc3QgJyArXG4gICAgICAgICAgICAnd2lsbCBiZSB1c2VkLicpO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzKSwgeyBob3N0OiBuZXdIb3N0U2V0dGluZywgc3NsOiBmYWxzZSwgZW11bGF0b3JPcHRpb25zOiBvcHRpb25zIH0pO1xuICAgIC8vIE5vLW9wIGlmIHRoZSBuZXcgY29uZmlndXJhdGlvbiBtYXRjaGVzIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24uIFRoaXMgc3VwcG9ydHMgU1NSXG4gICAgLy8gZW52aW9ybm1lbnRzIHdoaWNoIG1pZ2h0IGNhbGwgYGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvcmAgbXVsdGlwbGUgdGltZXMgYXMgYSBzdGFuZGFyZCBwcmFjdGljZS5cbiAgICBpZiAoZGVlcEVxdWFsKG5ld0NvbmZpZywgZXhpc3RpbmdDb25maWcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmlyZXN0b3JlLl9zZXRTZXR0aW5ncyhuZXdDb25maWcpO1xuICAgIGlmIChvcHRpb25zLm1vY2tVc2VyVG9rZW4pIHtcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICBsZXQgdXNlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1vY2tVc2VyVG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IG9wdGlvbnMubW9ja1VzZXJUb2tlbjtcbiAgICAgICAgICAgIHVzZXIgPSBVc2VyLk1PQ0tfVVNFUjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIExldCBjcmVhdGVNb2NrVXNlclRva2VuIHZhbGlkYXRlIGZpcnN0IChjYXRjaGVzIGNvbW1vbiBtaXN0YWtlcyBsaWtlXG4gICAgICAgICAgICAvLyBpbnZhbGlkIGZpZWxkIFwidWlkXCIgYW5kIG1pc3NpbmcgZmllbGQgXCJzdWJcIiAvIFwidXNlcl9pZFwiLilcbiAgICAgICAgICAgIHRva2VuID0gY3JlYXRlTW9ja1VzZXJUb2tlbihvcHRpb25zLm1vY2tVc2VyVG9rZW4sIChfYSA9IGZpcmVzdG9yZS5fYXBwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW9ucy5wcm9qZWN0SWQpO1xuICAgICAgICAgICAgY29uc3QgdWlkID0gb3B0aW9ucy5tb2NrVXNlclRva2VuLnN1YiB8fCBvcHRpb25zLm1vY2tVc2VyVG9rZW4udXNlcl9pZDtcbiAgICAgICAgICAgIGlmICghdWlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgXCJtb2NrVXNlclRva2VuIG11c3QgY29udGFpbiAnc3ViJyBvciAndXNlcl9pZCcgZmllbGQhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXNlciA9IG5ldyBVc2VyKHVpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZmlyZXN0b3JlLl9hdXRoQ3JlZGVudGlhbHMgPSBuZXcgRW11bGF0b3JBdXRoQ3JlZGVudGlhbHNQcm92aWRlcihuZXcgT0F1dGhUb2tlbih0b2tlbiwgdXNlcikpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBgUXVlcnlgIHJlZmVycyB0byBhIHF1ZXJ5IHdoaWNoIHlvdSBjYW4gcmVhZCBvciBsaXN0ZW4gdG8uIFlvdSBjYW4gYWxzb1xuICogY29uc3RydWN0IHJlZmluZWQgYFF1ZXJ5YCBvYmplY3RzIGJ5IGFkZGluZyBmaWx0ZXJzIGFuZCBvcmRlcmluZy5cbiAqL1xuY2xhc3MgUXVlcnkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGxpdGUgdmVyc2lvbiBvZiB0aGUgUXVlcnkgY2xhc3MgaW4gdGhlIG1haW4gU0RLLlxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yIHByb3RlY3RlZCAqL1xuICAgIGNvbnN0cnVjdG9yKGZpcmVzdG9yZSwgXG4gICAgLyoqXG4gICAgICogSWYgcHJvdmlkZWQsIHRoZSBgRmlyZXN0b3JlRGF0YUNvbnZlcnRlcmAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29udmVydGVyLCBfcXVlcnkpIHtcbiAgICAgICAgdGhpcy5jb252ZXJ0ZXIgPSBjb252ZXJ0ZXI7XG4gICAgICAgIHRoaXMuX3F1ZXJ5ID0gX3F1ZXJ5O1xuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBGaXJlc3RvcmUgcmVmZXJlbmNlLiAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAncXVlcnknO1xuICAgICAgICB0aGlzLmZpcmVzdG9yZSA9IGZpcmVzdG9yZTtcbiAgICB9XG4gICAgd2l0aENvbnZlcnRlcihjb252ZXJ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLmZpcmVzdG9yZSwgY29udmVydGVyLCB0aGlzLl9xdWVyeSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGBEb2N1bWVudFJlZmVyZW5jZWAgcmVmZXJzIHRvIGEgZG9jdW1lbnQgbG9jYXRpb24gaW4gYSBGaXJlc3RvcmUgZGF0YWJhc2VcbiAqIGFuZCBjYW4gYmUgdXNlZCB0byB3cml0ZSwgcmVhZCwgb3IgbGlzdGVuIHRvIHRoZSBsb2NhdGlvbi4gVGhlIGRvY3VtZW50IGF0XG4gKiB0aGUgcmVmZXJlbmNlZCBsb2NhdGlvbiBtYXkgb3IgbWF5IG5vdCBleGlzdC5cbiAqL1xuY2xhc3MgRG9jdW1lbnRSZWZlcmVuY2Uge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlLCBcbiAgICAvKipcbiAgICAgKiBJZiBwcm92aWRlZCwgdGhlIGBGaXJlc3RvcmVEYXRhQ29udmVydGVyYCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjb252ZXJ0ZXIsIF9rZXkpIHtcbiAgICAgICAgdGhpcy5jb252ZXJ0ZXIgPSBjb252ZXJ0ZXI7XG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIEZpcmVzdG9yZSByZWZlcmVuY2UuICovXG4gICAgICAgIHRoaXMudHlwZSA9ICdkb2N1bWVudCc7XG4gICAgICAgIHRoaXMuZmlyZXN0b3JlID0gZmlyZXN0b3JlO1xuICAgIH1cbiAgICBnZXQgX3BhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXkucGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGRvY3VtZW50J3MgaWRlbnRpZmllciB3aXRoaW4gaXRzIGNvbGxlY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5LnBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBwYXRoIG9mIHRoZSByZWZlcmVuY2VkIGRvY3VtZW50IChyZWxhdGl2ZVxuICAgICAqIHRvIHRoZSByb290IG9mIHRoZSBkYXRhYmFzZSkuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbGxlY3Rpb24gdGhpcyBgRG9jdW1lbnRSZWZlcmVuY2VgIGJlbG9uZ3MgdG8uXG4gICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uUmVmZXJlbmNlKHRoaXMuZmlyZXN0b3JlLCB0aGlzLmNvbnZlcnRlciwgdGhpcy5fa2V5LnBhdGgucG9wTGFzdCgpKTtcbiAgICB9XG4gICAgd2l0aENvbnZlcnRlcihjb252ZXJ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFJlZmVyZW5jZSh0aGlzLmZpcmVzdG9yZSwgY29udmVydGVyLCB0aGlzLl9rZXkpO1xuICAgIH1cbn1cbi8qKlxuICogQSBgQ29sbGVjdGlvblJlZmVyZW5jZWAgb2JqZWN0IGNhbiBiZSB1c2VkIGZvciBhZGRpbmcgZG9jdW1lbnRzLCBnZXR0aW5nXG4gKiBkb2N1bWVudCByZWZlcmVuY2VzLCBhbmQgcXVlcnlpbmcgZm9yIGRvY3VtZW50cyAodXNpbmcge0BsaW5rIChxdWVyeToxKX0pLlxuICovXG5jbGFzcyBDb2xsZWN0aW9uUmVmZXJlbmNlIGV4dGVuZHMgUXVlcnkge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlLCBjb252ZXJ0ZXIsIF9wYXRoKSB7XG4gICAgICAgIHN1cGVyKGZpcmVzdG9yZSwgY29udmVydGVyLCBuZXdRdWVyeUZvclBhdGgoX3BhdGgpKTtcbiAgICAgICAgdGhpcy5fcGF0aCA9IF9wYXRoO1xuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBGaXJlc3RvcmUgcmVmZXJlbmNlLiAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnY29sbGVjdGlvbic7XG4gICAgfVxuICAgIC8qKiBUaGUgY29sbGVjdGlvbidzIGlkZW50aWZpZXIuICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnkucGF0aC5sYXN0U2VnbWVudCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHBhdGggb2YgdGhlIHJlZmVyZW5jZWQgY29sbGVjdGlvbiAocmVsYXRpdmVcbiAgICAgKiB0byB0aGUgcm9vdCBvZiB0aGUgZGF0YWJhc2UpLlxuICAgICAqL1xuICAgIGdldCBwYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnkucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGNvbnRhaW5pbmcgYERvY3VtZW50UmVmZXJlbmNlYCBpZiB0aGlzIGlzIGFcbiAgICAgKiBzdWJjb2xsZWN0aW9uLiBJZiB0aGlzIGlzbid0IGEgc3ViY29sbGVjdGlvbiwgdGhlIHJlZmVyZW5jZSBpcyBudWxsLlxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSB0aGlzLl9wYXRoLnBvcExhc3QoKTtcbiAgICAgICAgaWYgKHBhcmVudFBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UodGhpcy5maXJlc3RvcmUsIFxuICAgICAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsLCBuZXcgRG9jdW1lbnRLZXkocGFyZW50UGF0aCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhDb252ZXJ0ZXIoY29udmVydGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvblJlZmVyZW5jZSh0aGlzLmZpcmVzdG9yZSwgY29udmVydGVyLCB0aGlzLl9wYXRoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0aW9uKHBhcmVudCwgcGF0aCwgLi4ucGF0aFNlZ21lbnRzKSB7XG4gICAgcGFyZW50ID0gZ2V0TW9kdWxhckluc3RhbmNlKHBhcmVudCk7XG4gICAgdmFsaWRhdGVOb25FbXB0eUFyZ3VtZW50KCdjb2xsZWN0aW9uJywgJ3BhdGgnLCBwYXRoKTtcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgRmlyZXN0b3JlJDEpIHtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCwgLi4ucGF0aFNlZ21lbnRzKTtcbiAgICAgICAgdmFsaWRhdGVDb2xsZWN0aW9uUGF0aChhYnNvbHV0ZVBhdGgpO1xuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWZlcmVuY2UocGFyZW50LCAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIGFic29sdXRlUGF0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkgJiZcbiAgICAgICAgICAgICEocGFyZW50IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBjb2xsZWN0aW9uKCkgdG8gYmUgYSBDb2xsZWN0aW9uUmVmZXJlbmNlLCAnICtcbiAgICAgICAgICAgICAgICAnYSBEb2N1bWVudFJlZmVyZW5jZSBvciBGaXJlYmFzZUZpcmVzdG9yZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHBhcmVudC5fcGF0aC5jaGlsZChSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhwYXRoLCAuLi5wYXRoU2VnbWVudHMpKTtcbiAgICAgICAgdmFsaWRhdGVDb2xsZWN0aW9uUGF0aChhYnNvbHV0ZVBhdGgpO1xuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWZlcmVuY2UocGFyZW50LmZpcmVzdG9yZSwgXG4gICAgICAgIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwgYWJzb2x1dGVQYXRoKTtcbiAgICB9XG59XG4vLyBUT0RPKGZpcmVzdG9yZWxpdGUpOiBDb25zaWRlciB1c2luZyBFcnJvckZhY3RvcnkgLVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9ibG9iLzAxMzFlMWYvcGFja2FnZXMvdXRpbC9zcmMvZXJyb3JzLnRzI0wxMDZcbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBgUXVlcnlgIGluc3RhbmNlIHRoYXQgaW5jbHVkZXMgYWxsIGRvY3VtZW50cyBpbiB0aGVcbiAqIGRhdGFiYXNlIHRoYXQgYXJlIGNvbnRhaW5lZCBpbiBhIGNvbGxlY3Rpb24gb3Igc3ViY29sbGVjdGlvbiB3aXRoIHRoZVxuICogZ2l2ZW4gYGNvbGxlY3Rpb25JZGAuXG4gKlxuICogQHBhcmFtIGZpcmVzdG9yZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSByb290IGBGaXJlc3RvcmVgIGluc3RhbmNlLlxuICogQHBhcmFtIGNvbGxlY3Rpb25JZCAtIElkZW50aWZpZXMgdGhlIGNvbGxlY3Rpb25zIHRvIHF1ZXJ5IG92ZXIuIEV2ZXJ5XG4gKiBjb2xsZWN0aW9uIG9yIHN1YmNvbGxlY3Rpb24gd2l0aCB0aGlzIElEIGFzIHRoZSBsYXN0IHNlZ21lbnQgb2YgaXRzIHBhdGhcbiAqIHdpbGwgYmUgaW5jbHVkZWQuIENhbm5vdCBjb250YWluIGEgc2xhc2guXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBgUXVlcnlgLlxuICovXG5mdW5jdGlvbiBjb2xsZWN0aW9uR3JvdXAoZmlyZXN0b3JlLCBjb2xsZWN0aW9uSWQpIHtcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlJDEpO1xuICAgIHZhbGlkYXRlTm9uRW1wdHlBcmd1bWVudCgnY29sbGVjdGlvbkdyb3VwJywgJ2NvbGxlY3Rpb24gaWQnLCBjb2xsZWN0aW9uSWQpO1xuICAgIGlmIChjb2xsZWN0aW9uSWQuaW5kZXhPZignLycpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgY29sbGVjdGlvbiBJRCAnJHtjb2xsZWN0aW9uSWR9JyBwYXNzZWQgdG8gZnVuY3Rpb24gYCArXG4gICAgICAgICAgICBgY29sbGVjdGlvbkdyb3VwKCkuIENvbGxlY3Rpb24gSURzIG11c3Qgbm90IGNvbnRhaW4gJy8nLmApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFF1ZXJ5KGZpcmVzdG9yZSwgXG4gICAgLyogY29udmVydGVyPSAqLyBudWxsLCBuZXdRdWVyeUZvckNvbGxlY3Rpb25Hcm91cChjb2xsZWN0aW9uSWQpKTtcbn1cbmZ1bmN0aW9uIGRvYyhwYXJlbnQsIHBhdGgsIC4uLnBhdGhTZWdtZW50cykge1xuICAgIHBhcmVudCA9IGdldE1vZHVsYXJJbnN0YW5jZShwYXJlbnQpO1xuICAgIC8vIFdlIGFsbG93IG9taXNzaW9uIG9mICdwYXRoU3RyaW5nJyBidXQgZXhwbGljaXRseSBwcm9oaWJpdCBwYXNzaW5nIGluIGJvdGhcbiAgICAvLyAndW5kZWZpbmVkJyBhbmQgJ251bGwnLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBhdGggPSBBdXRvSWQubmV3SWQoKTtcbiAgICB9XG4gICAgdmFsaWRhdGVOb25FbXB0eUFyZ3VtZW50KCdkb2MnLCAncGF0aCcsIHBhdGgpO1xuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBGaXJlc3RvcmUkMSkge1xuICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhwYXRoLCAuLi5wYXRoU2VnbWVudHMpO1xuICAgICAgICB2YWxpZGF0ZURvY3VtZW50UGF0aChhYnNvbHV0ZVBhdGgpO1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHBhcmVudCwgXG4gICAgICAgIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwgbmV3IERvY3VtZW50S2V5KGFic29sdXRlUGF0aCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpICYmXG4gICAgICAgICAgICAhKHBhcmVudCBpbnN0YW5jZW9mIENvbGxlY3Rpb25SZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gY29sbGVjdGlvbigpIHRvIGJlIGEgQ29sbGVjdGlvblJlZmVyZW5jZSwgJyArXG4gICAgICAgICAgICAgICAgJ2EgRG9jdW1lbnRSZWZlcmVuY2Ugb3IgRmlyZWJhc2VGaXJlc3RvcmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBwYXJlbnQuX3BhdGguY2hpbGQoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCwgLi4ucGF0aFNlZ21lbnRzKSk7XG4gICAgICAgIHZhbGlkYXRlRG9jdW1lbnRQYXRoKGFic29sdXRlUGF0aCk7XG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UocGFyZW50LmZpcmVzdG9yZSwgcGFyZW50IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSA/IHBhcmVudC5jb252ZXJ0ZXIgOiBudWxsLCBuZXcgRG9jdW1lbnRLZXkoYWJzb2x1dGVQYXRoKSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHJlZmVyZW5jZXMgYXJlIGVxdWFsLlxuICpcbiAqIEBwYXJhbSBsZWZ0IC0gQSByZWZlcmVuY2UgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSByaWdodCAtIEEgcmVmZXJlbmNlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSByZWZlcmVuY2VzIHBvaW50IHRvIHRoZSBzYW1lIGxvY2F0aW9uIGluIHRoZSBzYW1lXG4gKiBGaXJlc3RvcmUgZGF0YWJhc2UuXG4gKi9cbmZ1bmN0aW9uIHJlZkVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgbGVmdCA9IGdldE1vZHVsYXJJbnN0YW5jZShsZWZ0KTtcbiAgICByaWdodCA9IGdldE1vZHVsYXJJbnN0YW5jZShyaWdodCk7XG4gICAgaWYgKChsZWZ0IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UgfHxcbiAgICAgICAgbGVmdCBpbnN0YW5jZW9mIENvbGxlY3Rpb25SZWZlcmVuY2UpICYmXG4gICAgICAgIChyaWdodCBpbnN0YW5jZW9mIERvY3VtZW50UmVmZXJlbmNlIHx8IHJpZ2h0IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSkpIHtcbiAgICAgICAgcmV0dXJuIChsZWZ0LmZpcmVzdG9yZSA9PT0gcmlnaHQuZmlyZXN0b3JlICYmXG4gICAgICAgICAgICBsZWZ0LnBhdGggPT09IHJpZ2h0LnBhdGggJiZcbiAgICAgICAgICAgIGxlZnQuY29udmVydGVyID09PSByaWdodC5jb252ZXJ0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgcXVlcmllcyBwb2ludCB0byB0aGUgc2FtZSBjb2xsZWN0aW9uIGFuZCBhcHBseVxuICogdGhlIHNhbWUgY29uc3RyYWludHMuXG4gKlxuICogQHBhcmFtIGxlZnQgLSBBIGBRdWVyeWAgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSByaWdodCAtIEEgYFF1ZXJ5YCB0byBjb21wYXJlLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcmVmZXJlbmNlcyBwb2ludCB0byB0aGUgc2FtZSBsb2NhdGlvbiBpbiB0aGUgc2FtZVxuICogRmlyZXN0b3JlIGRhdGFiYXNlLlxuICovXG5mdW5jdGlvbiBxdWVyeUVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgbGVmdCA9IGdldE1vZHVsYXJJbnN0YW5jZShsZWZ0KTtcbiAgICByaWdodCA9IGdldE1vZHVsYXJJbnN0YW5jZShyaWdodCk7XG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBRdWVyeSAmJiByaWdodCBpbnN0YW5jZW9mIFF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiAobGVmdC5maXJlc3RvcmUgPT09IHJpZ2h0LmZpcmVzdG9yZSAmJlxuICAgICAgICAgICAgcXVlcnlFcXVhbHMobGVmdC5fcXVlcnksIHJpZ2h0Ll9xdWVyeSkgJiZcbiAgICAgICAgICAgIGxlZnQuY29udmVydGVyID09PSByaWdodC5jb252ZXJ0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBMT0dfVEFHID0gJ0FzeW5jUXVldWUnO1xuY2xhc3MgQXN5bmNRdWV1ZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHRhaWwgPSBQcm9taXNlLnJlc29sdmUoKSkge1xuICAgICAgICAvLyBBIGxpc3Qgb2YgcmV0cnlhYmxlIG9wZXJhdGlvbnMuIFJldHJ5YWJsZSBvcGVyYXRpb25zIGFyZSBydW4gaW4gb3JkZXIgYW5kXG4gICAgICAgIC8vIHJldHJpZWQgd2l0aCBiYWNrb2ZmLlxuICAgICAgICB0aGlzLnJldHJ5YWJsZU9wcyA9IFtdO1xuICAgICAgICAvLyBJcyB0aGlzIEFzeW5jUXVldWUgYmVpbmcgc2h1dCBkb3duPyBPbmNlIGl0IGlzIHNldCB0byB0cnVlLCBpdCB3aWxsIG5vdFxuICAgICAgICAvLyBiZSBjaGFuZ2VkIGFnYWluLlxuICAgICAgICB0aGlzLl9pc1NodXR0aW5nRG93biA9IGZhbHNlO1xuICAgICAgICAvLyBPcGVyYXRpb25zIHNjaGVkdWxlZCB0byBiZSBxdWV1ZWQgaW4gdGhlIGZ1dHVyZS4gT3BlcmF0aW9ucyBhcmVcbiAgICAgICAgLy8gYXV0b21hdGljYWxseSByZW1vdmVkIGFmdGVyIHRoZXkgYXJlIHJ1biBvciBjYW5jZWxlZC5cbiAgICAgICAgdGhpcy5kZWxheWVkT3BlcmF0aW9ucyA9IFtdO1xuICAgICAgICAvLyB2aXNpYmxlIGZvciB0ZXN0aW5nXG4gICAgICAgIHRoaXMuZmFpbHVyZSA9IG51bGw7XG4gICAgICAgIC8vIEZsYWcgc2V0IHdoaWxlIHRoZXJlJ3MgYW4gb3V0c3RhbmRpbmcgQXN5bmNRdWV1ZSBvcGVyYXRpb24sIHVzZWQgZm9yXG4gICAgICAgIC8vIGFzc2VydGlvbiBzYW5pdHktY2hlY2tzLlxuICAgICAgICB0aGlzLm9wZXJhdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgLy8gRW5hYmxlZCBkdXJpbmcgc2h1dGRvd24gb24gU2FmYXJpIHRvIHByZXZlbnQgZnV0dXJlIGFjY2VzcyB0byBJbmRleGVkREIuXG4gICAgICAgIHRoaXMuc2tpcE5vblJlc3RyaWN0ZWRUYXNrcyA9IGZhbHNlO1xuICAgICAgICAvLyBMaXN0IG9mIFRpbWVySWRzIHRvIGZhc3QtZm9yd2FyZCBkZWxheXMgZm9yLlxuICAgICAgICB0aGlzLnRpbWVySWRzVG9Ta2lwID0gW107XG4gICAgICAgIC8vIEJhY2tvZmYgdGltZXIgdXNlZCB0byBzY2hlZHVsZSByZXRyaWVzIGZvciByZXRyeWFibGUgb3BlcmF0aW9uc1xuICAgICAgICB0aGlzLmJhY2tvZmYgPSBuZXcgRXhwb25lbnRpYWxCYWNrb2ZmKHRoaXMsIFwiYXN5bmNfcXVldWVfcmV0cnlcIiAvKiBUaW1lcklkLkFzeW5jUXVldWVSZXRyeSAqLyk7XG4gICAgICAgIC8vIFZpc2liaWxpdHkgaGFuZGxlciB0aGF0IHRyaWdnZXJzIGFuIGltbWVkaWF0ZSByZXRyeSBvZiBhbGwgcmV0cnlhYmxlXG4gICAgICAgIC8vIG9wZXJhdGlvbnMuIE1lYW50IHRvIHNwZWVkIHVwIHJlY292ZXJ5IHdoZW4gd2UgcmVnYWluIGZpbGUgc3lzdGVtIGFjY2Vzc1xuICAgICAgICAvLyBhZnRlciBwYWdlIGNvbWVzIGludG8gZm9yZWdyb3VuZC5cbiAgICAgICAgdGhpcy52aXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5za2lwQmFja29mZigpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICAgIH1cbiAgICBnZXQgaXNTaHV0dGluZ0Rvd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NodXR0aW5nRG93bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlIHdpdGhvdXQgd2FpdGluZyBmb3IgaXQgdG8gY29tcGxldGUgKGkuZS5cbiAgICAgKiB3ZSBpZ25vcmUgdGhlIFByb21pc2UgcmVzdWx0KS5cbiAgICAgKi9cbiAgICBlbnF1ZXVlQW5kRm9yZ2V0KG9wKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgdGhpcy5lbnF1ZXVlKG9wKTtcbiAgICB9XG4gICAgZW5xdWV1ZUFuZEZvcmdldEV2ZW5XaGlsZVJlc3RyaWN0ZWQob3ApIHtcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RGYWlsZWQoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICB0aGlzLmVucXVldWVJbnRlcm5hbChvcCk7XG4gICAgfVxuICAgIGVudGVyUmVzdHJpY3RlZE1vZGUocHVyZ2VFeGlzdGluZ1Rhc2tzKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNTaHV0dGluZ0Rvd24pIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2h1dHRpbmdEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2tpcE5vblJlc3RyaWN0ZWRUYXNrcyA9IHB1cmdlRXhpc3RpbmdUYXNrcyB8fCBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbnF1ZXVlKG9wKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5Tm90RmFpbGVkKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc1NodXR0aW5nRG93bikge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGEgUHJvbWlzZSB3aGljaCBuZXZlciByZXNvbHZlcy5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIGRlZmVycmVkIFByb21pc2UgdGhhdCB3ZSBjYW4gcmV0dXJuIHRvIHRoZSBjYWxsZWUuIFRoaXNcbiAgICAgICAgLy8gYWxsb3dzIHVzIHRvIHJldHVybiBhIFwiaGFuZ2luZyBQcm9taXNlXCIgb25seSB0byB0aGUgY2FsbGVlIGFuZCBzdGlsbFxuICAgICAgICAvLyBhZHZhbmNlIHRoZSBxdWV1ZSBldmVuIHdoZW4gdGhlIG9wZXJhdGlvbiBpcyBub3QgcnVuLlxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmVucXVldWVJbnRlcm5hbCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNTaHV0dGluZ0Rvd24gJiYgdGhpcy5za2lwTm9uUmVzdHJpY3RlZFRhc2tzKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gbm90IHJlc29sdmUgJ3Rhc2snXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AoKS50aGVuKHRhc2sucmVzb2x2ZSwgdGFzay5yZWplY3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRhc2sucHJvbWlzZTtcbiAgICAgICAgfSkudGhlbigoKSA9PiB0YXNrLnByb21pc2UpO1xuICAgIH1cbiAgICBlbnF1ZXVlUmV0cnlhYmxlKG9wKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJldHJ5YWJsZU9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldHJ5TmV4dE9wKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSBuZXh0IG9wZXJhdGlvbiBmcm9tIHRoZSByZXRyeWFibGUgcXVldWUuIElmIHRoZSBvcGVyYXRpb24gZmFpbHMsXG4gICAgICogcmVzY2hlZHVsZXMgd2l0aCBiYWNrb2ZmLlxuICAgICAqL1xuICAgIGFzeW5jIHJldHJ5TmV4dE9wKCkge1xuICAgICAgICBpZiAodGhpcy5yZXRyeWFibGVPcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmV0cnlhYmxlT3BzWzBdKCk7XG4gICAgICAgICAgICB0aGlzLnJldHJ5YWJsZU9wcy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHLCAnT3BlcmF0aW9uIGZhaWxlZCB3aXRoIHJldHJ5YWJsZSBlcnJvcjogJyArIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTsgLy8gRmFpbHVyZSB3aWxsIGJlIGhhbmRsZWQgYnkgQXN5bmNRdWV1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJldHJ5YWJsZU9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYWRkaXRpb25hbCBvcGVyYXRpb25zLCB3ZSByZS1zY2hlZHVsZSBgcmV0cnlOZXh0T3AoKWAuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byBydW4gcmV0cnlhYmxlIG9wZXJhdGlvbnMgdGhhdCBmYWlsZWQgZHVyaW5nXG4gICAgICAgICAgICAvLyB0aGVpciBpbml0aWFsIGF0dGVtcHQgc2luY2Ugd2UgZG9uJ3Qga25vdyB3aGV0aGVyIHRoZXkgYXJlIGFscmVhZHlcbiAgICAgICAgICAgIC8vIGVucXVldWVkLiBJZiwgZm9yIGV4YW1wbGUsIGBvcDFgLCBgb3AyYCwgYG9wM2AgYXJlIGVucXVldWVkIGFuZCBgb3AxYFxuICAgICAgICAgICAgLy8gbmVlZHMgdG8gIGJlIHJlLXJ1biwgd2Ugd2lsbCBydW4gYG9wMWAsIGBvcDFgLCBgb3AyYCB1c2luZyB0aGVcbiAgICAgICAgICAgIC8vIGFscmVhZHkgZW5xdWV1ZWQgY2FsbHMgdG8gYHJldHJ5TmV4dE9wKClgLiBgb3AzKClgIHdpbGwgdGhlbiBydW4gaW4gdGhlXG4gICAgICAgICAgICAvLyBjYWxsIHNjaGVkdWxlZCBoZXJlLlxuICAgICAgICAgICAgLy8gU2luY2UgYGJhY2tvZmZBbmRSdW4oKWAgY2FuY2VscyBhbiBleGlzdGluZyBiYWNrb2ZmIGFuZCBzY2hlZHVsZXMgYVxuICAgICAgICAgICAgLy8gbmV3IGJhY2tvZmYgb24gZXZlcnkgY2FsbCwgdGhlcmUgaXMgb25seSBldmVyIGEgc2luZ2xlIGFkZGl0aW9uYWxcbiAgICAgICAgICAgIC8vIG9wZXJhdGlvbiBpbiB0aGUgcXVldWUuXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYuYmFja29mZkFuZFJ1bigoKSA9PiB0aGlzLnJldHJ5TmV4dE9wKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVucXVldWVJbnRlcm5hbChvcCkge1xuICAgICAgICBjb25zdCBuZXdUYWlsID0gdGhpcy50YWlsLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25JblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBvcCgpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZmFpbHVyZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHRoaXMub3BlcmF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZXRNZXNzYWdlT3JTdGFjayhlcnJvcik7XG4gICAgICAgICAgICAgICAgbG9nRXJyb3IoJ0lOVEVSTkFMIFVOSEFORExFRCBFUlJPUjogJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlIGVycm9yIHNvIHRoYXQgdGhpcy50YWlsIGJlY29tZXMgYSByZWplY3RlZCBQcm9taXNlIGFuZFxuICAgICAgICAgICAgICAgIC8vIGFsbCBmdXJ0aGVyIGF0dGVtcHRzIHRvIGNoYWluICh2aWEgLnRoZW4pIHdpbGwganVzdCBzaG9ydC1jaXJjdWl0XG4gICAgICAgICAgICAgICAgLy8gYW5kIHJldHVybiB0aGUgcmVqZWN0ZWQgUHJvbWlzZS5cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZXJhdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRhaWwgPSBuZXdUYWlsO1xuICAgICAgICByZXR1cm4gbmV3VGFpbDtcbiAgICB9XG4gICAgZW5xdWV1ZUFmdGVyRGVsYXkodGltZXJJZCwgZGVsYXlNcywgb3ApIHtcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RGYWlsZWQoKTtcbiAgICAgICAgLy8gRmFzdC1mb3J3YXJkIGRlbGF5cyBmb3IgdGltZXJJZHMgdGhhdCBoYXZlIGJlZW4gb3ZlcnJpZGRlbi5cbiAgICAgICAgaWYgKHRoaXMudGltZXJJZHNUb1NraXAuaW5kZXhPZih0aW1lcklkKSA+IC0xKSB7XG4gICAgICAgICAgICBkZWxheU1zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWxheWVkT3AgPSBEZWxheWVkT3BlcmF0aW9uLmNyZWF0ZUFuZFNjaGVkdWxlKHRoaXMsIHRpbWVySWQsIGRlbGF5TXMsIG9wLCByZW1vdmVkT3AgPT4gdGhpcy5yZW1vdmVEZWxheWVkT3BlcmF0aW9uKHJlbW92ZWRPcCkpO1xuICAgICAgICB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zLnB1c2goZGVsYXllZE9wKTtcbiAgICAgICAgcmV0dXJuIGRlbGF5ZWRPcDtcbiAgICB9XG4gICAgdmVyaWZ5Tm90RmFpbGVkKCkge1xuICAgICAgICBpZiAodGhpcy5mYWlsdXJlKSB7XG4gICAgICAgICAgICBmYWlsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmVyaWZ5T3BlcmF0aW9uSW5Qcm9ncmVzcygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgdW50aWwgYWxsIGN1cnJlbnRseSBxdWV1ZWQgdGFza3MgYXJlIGZpbmlzaGVkIGV4ZWN1dGluZy4gRGVsYXllZFxuICAgICAqIG9wZXJhdGlvbnMgYXJlIG5vdCBydW4uXG4gICAgICovXG4gICAgYXN5bmMgZHJhaW4oKSB7XG4gICAgICAgIC8vIE9wZXJhdGlvbnMgaW4gdGhlIHF1ZXVlIHByaW9yIHRvIGRyYWluaW5nIG1heSBoYXZlIGVucXVldWVkIGFkZGl0aW9uYWxcbiAgICAgICAgLy8gb3BlcmF0aW9ucy4gS2VlcCBkcmFpbmluZyB0aGUgcXVldWUgdW50aWwgdGhlIHRhaWwgaXMgbm8gbG9uZ2VyIGFkdmFuY2VkLFxuICAgICAgICAvLyB3aGljaCBpbmRpY2F0ZXMgdGhhdCBubyBtb3JlIG5ldyBvcGVyYXRpb25zIHdlcmUgZW5xdWV1ZWQgYW5kIHRoYXQgYWxsXG4gICAgICAgIC8vIG9wZXJhdGlvbnMgd2VyZSBleGVjdXRlZC5cbiAgICAgICAgbGV0IGN1cnJlbnRUYWlsO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjdXJyZW50VGFpbCA9IHRoaXMudGFpbDtcbiAgICAgICAgICAgIGF3YWl0IGN1cnJlbnRUYWlsO1xuICAgICAgICB9IHdoaWxlIChjdXJyZW50VGFpbCAhPT0gdGhpcy50YWlsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIFRlc3RzOiBEZXRlcm1pbmUgaWYgYSBkZWxheWVkIG9wZXJhdGlvbiB3aXRoIGEgcGFydGljdWxhciBUaW1lcklkXG4gICAgICogZXhpc3RzLlxuICAgICAqL1xuICAgIGNvbnRhaW5zRGVsYXllZE9wZXJhdGlvbih0aW1lcklkKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb3Agb2YgdGhpcy5kZWxheWVkT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wLnRpbWVySWQgPT09IHRpbWVySWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBUZXN0czogUnVucyBzb21lIG9yIGFsbCBkZWxheWVkIG9wZXJhdGlvbnMgZWFybHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGFzdFRpbWVySWQgLSBEZWxheWVkIG9wZXJhdGlvbnMgdXAgdG8gYW5kIGluY2x1ZGluZyB0aGlzIFRpbWVySWRcbiAgICAgKiB3aWxsIGJlIGRyYWluZWQuIFBhc3MgVGltZXJJZC5BbGwgdG8gcnVuIGFsbCBkZWxheWVkIG9wZXJhdGlvbnMuXG4gICAgICogQHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSBhbGwgb3BlcmF0aW9ucyBoYXZlIGJlZW4gcnVuLlxuICAgICAqL1xuICAgIHJ1bkFsbERlbGF5ZWRPcGVyYXRpb25zVW50aWwobGFzdFRpbWVySWQpIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IGRyYWluaW5nIG1heSBnZW5lcmF0ZSBtb3JlIGRlbGF5ZWQgb3BzLCBzbyB3ZSBkbyB0aGF0IGZpcnN0LlxuICAgICAgICByZXR1cm4gdGhpcy5kcmFpbigpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gUnVuIG9wcyBpbiB0aGUgc2FtZSBvcmRlciB0aGV5J2QgcnVuIGlmIHRoZXkgcmFuIG5hdHVyYWxseS5cbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXMgKi9cbiAgICAgICAgICAgIHRoaXMuZGVsYXllZE9wZXJhdGlvbnMuc29ydCgoYSwgYikgPT4gYS50YXJnZXRUaW1lTXMgLSBiLnRhcmdldFRpbWVNcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIHRoaXMuZGVsYXllZE9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcC5za2lwRGVsYXkoKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRpbWVySWQgIT09IFwiYWxsXCIgLyogVGltZXJJZC5BbGwgKi8gJiYgb3AudGltZXJJZCA9PT0gbGFzdFRpbWVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJhaW4oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBUZXN0czogU2tpcCBhbGwgc3Vic2VxdWVudCBkZWxheXMgZm9yIGEgdGltZXIgaWQuXG4gICAgICovXG4gICAgc2tpcERlbGF5c0ZvclRpbWVySWQodGltZXJJZCkge1xuICAgICAgICB0aGlzLnRpbWVySWRzVG9Ta2lwLnB1c2godGltZXJJZCk7XG4gICAgfVxuICAgIC8qKiBDYWxsZWQgb25jZSBhIERlbGF5ZWRPcGVyYXRpb24gaXMgcnVuIG9yIGNhbmNlbGVkLiAqL1xuICAgIHJlbW92ZURlbGF5ZWRPcGVyYXRpb24ob3ApIHtcbiAgICAgICAgLy8gTk9URTogaW5kZXhPZiAvIHNsaWNlIGFyZSBPKG4pLCBidXQgZGVsYXllZE9wZXJhdGlvbnMgaXMgZXhwZWN0ZWQgdG8gYmUgc21hbGwuXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5kZWxheWVkT3BlcmF0aW9ucy5pbmRleE9mKG9wKTtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlcyAqL1xuICAgICAgICB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxufVxuLyoqXG4gKiBDaHJvbWUgaW5jbHVkZXMgRXJyb3IubWVzc2FnZSBpbiBFcnJvci5zdGFjay4gT3RoZXIgYnJvd3NlcnMgZG8gbm90LlxuICogVGhpcyByZXR1cm5zIGV4cGVjdGVkIG91dHB1dCBvZiBtZXNzYWdlICsgc3RhY2sgd2hlbiBhdmFpbGFibGUuXG4gKiBAcGFyYW0gZXJyb3IgLSBFcnJvciBvciBGaXJlc3RvcmVFcnJvclxuICovXG5mdW5jdGlvbiBnZXRNZXNzYWdlT3JTdGFjayhlcnJvcikge1xuICAgIGxldCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fCAnJztcbiAgICBpZiAoZXJyb3Iuc3RhY2spIHtcbiAgICAgICAgaWYgKGVycm9yLnN0YWNrLmluY2x1ZGVzKGVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyb3Iuc3RhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSArICdcXG4nICsgZXJyb3Iuc3RhY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHRhc2sgb2YgbG9hZGluZyBhIEZpcmVzdG9yZSBidW5kbGUuIEl0IHByb3ZpZGVzIHByb2dyZXNzIG9mIGJ1bmRsZVxuICogbG9hZGluZywgYXMgd2VsbCBhcyB0YXNrIGNvbXBsZXRpb24gYW5kIGVycm9yIGV2ZW50cy5cbiAqXG4gKiBUaGUgQVBJIGlzIGNvbXBhdGlibGUgd2l0aCBgUHJvbWlzZTxMb2FkQnVuZGxlVGFza1Byb2dyZXNzPmAuXG4gKi9cbmNsYXNzIExvYWRCdW5kbGVUYXNrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlciA9IHt9O1xuICAgICAgICB0aGlzLl90YXNrQ29tcGxldGlvblJlc29sdmVyID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IHtcbiAgICAgICAgICAgIHRhc2tTdGF0ZTogJ1J1bm5pbmcnLFxuICAgICAgICAgICAgdG90YWxCeXRlczogMCxcbiAgICAgICAgICAgIHRvdGFsRG9jdW1lbnRzOiAwLFxuICAgICAgICAgICAgYnl0ZXNMb2FkZWQ6IDAsXG4gICAgICAgICAgICBkb2N1bWVudHNMb2FkZWQ6IDBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGZ1bmN0aW9ucyB0byBsaXN0ZW4gdG8gYnVuZGxlIGxvYWRpbmcgcHJvZ3Jlc3MgZXZlbnRzLlxuICAgICAqIEBwYXJhbSBuZXh0IC0gQ2FsbGVkIHdoZW4gdGhlcmUgaXMgYSBwcm9ncmVzcyB1cGRhdGUgZnJvbSBidW5kbGUgbG9hZGluZy4gVHlwaWNhbGx5IGBuZXh0YCBjYWxscyBvY2N1clxuICAgICAqICAgZWFjaCB0aW1lIGEgRmlyZXN0b3JlIGRvY3VtZW50IGlzIGxvYWRlZCBmcm9tIHRoZSBidW5kbGUuXG4gICAgICogQHBhcmFtIGVycm9yIC0gQ2FsbGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGR1cmluZyBidW5kbGUgbG9hZGluZy4gVGhlIHRhc2sgYWJvcnRzIGFmdGVyIHJlcG9ydGluZyB0aGVcbiAgICAgKiAgIGVycm9yLCBhbmQgdGhlcmUgc2hvdWxkIGJlIG5vIG1vcmUgdXBkYXRlcyBhZnRlciB0aGlzLlxuICAgICAqIEBwYXJhbSBjb21wbGV0ZSAtIENhbGxlZCB3aGVuIHRoZSBsb2FkaW5nIHRhc2sgaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgb25Qcm9ncmVzcyhuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlciA9IHtcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGNvbXBsZXRlXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgdGhlIGBQcm9taXNlPExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3M+LmNhdGNoYCBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb25SZWplY3RlZCAtIENhbGxlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgYnVuZGxlIGxvYWRpbmcuXG4gICAgICovXG4gICAgY2F0Y2gob25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFza0NvbXBsZXRpb25SZXNvbHZlci5wcm9taXNlLmNhdGNoKG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIHRoZSBgUHJvbWlzZTxMb2FkQnVuZGxlVGFza1Byb2dyZXNzPi50aGVuYCBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb25GdWxmaWxsZWQgLSBDYWxsZWQgb24gdGhlIGNvbXBsZXRpb24gb2YgdGhlIGxvYWRpbmcgdGFzayB3aXRoIGEgZmluYWwgYExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3NgIHVwZGF0ZS5cbiAgICAgKiAgIFRoZSB1cGRhdGUgd2lsbCBhbHdheXMgaGF2ZSBpdHMgYHRhc2tTdGF0ZWAgc2V0IHRvIGBcIlN1Y2Nlc3NcImAuXG4gICAgICogQHBhcmFtIG9uUmVqZWN0ZWQgLSBDYWxsZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgZHVyaW5nIGJ1bmRsZSBsb2FkaW5nLlxuICAgICAqL1xuICAgIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rhc2tDb21wbGV0aW9uUmVzb2x2ZXIucHJvbWlzZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgYWxsIG9ic2VydmVycyB0aGF0IGJ1bmRsZSBsb2FkaW5nIGhhcyBjb21wbGV0ZWQsIHdpdGggYSBwcm92aWRlZFxuICAgICAqIGBMb2FkQnVuZGxlVGFza1Byb2dyZXNzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb21wbGV0ZVdpdGgocHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5jb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rhc2tDb21wbGV0aW9uUmVzb2x2ZXIucmVzb2x2ZShwcm9ncmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIGFsbCBvYnNlcnZlcnMgdGhhdCBidW5kbGUgbG9hZGluZyBoYXMgZmFpbGVkLCB3aXRoIGEgcHJvdmlkZWRcbiAgICAgKiBgRXJyb3JgIGFzIHRoZSByZWFzb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mYWlsV2l0aChlcnJvcikge1xuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MudGFza1N0YXRlID0gJ0Vycm9yJztcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5uZXh0KHRoaXMuX2xhc3RQcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIuZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rhc2tDb21wbGV0aW9uUmVzb2x2ZXIucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgYSBwcm9ncmVzcyB1cGRhdGUgb2YgbG9hZGluZyBhIGJ1bmRsZS5cbiAgICAgKiBAcGFyYW0gcHJvZ3Jlc3MgLSBUaGUgbmV3IHByb2dyZXNzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc09ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIubmV4dChwcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENvbnN0YW50IHVzZWQgdG8gaW5kaWNhdGUgdGhlIExSVSBnYXJiYWdlIGNvbGxlY3Rpb24gc2hvdWxkIGJlIGRpc2FibGVkLlxuICogU2V0IHRoaXMgdmFsdWUgYXMgdGhlIGBjYWNoZVNpemVCeXRlc2Agb24gdGhlIHNldHRpbmdzIHBhc3NlZCB0byB0aGVcbiAqIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlLlxuICovXG5jb25zdCBDQUNIRV9TSVpFX1VOTElNSVRFRCA9IExSVV9DT0xMRUNUSU9OX0RJU0FCTEVEO1xuLyoqXG4gKiBUaGUgQ2xvdWQgRmlyZXN0b3JlIHNlcnZpY2UgaW50ZXJmYWNlLlxuICpcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIHVzZSB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0uXG4gKi9cbmNsYXNzIEZpcmVzdG9yZSBleHRlbmRzIEZpcmVzdG9yZSQxIHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xuICAgIGNvbnN0cnVjdG9yKGF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyLCBhcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXIsIGRhdGFiYXNlSWQsIGFwcCkge1xuICAgICAgICBzdXBlcihhdXRoQ3JlZGVudGlhbHNQcm92aWRlciwgYXBwQ2hlY2tDcmVkZW50aWFsc1Byb3ZpZGVyLCBkYXRhYmFzZUlkLCBhcHApO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBpdCdzIGEge0BsaW5rIEZpcmVzdG9yZX0gb3IgRmlyZXN0b3JlIExpdGUgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnZmlyZXN0b3JlJztcbiAgICAgICAgdGhpcy5fcXVldWUgPSBuZXcgQXN5bmNRdWV1ZUltcGwoKTtcbiAgICAgICAgdGhpcy5fcGVyc2lzdGVuY2VLZXkgPSAoYXBwID09PSBudWxsIHx8IGFwcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXBwLm5hbWUpIHx8ICdbREVGQVVMVF0nO1xuICAgIH1cbiAgICBhc3luYyBfdGVybWluYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5fZmlyZXN0b3JlQ2xpZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0ZXJtaW5hdGUgPSB0aGlzLl9maXJlc3RvcmVDbGllbnQudGVybWluYXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyBBc3luY1F1ZXVlSW1wbCh0ZXJtaW5hdGUpO1xuICAgICAgICAgICAgdGhpcy5fZmlyZXN0b3JlQ2xpZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYXdhaXQgdGVybWluYXRlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgRmlyZXN0b3JlfSB3aXRoIHRoZSBwcm92aWRlZCBzZXR0aW5ncy5cbiAqIENhbiBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgYW55IG90aGVyIGZ1bmN0aW9uLCBpbmNsdWRpbmdcbiAqIHtAbGluayAoZ2V0RmlyZXN0b3JlOjEpfS4gSWYgdGhlIGN1c3RvbSBzZXR0aW5ncyBhcmUgZW1wdHksIHRoaXMgZnVuY3Rpb24gaXNcbiAqIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0uXG4gKlxuICogQHBhcmFtIGFwcCAtIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gd2l0aCB3aGljaCB0aGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2Ugd2lsbFxuICogYmUgYXNzb2NpYXRlZC5cbiAqIEBwYXJhbSBzZXR0aW5ncyAtIEEgc2V0dGluZ3Mgb2JqZWN0IHRvIGNvbmZpZ3VyZSB0aGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZGF0YWJhc2VJZCAtIFRoZSBuYW1lIG9mIHRoZSBkYXRhYmFzZS5cbiAqIEByZXR1cm5zIEEgbmV3bHkgaW5pdGlhbGl6ZWQge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVGaXJlc3RvcmUoYXBwLCBzZXR0aW5ncywgZGF0YWJhc2VJZCkge1xuICAgIGlmICghZGF0YWJhc2VJZCkge1xuICAgICAgICBkYXRhYmFzZUlkID0gREVGQVVMVF9EQVRBQkFTRV9OQU1FO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsICdmaXJlc3RvcmUnKTtcbiAgICBpZiAocHJvdmlkZXIuaXNJbml0aWFsaXplZChkYXRhYmFzZUlkKSkge1xuICAgICAgICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gcHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGRhdGFiYXNlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxTZXR0aW5ncyA9IHByb3ZpZGVyLmdldE9wdGlvbnMoZGF0YWJhc2VJZCk7XG4gICAgICAgIGlmIChkZWVwRXF1YWwoaW5pdGlhbFNldHRpbmdzLCBzZXR0aW5ncykpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0luc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ2luaXRpYWxpemVGaXJlc3RvcmUoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCB3aXRoICcgK1xuICAgICAgICAgICAgICAgICdkaWZmZXJlbnQgb3B0aW9ucy4gVG8gYXZvaWQgdGhpcyBlcnJvciwgY2FsbCBpbml0aWFsaXplRmlyZXN0b3JlKCkgd2l0aCB0aGUgJyArXG4gICAgICAgICAgICAgICAgJ3NhbWUgb3B0aW9ucyBhcyB3aGVuIGl0IHdhcyBvcmlnaW5hbGx5IGNhbGxlZCwgb3IgY2FsbCBnZXRGaXJlc3RvcmUoKSB0byByZXR1cm4gdGhlJyArXG4gICAgICAgICAgICAgICAgJyBhbHJlYWR5IGluaXRpYWxpemVkIGluc3RhbmNlLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHNldHRpbmdzLmxvY2FsQ2FjaGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgY2FjaGUgYW5kIGNhY2hlU2l6ZUJ5dGVzIGNhbm5vdCBiZSBzcGVjaWZpZWQgYXQgdGhlIHNhbWUgdGltZSBhcyBjYWNoZVNpemVCeXRlcyB3aWxsYCArXG4gICAgICAgICAgICBgYmUgZGVwcmVjYXRlZC4gSW5zdGVhZCwgc3BlY2lmeSB0aGUgY2FjaGUgc2l6ZSBpbiB0aGUgY2FjaGUgb2JqZWN0YCk7XG4gICAgfVxuICAgIGlmIChzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzICE9PSBDQUNIRV9TSVpFX1VOTElNSVRFRCAmJlxuICAgICAgICBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyA8IExSVV9NSU5JTVVNX0NBQ0hFX1NJWkVfQllURVMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYGNhY2hlU2l6ZUJ5dGVzIG11c3QgYmUgYXQgbGVhc3QgJHtMUlVfTUlOSU1VTV9DQUNIRV9TSVpFX0JZVEVTfWApO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdmlkZXIuaW5pdGlhbGl6ZSh7XG4gICAgICAgIG9wdGlvbnM6IHNldHRpbmdzLFxuICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IGRhdGFiYXNlSWRcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEZpcmVzdG9yZShhcHBPckRhdGFiYXNlSWQsIG9wdGlvbmFsRGF0YWJhc2VJZCkge1xuICAgIGNvbnN0IGFwcCA9IHR5cGVvZiBhcHBPckRhdGFiYXNlSWQgPT09ICdvYmplY3QnID8gYXBwT3JEYXRhYmFzZUlkIDogZ2V0QXBwKCk7XG4gICAgY29uc3QgZGF0YWJhc2VJZCA9IHR5cGVvZiBhcHBPckRhdGFiYXNlSWQgPT09ICdzdHJpbmcnXG4gICAgICAgID8gYXBwT3JEYXRhYmFzZUlkXG4gICAgICAgIDogb3B0aW9uYWxEYXRhYmFzZUlkIHx8IERFRkFVTFRfREFUQUJBU0VfTkFNRTtcbiAgICBjb25zdCBkYiA9IF9nZXRQcm92aWRlcihhcHAsICdmaXJlc3RvcmUnKS5nZXRJbW1lZGlhdGUoe1xuICAgICAgICBpZGVudGlmaWVyOiBkYXRhYmFzZUlkXG4gICAgfSk7XG4gICAgaWYgKCFkYi5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgZW11bGF0b3IgPSBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQoJ2ZpcmVzdG9yZScpO1xuICAgICAgICBpZiAoZW11bGF0b3IpIHtcbiAgICAgICAgICAgIGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvcihkYiwgLi4uZW11bGF0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYjtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKSB7XG4gICAgaWYgKGZpcmVzdG9yZS5fdGVybWluYXRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnVGhlIGNsaWVudCBoYXMgYWxyZWFkeSBiZWVuIHRlcm1pbmF0ZWQuJyk7XG4gICAgfVxuICAgIGlmICghZmlyZXN0b3JlLl9maXJlc3RvcmVDbGllbnQpIHtcbiAgICAgICAgY29uZmlndXJlRmlyZXN0b3JlKGZpcmVzdG9yZSk7XG4gICAgfVxuICAgIHJldHVybiBmaXJlc3RvcmUuX2ZpcmVzdG9yZUNsaWVudDtcbn1cbmZ1bmN0aW9uIGNvbmZpZ3VyZUZpcmVzdG9yZShmaXJlc3RvcmUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBzZXR0aW5ncyA9IGZpcmVzdG9yZS5fZnJlZXplU2V0dGluZ3MoKTtcbiAgICBjb25zdCBkYXRhYmFzZUluZm8gPSBtYWtlRGF0YWJhc2VJbmZvKGZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgKChfYSA9IGZpcmVzdG9yZS5fYXBwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW9ucy5hcHBJZCkgfHwgJycsIGZpcmVzdG9yZS5fcGVyc2lzdGVuY2VLZXksIHNldHRpbmdzKTtcbiAgICBpZiAoIWZpcmVzdG9yZS5fY29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICAgIGlmICgoKF9iID0gc2V0dGluZ3MubG9jYWxDYWNoZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIpICYmXG4gICAgICAgICAgICAoKF9jID0gc2V0dGluZ3MubG9jYWxDYWNoZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLl9vbmxpbmVDb21wb25lbnRQcm92aWRlcikpIHtcbiAgICAgICAgICAgIGZpcmVzdG9yZS5fY29tcG9uZW50c1Byb3ZpZGVyID0ge1xuICAgICAgICAgICAgICAgIF9vZmZsaW5lOiBzZXR0aW5ncy5sb2NhbENhY2hlLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgX29ubGluZTogc2V0dGluZ3MubG9jYWxDYWNoZS5fb25saW5lQ29tcG9uZW50UHJvdmlkZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmlyZXN0b3JlLl9maXJlc3RvcmVDbGllbnQgPSBuZXcgRmlyZXN0b3JlQ2xpZW50KGZpcmVzdG9yZS5fYXV0aENyZWRlbnRpYWxzLCBmaXJlc3RvcmUuX2FwcENoZWNrQ3JlZGVudGlhbHMsIGZpcmVzdG9yZS5fcXVldWUsIGRhdGFiYXNlSW5mbywgZmlyZXN0b3JlLl9jb21wb25lbnRzUHJvdmlkZXIgJiZcbiAgICAgICAgYnVpbGRDb21wb25lbnRQcm92aWRlcihmaXJlc3RvcmUuX2NvbXBvbmVudHNQcm92aWRlcikpO1xufVxuZnVuY3Rpb24gYnVpbGRDb21wb25lbnRQcm92aWRlcihjb21wb25lbnRzUHJvdmlkZXIpIHtcbiAgICBjb25zdCBvbmxpbmUgPSBjb21wb25lbnRzUHJvdmlkZXIgPT09IG51bGwgfHwgY29tcG9uZW50c1Byb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb25lbnRzUHJvdmlkZXIuX29ubGluZS5idWlsZCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIF9vZmZsaW5lOiBjb21wb25lbnRzUHJvdmlkZXIgPT09IG51bGwgfHwgY29tcG9uZW50c1Byb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb25lbnRzUHJvdmlkZXIuX29mZmxpbmUuYnVpbGQob25saW5lKSxcbiAgICAgICAgX29ubGluZTogb25saW5lXG4gICAgfTtcbn1cbi8qKlxuICogQXR0ZW1wdHMgdG8gZW5hYmxlIHBlcnNpc3RlbnQgc3RvcmFnZSwgaWYgcG9zc2libGUuXG4gKlxuICogT24gZmFpbHVyZSwgYGVuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlKClgIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlIG9yXG4gKiB0aHJvdyBhbiBleGNlcHRpb24uIFRoZXJlIGFyZSBzZXZlcmFsIHJlYXNvbnMgd2h5IHRoaXMgY2FuIGZhaWwsIHdoaWNoIGNhbiBiZVxuICogaWRlbnRpZmllZCBieSB0aGUgYGNvZGVgIG9uIHRoZSBlcnJvci5cbiAqXG4gKiAgICogZmFpbGVkLXByZWNvbmRpdGlvbjogVGhlIGFwcCBpcyBhbHJlYWR5IG9wZW4gaW4gYW5vdGhlciBicm93c2VyIHRhYi5cbiAqICAgKiB1bmltcGxlbWVudGVkOiBUaGUgYnJvd3NlciBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgb2ZmbGluZSBwZXJzaXN0ZW5jZVxuICogICAgIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCBldmVuIGFmdGVyIGEgZmFpbHVyZSwgdGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHdpbGwgcmVtYWluXG4gKiB1c2FibGUsIGhvd2V2ZXIgb2ZmbGluZSBwZXJzaXN0ZW5jZSB3aWxsIGJlIGRpc2FibGVkLlxuICpcbiAqIE5vdGU6IGBlbmFibGVJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgYW55IG90aGVyIGZ1bmN0aW9uc1xuICogKG90aGVyIHRoYW4ge0BsaW5rIGluaXRpYWxpemVGaXJlc3RvcmV9LCB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0gb3JcbiAqIHtAbGluayBjbGVhckluZGV4ZWREYlBlcnNpc3RlbmNlfS5cbiAqXG4gKiBQZXJzaXN0ZW5jZSBjYW5ub3QgYmUgdXNlZCBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gKlxuICogQHBhcmFtIGZpcmVzdG9yZSAtIFRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSB0byBlbmFibGUgcGVyc2lzdGVuY2UgZm9yLlxuICogQHBhcmFtIHBlcnNpc3RlbmNlU2V0dGluZ3MgLSBPcHRpb25hbCBzZXR0aW5ncyBvYmplY3QgdG8gY29uZmlndXJlXG4gKiBwZXJzaXN0ZW5jZS5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVwcmVzZW50cyBzdWNjZXNzZnVsbHkgZW5hYmxpbmcgcGVyc2lzdGVudCBzdG9yYWdlLlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gSW5zdGVhZCwgc2V0XG4gKiBgRmlyZXN0b3JlU2V0dGluZ3MubG9jYWxDYWNoZWAgdG8gYW4gaW5zdGFuY2Ugb2YgYFBlcnNpc3RlbnRMb2NhbENhY2hlYCB0b1xuICogdHVybiBvbiBJbmRleGVkRGIgY2FjaGUuIENhbGxpbmcgdGhpcyBmdW5jdGlvbiB3aGVuIGBGaXJlc3RvcmVTZXR0aW5ncy5sb2NhbENhY2hlYFxuICogaXMgYWxyZWFkeSBzcGVjaWZpZWQgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlKGZpcmVzdG9yZSwgcGVyc2lzdGVuY2VTZXR0aW5ncykge1xuICAgIGxvZ1dhcm4oJ2VuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlKCkgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUsICcgK1xuICAgICAgICAneW91IGNhbiB1c2UgYEZpcmVzdG9yZVNldHRpbmdzLmNhY2hlYCBpbnN0ZWFkLicpO1xuICAgIGNvbnN0IHNldHRpbmdzID0gZmlyZXN0b3JlLl9mcmVlemVTZXR0aW5ncygpO1xuICAgIHNldFBlcnNpc3RlbmNlUHJvdmlkZXJzKGZpcmVzdG9yZSwgT25saW5lQ29tcG9uZW50UHJvdmlkZXIucHJvdmlkZXIsIHtcbiAgICAgICAgYnVpbGQ6IChvbmxpbmVDb21wb25lbnRzKSA9PiBuZXcgSW5kZXhlZERiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKG9ubGluZUNvbXBvbmVudHMsIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzLCBwZXJzaXN0ZW5jZVNldHRpbmdzID09PSBudWxsIHx8IHBlcnNpc3RlbmNlU2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlcnNpc3RlbmNlU2V0dGluZ3MuZm9yY2VPd25lcnNoaXApXG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBlbmFibGUgbXVsdGktdGFiIHBlcnNpc3RlbnQgc3RvcmFnZSwgaWYgcG9zc2libGUuIElmIGVuYWJsZWRcbiAqIGFjcm9zcyBhbGwgdGFicywgYWxsIG9wZXJhdGlvbnMgc2hhcmUgYWNjZXNzIHRvIGxvY2FsIHBlcnNpc3RlbmNlLCBpbmNsdWRpbmdcbiAqIHNoYXJlZCBleGVjdXRpb24gb2YgcXVlcmllcyBhbmQgbGF0ZW5jeS1jb21wZW5zYXRlZCBsb2NhbCBkb2N1bWVudCB1cGRhdGVzXG4gKiBhY3Jvc3MgYWxsIGNvbm5lY3RlZCBpbnN0YW5jZXMuXG4gKlxuICogT24gZmFpbHVyZSwgYGVuYWJsZU11bHRpVGFiSW5kZXhlZERiUGVyc2lzdGVuY2UoKWAgd2lsbCByZWplY3QgdGhlIHByb21pc2Ugb3JcbiAqIHRocm93IGFuIGV4Y2VwdGlvbi4gVGhlcmUgYXJlIHNldmVyYWwgcmVhc29ucyB3aHkgdGhpcyBjYW4gZmFpbCwgd2hpY2ggY2FuIGJlXG4gKiBpZGVudGlmaWVkIGJ5IHRoZSBgY29kZWAgb24gdGhlIGVycm9yLlxuICpcbiAqICAgKiBmYWlsZWQtcHJlY29uZGl0aW9uOiBUaGUgYXBwIGlzIGFscmVhZHkgb3BlbiBpbiBhbm90aGVyIGJyb3dzZXIgdGFiIGFuZFxuICogICAgIG11bHRpLXRhYiBpcyBub3QgZW5hYmxlZC5cbiAqICAgKiB1bmltcGxlbWVudGVkOiBUaGUgYnJvd3NlciBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgb2ZmbGluZSBwZXJzaXN0ZW5jZVxuICogICAgIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCBldmVuIGFmdGVyIGEgZmFpbHVyZSwgdGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHdpbGwgcmVtYWluXG4gKiB1c2FibGUsIGhvd2V2ZXIgb2ZmbGluZSBwZXJzaXN0ZW5jZSB3aWxsIGJlIGRpc2FibGVkLlxuICpcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gZW5hYmxlIHBlcnNpc3RlbmNlIGZvci5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVwcmVzZW50cyBzdWNjZXNzZnVsbHkgZW5hYmxpbmcgcGVyc2lzdGVudFxuICogc3RvcmFnZS5cbiAqIEBkZXByZWNhdGVkIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIEluc3RlYWQsIHNldFxuICogYEZpcmVzdG9yZVNldHRpbmdzLmxvY2FsQ2FjaGVgIHRvIGFuIGluc3RhbmNlIG9mIGBQZXJzaXN0ZW50TG9jYWxDYWNoZWAgdG9cbiAqIHR1cm4gb24gaW5kZXhlZGRiIGNhY2hlLiBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gd2hlbiBgRmlyZXN0b3JlU2V0dGluZ3MubG9jYWxDYWNoZWBcbiAqIGlzIGFscmVhZHkgc3BlY2lmaWVkIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICovXG5hc3luYyBmdW5jdGlvbiBlbmFibGVNdWx0aVRhYkluZGV4ZWREYlBlcnNpc3RlbmNlKGZpcmVzdG9yZSkge1xuICAgIGxvZ1dhcm4oJ2VuYWJsZU11bHRpVGFiSW5kZXhlZERiUGVyc2lzdGVuY2UoKSB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZSwgJyArXG4gICAgICAgICd5b3UgY2FuIHVzZSBgRmlyZXN0b3JlU2V0dGluZ3MuY2FjaGVgIGluc3RlYWQuJyk7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBmaXJlc3RvcmUuX2ZyZWV6ZVNldHRpbmdzKCk7XG4gICAgc2V0UGVyc2lzdGVuY2VQcm92aWRlcnMoZmlyZXN0b3JlLCBPbmxpbmVDb21wb25lbnRQcm92aWRlci5wcm92aWRlciwge1xuICAgICAgICBidWlsZDogKG9ubGluZUNvbXBvbmVudHMpID0+IG5ldyBNdWx0aVRhYk9mZmxpbmVDb21wb25lbnRQcm92aWRlcihvbmxpbmVDb21wb25lbnRzLCBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcylcbiAgICB9KTtcbn1cbi8qKlxuICogUmVnaXN0ZXJzIGJvdGggdGhlIGBPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXJgIGFuZCBgT25saW5lQ29tcG9uZW50UHJvdmlkZXJgLlxuICogSWYgdGhlIG9wZXJhdGlvbiBmYWlscyB3aXRoIGEgcmVjb3ZlcmFibGUgZXJyb3IgKHNlZVxuICogYGNhblJlY292ZXJGcm9tSW5kZXhlZERiRXJyb3IoKWAgYmVsb3cpLCB0aGUgcmV0dXJuZWQgUHJvbWlzZSBpcyByZWplY3RlZFxuICogYnV0IHRoZSBjbGllbnQgcmVtYWlucyB1c2FibGUuXG4gKi9cbmZ1bmN0aW9uIHNldFBlcnNpc3RlbmNlUHJvdmlkZXJzKGZpcmVzdG9yZSwgb25saW5lQ29tcG9uZW50UHJvdmlkZXIsIG9mZmxpbmVDb21wb25lbnRQcm92aWRlcikge1xuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGlmIChmaXJlc3RvcmUuX2ZpcmVzdG9yZUNsaWVudCB8fCBmaXJlc3RvcmUuX3Rlcm1pbmF0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ0ZpcmVzdG9yZSBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQgYW5kIHBlcnNpc3RlbmNlIGNhbiBubyBsb25nZXIgYmUgJyArXG4gICAgICAgICAgICAnZW5hYmxlZC4gWW91IGNhbiBvbmx5IGVuYWJsZSBwZXJzaXN0ZW5jZSBiZWZvcmUgY2FsbGluZyBhbnkgb3RoZXIgJyArXG4gICAgICAgICAgICAnbWV0aG9kcyBvbiBhIEZpcmVzdG9yZSBvYmplY3QuJyk7XG4gICAgfVxuICAgIGlmIChmaXJlc3RvcmUuX2NvbXBvbmVudHNQcm92aWRlciB8fCBmaXJlc3RvcmUuX2dldFNldHRpbmdzKCkubG9jYWxDYWNoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnU0RLIGNhY2hlIGlzIGFscmVhZHkgc3BlY2lmaWVkLicpO1xuICAgIH1cbiAgICBmaXJlc3RvcmUuX2NvbXBvbmVudHNQcm92aWRlciA9IHtcbiAgICAgICAgX29ubGluZTogb25saW5lQ29tcG9uZW50UHJvdmlkZXIsXG4gICAgICAgIF9vZmZsaW5lOiBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXJcbiAgICB9O1xuICAgIGNvbmZpZ3VyZUZpcmVzdG9yZShmaXJlc3RvcmUpO1xufVxuLyoqXG4gKiBDbGVhcnMgdGhlIHBlcnNpc3RlbnQgc3RvcmFnZS4gVGhpcyBpbmNsdWRlcyBwZW5kaW5nIHdyaXRlcyBhbmQgY2FjaGVkXG4gKiBkb2N1bWVudHMuXG4gKlxuICogTXVzdCBiZSBjYWxsZWQgd2hpbGUgdGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIGlzIG5vdCBzdGFydGVkIChhZnRlciB0aGUgYXBwIGlzXG4gKiB0ZXJtaW5hdGVkIG9yIHdoZW4gdGhlIGFwcCBpcyBmaXJzdCBpbml0aWFsaXplZCkuIE9uIHN0YXJ0dXAsIHRoaXMgZnVuY3Rpb25cbiAqIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBvdGhlciBmdW5jdGlvbnMgKG90aGVyIHRoYW4ge0BsaW5rXG4gKiBpbml0aWFsaXplRmlyZXN0b3JlfSBvciB7QGxpbmsgKGdldEZpcmVzdG9yZToxKX0pKS4gSWYgdGhlIHtAbGluayBGaXJlc3RvcmV9XG4gKiBpbnN0YW5jZSBpcyBzdGlsbCBydW5uaW5nLCB0aGUgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIGVycm9yIGNvZGVcbiAqIG9mIGBmYWlsZWQtcHJlY29uZGl0aW9uYC5cbiAqXG4gKiBOb3RlOiBgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCBpcyBwcmltYXJpbHkgaW50ZW5kZWQgdG8gaGVscCB3cml0ZVxuICogcmVsaWFibGUgdGVzdHMgdGhhdCB1c2UgQ2xvdWQgRmlyZXN0b3JlLiBJdCB1c2VzIGFuIGVmZmljaWVudCBtZWNoYW5pc20gZm9yXG4gKiBkcm9wcGluZyBleGlzdGluZyBkYXRhIGJ1dCBkb2VzIG5vdCBhdHRlbXB0IHRvIHNlY3VyZWx5IG92ZXJ3cml0ZSBvclxuICogb3RoZXJ3aXNlIG1ha2UgY2FjaGVkIGRhdGEgdW5yZWNvdmVyYWJsZS4gRm9yIGFwcGxpY2F0aW9ucyB0aGF0IGFyZSBzZW5zaXRpdmVcbiAqIHRvIHRoZSBkaXNjbG9zdXJlIG9mIGNhY2hlZCBkYXRhIGluIGJldHdlZW4gdXNlciBzZXNzaW9ucywgd2Ugc3Ryb25nbHlcbiAqIHJlY29tbWVuZCBub3QgZW5hYmxpbmcgcGVyc2lzdGVuY2UgYXQgYWxsLlxuICpcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gY2xlYXIgcGVyc2lzdGVuY2UgZm9yLlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSBwZXJzaXN0ZW50IHN0b3JhZ2UgaXNcbiAqIGNsZWFyZWQuIE90aGVyd2lzZSwgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvci5cbiAqL1xuZnVuY3Rpb24gY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZShmaXJlc3RvcmUpIHtcbiAgICBpZiAoZmlyZXN0b3JlLl9pbml0aWFsaXplZCAmJiAhZmlyZXN0b3JlLl90ZXJtaW5hdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdQZXJzaXN0ZW5jZSBjYW4gb25seSBiZSBjbGVhcmVkIGJlZm9yZSBhIEZpcmVzdG9yZSBpbnN0YW5jZSBpcyAnICtcbiAgICAgICAgICAgICdpbml0aWFsaXplZCBvciBhZnRlciBpdCBpcyB0ZXJtaW5hdGVkLicpO1xuICAgIH1cbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIGZpcmVzdG9yZS5fcXVldWUuZW5xdWV1ZUFuZEZvcmdldEV2ZW5XaGlsZVJlc3RyaWN0ZWQoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgaW5kZXhlZERiQ2xlYXJQZXJzaXN0ZW5jZShpbmRleGVkRGJTdG9yYWdlUHJlZml4KGZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgZmlyZXN0b3JlLl9wZXJzaXN0ZW5jZUtleSkpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cbi8qKlxuICogV2FpdHMgdW50aWwgYWxsIGN1cnJlbnRseSBwZW5kaW5nIHdyaXRlcyBmb3IgdGhlIGFjdGl2ZSB1c2VyIGhhdmUgYmVlblxuICogYWNrbm93bGVkZ2VkIGJ5IHRoZSBiYWNrZW5kLlxuICpcbiAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyBvdXRzdGFuZGluZyB3cml0ZXMuXG4gKiBPdGhlcndpc2UsIHRoZSBwcm9taXNlIHdhaXRzIGZvciBhbGwgcHJldmlvdXNseSBpc3N1ZWQgd3JpdGVzIChpbmNsdWRpbmdcbiAqIHRob3NlIHdyaXR0ZW4gaW4gYSBwcmV2aW91cyBhcHAgc2Vzc2lvbiksIGJ1dCBpdCBkb2VzIG5vdCB3YWl0IGZvciB3cml0ZXNcbiAqIHRoYXQgd2VyZSBhZGRlZCBhZnRlciB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLiBJZiB5b3Ugd2FudCB0byB3YWl0IGZvclxuICogYWRkaXRpb25hbCB3cml0ZXMsIGNhbGwgYHdhaXRGb3JQZW5kaW5nV3JpdGVzKClgIGFnYWluLlxuICpcbiAqIEFueSBvdXRzdGFuZGluZyBgd2FpdEZvclBlbmRpbmdXcml0ZXMoKWAgcHJvbWlzZXMgYXJlIHJlamVjdGVkIGR1cmluZyB1c2VyXG4gKiBjaGFuZ2VzLlxuICpcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHdoaWNoIHJlc29sdmVzIHdoZW4gYWxsIGN1cnJlbnRseSBwZW5kaW5nIHdyaXRlcyBoYXZlIGJlZW5cbiAqIGFja25vd2xlZGdlZCBieSB0aGUgYmFja2VuZC5cbiAqL1xuZnVuY3Rpb24gd2FpdEZvclBlbmRpbmdXcml0ZXMoZmlyZXN0b3JlKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRXYWl0Rm9yUGVuZGluZ1dyaXRlcyhjbGllbnQpO1xufVxuLyoqXG4gKiBSZS1lbmFibGVzIHVzZSBvZiB0aGUgbmV0d29yayBmb3IgdGhpcyB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSBhZnRlciBhIHByaW9yXG4gKiBjYWxsIHRvIHtAbGluayBkaXNhYmxlTmV0d29ya30uXG4gKlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCBvbmNlIHRoZSBuZXR3b3JrIGhhcyBiZWVuIGVuYWJsZWQuXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZU5ldHdvcmsoZmlyZXN0b3JlKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRFbmFibGVOZXR3b3JrKGNsaWVudCk7XG59XG4vKipcbiAqIERpc2FibGVzIG5ldHdvcmsgdXNhZ2UgZm9yIHRoaXMgaW5zdGFuY2UuIEl0IGNhbiBiZSByZS1lbmFibGVkIHZpYSB7QGxpbmtcbiAqIGVuYWJsZU5ldHdvcmt9LiBXaGlsZSB0aGUgbmV0d29yayBpcyBkaXNhYmxlZCwgYW55IHNuYXBzaG90IGxpc3RlbmVycyxcbiAqIGBnZXREb2MoKWAgb3IgYGdldERvY3MoKWAgY2FsbHMgd2lsbCByZXR1cm4gcmVzdWx0cyBmcm9tIGNhY2hlLCBhbmQgYW55IHdyaXRlXG4gKiBvcGVyYXRpb25zIHdpbGwgYmUgcXVldWVkIHVudGlsIHRoZSBuZXR3b3JrIGlzIHJlc3RvcmVkLlxuICpcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgaXMgcmVzb2x2ZWQgb25jZSB0aGUgbmV0d29yayBoYXMgYmVlbiBkaXNhYmxlZC5cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZU5ldHdvcmsoZmlyZXN0b3JlKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnREaXNhYmxlTmV0d29yayhjbGllbnQpO1xufVxuLyoqXG4gKiBUZXJtaW5hdGVzIHRoZSBwcm92aWRlZCB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZS5cbiAqXG4gKiBBZnRlciBjYWxsaW5nIGB0ZXJtaW5hdGUoKWAgb25seSB0aGUgYGNsZWFySW5kZXhlZERiUGVyc2lzdGVuY2UoKWAgZnVuY3Rpb25cbiAqIG1heSBiZSB1c2VkLiBBbnkgb3RoZXIgZnVuY3Rpb24gd2lsbCB0aHJvdyBhIGBGaXJlc3RvcmVFcnJvcmAuXG4gKlxuICogVG8gcmVzdGFydCBhZnRlciB0ZXJtaW5hdGlvbiwgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEZpcmViYXNlRmlyZXN0b3JlIHdpdGhcbiAqIHtAbGluayAoZ2V0RmlyZXN0b3JlOjEpfS5cbiAqXG4gKiBUZXJtaW5hdGlvbiBkb2VzIG5vdCBjYW5jZWwgYW55IHBlbmRpbmcgd3JpdGVzLCBhbmQgYW55IHByb21pc2VzIHRoYXQgYXJlXG4gKiBhd2FpdGluZyBhIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciB3aWxsIG5vdCBiZSByZXNvbHZlZC4gSWYgeW91IGhhdmVcbiAqIHBlcnNpc3RlbmNlIGVuYWJsZWQsIHRoZSBuZXh0IHRpbWUgeW91IHN0YXJ0IHRoaXMgaW5zdGFuY2UsIGl0IHdpbGwgcmVzdW1lXG4gKiBzZW5kaW5nIHRoZXNlIHdyaXRlcyB0byB0aGUgc2VydmVyLlxuICpcbiAqIE5vdGU6IFVuZGVyIG5vcm1hbCBjaXJjdW1zdGFuY2VzLCBjYWxsaW5nIGB0ZXJtaW5hdGUoKWAgaXMgbm90IHJlcXVpcmVkLiBUaGlzXG4gKiBmdW5jdGlvbiBpcyB1c2VmdWwgb25seSB3aGVuIHlvdSB3YW50IHRvIGZvcmNlIHRoaXMgaW5zdGFuY2UgdG8gcmVsZWFzZSBhbGxcbiAqIG9mIGl0cyByZXNvdXJjZXMgb3IgaW4gY29tYmluYXRpb24gd2l0aCBgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCB0b1xuICogZW5zdXJlIHRoYXQgYWxsIGxvY2FsIHN0YXRlIGlzIGRlc3Ryb3llZCBiZXR3ZWVuIHRlc3QgcnVucy5cbiAqXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIGluc3RhbmNlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseVxuICogdGVybWluYXRlZC5cbiAqL1xuZnVuY3Rpb24gdGVybWluYXRlKGZpcmVzdG9yZSkge1xuICAgIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UoZmlyZXN0b3JlLmFwcCwgJ2ZpcmVzdG9yZScsIGZpcmVzdG9yZS5fZGF0YWJhc2VJZC5kYXRhYmFzZSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZS5fZGVsZXRlKCk7XG59XG4vKipcbiAqIExvYWRzIGEgRmlyZXN0b3JlIGJ1bmRsZSBpbnRvIHRoZSBsb2NhbCBjYWNoZS5cbiAqXG4gKiBAcGFyYW0gZmlyZXN0b3JlIC0gVGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHRvIGxvYWQgYnVuZGxlcyBmb3IuXG4gKiBAcGFyYW0gYnVuZGxlRGF0YSAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGJ1bmRsZSB0byBiZSBsb2FkZWQuIFZhbGlkXG4gKiBvYmplY3RzIGFyZSBgQXJyYXlCdWZmZXJgLCBgUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5gIG9yIGBzdHJpbmdgLlxuICpcbiAqIEByZXR1cm5zIEEgYExvYWRCdW5kbGVUYXNrYCBvYmplY3QsIHdoaWNoIG5vdGlmaWVzIGNhbGxlcnMgd2l0aCBwcm9ncmVzc1xuICogdXBkYXRlcywgYW5kIGNvbXBsZXRpb24gb3IgZXJyb3IgZXZlbnRzLiBJdCBjYW4gYmUgdXNlZCBhcyBhXG4gKiBgUHJvbWlzZTxMb2FkQnVuZGxlVGFza1Byb2dyZXNzPmAuXG4gKi9cbmZ1bmN0aW9uIGxvYWRCdW5kbGUoZmlyZXN0b3JlLCBidW5kbGVEYXRhKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGNvbnN0IHJlc3VsdFRhc2sgPSBuZXcgTG9hZEJ1bmRsZVRhc2soKTtcbiAgICBmaXJlc3RvcmVDbGllbnRMb2FkQnVuZGxlKGNsaWVudCwgZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCBidW5kbGVEYXRhLCByZXN1bHRUYXNrKTtcbiAgICByZXR1cm4gcmVzdWx0VGFzaztcbn1cbi8qKlxuICogUmVhZHMgYSBGaXJlc3RvcmUge0BsaW5rIFF1ZXJ5fSBmcm9tIGxvY2FsIGNhY2hlLCBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlblxuICogbmFtZS5cbiAqXG4gKiBUaGUgbmFtZWQgcXVlcmllcyBhcmUgcGFja2FnZWQgIGludG8gYnVuZGxlcyBvbiB0aGUgc2VydmVyIHNpZGUgKGFsb25nXG4gKiB3aXRoIHJlc3VsdGluZyBkb2N1bWVudHMpLCBhbmQgbG9hZGVkIHRvIGxvY2FsIGNhY2hlIHVzaW5nIGBsb2FkQnVuZGxlYC4gT25jZVxuICogaW4gbG9jYWwgY2FjaGUsIHVzZSB0aGlzIG1ldGhvZCB0byBleHRyYWN0IGEge0BsaW5rIFF1ZXJ5fSBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gcmVhZCB0aGUgcXVlcnkgZnJvbS5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHF1ZXJ5LlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCB3aXRoIHRoZSBRdWVyeSBvciBgbnVsbGAuXG4gKi9cbmZ1bmN0aW9uIG5hbWVkUXVlcnkoZmlyZXN0b3JlLCBuYW1lKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXROYW1lZFF1ZXJ5KGNsaWVudCwgbmFtZSkudGhlbihuYW1lZFF1ZXJ5ID0+IHtcbiAgICAgICAgaWYgKCFuYW1lZFF1ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KGZpcmVzdG9yZSwgbnVsbCwgbmFtZWRRdWVyeS5xdWVyeSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiByZWdpc3RlckZpcmVzdG9yZSh2YXJpYW50LCB1c2VGZXRjaFN0cmVhbXMgPSB0cnVlKSB7XG4gICAgc2V0U0RLVmVyc2lvbihTREtfVkVSU0lPTiQxKTtcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgnZmlyZXN0b3JlJywgKGNvbnRhaW5lciwgeyBpbnN0YW5jZUlkZW50aWZpZXI6IGRhdGFiYXNlSWQsIG9wdGlvbnM6IHNldHRpbmdzIH0pID0+IHtcbiAgICAgICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgY29uc3QgZmlyZXN0b3JlSW5zdGFuY2UgPSBuZXcgRmlyZXN0b3JlKG5ldyBGaXJlYmFzZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKGNvbnRhaW5lci5nZXRQcm92aWRlcignYXV0aC1pbnRlcm5hbCcpKSwgbmV3IEZpcmViYXNlQXBwQ2hlY2tUb2tlblByb3ZpZGVyKGFwcCwgY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAtY2hlY2staW50ZXJuYWwnKSksIGRhdGFiYXNlSWRGcm9tQXBwKGFwcCwgZGF0YWJhc2VJZCksIGFwcCk7XG4gICAgICAgIHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7IHVzZUZldGNoU3RyZWFtcyB9LCBzZXR0aW5ncyk7XG4gICAgICAgIGZpcmVzdG9yZUluc3RhbmNlLl9zZXRTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgIHJldHVybiBmaXJlc3RvcmVJbnN0YW5jZTtcbiAgICB9LCAnUFVCTElDJykuc2V0TXVsdGlwbGVJbnN0YW5jZXModHJ1ZSkpO1xuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uJDEsIHZhcmlhbnQpO1xuICAgIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbTIwMTcsIGNqczIwMTcsIGV0YyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24kMSwgJ2VzbTIwMTcnKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIEFnZ3JlZ2F0ZSB0eXBlLlxuICovXG5jbGFzcyBBZ2dyZWdhdGVJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihhbGlhcywgYWdncmVnYXRlVHlwZSwgZmllbGRQYXRoKSB7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVUeXBlID0gYWdncmVnYXRlVHlwZTtcbiAgICAgICAgdGhpcy5maWVsZFBhdGggPSBmaWVsZFBhdGg7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFnZ3JlZ2F0aW9uIHRoYXQgY2FuIGJlIHBlcmZvcm1lZCBieSBGaXJlc3RvcmUuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbmNsYXNzIEFnZ3JlZ2F0ZUZpZWxkIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgQWdncmVnYXRlRmllbGQ8VD5cbiAgICAgKiBAcGFyYW0gYWdncmVnYXRlVHlwZSBTcGVjaWZpZXMgdGhlIHR5cGUgb2YgYWdncmVnYXRpb24gb3BlcmF0aW9uIHRvIHBlcmZvcm0uXG4gICAgICogQHBhcmFtIF9pbnRlcm5hbEZpZWxkUGF0aCBPcHRpb25hbGx5IHNwZWNpZmllcyB0aGUgZmllbGQgdGhhdCBpcyBhZ2dyZWdhdGVkLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFnZ3JlZ2F0ZVR5cGUgPSAnY291bnQnLCBfaW50ZXJuYWxGaWVsZFBhdGgpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxGaWVsZFBhdGggPSBfaW50ZXJuYWxGaWVsZFBhdGg7XG4gICAgICAgIC8qKiBBIHR5cGUgc3RyaW5nIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzLiAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnQWdncmVnYXRlRmllbGQnO1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZVR5cGUgPSBhZ2dyZWdhdGVUeXBlO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIHJlc3VsdHMgb2YgZXhlY3V0aW5nIGFuIGFnZ3JlZ2F0aW9uIHF1ZXJ5LlxuICovXG5jbGFzcyBBZ2dyZWdhdGVRdWVyeVNuYXBzaG90IHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBfdXNlckRhdGFXcml0ZXIsIF9kYXRhKSB7XG4gICAgICAgIHRoaXMuX3VzZXJEYXRhV3JpdGVyID0gX3VzZXJEYXRhV3JpdGVyO1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIC8qKiBBIHR5cGUgc3RyaW5nIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzLiAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnQWdncmVnYXRlUXVlcnlTbmFwc2hvdCc7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0cyBvZiB0aGUgYWdncmVnYXRpb25zIHBlcmZvcm1lZCBvdmVyIHRoZSB1bmRlcmx5aW5nXG4gICAgICogcXVlcnkuXG4gICAgICpcbiAgICAgKiBUaGUga2V5cyBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0IHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhvc2Ugb2YgdGhlXG4gICAgICogYEFnZ3JlZ2F0ZVNwZWNgIG9iamVjdCBzcGVjaWZpZWQgdG8gdGhlIGFnZ3JlZ2F0aW9uIG1ldGhvZCwgYW5kIHRoZSB2YWx1ZXNcbiAgICAgKiB3aWxsIGJlIHRoZSBjb3JyZXNwb25kaW5nIGFnZ3JlZ2F0aW9uIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHRzIG9mIHRoZSBhZ2dyZWdhdGlvbnMgcGVyZm9ybWVkIG92ZXIgdGhlIHVuZGVybHlpbmdcbiAgICAgKiBxdWVyeS5cbiAgICAgKi9cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXNlckRhdGFXcml0ZXIuY29udmVydE9iamVjdE1hcCh0aGlzLl9kYXRhKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGltbXV0YWJsZSBvYmplY3QgcmVwcmVzZW50aW5nIGFuIGFycmF5IG9mIGJ5dGVzLlxuICovXG5jbGFzcyBCeXRlcyB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihieXRlU3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2J5dGVTdHJpbmcgPSBieXRlU3RyaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBCeXRlc2Agb2JqZWN0IGZyb20gdGhlIGdpdmVuIEJhc2U2NCBzdHJpbmcsIGNvbnZlcnRpbmcgaXQgdG9cbiAgICAgKiBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBiYXNlNjQgLSBUaGUgQmFzZTY0IHN0cmluZyB1c2VkIHRvIGNyZWF0ZSB0aGUgYEJ5dGVzYCBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21CYXNlNjRTdHJpbmcoYmFzZTY0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVzKEJ5dGVTdHJpbmcuZnJvbUJhc2U2NFN0cmluZyhiYXNlNjQpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgZGF0YSBmcm9tIEJhc2U2NCBzdHJpbmc6ICcgKyBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBCeXRlc2Agb2JqZWN0IGZyb20gdGhlIGdpdmVuIFVpbnQ4QXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJyYXkgLSBUaGUgVWludDhBcnJheSB1c2VkIHRvIGNyZWF0ZSB0aGUgYEJ5dGVzYCBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21VaW50OEFycmF5KGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgQnl0ZXMoQnl0ZVN0cmluZy5mcm9tVWludDhBcnJheShhcnJheSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIGJ5dGVzIGFzIGEgQmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEJhc2U2NC1lbmNvZGVkIHN0cmluZyBjcmVhdGVkIGZyb20gdGhlIGBCeXRlc2Agb2JqZWN0LlxuICAgICAqL1xuICAgIHRvQmFzZTY0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZVN0cmluZy50b0Jhc2U2NCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIGJ5dGVzIGluIGEgbmV3IGBVaW50OEFycmF5YC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBVaW50OEFycmF5IGNyZWF0ZWQgZnJvbSB0aGUgYEJ5dGVzYCBvYmplY3QuXG4gICAgICovXG4gICAgdG9VaW50OEFycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZVN0cmluZy50b1VpbnQ4QXJyYXkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYEJ5dGVzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYEJ5dGVzYCBvYmplY3QuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnQnl0ZXMoYmFzZTY0OiAnICsgdGhpcy50b0Jhc2U2NCgpICsgJyknO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgQnl0ZXNgIG9iamVjdCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG90aGVyIC0gVGhlIGBCeXRlc2Agb2JqZWN0IHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYEJ5dGVzYCBvYmplY3QgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKi9cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ieXRlU3RyaW5nLmlzRXF1YWwob3RoZXIuX2J5dGVTdHJpbmcpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBgRmllbGRQYXRoYCByZWZlcnMgdG8gYSBmaWVsZCBpbiBhIGRvY3VtZW50LiBUaGUgcGF0aCBtYXkgY29uc2lzdCBvZiBhXG4gKiBzaW5nbGUgZmllbGQgbmFtZSAocmVmZXJyaW5nIHRvIGEgdG9wLWxldmVsIGZpZWxkIGluIHRoZSBkb2N1bWVudCksIG9yIGFcbiAqIGxpc3Qgb2YgZmllbGQgbmFtZXMgKHJlZmVycmluZyB0byBhIG5lc3RlZCBmaWVsZCBpbiB0aGUgZG9jdW1lbnQpLlxuICpcbiAqIENyZWF0ZSBhIGBGaWVsZFBhdGhgIGJ5IHByb3ZpZGluZyBmaWVsZCBuYW1lcy4gSWYgbW9yZSB0aGFuIG9uZSBmaWVsZFxuICogbmFtZSBpcyBwcm92aWRlZCwgdGhlIHBhdGggd2lsbCBwb2ludCB0byBhIG5lc3RlZCBmaWVsZCBpbiBhIGRvY3VtZW50LlxuICovXG5jbGFzcyBGaWVsZFBhdGgge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgRmllbGRQYXRoYCBmcm9tIHRoZSBwcm92aWRlZCBmaWVsZCBuYW1lcy4gSWYgbW9yZSB0aGFuIG9uZSBmaWVsZFxuICAgICAqIG5hbWUgaXMgcHJvdmlkZWQsIHRoZSBwYXRoIHdpbGwgcG9pbnQgdG8gYSBuZXN0ZWQgZmllbGQgaW4gYSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZE5hbWVzIC0gQSBsaXN0IG9mIGZpZWxkIG5hbWVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmZpZWxkTmFtZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoZmllbGROYW1lc1tpXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBmaWVsZCBuYW1lIGF0IGFyZ3VtZW50ICQoaSArIDEpLiBgICtcbiAgICAgICAgICAgICAgICAgICAgJ0ZpZWxkIG5hbWVzIG11c3Qgbm90IGJlIGVtcHR5LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVybmFsUGF0aCA9IG5ldyBGaWVsZFBhdGgkMShmaWVsZE5hbWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYEZpZWxkUGF0aGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBgRmllbGRQYXRoYCB0byBjb21wYXJlIGFnYWluc3QuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGBGaWVsZFBhdGhgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICovXG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxQYXRoLmlzRXF1YWwob3RoZXIuX2ludGVybmFsUGF0aCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3BlY2lhbCBzZW50aW5lbCBgRmllbGRQYXRoYCB0byByZWZlciB0byB0aGUgSUQgb2YgYSBkb2N1bWVudC5cbiAqIEl0IGNhbiBiZSB1c2VkIGluIHF1ZXJpZXMgdG8gc29ydCBvciBmaWx0ZXIgYnkgdGhlIGRvY3VtZW50IElELlxuICovXG5mdW5jdGlvbiBkb2N1bWVudElkKCkge1xuICAgIHJldHVybiBuZXcgRmllbGRQYXRoKERPQ1VNRU5UX0tFWV9OQU1FKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogU2VudGluZWwgdmFsdWVzIHRoYXQgY2FuIGJlIHVzZWQgd2hlbiB3cml0aW5nIGRvY3VtZW50IGZpZWxkcyB3aXRoIGBzZXQoKWBcbiAqIG9yIGB1cGRhdGUoKWAuXG4gKi9cbmNsYXNzIEZpZWxkVmFsdWUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBfbWV0aG9kTmFtZSAtIFRoZSBwdWJsaWMgQVBJIGVuZHBvaW50IHRoYXQgcmV0dXJucyB0aGlzIGNsYXNzLlxuICAgICAqIEBoaWRlY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfbWV0aG9kTmFtZSkge1xuICAgICAgICB0aGlzLl9tZXRob2ROYW1lID0gX21ldGhvZE5hbWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBpbW11dGFibGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIGdlb2dyYXBoaWMgbG9jYXRpb24gaW4gRmlyZXN0b3JlLiBUaGVcbiAqIGxvY2F0aW9uIGlzIHJlcHJlc2VudGVkIGFzIGxhdGl0dWRlL2xvbmdpdHVkZSBwYWlyLlxuICpcbiAqIExhdGl0dWRlIHZhbHVlcyBhcmUgaW4gdGhlIHJhbmdlIG9mIFstOTAsIDkwXS5cbiAqIExvbmdpdHVkZSB2YWx1ZXMgYXJlIGluIHRoZSByYW5nZSBvZiBbLTE4MCwgMTgwXS5cbiAqL1xuY2xhc3MgR2VvUG9pbnQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW1tdXRhYmxlIGBHZW9Qb2ludGAgb2JqZWN0IHdpdGggdGhlIHByb3ZpZGVkIGxhdGl0dWRlIGFuZFxuICAgICAqIGxvbmdpdHVkZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIGxhdGl0dWRlIC0gVGhlIGxhdGl0dWRlIGFzIG51bWJlciBiZXR3ZWVuIC05MCBhbmQgOTAuXG4gICAgICogQHBhcmFtIGxvbmdpdHVkZSAtIFRoZSBsb25naXR1ZGUgYXMgbnVtYmVyIGJldHdlZW4gLTE4MCBhbmQgMTgwLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxhdGl0dWRlLCBsb25naXR1ZGUpIHtcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShsYXRpdHVkZSkgfHwgbGF0aXR1ZGUgPCAtOTAgfHwgbGF0aXR1ZGUgPiA5MCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0xhdGl0dWRlIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAtOTAgYW5kIDkwLCBidXQgd2FzOiAnICsgbGF0aXR1ZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNGaW5pdGUobG9uZ2l0dWRlKSB8fCBsb25naXR1ZGUgPCAtMTgwIHx8IGxvbmdpdHVkZSA+IDE4MCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0xvbmdpdHVkZSBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gLTE4MCBhbmQgMTgwLCBidXQgd2FzOiAnICsgbG9uZ2l0dWRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXQgPSBsYXRpdHVkZTtcbiAgICAgICAgdGhpcy5fbG9uZyA9IGxvbmdpdHVkZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxhdGl0dWRlIG9mIHRoaXMgYEdlb1BvaW50YCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBnZXQgbGF0aXR1ZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsb25naXR1ZGUgb2YgdGhpcyBgR2VvUG9pbnRgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldCBsb25naXR1ZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb25nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgR2VvUG9pbnRgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgYEdlb1BvaW50YCB0byBjb21wYXJlIGFnYWluc3QuXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGBHZW9Qb2ludGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAgICAgKi9cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXQgPT09IG90aGVyLl9sYXQgJiYgdGhpcy5fbG9uZyA9PT0gb3RoZXIuX2xvbmc7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBHZW9Qb2ludC4gKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IGxhdGl0dWRlOiB0aGlzLl9sYXQsIGxvbmdpdHVkZTogdGhpcy5fbG9uZyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3R1YWxseSBwcml2YXRlIHRvIEpTIGNvbnN1bWVycyBvZiBvdXIgQVBJLCBzbyB0aGlzIGZ1bmN0aW9uIGlzIHByZWZpeGVkXG4gICAgICogd2l0aCBhbiB1bmRlcnNjb3JlLlxuICAgICAqL1xuICAgIF9jb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIChwcmltaXRpdmVDb21wYXJhdG9yKHRoaXMuX2xhdCwgb3RoZXIuX2xhdCkgfHxcbiAgICAgICAgICAgIHByaW1pdGl2ZUNvbXBhcmF0b3IodGhpcy5fbG9uZywgb3RoZXIuX2xvbmcpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSB2ZWN0b3IgdHlwZSBpbiBGaXJlc3RvcmUgZG9jdW1lbnRzLlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIHdpdGggPGNvZGU+e0BsaW5rIHZlY3Rvcn08L2NvZGU+LlxuICpcbiAqIEBjbGFzcyBWZWN0b3JWYWx1ZVxuICovXG5jbGFzcyBWZWN0b3JWYWx1ZSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcbiAgICAgICAgLy8gTWFraW5nIGEgY29weSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgICAgICB0aGlzLl92YWx1ZXMgPSAodmFsdWVzIHx8IFtdKS5tYXAobiA9PiBuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIHJhdyBudW1iZXIgYXJyYXkgZm9ybSBvZiB0aGUgdmVjdG9yLlxuICAgICAqL1xuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXMubWFwKG4gPT4gbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSB0d28gYFZlY3RvclZhbHVlYCB2YWx1ZXMgaGF2ZSB0aGUgc2FtZSByYXcgbnVtYmVyIGFycmF5cywgcmV0dXJucyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBpc1ByaW1pdGl2ZUFycmF5RXF1YWwodGhpcy5fdmFsdWVzLCBvdGhlci5fdmFsdWVzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBSRVNFUlZFRF9GSUVMRF9SRUdFWCA9IC9eX18uKl9fJC87XG4vKiogVGhlIHJlc3VsdCBvZiBwYXJzaW5nIGRvY3VtZW50IGRhdGEgKGUuZy4gZm9yIGEgc2V0RGF0YSBjYWxsKS4gKi9cbmNsYXNzIFBhcnNlZFNldERhdGEge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGZpZWxkTWFzaywgZmllbGRUcmFuc2Zvcm1zKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZmllbGRNYXNrID0gZmllbGRNYXNrO1xuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IGZpZWxkVHJhbnNmb3JtcztcbiAgICB9XG4gICAgdG9NdXRhdGlvbihrZXksIHByZWNvbmRpdGlvbikge1xuICAgICAgICBpZiAodGhpcy5maWVsZE1hc2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGF0Y2hNdXRhdGlvbihrZXksIHRoaXMuZGF0YSwgdGhpcy5maWVsZE1hc2ssIHByZWNvbmRpdGlvbiwgdGhpcy5maWVsZFRyYW5zZm9ybXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXRNdXRhdGlvbihrZXksIHRoaXMuZGF0YSwgcHJlY29uZGl0aW9uLCB0aGlzLmZpZWxkVHJhbnNmb3Jtcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogVGhlIHJlc3VsdCBvZiBwYXJzaW5nIFwidXBkYXRlXCIgZGF0YSAoaS5lLiBmb3IgYW4gdXBkYXRlRGF0YSBjYWxsKS4gKi9cbmNsYXNzIFBhcnNlZFVwZGF0ZURhdGEge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIFxuICAgIC8vIFRoZSBmaWVsZE1hc2sgZG9lcyBub3QgaW5jbHVkZSBkb2N1bWVudCB0cmFuc2Zvcm1zLlxuICAgIGZpZWxkTWFzaywgZmllbGRUcmFuc2Zvcm1zKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZmllbGRNYXNrID0gZmllbGRNYXNrO1xuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IGZpZWxkVHJhbnNmb3JtcztcbiAgICB9XG4gICAgdG9NdXRhdGlvbihrZXksIHByZWNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGNoTXV0YXRpb24oa2V5LCB0aGlzLmRhdGEsIHRoaXMuZmllbGRNYXNrLCBwcmVjb25kaXRpb24sIHRoaXMuZmllbGRUcmFuc2Zvcm1zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1dyaXRlKGRhdGFTb3VyY2UpIHtcbiAgICBzd2l0Y2ggKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgY2FzZSAwIC8qIFVzZXJEYXRhU291cmNlLlNldCAqLzogLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgIGNhc2UgMiAvKiBVc2VyRGF0YVNvdXJjZS5NZXJnZVNldCAqLzogLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgIGNhc2UgMSAvKiBVc2VyRGF0YVNvdXJjZS5VcGRhdGUgKi86XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAzIC8qIFVzZXJEYXRhU291cmNlLkFyZ3VtZW50ICovOlxuICAgICAgICBjYXNlIDQgLyogVXNlckRhdGFTb3VyY2UuQXJyYXlBcmd1bWVudCAqLzpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcbiAgICB9XG59XG4vKiogQSBcImNvbnRleHRcIiBvYmplY3QgcGFzc2VkIGFyb3VuZCB3aGlsZSBwYXJzaW5nIHVzZXIgZGF0YS4gKi9cbmNsYXNzIFBhcnNlQ29udGV4dEltcGwge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgUGFyc2VDb250ZXh0IHdpdGggdGhlIGdpdmVuIHNvdXJjZSBhbmQgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXR0aW5ncyAtIFRoZSBzZXR0aW5ncyBmb3IgdGhlIHBhcnNlci5cbiAgICAgKiBAcGFyYW0gZGF0YWJhc2VJZCAtIFRoZSBkYXRhYmFzZSBJRCBvZiB0aGUgRmlyZXN0b3JlIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBzZXJpYWxpemVyIC0gVGhlIHNlcmlhbGl6ZXIgdG8gdXNlIHRvIGdlbmVyYXRlIHRoZSBWYWx1ZSBwcm90by5cbiAgICAgKiBAcGFyYW0gaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyAtIFdoZXRoZXIgdG8gaWdub3JlIHVuZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICogcmF0aGVyIHRoYW4gdGhyb3cuXG4gICAgICogQHBhcmFtIGZpZWxkVHJhbnNmb3JtcyAtIEEgbXV0YWJsZSBsaXN0IG9mIGZpZWxkIHRyYW5zZm9ybXMgZW5jb3VudGVyZWRcbiAgICAgKiB3aGlsZSBwYXJzaW5nIHRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSBmaWVsZE1hc2sgLSBBIG11dGFibGUgbGlzdCBvZiBmaWVsZCBwYXRocyBlbmNvdW50ZXJlZCB3aGlsZSBwYXJzaW5nXG4gICAgICogdGhlIGRhdGEuXG4gICAgICpcbiAgICAgKiBUT0RPKGIvMzQ4NzExMzEpOiBXZSBkb24ndCBzdXBwb3J0IGFycmF5IHBhdGhzIHJpZ2h0IG5vdywgc28gcGF0aCBjYW4gYmVcbiAgICAgKiBudWxsIHRvIGluZGljYXRlIHRoZSBjb250ZXh0IHJlcHJlc2VudHMgYW55IGxvY2F0aW9uIHdpdGhpbiBhbiBhcnJheSAoaW5cbiAgICAgKiB3aGljaCBjYXNlIGNlcnRhaW4gZmVhdHVyZXMgd2lsbCBub3Qgd29yayBhbmQgZXJyb3JzIHdpbGwgYmUgc29tZXdoYXRcbiAgICAgKiBjb21wcm9taXNlZCkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MsIGRhdGFiYXNlSWQsIHNlcmlhbGl6ZXIsIGlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMsIGZpZWxkVHJhbnNmb3JtcywgZmllbGRNYXNrKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5kYXRhYmFzZUlkID0gZGF0YWJhc2VJZDtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcbiAgICAgICAgdGhpcy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzID0gaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcztcbiAgICAgICAgLy8gTWlub3IgaGFjazogSWYgZmllbGRUcmFuc2Zvcm1zIGlzIHVuZGVmaW5lZCwgd2UgYXNzdW1lIHRoaXMgaXMgYW5cbiAgICAgICAgLy8gZXh0ZXJuYWwgY2FsbCBhbmQgd2UgbmVlZCB0byB2YWxpZGF0ZSB0aGUgZW50aXJlIHBhdGguXG4gICAgICAgIGlmIChmaWVsZFRyYW5zZm9ybXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IGZpZWxkVHJhbnNmb3JtcyB8fCBbXTtcbiAgICAgICAgdGhpcy5maWVsZE1hc2sgPSBmaWVsZE1hc2sgfHwgW107XG4gICAgfVxuICAgIGdldCBwYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5wYXRoO1xuICAgIH1cbiAgICBnZXQgZGF0YVNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MuZGF0YVNvdXJjZTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBuZXcgY29udGV4dCB3aXRoIHRoZSBzcGVjaWZpZWQgc2V0dGluZ3Mgb3ZlcndyaXR0ZW4uICovXG4gICAgY29udGV4dFdpdGgoY29uZmlndXJhdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dEltcGwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnNldHRpbmdzKSwgY29uZmlndXJhdGlvbiksIHRoaXMuZGF0YWJhc2VJZCwgdGhpcy5zZXJpYWxpemVyLCB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMsIHRoaXMuZmllbGRUcmFuc2Zvcm1zLCB0aGlzLmZpZWxkTWFzayk7XG4gICAgfVxuICAgIGNoaWxkQ29udGV4dEZvckZpZWxkKGZpZWxkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gKF9hID0gdGhpcy5wYXRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hpbGQoZmllbGQpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0V2l0aCh7IHBhdGg6IGNoaWxkUGF0aCwgYXJyYXlFbGVtZW50OiBmYWxzZSB9KTtcbiAgICAgICAgY29udGV4dC52YWxpZGF0ZVBhdGhTZWdtZW50KGZpZWxkKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIGNoaWxkQ29udGV4dEZvckZpZWxkUGF0aChmaWVsZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IChfYSA9IHRoaXMucGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNoaWxkKGZpZWxkKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dFdpdGgoeyBwYXRoOiBjaGlsZFBhdGgsIGFycmF5RWxlbWVudDogZmFsc2UgfSk7XG4gICAgICAgIGNvbnRleHQudmFsaWRhdGVQYXRoKCk7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICBjaGlsZENvbnRleHRGb3JBcnJheShpbmRleCkge1xuICAgICAgICAvLyBUT0RPKGIvMzQ4NzExMzEpOiBXZSBkb24ndCBzdXBwb3J0IGFycmF5IHBhdGhzIHJpZ2h0IG5vdzsgc28gbWFrZSBwYXRoXG4gICAgICAgIC8vIHVuZGVmaW5lZC5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dFdpdGgoeyBwYXRoOiB1bmRlZmluZWQsIGFycmF5RWxlbWVudDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgY3JlYXRlRXJyb3IocmVhc29uKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFcnJvcihyZWFzb24sIHRoaXMuc2V0dGluZ3MubWV0aG9kTmFtZSwgdGhpcy5zZXR0aW5ncy5oYXNDb252ZXJ0ZXIgfHwgZmFsc2UsIHRoaXMucGF0aCwgdGhpcy5zZXR0aW5ncy50YXJnZXREb2MpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyAndHJ1ZScgaWYgJ2ZpZWxkUGF0aCcgd2FzIHRyYXZlcnNlZCB3aGVuIGNyZWF0aW5nIHRoaXMgY29udGV4dC4gKi9cbiAgICBjb250YWlucyhmaWVsZFBhdGgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZpZWxkTWFzay5maW5kKGZpZWxkID0+IGZpZWxkUGF0aC5pc1ByZWZpeE9mKGZpZWxkKSkgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMuZmluZCh0cmFuc2Zvcm0gPT4gZmllbGRQYXRoLmlzUHJlZml4T2YodHJhbnNmb3JtLmZpZWxkKSkgIT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHZhbGlkYXRlUGF0aCgpIHtcbiAgICAgICAgLy8gVE9ETyhiLzM0ODcxMTMxKTogUmVtb3ZlIG51bGwgY2hlY2sgb25jZSB3ZSBoYXZlIHByb3BlciBwYXRocyBmb3IgZmllbGRzXG4gICAgICAgIC8vIHdpdGhpbiBhcnJheXMuXG4gICAgICAgIGlmICghdGhpcy5wYXRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQYXRoU2VnbWVudCh0aGlzLnBhdGguZ2V0KGkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWxpZGF0ZVBhdGhTZWdtZW50KHNlZ21lbnQpIHtcbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKCdEb2N1bWVudCBmaWVsZHMgbXVzdCBub3QgYmUgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNXcml0ZSh0aGlzLmRhdGFTb3VyY2UpICYmIFJFU0VSVkVEX0ZJRUxEX1JFR0VYLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IoJ0RvY3VtZW50IGZpZWxkcyBjYW5ub3QgYmVnaW4gYW5kIGVuZCB3aXRoIFwiX19cIicpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgZm9yIHBhcnNpbmcgcmF3IHVzZXIgaW5wdXQgKHByb3ZpZGVkIHZpYSB0aGUgQVBJKSBpbnRvIGludGVybmFsIG1vZGVsXG4gKiBjbGFzc2VzLlxuICovXG5jbGFzcyBVc2VyRGF0YVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IoZGF0YWJhc2VJZCwgaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcywgc2VyaWFsaXplcikge1xuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBkYXRhYmFzZUlkO1xuICAgICAgICB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgPSBpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyIHx8IG5ld1NlcmlhbGl6ZXIoZGF0YWJhc2VJZCk7XG4gICAgfVxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHRvcC1sZXZlbCBwYXJzZSBjb250ZXh0LiAqL1xuICAgIGNyZWF0ZUNvbnRleHQoZGF0YVNvdXJjZSwgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jLCBoYXNDb252ZXJ0ZXIgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dEltcGwoe1xuICAgICAgICAgICAgZGF0YVNvdXJjZSxcbiAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICB0YXJnZXREb2MsXG4gICAgICAgICAgICBwYXRoOiBGaWVsZFBhdGgkMS5lbXB0eVBhdGgoKSxcbiAgICAgICAgICAgIGFycmF5RWxlbWVudDogZmFsc2UsXG4gICAgICAgICAgICBoYXNDb252ZXJ0ZXJcbiAgICAgICAgfSwgdGhpcy5kYXRhYmFzZUlkLCB0aGlzLnNlcmlhbGl6ZXIsIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3VXNlckRhdGFSZWFkZXIoZmlyZXN0b3JlKSB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBmaXJlc3RvcmUuX2ZyZWV6ZVNldHRpbmdzKCk7XG4gICAgY29uc3Qgc2VyaWFsaXplciA9IG5ld1NlcmlhbGl6ZXIoZmlyZXN0b3JlLl9kYXRhYmFzZUlkKTtcbiAgICByZXR1cm4gbmV3IFVzZXJEYXRhUmVhZGVyKGZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgISFzZXR0aW5ncy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzLCBzZXJpYWxpemVyKTtcbn1cbi8qKiBQYXJzZSBkb2N1bWVudCBkYXRhIGZyb20gYSBzZXQoKSBjYWxsLiAqL1xuZnVuY3Rpb24gcGFyc2VTZXREYXRhKHVzZXJEYXRhUmVhZGVyLCBtZXRob2ROYW1lLCB0YXJnZXREb2MsIGlucHV0LCBoYXNDb252ZXJ0ZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VyRGF0YVJlYWRlci5jcmVhdGVDb250ZXh0KG9wdGlvbnMubWVyZ2UgfHwgb3B0aW9ucy5tZXJnZUZpZWxkc1xuICAgICAgICA/IDIgLyogVXNlckRhdGFTb3VyY2UuTWVyZ2VTZXQgKi9cbiAgICAgICAgOiAwIC8qIFVzZXJEYXRhU291cmNlLlNldCAqLywgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jLCBoYXNDb252ZXJ0ZXIpO1xuICAgIHZhbGlkYXRlUGxhaW5PYmplY3QoJ0RhdGEgbXVzdCBiZSBhbiBvYmplY3QsIGJ1dCBpdCB3YXM6JywgY29udGV4dCwgaW5wdXQpO1xuICAgIGNvbnN0IHVwZGF0ZURhdGEgPSBwYXJzZU9iamVjdChpbnB1dCwgY29udGV4dCk7XG4gICAgbGV0IGZpZWxkTWFzaztcbiAgICBsZXQgZmllbGRUcmFuc2Zvcm1zO1xuICAgIGlmIChvcHRpb25zLm1lcmdlKSB7XG4gICAgICAgIGZpZWxkTWFzayA9IG5ldyBGaWVsZE1hc2soY29udGV4dC5maWVsZE1hc2spO1xuICAgICAgICBmaWVsZFRyYW5zZm9ybXMgPSBjb250ZXh0LmZpZWxkVHJhbnNmb3JtcztcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5tZXJnZUZpZWxkcykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGaWVsZFBhdGhzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3RyaW5nT3JGaWVsZFBhdGggb2Ygb3B0aW9ucy5tZXJnZUZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgZmllbGRQYXRoID0gZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEobWV0aG9kTmFtZSwgc3RyaW5nT3JGaWVsZFBhdGgsIHRhcmdldERvYyk7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuY29udGFpbnMoZmllbGRQYXRoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBGaWVsZCAnJHtmaWVsZFBhdGh9JyBpcyBzcGVjaWZpZWQgaW4geW91ciBmaWVsZCBtYXNrIGJ1dCBtaXNzaW5nIGZyb20geW91ciBpbnB1dCBkYXRhLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmaWVsZE1hc2tDb250YWlucyh2YWxpZGF0ZWRGaWVsZFBhdGhzLCBmaWVsZFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVkRmllbGRQYXRocy5wdXNoKGZpZWxkUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRNYXNrID0gbmV3IEZpZWxkTWFzayh2YWxpZGF0ZWRGaWVsZFBhdGhzKTtcbiAgICAgICAgZmllbGRUcmFuc2Zvcm1zID0gY29udGV4dC5maWVsZFRyYW5zZm9ybXMuZmlsdGVyKHRyYW5zZm9ybSA9PiBmaWVsZE1hc2suY292ZXJzKHRyYW5zZm9ybS5maWVsZCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmllbGRNYXNrID0gbnVsbDtcbiAgICAgICAgZmllbGRUcmFuc2Zvcm1zID0gY29udGV4dC5maWVsZFRyYW5zZm9ybXM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUGFyc2VkU2V0RGF0YShuZXcgT2JqZWN0VmFsdWUodXBkYXRlRGF0YSksIGZpZWxkTWFzaywgZmllbGRUcmFuc2Zvcm1zKTtcbn1cbmNsYXNzIERlbGV0ZUZpZWxkVmFsdWVJbXBsIGV4dGVuZHMgRmllbGRWYWx1ZSB7XG4gICAgX3RvRmllbGRUcmFuc2Zvcm0oY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dC5kYXRhU291cmNlID09PSAyIC8qIFVzZXJEYXRhU291cmNlLk1lcmdlU2V0ICovKSB7XG4gICAgICAgICAgICAvLyBObyB0cmFuc2Zvcm0gdG8gYWRkIGZvciBhIGRlbGV0ZSwgYnV0IHdlIG5lZWQgdG8gYWRkIGl0IHRvIG91clxuICAgICAgICAgICAgLy8gZmllbGRNYXNrIHNvIGl0IGdldHMgZGVsZXRlZC5cbiAgICAgICAgICAgIGNvbnRleHQuZmllbGRNYXNrLnB1c2goY29udGV4dC5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZXh0LmRhdGFTb3VyY2UgPT09IDEgLyogVXNlckRhdGFTb3VyY2UuVXBkYXRlICovKSB7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGAke3RoaXMuX21ldGhvZE5hbWV9KCkgY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWwgYCArXG4gICAgICAgICAgICAgICAgJ29mIHlvdXIgdXBkYXRlIGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZG4ndCBlbmNvdW50ZXIgZGVsZXRlIHNlbnRpbmVscyBmb3IgcXVlcmllcyBvciBub24tbWVyZ2Ugc2V0KCkgY2FsbHMuXG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGAke3RoaXMuX21ldGhvZE5hbWV9KCkgY2Fubm90IGJlIHVzZWQgd2l0aCBzZXQoKSB1bmxlc3MgeW91IHBhc3MgYCArXG4gICAgICAgICAgICAgICAgJ3ttZXJnZTp0cnVlfScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIERlbGV0ZUZpZWxkVmFsdWVJbXBsO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIGNoaWxkIGNvbnRleHQgZm9yIHBhcnNpbmcgU2VyaWFsaXphYmxlRmllbGRWYWx1ZXMuXG4gKlxuICogVGhpcyBpcyBkaWZmZXJlbnQgdGhhbiBjYWxsaW5nIGBQYXJzZUNvbnRleHQuY29udGV4dFdpdGhgIGJlY2F1c2UgaXQga2VlcHNcbiAqIHRoZSBmaWVsZFRyYW5zZm9ybXMgYW5kIGZpZWxkTWFzayBzZXBhcmF0ZS5cbiAqXG4gKiBUaGUgY3JlYXRlZCBjb250ZXh0IGhhcyBpdHMgYGRhdGFTb3VyY2VgIHNldCB0byBgVXNlckRhdGFTb3VyY2UuQXJndW1lbnRgLlxuICogQWx0aG91Z2ggdGhlc2UgdmFsdWVzIGFyZSB1c2VkIHdpdGggd3JpdGVzLCBhbnkgZWxlbWVudHMgaW4gdGhlc2UgRmllbGRWYWx1ZXNcbiAqIGFyZSBub3QgY29uc2lkZXJlZCB3cml0ZXMgc2luY2UgdGhleSBjYW5ub3QgY29udGFpbiBhbnkgRmllbGRWYWx1ZSBzZW50aW5lbHMsXG4gKiBldGMuXG4gKlxuICogQHBhcmFtIGZpZWxkVmFsdWUgLSBUaGUgc2VudGluZWwgRmllbGRWYWx1ZSBmb3Igd2hpY2ggdG8gY3JlYXRlIGEgY2hpbGRcbiAqICAgICBjb250ZXh0LlxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgcGFyZW50IGNvbnRleHQuXG4gKiBAcGFyYW0gYXJyYXlFbGVtZW50IC0gV2hldGhlciBvciBub3QgdGhlIEZpZWxkVmFsdWUgaGFzIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiBjcmVhdGVTZW50aW5lbENoaWxkQ29udGV4dChmaWVsZFZhbHVlLCBjb250ZXh0LCBhcnJheUVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dEltcGwoe1xuICAgICAgICBkYXRhU291cmNlOiAzIC8qIFVzZXJEYXRhU291cmNlLkFyZ3VtZW50ICovLFxuICAgICAgICB0YXJnZXREb2M6IGNvbnRleHQuc2V0dGluZ3MudGFyZ2V0RG9jLFxuICAgICAgICBtZXRob2ROYW1lOiBmaWVsZFZhbHVlLl9tZXRob2ROYW1lLFxuICAgICAgICBhcnJheUVsZW1lbnRcbiAgICB9LCBjb250ZXh0LmRhdGFiYXNlSWQsIGNvbnRleHQuc2VyaWFsaXplciwgY29udGV4dC5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzKTtcbn1cbmNsYXNzIFNlcnZlclRpbWVzdGFtcEZpZWxkVmFsdWVJbXBsIGV4dGVuZHMgRmllbGRWYWx1ZSB7XG4gICAgX3RvRmllbGRUcmFuc2Zvcm0oY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkVHJhbnNmb3JtKGNvbnRleHQucGF0aCwgbmV3IFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSgpKTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBTZXJ2ZXJUaW1lc3RhbXBGaWVsZFZhbHVlSW1wbDtcbiAgICB9XG59XG5jbGFzcyBBcnJheVVuaW9uRmllbGRWYWx1ZUltcGwgZXh0ZW5kcyBGaWVsZFZhbHVlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lLCBfZWxlbWVudHMpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kTmFtZSk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzID0gX2VsZW1lbnRzO1xuICAgIH1cbiAgICBfdG9GaWVsZFRyYW5zZm9ybShjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlQ29udGV4dCA9IGNyZWF0ZVNlbnRpbmVsQ2hpbGRDb250ZXh0KHRoaXMsIGNvbnRleHQsIFxuICAgICAgICAvKmFycmF5PSovIHRydWUpO1xuICAgICAgICBjb25zdCBwYXJzZWRFbGVtZW50cyA9IHRoaXMuX2VsZW1lbnRzLm1hcChlbGVtZW50ID0+IHBhcnNlRGF0YShlbGVtZW50LCBwYXJzZUNvbnRleHQpKTtcbiAgICAgICAgY29uc3QgYXJyYXlVbmlvbiA9IG5ldyBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKHBhcnNlZEVsZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFRyYW5zZm9ybShjb250ZXh0LnBhdGgsIGFycmF5VW5pb24pO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBBcnJheVVuaW9uRmllbGRWYWx1ZUltcGwgJiZcbiAgICAgICAgICAgIGRlZXBFcXVhbCh0aGlzLl9lbGVtZW50cywgb3RoZXIuX2VsZW1lbnRzKSk7XG4gICAgfVxufVxuY2xhc3MgQXJyYXlSZW1vdmVGaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZE5hbWUsIF9lbGVtZW50cykge1xuICAgICAgICBzdXBlcihtZXRob2ROYW1lKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBfZWxlbWVudHM7XG4gICAgfVxuICAgIF90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VDb250ZXh0ID0gY3JlYXRlU2VudGluZWxDaGlsZENvbnRleHQodGhpcywgY29udGV4dCwgXG4gICAgICAgIC8qYXJyYXk9Ki8gdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZEVsZW1lbnRzID0gdGhpcy5fZWxlbWVudHMubWFwKGVsZW1lbnQgPT4gcGFyc2VEYXRhKGVsZW1lbnQsIHBhcnNlQ29udGV4dCkpO1xuICAgICAgICBjb25zdCBhcnJheVVuaW9uID0gbmV3IEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKHBhcnNlZEVsZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFRyYW5zZm9ybShjb250ZXh0LnBhdGgsIGFycmF5VW5pb24pO1xuICAgIH1cbiAgICBpc0VxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBBcnJheVJlbW92ZUZpZWxkVmFsdWVJbXBsICYmXG4gICAgICAgICAgICBkZWVwRXF1YWwodGhpcy5fZWxlbWVudHMsIG90aGVyLl9lbGVtZW50cykpO1xuICAgIH1cbn1cbmNsYXNzIE51bWVyaWNJbmNyZW1lbnRGaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZE5hbWUsIF9vcGVyYW5kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZE5hbWUpO1xuICAgICAgICB0aGlzLl9vcGVyYW5kID0gX29wZXJhbmQ7XG4gICAgfVxuICAgIF90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgbnVtZXJpY0luY3JlbWVudCA9IG5ldyBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uKGNvbnRleHQuc2VyaWFsaXplciwgdG9OdW1iZXIoY29udGV4dC5zZXJpYWxpemVyLCB0aGlzLl9vcGVyYW5kKSk7XG4gICAgICAgIHJldHVybiBuZXcgRmllbGRUcmFuc2Zvcm0oY29udGV4dC5wYXRoLCBudW1lcmljSW5jcmVtZW50KTtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKG90aGVyIGluc3RhbmNlb2YgTnVtZXJpY0luY3JlbWVudEZpZWxkVmFsdWVJbXBsICYmXG4gICAgICAgICAgICB0aGlzLl9vcGVyYW5kID09PSBvdGhlci5fb3BlcmFuZCk7XG4gICAgfVxufVxuLyoqIFBhcnNlIHVwZGF0ZSBkYXRhIGZyb20gYW4gdXBkYXRlKCkgY2FsbC4gKi9cbmZ1bmN0aW9uIHBhcnNlVXBkYXRlRGF0YSh1c2VyRGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jLCBpbnB1dCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VyRGF0YVJlYWRlci5jcmVhdGVDb250ZXh0KDEgLyogVXNlckRhdGFTb3VyY2UuVXBkYXRlICovLCBtZXRob2ROYW1lLCB0YXJnZXREb2MpO1xuICAgIHZhbGlkYXRlUGxhaW5PYmplY3QoJ0RhdGEgbXVzdCBiZSBhbiBvYmplY3QsIGJ1dCBpdCB3YXM6JywgY29udGV4dCwgaW5wdXQpO1xuICAgIGNvbnN0IGZpZWxkTWFza1BhdGhzID0gW107XG4gICAgY29uc3QgdXBkYXRlRGF0YSA9IE9iamVjdFZhbHVlLmVtcHR5KCk7XG4gICAgZm9yRWFjaChpbnB1dCwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcobWV0aG9kTmFtZSwga2V5LCB0YXJnZXREb2MpO1xuICAgICAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxuICAgICAgICAvLyBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXG4gICAgICAgIHZhbHVlID0gZ2V0TW9kdWxhckluc3RhbmNlKHZhbHVlKTtcbiAgICAgICAgY29uc3QgY2hpbGRDb250ZXh0ID0gY29udGV4dC5jaGlsZENvbnRleHRGb3JGaWVsZFBhdGgocGF0aCk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERlbGV0ZUZpZWxkVmFsdWVJbXBsKSB7XG4gICAgICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGZpZWxkIG1hc2ssIGJ1dCBkb24ndCBhZGQgYW55dGhpbmcgdG8gdXBkYXRlRGF0YS5cbiAgICAgICAgICAgIGZpZWxkTWFza1BhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlRGF0YSh2YWx1ZSwgY2hpbGRDb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZmllbGRNYXNrUGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVEYXRhLnNldChwYXRoLCBwYXJzZWRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBtYXNrID0gbmV3IEZpZWxkTWFzayhmaWVsZE1hc2tQYXRocyk7XG4gICAgcmV0dXJuIG5ldyBQYXJzZWRVcGRhdGVEYXRhKHVwZGF0ZURhdGEsIG1hc2ssIGNvbnRleHQuZmllbGRUcmFuc2Zvcm1zKTtcbn1cbi8qKiBQYXJzZSB1cGRhdGUgZGF0YSBmcm9tIGEgbGlzdCBvZiBmaWVsZC92YWx1ZSBhcmd1bWVudHMuICovXG5mdW5jdGlvbiBwYXJzZVVwZGF0ZVZhcmFyZ3ModXNlckRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIHRhcmdldERvYywgZmllbGQsIHZhbHVlLCBtb3JlRmllbGRzQW5kVmFsdWVzKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZXJEYXRhUmVhZGVyLmNyZWF0ZUNvbnRleHQoMSAvKiBVc2VyRGF0YVNvdXJjZS5VcGRhdGUgKi8sIG1ldGhvZE5hbWUsIHRhcmdldERvYyk7XG4gICAgY29uc3Qga2V5cyA9IFtmaWVsZFBhdGhGcm9tQXJndW1lbnQkMShtZXRob2ROYW1lLCBmaWVsZCwgdGFyZ2V0RG9jKV07XG4gICAgY29uc3QgdmFsdWVzID0gW3ZhbHVlXTtcbiAgICBpZiAobW9yZUZpZWxkc0FuZFZhbHVlcy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBGdW5jdGlvbiAke21ldGhvZE5hbWV9KCkgbmVlZHMgdG8gYmUgY2FsbGVkIHdpdGggYW4gZXZlbiBudW1iZXIgYCArXG4gICAgICAgICAgICAnb2YgYXJndW1lbnRzIHRoYXQgYWx0ZXJuYXRlIGJldHdlZW4gZmllbGQgbmFtZXMgYW5kIHZhbHVlcy4nKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb3JlRmllbGRzQW5kVmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGtleXMucHVzaChmaWVsZFBhdGhGcm9tQXJndW1lbnQkMShtZXRob2ROYW1lLCBtb3JlRmllbGRzQW5kVmFsdWVzW2ldKSk7XG4gICAgICAgIHZhbHVlcy5wdXNoKG1vcmVGaWVsZHNBbmRWYWx1ZXNbaSArIDFdKTtcbiAgICB9XG4gICAgY29uc3QgZmllbGRNYXNrUGF0aHMgPSBbXTtcbiAgICBjb25zdCB1cGRhdGVEYXRhID0gT2JqZWN0VmFsdWUuZW1wdHkoKTtcbiAgICAvLyBXZSBpdGVyYXRlIGluIHJldmVyc2Ugb3JkZXIgdG8gcGljayB0aGUgbGFzdCB2YWx1ZSBmb3IgYSBmaWVsZCBpZiB0aGVcbiAgICAvLyB1c2VyIHNwZWNpZmllZCB0aGUgZmllbGQgbXVsdGlwbGUgdGltZXMuXG4gICAgZm9yIChsZXQgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKCFmaWVsZE1hc2tDb250YWlucyhmaWVsZE1hc2tQYXRocywga2V5c1tpXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBrZXlzW2ldO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgLy8gRm9yIENvbXBhdCB0eXBlcywgd2UgaGF2ZSB0byBcImV4dHJhY3RcIiB0aGUgdW5kZXJseWluZyB0eXBlcyBiZWZvcmVcbiAgICAgICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gZ2V0TW9kdWxhckluc3RhbmNlKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ29udGV4dCA9IGNvbnRleHQuY2hpbGRDb250ZXh0Rm9yRmllbGRQYXRoKHBhdGgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGVsZXRlRmllbGRWYWx1ZUltcGwpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGZpZWxkIG1hc2ssIGJ1dCBkb24ndCBhZGQgYW55dGhpbmcgdG8gdXBkYXRlRGF0YS5cbiAgICAgICAgICAgICAgICBmaWVsZE1hc2tQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZURhdGEodmFsdWUsIGNoaWxkQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRNYXNrUGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlRGF0YS5zZXQocGF0aCwgcGFyc2VkVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtYXNrID0gbmV3IEZpZWxkTWFzayhmaWVsZE1hc2tQYXRocyk7XG4gICAgcmV0dXJuIG5ldyBQYXJzZWRVcGRhdGVEYXRhKHVwZGF0ZURhdGEsIG1hc2ssIGNvbnRleHQuZmllbGRUcmFuc2Zvcm1zKTtcbn1cbi8qKlxuICogUGFyc2UgYSBcInF1ZXJ5IHZhbHVlXCIgKGUuZy4gdmFsdWUgaW4gYSB3aGVyZSBmaWx0ZXIgb3IgYSB2YWx1ZSBpbiBhIGN1cnNvclxuICogYm91bmQpLlxuICpcbiAqIEBwYXJhbSBhbGxvd0FycmF5cyAtIFdoZXRoZXIgdGhlIHF1ZXJ5IHZhbHVlIGlzIGFuIGFycmF5IHRoYXQgbWF5IGRpcmVjdGx5XG4gKiBjb250YWluIGFkZGl0aW9uYWwgYXJyYXlzIChlLmcuIHRoZSBvcGVyYW5kIG9mIGFuIGBpbmAgcXVlcnkpLlxuICovXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5VmFsdWUodXNlckRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIGlucHV0LCBhbGxvd0FycmF5cyA9IGZhbHNlKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZXJEYXRhUmVhZGVyLmNyZWF0ZUNvbnRleHQoYWxsb3dBcnJheXMgPyA0IC8qIFVzZXJEYXRhU291cmNlLkFycmF5QXJndW1lbnQgKi8gOiAzIC8qIFVzZXJEYXRhU291cmNlLkFyZ3VtZW50ICovLCBtZXRob2ROYW1lKTtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZURhdGEoaW5wdXQsIGNvbnRleHQpO1xuICAgIHJldHVybiBwYXJzZWQ7XG59XG4vKipcbiAqIFBhcnNlcyB1c2VyIGRhdGEgdG8gUHJvdG9idWYgVmFsdWVzLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIERhdGEgdG8gYmUgcGFyc2VkLlxuICogQHBhcmFtIGNvbnRleHQgLSBBIGNvbnRleHQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBwYXRoIGJlaW5nIHBhcnNlZCxcbiAqIHRoZSBzb3VyY2Ugb2YgdGhlIGRhdGEgYmVpbmcgcGFyc2VkLCBldGMuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIHZhbHVlLCBvciBudWxsIGlmIHRoZSB2YWx1ZSB3YXMgYSBGaWVsZFZhbHVlIHNlbnRpbmVsXG4gKiB0aGF0IHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBwYXJzZWQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VEYXRhKGlucHV0LCBjb250ZXh0KSB7XG4gICAgLy8gVW53cmFwIHRoZSBBUEkgdHlwZSBmcm9tIHRoZSBDb21wYXQgU0RLLiBUaGlzIHdpbGwgcmV0dXJuIHRoZSBBUEkgdHlwZVxuICAgIC8vIGZyb20gZmlyZXN0b3JlLWV4cC5cbiAgICBpbnB1dCA9IGdldE1vZHVsYXJJbnN0YW5jZShpbnB1dCk7XG4gICAgaWYgKGxvb2tzTGlrZUpzb25PYmplY3QoaW5wdXQpKSB7XG4gICAgICAgIHZhbGlkYXRlUGxhaW5PYmplY3QoJ1Vuc3VwcG9ydGVkIGZpZWxkIHZhbHVlOicsIGNvbnRleHQsIGlucHV0KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0KGlucHV0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBGaWVsZFZhbHVlKSB7XG4gICAgICAgIC8vIEZpZWxkVmFsdWVzIHVzdWFsbHkgcGFyc2UgaW50byB0cmFuc2Zvcm1zIChleGNlcHQgZGVsZXRlRmllbGQoKSlcbiAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSBkbyBub3Qgd2FudCB0byBpbmNsdWRlIHRoaXMgZmllbGQgaW4gb3VyIHBhcnNlZCBkYXRhXG4gICAgICAgIC8vIChhcyBkb2luZyBzbyB3aWxsIG92ZXJ3cml0ZSB0aGUgZmllbGQgZGlyZWN0bHkgcHJpb3IgdG8gdGhlIHRyYW5zZm9ybVxuICAgICAgICAvLyB0cnlpbmcgdG8gdHJhbnNmb3JtIGl0KS4gU28gd2UgZG9uJ3QgYWRkIHRoaXMgbG9jYXRpb24gdG9cbiAgICAgICAgLy8gY29udGV4dC5maWVsZE1hc2sgYW5kIHdlIHJldHVybiBudWxsIGFzIG91ciBwYXJzaW5nIHJlc3VsdC5cbiAgICAgICAgcGFyc2VTZW50aW5lbEZpZWxkVmFsdWUoaW5wdXQsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Lmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMpIHtcbiAgICAgICAgLy8gSWYgdGhlIGlucHV0IGlzIHVuZGVmaW5lZCBpdCBjYW4gbmV2ZXIgcGFydGljaXBhdGUgaW4gdGhlIGZpZWxkTWFzaywgc29cbiAgICAgICAgLy8gZG9uJ3QgaGFuZGxlIHRoaXMgYmVsb3cuIElmIGBpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzYCBpcyBmYWxzZSxcbiAgICAgICAgLy8gYHBhcnNlU2NhbGFyVmFsdWVgIHdpbGwgcmVqZWN0IGFuIHVuZGVmaW5lZCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJZiBjb250ZXh0LnBhdGggaXMgbnVsbCB3ZSBhcmUgaW5zaWRlIGFuIGFycmF5IGFuZCB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAgIC8vIGZpZWxkIG1hc2sgcGF0aHMgbW9yZSBncmFudWxhciB0aGFuIHRoZSB0b3AtbGV2ZWwgYXJyYXkuXG4gICAgICAgIGlmIChjb250ZXh0LnBhdGgpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmllbGRNYXNrLnB1c2goY29udGV4dC5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgLy8gVE9ETyhiLzM0ODcxMTMxKTogSW5jbHVkZSB0aGUgcGF0aCBjb250YWluaW5nIHRoZSBhcnJheSBpbiB0aGUgZXJyb3JcbiAgICAgICAgICAgIC8vIG1lc3NhZ2UuXG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBJTiBxdWVyaWVzLCB0aGUgcGFyc2VkIGRhdGEgaXMgYW4gYXJyYXkgKHJlcHJlc2VudGluZ1xuICAgICAgICAgICAgLy8gdGhlIHNldCBvZiB2YWx1ZXMgdG8gYmUgaW5jbHVkZWQgZm9yIHRoZSBJTiBxdWVyeSkgdGhhdCBtYXkgZGlyZWN0bHlcbiAgICAgICAgICAgIC8vIGNvbnRhaW4gYWRkaXRpb25hbCBhcnJheXMgKGVhY2ggcmVwcmVzZW50aW5nIGFuIGluZGl2aWR1YWwgZmllbGRcbiAgICAgICAgICAgIC8vIHZhbHVlKSwgc28gd2UgZGlzYWJsZSB0aGlzIHZhbGlkYXRpb24uXG4gICAgICAgICAgICBpZiAoY29udGV4dC5zZXR0aW5ncy5hcnJheUVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRhdGFTb3VyY2UgIT09IDQgLyogVXNlckRhdGFTb3VyY2UuQXJyYXlBcmd1bWVudCAqLykge1xuICAgICAgICAgICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoJ05lc3RlZCBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUFycmF5KGlucHV0LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVNjYWxhclZhbHVlKGlucHV0LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iaiwgY29udGV4dCkge1xuICAgIGNvbnN0IGZpZWxkcyA9IHt9O1xuICAgIGlmIChpc0VtcHR5KG9iaikpIHtcbiAgICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVtcHR5IG9iamVjdCwgd2UgZXhwbGljaXRseSBhZGQgaXQgdG8gdGhlIHVwZGF0ZVxuICAgICAgICAvLyBtYXNrIHRvIGVuc3VyZSB0aGF0IHRoZSBzZXJ2ZXIgY3JlYXRlcyBhIG1hcCBlbnRyeS5cbiAgICAgICAgaWYgKGNvbnRleHQucGF0aCAmJiBjb250ZXh0LnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29udGV4dC5maWVsZE1hc2sucHVzaChjb250ZXh0LnBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3JFYWNoKG9iaiwgKGtleSwgdmFsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlRGF0YSh2YWwsIGNvbnRleHQuY2hpbGRDb250ZXh0Rm9yRmllbGQoa2V5KSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZpZWxkc1trZXldID0gcGFyc2VkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyBtYXBWYWx1ZTogeyBmaWVsZHMgfSB9O1xufVxuZnVuY3Rpb24gcGFyc2VBcnJheShhcnJheSwgY29udGV4dCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBlbnRyeUluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGFycmF5KSB7XG4gICAgICAgIGxldCBwYXJzZWRFbnRyeSA9IHBhcnNlRGF0YShlbnRyeSwgY29udGV4dC5jaGlsZENvbnRleHRGb3JBcnJheShlbnRyeUluZGV4KSk7XG4gICAgICAgIGlmIChwYXJzZWRFbnRyeSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBKdXN0IGluY2x1ZGUgbnVsbHMgaW4gdGhlIGFycmF5IGZvciBmaWVsZHMgYmVpbmcgcmVwbGFjZWQgd2l0aCBhXG4gICAgICAgICAgICAvLyBzZW50aW5lbC5cbiAgICAgICAgICAgIHBhcnNlZEVudHJ5ID0geyBudWxsVmFsdWU6ICdOVUxMX1ZBTFVFJyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcy5wdXNoKHBhcnNlZEVudHJ5KTtcbiAgICAgICAgZW50cnlJbmRleCsrO1xuICAgIH1cbiAgICByZXR1cm4geyBhcnJheVZhbHVlOiB7IHZhbHVlcyB9IH07XG59XG4vKipcbiAqIFwiUGFyc2VzXCIgdGhlIHByb3ZpZGVkIEZpZWxkVmFsdWVJbXBsLCBhZGRpbmcgYW55IG5lY2Vzc2FyeSB0cmFuc2Zvcm1zIHRvXG4gKiBjb250ZXh0LmZpZWxkVHJhbnNmb3Jtcy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VTZW50aW5lbEZpZWxkVmFsdWUodmFsdWUsIGNvbnRleHQpIHtcbiAgICAvLyBTZW50aW5lbHMgYXJlIG9ubHkgc3VwcG9ydGVkIHdpdGggd3JpdGVzLCBhbmQgbm90IHdpdGhpbiBhcnJheXMuXG4gICAgaWYgKCFpc1dyaXRlKGNvbnRleHQuZGF0YVNvdXJjZSkpIHtcbiAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihgJHt2YWx1ZS5fbWV0aG9kTmFtZX0oKSBjYW4gb25seSBiZSB1c2VkIHdpdGggdXBkYXRlKCkgYW5kIHNldCgpYCk7XG4gICAgfVxuICAgIGlmICghY29udGV4dC5wYXRoKSB7XG4gICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoYCR7dmFsdWUuX21ldGhvZE5hbWV9KCkgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgaW5zaWRlIGFycmF5c2ApO1xuICAgIH1cbiAgICBjb25zdCBmaWVsZFRyYW5zZm9ybSA9IHZhbHVlLl90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpO1xuICAgIGlmIChmaWVsZFRyYW5zZm9ybSkge1xuICAgICAgICBjb250ZXh0LmZpZWxkVHJhbnNmb3Jtcy5wdXNoKGZpZWxkVHJhbnNmb3JtKTtcbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciB0byBwYXJzZSBhIHNjYWxhciB2YWx1ZSAoaS5lLiBub3QgYW4gT2JqZWN0LCBBcnJheSwgb3IgRmllbGRWYWx1ZSlcbiAqXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU2NhbGFyVmFsdWUodmFsdWUsIGNvbnRleHQpIHtcbiAgICB2YWx1ZSA9IGdldE1vZHVsYXJJbnN0YW5jZSh2YWx1ZSk7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7IG51bGxWYWx1ZTogJ05VTExfVkFMVUUnIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRvTnVtYmVyKGNvbnRleHQuc2VyaWFsaXplciwgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4geyBib29sZWFuVmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RyaW5nVmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBUaW1lc3RhbXAuZnJvbURhdGUodmFsdWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGltZXN0YW1wVmFsdWU6IHRvVGltZXN0YW1wKGNvbnRleHQuc2VyaWFsaXplciwgdGltZXN0YW1wKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRpbWVzdGFtcCkge1xuICAgICAgICAvLyBGaXJlc3RvcmUgYmFja2VuZCB0cnVuY2F0ZXMgcHJlY2lzaW9uIGRvd24gdG8gbWljcm9zZWNvbmRzLiBUbyBlbnN1cmVcbiAgICAgICAgLy8gb2ZmbGluZSBtb2RlIHdvcmtzIHRoZSBzYW1lIHdpdGggcmVnYXJkcyB0byB0cnVuY2F0aW9uLCBwZXJmb3JtIHRoZVxuICAgICAgICAvLyB0cnVuY2F0aW9uIGltbWVkaWF0ZWx5IHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIGJhY2tlbmQgdG8gZG8gdGhhdC5cbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IFRpbWVzdGFtcCh2YWx1ZS5zZWNvbmRzLCBNYXRoLmZsb29yKHZhbHVlLm5hbm9zZWNvbmRzIC8gMTAwMCkgKiAxMDAwKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcFZhbHVlOiB0b1RpbWVzdGFtcChjb250ZXh0LnNlcmlhbGl6ZXIsIHRpbWVzdGFtcClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBHZW9Qb2ludCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2VvUG9pbnRWYWx1ZToge1xuICAgICAgICAgICAgICAgIGxhdGl0dWRlOiB2YWx1ZS5sYXRpdHVkZSxcbiAgICAgICAgICAgICAgICBsb25naXR1ZGU6IHZhbHVlLmxvbmdpdHVkZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJ5dGVzKSB7XG4gICAgICAgIHJldHVybiB7IGJ5dGVzVmFsdWU6IHRvQnl0ZXMoY29udGV4dC5zZXJpYWxpemVyLCB2YWx1ZS5fYnl0ZVN0cmluZykgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkge1xuICAgICAgICBjb25zdCB0aGlzRGIgPSBjb250ZXh0LmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IG90aGVyRGIgPSB2YWx1ZS5maXJlc3RvcmUuX2RhdGFiYXNlSWQ7XG4gICAgICAgIGlmICghb3RoZXJEYi5pc0VxdWFsKHRoaXNEYikpIHtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoJ0RvY3VtZW50IHJlZmVyZW5jZSBpcyBmb3IgZGF0YWJhc2UgJyArXG4gICAgICAgICAgICAgICAgYCR7b3RoZXJEYi5wcm9qZWN0SWR9LyR7b3RoZXJEYi5kYXRhYmFzZX0gYnV0IHNob3VsZCBiZSBgICtcbiAgICAgICAgICAgICAgICBgZm9yIGRhdGFiYXNlICR7dGhpc0RiLnByb2plY3RJZH0vJHt0aGlzRGIuZGF0YWJhc2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZVZhbHVlOiB0b1Jlc291cmNlTmFtZSh2YWx1ZS5maXJlc3RvcmUuX2RhdGFiYXNlSWQgfHwgY29udGV4dC5kYXRhYmFzZUlkLCB2YWx1ZS5fa2V5LnBhdGgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgVmVjdG9yVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVmVjdG9yVmFsdWUodmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihgVW5zdXBwb3J0ZWQgZmllbGQgdmFsdWU6ICR7dmFsdWVEZXNjcmlwdGlvbih2YWx1ZSl9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFZlY3RvclZhbHVlIHByb3RvIHZhbHVlICh1c2luZyB0aGUgaW50ZXJuYWwgZm9ybWF0KS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VWZWN0b3JWYWx1ZSh2YWx1ZSwgY29udGV4dCkge1xuICAgIGNvbnN0IG1hcFZhbHVlID0ge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIFtUWVBFX0tFWV06IHtcbiAgICAgICAgICAgICAgICBzdHJpbmdWYWx1ZTogVkVDVE9SX1ZBTFVFX1NFTlRJTkVMXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1ZFQ1RPUl9NQVBfVkVDVE9SU19LRVldOiB7XG4gICAgICAgICAgICAgICAgYXJyYXlWYWx1ZToge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHZhbHVlLnRvQXJyYXkoKS5tYXAodmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKCdWZWN0b3JWYWx1ZXMgbXVzdCBvbmx5IGNvbnRhaW4gbnVtZXJpYyB2YWx1ZXMuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9Eb3VibGUoY29udGV4dC5zZXJpYWxpemVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4geyBtYXBWYWx1ZSB9O1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhbiBvYmplY3QgbG9va3MgbGlrZSBhIEpTT04gb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICogaW50byBhIHN0cnVjdC4gTm9ybWFsIGNsYXNzL3Byb3RvdHlwZSBpbnN0YW5jZXMgYXJlIGNvbnNpZGVyZWQgdG8gbG9vayBsaWtlXG4gKiBKU09OIG9iamVjdHMgc2luY2UgdGhleSBzaG91bGQgYmUgY29udmVydGVkIHRvIGEgc3RydWN0IHZhbHVlLiBBcnJheXMsIERhdGVzLFxuICogR2VvUG9pbnRzLCBldGMuIGFyZSBub3QgY29uc2lkZXJlZCB0byBsb29rIGxpa2UgSlNPTiBvYmplY3RzIHNpbmNlIHRoZXkgbWFwXG4gKiB0byBzcGVjaWZpYyBGaWVsZFZhbHVlIHR5cGVzIG90aGVyIHRoYW4gT2JqZWN0VmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxvb2tzTGlrZUpzb25PYmplY3QoaW5wdXQpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgaW5wdXQgIT09IG51bGwgJiZcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIEFycmF5KSAmJlxuICAgICAgICAhKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkgJiZcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIFRpbWVzdGFtcCkgJiZcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIEdlb1BvaW50KSAmJlxuICAgICAgICAhKGlucHV0IGluc3RhbmNlb2YgQnl0ZXMpICYmXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkgJiZcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIEZpZWxkVmFsdWUpICYmXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBWZWN0b3JWYWx1ZSkpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQbGFpbk9iamVjdChtZXNzYWdlLCBjb250ZXh0LCBpbnB1dCkge1xuICAgIGlmICghbG9va3NMaWtlSnNvbk9iamVjdChpbnB1dCkgfHwgIWlzUGxhaW5PYmplY3QoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsdWVEZXNjcmlwdGlvbihpbnB1dCk7XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gJ2FuIG9iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIE1hc3NhZ2UgdGhlIGVycm9yIGlmIGl0IHdhcyBhbiBvYmplY3QuXG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKG1lc3NhZ2UgKyAnIGEgY3VzdG9tIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihtZXNzYWdlICsgJyAnICsgZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdGhhdCBjYWxscyBmcm9tRG90U2VwYXJhdGVkU3RyaW5nKCkgYnV0IHdyYXBzIGFueSBlcnJvciB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIGZpZWxkUGF0aEZyb21Bcmd1bWVudCQxKG1ldGhvZE5hbWUsIHBhdGgsIHRhcmdldERvYykge1xuICAgIC8vIElmIHJlcXVpcmVkLCByZXBsYWNlIHRoZSBGaWVsZFBhdGggQ29tcGF0IGNsYXNzIHdpdGggdGhlIGZpcmVzdG9yZS1leHBcbiAgICAvLyBGaWVsZFBhdGguXG4gICAgcGF0aCA9IGdldE1vZHVsYXJJbnN0YW5jZShwYXRoKTtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIEZpZWxkUGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5faW50ZXJuYWxQYXRoO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcobWV0aG9kTmFtZSwgcGF0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ZpZWxkIHBhdGggYXJndW1lbnRzIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcgb3IgJztcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IobWVzc2FnZSwgbWV0aG9kTmFtZSwgXG4gICAgICAgIC8qIGhhc0NvbnZlcnRlcj0gKi8gZmFsc2UsIFxuICAgICAgICAvKiBwYXRoPSAqLyB1bmRlZmluZWQsIHRhcmdldERvYyk7XG4gICAgfVxufVxuLyoqXG4gKiBNYXRjaGVzIGFueSBjaGFyYWN0ZXJzIGluIGEgZmllbGQgcGF0aCBzdHJpbmcgdGhhdCBhcmUgcmVzZXJ2ZWQuXG4gKi9cbmNvbnN0IEZJRUxEX1BBVEhfUkVTRVJWRUQgPSBuZXcgUmVnRXhwKCdbflxcXFwqL1xcXFxbXFxcXF1dJyk7XG4vKipcbiAqIFdyYXBzIGZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcgd2l0aCBhbiBlcnJvciBtZXNzYWdlIGFib3V0IHRoZSBtZXRob2QgdGhhdFxuICogd2FzIHRocm93bi5cbiAqIEBwYXJhbSBtZXRob2ROYW1lIC0gVGhlIHB1YmxpY2x5IHZpc2libGUgbWV0aG9kIG5hbWVcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGRvdC1zZXBhcmF0ZWQgc3RyaW5nIGZvcm0gb2YgYSBmaWVsZCBwYXRoIHdoaWNoIHdpbGwgYmVcbiAqIHNwbGl0IG9uIGRvdHMuXG4gKiBAcGFyYW0gdGFyZ2V0RG9jIC0gVGhlIGRvY3VtZW50IGFnYWluc3Qgd2hpY2ggdGhlIGZpZWxkIHBhdGggd2lsbCBiZVxuICogZXZhbHVhdGVkLlxuICovXG5mdW5jdGlvbiBmaWVsZFBhdGhGcm9tRG90U2VwYXJhdGVkU3RyaW5nKG1ldGhvZE5hbWUsIHBhdGgsIHRhcmdldERvYykge1xuICAgIGNvbnN0IGZvdW5kID0gcGF0aC5zZWFyY2goRklFTERfUEFUSF9SRVNFUlZFRCk7XG4gICAgaWYgKGZvdW5kID49IDApIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoYEludmFsaWQgZmllbGQgcGF0aCAoJHtwYXRofSkuIFBhdGhzIG11c3Qgbm90IGNvbnRhaW4gYCArXG4gICAgICAgICAgICBgJ34nLCAnKicsICcvJywgJ1snLCBvciAnXSdgLCBtZXRob2ROYW1lLCBcbiAgICAgICAgLyogaGFzQ29udmVydGVyPSAqLyBmYWxzZSwgXG4gICAgICAgIC8qIHBhdGg9ICovIHVuZGVmaW5lZCwgdGFyZ2V0RG9jKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgoLi4ucGF0aC5zcGxpdCgnLicpKS5faW50ZXJuYWxQYXRoO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihgSW52YWxpZCBmaWVsZCBwYXRoICgke3BhdGh9KS4gUGF0aHMgbXVzdCBub3QgYmUgZW1wdHksIGAgK1xuICAgICAgICAgICAgYGJlZ2luIHdpdGggJy4nLCBlbmQgd2l0aCAnLicsIG9yIGNvbnRhaW4gJy4uJ2AsIG1ldGhvZE5hbWUsIFxuICAgICAgICAvKiBoYXNDb252ZXJ0ZXI9ICovIGZhbHNlLCBcbiAgICAgICAgLyogcGF0aD0gKi8gdW5kZWZpbmVkLCB0YXJnZXREb2MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yKHJlYXNvbiwgbWV0aG9kTmFtZSwgaGFzQ29udmVydGVyLCBwYXRoLCB0YXJnZXREb2MpIHtcbiAgICBjb25zdCBoYXNQYXRoID0gcGF0aCAmJiAhcGF0aC5pc0VtcHR5KCk7XG4gICAgY29uc3QgaGFzRG9jdW1lbnQgPSB0YXJnZXREb2MgIT09IHVuZGVmaW5lZDtcbiAgICBsZXQgbWVzc2FnZSA9IGBGdW5jdGlvbiAke21ldGhvZE5hbWV9KCkgY2FsbGVkIHdpdGggaW52YWxpZCBkYXRhYDtcbiAgICBpZiAoaGFzQ29udmVydGVyKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gJyAodmlhIGB0b0ZpcmVzdG9yZSgpYCknO1xuICAgIH1cbiAgICBtZXNzYWdlICs9ICcuICc7XG4gICAgbGV0IGRlc2NyaXB0aW9uID0gJyc7XG4gICAgaWYgKGhhc1BhdGggfHwgaGFzRG9jdW1lbnQpIHtcbiAgICAgICAgZGVzY3JpcHRpb24gKz0gJyAoZm91bmQnO1xuICAgICAgICBpZiAoaGFzUGF0aCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gKz0gYCBpbiBmaWVsZCAke3BhdGh9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uICs9IGAgaW4gZG9jdW1lbnQgJHt0YXJnZXREb2N9YDtcbiAgICAgICAgfVxuICAgICAgICBkZXNjcmlwdGlvbiArPSAnKSc7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBtZXNzYWdlICsgcmVhc29uICsgZGVzY3JpcHRpb24pO1xufVxuLyoqIENoZWNrcyBgaGF5c3RhY2tgIGlmIEZpZWxkUGF0aCBgbmVlZGxlYCBpcyBwcmVzZW50LiBSdW5zIGluIE8obikuICovXG5mdW5jdGlvbiBmaWVsZE1hc2tDb250YWlucyhoYXlzdGFjaywgbmVlZGxlKSB7XG4gICAgcmV0dXJuIGhheXN0YWNrLnNvbWUodiA9PiB2LmlzRXF1YWwobmVlZGxlKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgYERvY3VtZW50U25hcHNob3RgIGNvbnRhaW5zIGRhdGEgcmVhZCBmcm9tIGEgZG9jdW1lbnQgaW4geW91ciBGaXJlc3RvcmVcbiAqIGRhdGFiYXNlLiBUaGUgZGF0YSBjYW4gYmUgZXh0cmFjdGVkIHdpdGggYC5kYXRhKClgIG9yIGAuZ2V0KDxmaWVsZD4pYCB0b1xuICogZ2V0IGEgc3BlY2lmaWMgZmllbGQuXG4gKlxuICogRm9yIGEgYERvY3VtZW50U25hcHNob3RgIHRoYXQgcG9pbnRzIHRvIGEgbm9uLWV4aXN0aW5nIGRvY3VtZW50LCBhbnkgZGF0YVxuICogYWNjZXNzIHdpbGwgcmV0dXJuICd1bmRlZmluZWQnLiBZb3UgY2FuIHVzZSB0aGUgYGV4aXN0cygpYCBtZXRob2QgdG9cbiAqIGV4cGxpY2l0bHkgdmVyaWZ5IGEgZG9jdW1lbnQncyBleGlzdGVuY2UuXG4gKi9cbmNsYXNzIERvY3VtZW50U25hcHNob3QkMSB7XG4gICAgLy8gTm90ZTogVGhpcyBjbGFzcyBpcyBzdHJpcHBlZCBkb3duIHZlcnNpb24gb2YgdGhlIERvY3VtZW50U25hcHNob3QgaW5cbiAgICAvLyB0aGUgbGVnYWN5IFNESy4gVGhlIGNoYW5nZXMgYXJlOlxuICAgIC8vIC0gTm8gc3VwcG9ydCBmb3IgU25hcHNob3RNZXRhZGF0YS5cbiAgICAvLyAtIE5vIHN1cHBvcnQgZm9yIFNuYXBzaG90T3B0aW9ucy5cbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciBwcm90ZWN0ZWQgKi9cbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlLCBfdXNlckRhdGFXcml0ZXIsIF9rZXksIF9kb2N1bWVudCwgX2NvbnZlcnRlcikge1xuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xuICAgICAgICB0aGlzLl91c2VyRGF0YVdyaXRlciA9IF91c2VyRGF0YVdyaXRlcjtcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuX2NvbnZlcnRlciA9IF9jb252ZXJ0ZXI7XG4gICAgfVxuICAgIC8qKiBQcm9wZXJ0eSBvZiB0aGUgYERvY3VtZW50U25hcHNob3RgIHRoYXQgcHJvdmlkZXMgdGhlIGRvY3VtZW50J3MgSUQuICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5LnBhdGgubGFzdFNlZ21lbnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGBEb2N1bWVudFJlZmVyZW5jZWAgZm9yIHRoZSBkb2N1bWVudCBpbmNsdWRlZCBpbiB0aGUgYERvY3VtZW50U25hcHNob3RgLlxuICAgICAqL1xuICAgIGdldCByZWYoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UodGhpcy5fZmlyZXN0b3JlLCB0aGlzLl9jb252ZXJ0ZXIsIHRoaXMuX2tleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25hbHMgd2hldGhlciBvciBub3QgdGhlIGRvY3VtZW50IGF0IHRoZSBzbmFwc2hvdCdzIGxvY2F0aW9uIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGRvY3VtZW50IGV4aXN0cy5cbiAgICAgKi9cbiAgICBleGlzdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb2N1bWVudCAhPT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IGFzIGFuIGBPYmplY3RgLiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmXG4gICAgICogdGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBgT2JqZWN0YCBjb250YWluaW5nIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IG9yIGB1bmRlZmluZWRgXG4gICAgICogaWYgdGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QuXG4gICAgICovXG4gICAgZGF0YSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9jb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB1c2UgdGhlIGNvbnZlcnRlciBhbmQgY3JlYXRlIGEgbmV3IERvY3VtZW50U25hcHNob3RcbiAgICAgICAgICAgIC8vIGlmIGEgY29udmVydGVyIGhhcyBiZWVuIHByb3ZpZGVkLlxuICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBuZXcgUXVlcnlEb2N1bWVudFNuYXBzaG90JDEodGhpcy5fZmlyZXN0b3JlLCB0aGlzLl91c2VyRGF0YVdyaXRlciwgdGhpcy5fa2V5LCB0aGlzLl9kb2N1bWVudCwgXG4gICAgICAgICAgICAvKiBjb252ZXJ0ZXI9ICovIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRlci5mcm9tRmlyZXN0b3JlKHNuYXBzaG90KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91c2VyRGF0YVdyaXRlci5jb252ZXJ0VmFsdWUodGhpcy5fZG9jdW1lbnQuZGF0YS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBmaWVsZCBzcGVjaWZpZWQgYnkgYGZpZWxkUGF0aGAuIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlXG4gICAgICogZG9jdW1lbnQgb3IgZmllbGQgZG9lc24ndCBleGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZFBhdGggLSBUaGUgcGF0aCAoZm9yIGV4YW1wbGUgJ2Zvbycgb3IgJ2Zvby5iYXInKSB0byBhIHNwZWNpZmljXG4gICAgICogZmllbGQuXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgYXQgdGhlIHNwZWNpZmllZCBmaWVsZCBsb2NhdGlvbiBvciB1bmRlZmluZWQgaWYgbm8gc3VjaFxuICAgICAqIGZpZWxkIGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgLy8gV2UgYXJlIHVzaW5nIGBhbnlgIGhlcmUgdG8gYXZvaWQgYW4gZXhwbGljaXQgY2FzdCBieSBvdXIgdXNlcnMuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBnZXQoZmllbGRQYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kb2N1bWVudCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9kb2N1bWVudC5kYXRhLmZpZWxkKGZpZWxkUGF0aEZyb21Bcmd1bWVudCgnRG9jdW1lbnRTbmFwc2hvdC5nZXQnLCBmaWVsZFBhdGgpKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl91c2VyRGF0YVdyaXRlci5jb252ZXJ0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBBIGBRdWVyeURvY3VtZW50U25hcHNob3RgIGNvbnRhaW5zIGRhdGEgcmVhZCBmcm9tIGEgZG9jdW1lbnQgaW4geW91clxuICogRmlyZXN0b3JlIGRhdGFiYXNlIGFzIHBhcnQgb2YgYSBxdWVyeS4gVGhlIGRvY3VtZW50IGlzIGd1YXJhbnRlZWQgdG8gZXhpc3RcbiAqIGFuZCBpdHMgZGF0YSBjYW4gYmUgZXh0cmFjdGVkIHdpdGggYC5kYXRhKClgIG9yIGAuZ2V0KDxmaWVsZD4pYCB0byBnZXQgYVxuICogc3BlY2lmaWMgZmllbGQuXG4gKlxuICogQSBgUXVlcnlEb2N1bWVudFNuYXBzaG90YCBvZmZlcnMgdGhlIHNhbWUgQVBJIHN1cmZhY2UgYXMgYVxuICogYERvY3VtZW50U25hcHNob3RgLiBTaW5jZSBxdWVyeSByZXN1bHRzIGNvbnRhaW4gb25seSBleGlzdGluZyBkb2N1bWVudHMsIHRoZVxuICogYGV4aXN0c2AgcHJvcGVydHkgd2lsbCBhbHdheXMgYmUgdHJ1ZSBhbmQgYGRhdGEoKWAgd2lsbCBuZXZlciByZXR1cm5cbiAqICd1bmRlZmluZWQnLlxuICovXG5jbGFzcyBRdWVyeURvY3VtZW50U25hcHNob3QkMSBleHRlbmRzIERvY3VtZW50U25hcHNob3QkMSB7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IGFzIGFuIGBPYmplY3RgLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHJldHVybnMgQW4gYE9iamVjdGAgY29udGFpbmluZyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZGF0YSgpO1xuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIHRoYXQgY2FsbHMgYGZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcoKWAgYnV0IHdyYXBzIGFueSBlcnJvciB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIGZpZWxkUGF0aEZyb21Bcmd1bWVudChtZXRob2ROYW1lLCBhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcobWV0aG9kTmFtZSwgYXJnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgRmllbGRQYXRoKSB7XG4gICAgICAgIHJldHVybiBhcmcuX2ludGVybmFsUGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhcmcuX2RlbGVnYXRlLl9pbnRlcm5hbFBhdGg7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVIYXNFeHBsaWNpdE9yZGVyQnlGb3JMaW1pdFRvTGFzdChxdWVyeSkge1xuICAgIGlmIChxdWVyeS5saW1pdFR5cGUgPT09IFwiTFwiIC8qIExpbWl0VHlwZS5MYXN0ICovICYmXG4gICAgICAgIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5JTVBMRU1FTlRFRCwgJ2xpbWl0VG9MYXN0KCkgcXVlcmllcyByZXF1aXJlIHNwZWNpZnlpbmcgYXQgbGVhc3Qgb25lIG9yZGVyQnkoKSBjbGF1c2UnKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGBBcHBsaWFibGVDb25zdHJhaW50YCBpcyBhbiBhYnN0cmFjdGlvbiBvZiBhIGNvbnN0cmFpbnQgdGhhdCBjYW4gYmUgYXBwbGllZFxuICogdG8gYSBGaXJlc3RvcmUgcXVlcnkuXG4gKi9cbmNsYXNzIEFwcGxpYWJsZUNvbnN0cmFpbnQge1xufVxuLyoqXG4gKiBBIGBRdWVyeUNvbnN0cmFpbnRgIGlzIHVzZWQgdG8gbmFycm93IHRoZSBzZXQgb2YgZG9jdW1lbnRzIHJldHVybmVkIGJ5IGFcbiAqIEZpcmVzdG9yZSBxdWVyeS4gYFF1ZXJ5Q29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nIHtAbGluayB3aGVyZX0sXG4gKiB7QGxpbmsgb3JkZXJCeX0sIHtAbGluayAoc3RhcnRBdDoxKX0sIHtAbGluayAoc3RhcnRBZnRlcjoxKX0sIHtAbGlua1xuICogKGVuZEJlZm9yZToxKX0sIHtAbGluayAoZW5kQXQ6MSl9LCB7QGxpbmsgbGltaXR9LCB7QGxpbmsgbGltaXRUb0xhc3R9IGFuZFxuICogY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayAocXVlcnk6MSl9IHRvIGNyZWF0ZSBhIG5ldyBxdWVyeSBpbnN0YW5jZSB0aGF0XG4gKiBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5Q29uc3RyYWludGAuXG4gKi9cbmNsYXNzIFF1ZXJ5Q29uc3RyYWludCBleHRlbmRzIEFwcGxpYWJsZUNvbnN0cmFpbnQge1xufVxuZnVuY3Rpb24gcXVlcnkocXVlcnksIHF1ZXJ5Q29uc3RyYWludCwgLi4uYWRkaXRpb25hbFF1ZXJ5Q29uc3RyYWludHMpIHtcbiAgICBsZXQgcXVlcnlDb25zdHJhaW50cyA9IFtdO1xuICAgIGlmIChxdWVyeUNvbnN0cmFpbnQgaW5zdGFuY2VvZiBBcHBsaWFibGVDb25zdHJhaW50KSB7XG4gICAgICAgIHF1ZXJ5Q29uc3RyYWludHMucHVzaChxdWVyeUNvbnN0cmFpbnQpO1xuICAgIH1cbiAgICBxdWVyeUNvbnN0cmFpbnRzID0gcXVlcnlDb25zdHJhaW50cy5jb25jYXQoYWRkaXRpb25hbFF1ZXJ5Q29uc3RyYWludHMpO1xuICAgIHZhbGlkYXRlUXVlcnlDb25zdHJhaW50QXJyYXkocXVlcnlDb25zdHJhaW50cyk7XG4gICAgZm9yIChjb25zdCBjb25zdHJhaW50IG9mIHF1ZXJ5Q29uc3RyYWludHMpIHtcbiAgICAgICAgcXVlcnkgPSBjb25zdHJhaW50Ll9hcHBseShxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbn1cbi8qKlxuICogQSBgUXVlcnlGaWVsZEZpbHRlckNvbnN0cmFpbnRgIGlzIHVzZWQgdG8gbmFycm93IHRoZSBzZXQgb2YgZG9jdW1lbnRzIHJldHVybmVkIGJ5XG4gKiBhIEZpcmVzdG9yZSBxdWVyeSBieSBmaWx0ZXJpbmcgb24gb25lIG9yIG1vcmUgZG9jdW1lbnQgZmllbGRzLlxuICogYFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIHdoZXJlfSBhbmQgY2FuIHRoZW5cbiAqIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYSBuZXcgcXVlcnkgaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zXG4gKiB0aGlzIGBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludGAuXG4gKi9cbmNsYXNzIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfZmllbGQsIF9vcCwgX3ZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2ZpZWxkID0gX2ZpZWxkO1xuICAgICAgICB0aGlzLl9vcCA9IF9vcDtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cbiAgICAgICAgdGhpcy50eXBlID0gJ3doZXJlJztcbiAgICB9XG4gICAgc3RhdGljIF9jcmVhdGUoX2ZpZWxkLCBfb3AsIF92YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50KF9maWVsZCwgX29wLCBfdmFsdWUpO1xuICAgIH1cbiAgICBfYXBwbHkocXVlcnkpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyID0gdGhpcy5fcGFyc2UocXVlcnkpO1xuICAgICAgICB2YWxpZGF0ZU5ld0ZpZWxkRmlsdGVyKHF1ZXJ5Ll9xdWVyeSwgZmlsdGVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShxdWVyeS5maXJlc3RvcmUsIHF1ZXJ5LmNvbnZlcnRlciwgcXVlcnlXaXRoQWRkZWRGaWx0ZXIocXVlcnkuX3F1ZXJ5LCBmaWx0ZXIpKTtcbiAgICB9XG4gICAgX3BhcnNlKHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKHF1ZXJ5LmZpcmVzdG9yZSk7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IG5ld1F1ZXJ5RmlsdGVyKHF1ZXJ5Ll9xdWVyeSwgJ3doZXJlJywgcmVhZGVyLCBxdWVyeS5maXJlc3RvcmUuX2RhdGFiYXNlSWQsIHRoaXMuX2ZpZWxkLCB0aGlzLl9vcCwgdGhpcy5fdmFsdWUpO1xuICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludH0gdGhhdCBlbmZvcmNlcyB0aGF0IGRvY3VtZW50c1xuICogbXVzdCBjb250YWluIHRoZSBzcGVjaWZpZWQgZmllbGQgYW5kIHRoYXQgdGhlIHZhbHVlIHNob3VsZCBzYXRpc2Z5IHRoZVxuICogcmVsYXRpb24gY29uc3RyYWludCBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0gZmllbGRQYXRoIC0gVGhlIHBhdGggdG8gY29tcGFyZVxuICogQHBhcmFtIG9wU3RyIC0gVGhlIG9wZXJhdGlvbiBzdHJpbmcgKGUuZyBcIiZsdDtcIiwgXCImbHQ7PVwiLCBcIj09XCIsIFwiJmx0O1wiLFxuICogICBcIiZsdDs9XCIsIFwiIT1cIikuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgZm9yIGNvbXBhcmlzb25cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHtAbGluayBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludH0uXG4gKi9cbmZ1bmN0aW9uIHdoZXJlKGZpZWxkUGF0aCwgb3BTdHIsIHZhbHVlKSB7XG4gICAgY29uc3Qgb3AgPSBvcFN0cjtcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkUGF0aEZyb21Bcmd1bWVudCgnd2hlcmUnLCBmaWVsZFBhdGgpO1xuICAgIHJldHVybiBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludC5fY3JlYXRlKGZpZWxkLCBvcCwgdmFsdWUpO1xufVxuLyoqXG4gKiBBIGBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnRgIGlzIHVzZWQgdG8gbmFycm93IHRoZSBzZXQgb2YgZG9jdW1lbnRzXG4gKiByZXR1cm5lZCBieSBhIEZpcmVzdG9yZSBxdWVyeSBieSBwZXJmb3JtaW5nIHRoZSBsb2dpY2FsIE9SIG9yIEFORCBvZiBtdWx0aXBsZVxuICoge0BsaW5rIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50fXMgb3Ige0BsaW5rIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludH1zLlxuICogYFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nIHtAbGluayBvcn0gb3JcbiAqIHtAbGluayBhbmR9IGFuZCBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGEgbmV3IHF1ZXJ5XG4gKiBpbnN0YW5jZSB0aGF0IGFsc28gY29udGFpbnMgdGhlIGBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnRgLlxuICovXG5jbGFzcyBRdWVyeUNvbXBvc2l0ZUZpbHRlckNvbnN0cmFpbnQgZXh0ZW5kcyBBcHBsaWFibGVDb25zdHJhaW50IHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBxdWVyeSBjb25zdHJhaW50ICovXG4gICAgdHlwZSwgX3F1ZXJ5Q29uc3RyYWludHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5fcXVlcnlDb25zdHJhaW50cyA9IF9xdWVyeUNvbnN0cmFpbnRzO1xuICAgIH1cbiAgICBzdGF0aWMgX2NyZWF0ZSh0eXBlLCBfcXVlcnlDb25zdHJhaW50cykge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCh0eXBlLCBfcXVlcnlDb25zdHJhaW50cyk7XG4gICAgfVxuICAgIF9wYXJzZShxdWVyeSkge1xuICAgICAgICBjb25zdCBwYXJzZWRGaWx0ZXJzID0gdGhpcy5fcXVlcnlDb25zdHJhaW50c1xuICAgICAgICAgICAgLm1hcChxdWVyeUNvbnN0cmFpbnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5Q29uc3RyYWludC5fcGFyc2UocXVlcnkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihwYXJzZWRGaWx0ZXIgPT4gcGFyc2VkRmlsdGVyLmdldEZpbHRlcnMoKS5sZW5ndGggPiAwKTtcbiAgICAgICAgaWYgKHBhcnNlZEZpbHRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkRmlsdGVyc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29tcG9zaXRlRmlsdGVyLmNyZWF0ZShwYXJzZWRGaWx0ZXJzLCB0aGlzLl9nZXRPcGVyYXRvcigpKTtcbiAgICB9XG4gICAgX2FwcGx5KHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEZpbHRlciA9IHRoaXMuX3BhcnNlKHF1ZXJ5KTtcbiAgICAgICAgaWYgKHBhcnNlZEZpbHRlci5nZXRGaWx0ZXJzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGV4aXN0aW5nIHF1ZXJ5IGlmIG5vdCBhZGRpbmcgYW55IG1vcmUgZmlsdGVycyAoZS5nLiBhbiBlbXB0eVxuICAgICAgICAgICAgLy8gY29tcG9zaXRlIGZpbHRlcikuXG4gICAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVOZXdGaWx0ZXIocXVlcnkuX3F1ZXJ5LCBwYXJzZWRGaWx0ZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhBZGRlZEZpbHRlcihxdWVyeS5fcXVlcnksIHBhcnNlZEZpbHRlcikpO1xuICAgIH1cbiAgICBfZ2V0UXVlcnlDb25zdHJhaW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5Q29uc3RyYWludHM7XG4gICAgfVxuICAgIF9nZXRPcGVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2FuZCcgPyBcImFuZFwiIC8qIENvbXBvc2l0ZU9wZXJhdG9yLkFORCAqLyA6IFwib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqLztcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludH0gdGhhdCBpcyBhIGRpc2p1bmN0aW9uIG9mXG4gKiB0aGUgZ2l2ZW4gZmlsdGVyIGNvbnN0cmFpbnRzLiBBIGRpc2p1bmN0aW9uIGZpbHRlciBpbmNsdWRlcyBhIGRvY3VtZW50IGlmIGl0XG4gKiBzYXRpc2ZpZXMgYW55IG9mIHRoZSBnaXZlbiBmaWx0ZXJzLlxuICpcbiAqIEBwYXJhbSBxdWVyeUNvbnN0cmFpbnRzIC0gT3B0aW9uYWwuIFRoZSBsaXN0IG9mXG4gKiB7QGxpbmsgUXVlcnlGaWx0ZXJDb25zdHJhaW50fXMgdG8gcGVyZm9ybSBhIGRpc2p1bmN0aW9uIGZvci4gVGhlc2UgbXVzdCBiZVxuICogY3JlYXRlZCB3aXRoIGNhbGxzIHRvIHtAbGluayB3aGVyZX0sIHtAbGluayBvcn0sIG9yIHtAbGluayBhbmR9LlxuICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQge0BsaW5rIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludH0uXG4gKi9cbmZ1bmN0aW9uIG9yKC4uLnF1ZXJ5Q29uc3RyYWludHMpIHtcbiAgICAvLyBPbmx5IHN1cHBvcnQgUXVlcnlGaWx0ZXJDb25zdHJhaW50c1xuICAgIHF1ZXJ5Q29uc3RyYWludHMuZm9yRWFjaChxdWVyeUNvbnN0cmFpbnQgPT4gdmFsaWRhdGVRdWVyeUZpbHRlckNvbnN0cmFpbnQoJ29yJywgcXVlcnlDb25zdHJhaW50KSk7XG4gICAgcmV0dXJuIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludC5fY3JlYXRlKFwib3JcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5PUiAqLywgcXVlcnlDb25zdHJhaW50cyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludH0gdGhhdCBpcyBhIGNvbmp1bmN0aW9uIG9mXG4gKiB0aGUgZ2l2ZW4gZmlsdGVyIGNvbnN0cmFpbnRzLiBBIGNvbmp1bmN0aW9uIGZpbHRlciBpbmNsdWRlcyBhIGRvY3VtZW50IGlmIGl0XG4gKiBzYXRpc2ZpZXMgYWxsIG9mIHRoZSBnaXZlbiBmaWx0ZXJzLlxuICpcbiAqIEBwYXJhbSBxdWVyeUNvbnN0cmFpbnRzIC0gT3B0aW9uYWwuIFRoZSBsaXN0IG9mXG4gKiB7QGxpbmsgUXVlcnlGaWx0ZXJDb25zdHJhaW50fXMgdG8gcGVyZm9ybSBhIGNvbmp1bmN0aW9uIGZvci4gVGhlc2UgbXVzdCBiZVxuICogY3JlYXRlZCB3aXRoIGNhbGxzIHRvIHtAbGluayB3aGVyZX0sIHtAbGluayBvcn0sIG9yIHtAbGluayBhbmR9LlxuICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQge0BsaW5rIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludH0uXG4gKi9cbmZ1bmN0aW9uIGFuZCguLi5xdWVyeUNvbnN0cmFpbnRzKSB7XG4gICAgLy8gT25seSBzdXBwb3J0IFF1ZXJ5RmlsdGVyQ29uc3RyYWludHNcbiAgICBxdWVyeUNvbnN0cmFpbnRzLmZvckVhY2gocXVlcnlDb25zdHJhaW50ID0+IHZhbGlkYXRlUXVlcnlGaWx0ZXJDb25zdHJhaW50KCdhbmQnLCBxdWVyeUNvbnN0cmFpbnQpKTtcbiAgICByZXR1cm4gUXVlcnlDb21wb3NpdGVGaWx0ZXJDb25zdHJhaW50Ll9jcmVhdGUoXCJhbmRcIiAvKiBDb21wb3NpdGVPcGVyYXRvci5BTkQgKi8sIHF1ZXJ5Q29uc3RyYWludHMpO1xufVxuLyoqXG4gKiBBIGBRdWVyeU9yZGVyQnlDb25zdHJhaW50YCBpcyB1c2VkIHRvIHNvcnQgdGhlIHNldCBvZiBkb2N1bWVudHMgcmV0dXJuZWQgYnkgYVxuICogRmlyZXN0b3JlIHF1ZXJ5LiBgUXVlcnlPcmRlckJ5Q29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nXG4gKiB7QGxpbmsgb3JkZXJCeX0gYW5kIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYSBuZXcgcXVlcnlcbiAqIGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeU9yZGVyQnlDb25zdHJhaW50YC5cbiAqXG4gKiBOb3RlOiBEb2N1bWVudHMgdGhhdCBkbyBub3QgY29udGFpbiB0aGUgb3JkZXJCeSBmaWVsZCB3aWxsIG5vdCBiZSBwcmVzZW50IGluXG4gKiB0aGUgcXVlcnkgcmVzdWx0LlxuICovXG5jbGFzcyBRdWVyeU9yZGVyQnlDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfZmllbGQsIF9kaXJlY3Rpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZmllbGQgPSBfZmllbGQ7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IF9kaXJlY3Rpb247XG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHF1ZXJ5IGNvbnN0cmFpbnQgKi9cbiAgICAgICAgdGhpcy50eXBlID0gJ29yZGVyQnknO1xuICAgIH1cbiAgICBzdGF0aWMgX2NyZWF0ZShfZmllbGQsIF9kaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeU9yZGVyQnlDb25zdHJhaW50KF9maWVsZCwgX2RpcmVjdGlvbik7XG4gICAgfVxuICAgIF9hcHBseShxdWVyeSkge1xuICAgICAgICBjb25zdCBvcmRlckJ5ID0gbmV3UXVlcnlPcmRlckJ5KHF1ZXJ5Ll9xdWVyeSwgdGhpcy5fZmllbGQsIHRoaXMuX2RpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkocXVlcnkuZmlyZXN0b3JlLCBxdWVyeS5jb252ZXJ0ZXIsIHF1ZXJ5V2l0aEFkZGVkT3JkZXJCeShxdWVyeS5fcXVlcnksIG9yZGVyQnkpKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUXVlcnlPcmRlckJ5Q29uc3RyYWludH0gdGhhdCBzb3J0cyB0aGUgcXVlcnkgcmVzdWx0IGJ5IHRoZVxuICogc3BlY2lmaWVkIGZpZWxkLCBvcHRpb25hbGx5IGluIGRlc2NlbmRpbmcgb3JkZXIgaW5zdGVhZCBvZiBhc2NlbmRpbmcuXG4gKlxuICogTm90ZTogRG9jdW1lbnRzIHRoYXQgZG8gbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCBmaWVsZCB3aWxsIG5vdCBiZSBwcmVzZW50XG4gKiBpbiB0aGUgcXVlcnkgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSBmaWVsZFBhdGggLSBUaGUgZmllbGQgdG8gc29ydCBieS5cbiAqIEBwYXJhbSBkaXJlY3Rpb25TdHIgLSBPcHRpb25hbCBkaXJlY3Rpb24gdG8gc29ydCBieSAoJ2FzYycgb3IgJ2Rlc2MnKS4gSWZcbiAqIG5vdCBzcGVjaWZpZWQsIG9yZGVyIHdpbGwgYmUgYXNjZW5kaW5nLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQge0BsaW5rIFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnR9LlxuICovXG5mdW5jdGlvbiBvcmRlckJ5KGZpZWxkUGF0aCwgZGlyZWN0aW9uU3RyID0gJ2FzYycpIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHI7XG4gICAgY29uc3QgcGF0aCA9IGZpZWxkUGF0aEZyb21Bcmd1bWVudCgnb3JkZXJCeScsIGZpZWxkUGF0aCk7XG4gICAgcmV0dXJuIFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnQuX2NyZWF0ZShwYXRoLCBkaXJlY3Rpb24pO1xufVxuLyoqXG4gKiBBIGBRdWVyeUxpbWl0Q29uc3RyYWludGAgaXMgdXNlZCB0byBsaW1pdCB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyByZXR1cm5lZCBieVxuICogYSBGaXJlc3RvcmUgcXVlcnkuXG4gKiBgUXVlcnlMaW1pdENvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgbGltaXR9IG9yXG4gKiB7QGxpbmsgbGltaXRUb0xhc3R9IGFuZCBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIChxdWVyeToxKX0gdG8gY3JlYXRlIGEgbmV3XG4gKiBxdWVyeSBpbnN0YW5jZSB0aGF0IGFsc28gY29udGFpbnMgdGhpcyBgUXVlcnlMaW1pdENvbnN0cmFpbnRgLlxuICovXG5jbGFzcyBRdWVyeUxpbWl0Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgcXVlcnkgY29uc3RyYWludCAqL1xuICAgIHR5cGUsIF9saW1pdCwgX2xpbWl0VHlwZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9saW1pdCA9IF9saW1pdDtcbiAgICAgICAgdGhpcy5fbGltaXRUeXBlID0gX2xpbWl0VHlwZTtcbiAgICB9XG4gICAgc3RhdGljIF9jcmVhdGUodHlwZSwgX2xpbWl0LCBfbGltaXRUeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlMaW1pdENvbnN0cmFpbnQodHlwZSwgX2xpbWl0LCBfbGltaXRUeXBlKTtcbiAgICB9XG4gICAgX2FwcGx5KHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkocXVlcnkuZmlyZXN0b3JlLCBxdWVyeS5jb252ZXJ0ZXIsIHF1ZXJ5V2l0aExpbWl0KHF1ZXJ5Ll9xdWVyeSwgdGhpcy5fbGltaXQsIHRoaXMuX2xpbWl0VHlwZSkpO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBRdWVyeUxpbWl0Q29uc3RyYWludH0gdGhhdCBvbmx5IHJldHVybnMgdGhlIGZpcnN0IG1hdGNoaW5nXG4gKiBkb2N1bWVudHMuXG4gKlxuICogQHBhcmFtIGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIHJldHVybi5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHtAbGluayBRdWVyeUxpbWl0Q29uc3RyYWludH0uXG4gKi9cbmZ1bmN0aW9uIGxpbWl0KGxpbWl0KSB7XG4gICAgdmFsaWRhdGVQb3NpdGl2ZU51bWJlcignbGltaXQnLCBsaW1pdCk7XG4gICAgcmV0dXJuIFF1ZXJ5TGltaXRDb25zdHJhaW50Ll9jcmVhdGUoJ2xpbWl0JywgbGltaXQsIFwiRlwiIC8qIExpbWl0VHlwZS5GaXJzdCAqLyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUXVlcnlMaW1pdENvbnN0cmFpbnR9IHRoYXQgb25seSByZXR1cm5zIHRoZSBsYXN0IG1hdGNoaW5nXG4gKiBkb2N1bWVudHMuXG4gKlxuICogWW91IG11c3Qgc3BlY2lmeSBhdCBsZWFzdCBvbmUgYG9yZGVyQnlgIGNsYXVzZSBmb3IgYGxpbWl0VG9MYXN0YCBxdWVyaWVzLFxuICogb3RoZXJ3aXNlIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biBkdXJpbmcgZXhlY3V0aW9uLlxuICpcbiAqIEBwYXJhbSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCB7QGxpbmsgUXVlcnlMaW1pdENvbnN0cmFpbnR9LlxuICovXG5mdW5jdGlvbiBsaW1pdFRvTGFzdChsaW1pdCkge1xuICAgIHZhbGlkYXRlUG9zaXRpdmVOdW1iZXIoJ2xpbWl0VG9MYXN0JywgbGltaXQpO1xuICAgIHJldHVybiBRdWVyeUxpbWl0Q29uc3RyYWludC5fY3JlYXRlKCdsaW1pdFRvTGFzdCcsIGxpbWl0LCBcIkxcIiAvKiBMaW1pdFR5cGUuTGFzdCAqLyk7XG59XG4vKipcbiAqIEEgYFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnRgIGlzIHVzZWQgdG8gZXhjbHVkZSBkb2N1bWVudHMgZnJvbSB0aGUgc3RhcnQgb2YgYVxuICogcmVzdWx0IHNldCByZXR1cm5lZCBieSBhIEZpcmVzdG9yZSBxdWVyeS5cbiAqIGBRdWVyeVN0YXJ0QXRDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIChzdGFydEF0OjEpfSBvclxuICoge0BsaW5rIChzdGFydEFmdGVyOjEpfSBhbmQgY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayAocXVlcnk6MSl9IHRvIGNyZWF0ZSBhXG4gKiBuZXcgcXVlcnkgaW5zdGFuY2UgdGhhdCBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnRgLlxuICovXG5jbGFzcyBRdWVyeVN0YXJ0QXRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBxdWVyeSBjb25zdHJhaW50ICovXG4gICAgdHlwZSwgX2RvY09yRmllbGRzLCBfaW5jbHVzaXZlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX2RvY09yRmllbGRzID0gX2RvY09yRmllbGRzO1xuICAgICAgICB0aGlzLl9pbmNsdXNpdmUgPSBfaW5jbHVzaXZlO1xuICAgIH1cbiAgICBzdGF0aWMgX2NyZWF0ZSh0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeVN0YXJ0QXRDb25zdHJhaW50KHR5cGUsIF9kb2NPckZpZWxkcywgX2luY2x1c2l2ZSk7XG4gICAgfVxuICAgIF9hcHBseShxdWVyeSkge1xuICAgICAgICBjb25zdCBib3VuZCA9IG5ld1F1ZXJ5Qm91bmRGcm9tRG9jT3JGaWVsZHMocXVlcnksIHRoaXMudHlwZSwgdGhpcy5fZG9jT3JGaWVsZHMsIHRoaXMuX2luY2x1c2l2ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkocXVlcnkuZmlyZXN0b3JlLCBxdWVyeS5jb252ZXJ0ZXIsIHF1ZXJ5V2l0aFN0YXJ0QXQocXVlcnkuX3F1ZXJ5LCBib3VuZCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0YXJ0QXQoLi4uZG9jT3JGaWVsZHMpIHtcbiAgICByZXR1cm4gUXVlcnlTdGFydEF0Q29uc3RyYWludC5fY3JlYXRlKCdzdGFydEF0JywgZG9jT3JGaWVsZHMsIFxuICAgIC8qaW5jbHVzaXZlPSovIHRydWUpO1xufVxuZnVuY3Rpb24gc3RhcnRBZnRlciguLi5kb2NPckZpZWxkcykge1xuICAgIHJldHVybiBRdWVyeVN0YXJ0QXRDb25zdHJhaW50Ll9jcmVhdGUoJ3N0YXJ0QWZ0ZXInLCBkb2NPckZpZWxkcywgXG4gICAgLyppbmNsdXNpdmU9Ki8gZmFsc2UpO1xufVxuLyoqXG4gKiBBIGBRdWVyeUVuZEF0Q29uc3RyYWludGAgaXMgdXNlZCB0byBleGNsdWRlIGRvY3VtZW50cyBmcm9tIHRoZSBlbmQgb2YgYVxuICogcmVzdWx0IHNldCByZXR1cm5lZCBieSBhIEZpcmVzdG9yZSBxdWVyeS5cbiAqIGBRdWVyeUVuZEF0Q29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nIHtAbGluayAoZW5kQXQ6MSl9IG9yXG4gKiB7QGxpbmsgKGVuZEJlZm9yZToxKX0gYW5kIGNhbiB0aGVuIGJlIHBhc3NlZCB0byB7QGxpbmsgKHF1ZXJ5OjEpfSB0byBjcmVhdGUgYSBuZXdcbiAqIHF1ZXJ5IGluc3RhbmNlIHRoYXQgYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeUVuZEF0Q29uc3RyYWludGAuXG4gKi9cbmNsYXNzIFF1ZXJ5RW5kQXRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBxdWVyeSBjb25zdHJhaW50ICovXG4gICAgdHlwZSwgX2RvY09yRmllbGRzLCBfaW5jbHVzaXZlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX2RvY09yRmllbGRzID0gX2RvY09yRmllbGRzO1xuICAgICAgICB0aGlzLl9pbmNsdXNpdmUgPSBfaW5jbHVzaXZlO1xuICAgIH1cbiAgICBzdGF0aWMgX2NyZWF0ZSh0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUVuZEF0Q29uc3RyYWludCh0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpO1xuICAgIH1cbiAgICBfYXBwbHkocXVlcnkpIHtcbiAgICAgICAgY29uc3QgYm91bmQgPSBuZXdRdWVyeUJvdW5kRnJvbURvY09yRmllbGRzKHF1ZXJ5LCB0aGlzLnR5cGUsIHRoaXMuX2RvY09yRmllbGRzLCB0aGlzLl9pbmNsdXNpdmUpO1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhFbmRBdChxdWVyeS5fcXVlcnksIGJvdW5kKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZW5kQmVmb3JlKC4uLmRvY09yRmllbGRzKSB7XG4gICAgcmV0dXJuIFF1ZXJ5RW5kQXRDb25zdHJhaW50Ll9jcmVhdGUoJ2VuZEJlZm9yZScsIGRvY09yRmllbGRzLCBcbiAgICAvKmluY2x1c2l2ZT0qLyBmYWxzZSk7XG59XG5mdW5jdGlvbiBlbmRBdCguLi5kb2NPckZpZWxkcykge1xuICAgIHJldHVybiBRdWVyeUVuZEF0Q29uc3RyYWludC5fY3JlYXRlKCdlbmRBdCcsIGRvY09yRmllbGRzLCBcbiAgICAvKmluY2x1c2l2ZT0qLyB0cnVlKTtcbn1cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgYm91bmQgZnJvbSBhIGRvY3VtZW50IG9yIGZpZWxkcyAqL1xuZnVuY3Rpb24gbmV3UXVlcnlCb3VuZEZyb21Eb2NPckZpZWxkcyhxdWVyeSwgbWV0aG9kTmFtZSwgZG9jT3JGaWVsZHMsIGluY2x1c2l2ZSkge1xuICAgIGRvY09yRmllbGRzWzBdID0gZ2V0TW9kdWxhckluc3RhbmNlKGRvY09yRmllbGRzWzBdKTtcbiAgICBpZiAoZG9jT3JGaWVsZHNbMF0gaW5zdGFuY2VvZiBEb2N1bWVudFNuYXBzaG90JDEpIHtcbiAgICAgICAgcmV0dXJuIG5ld1F1ZXJ5Qm91bmRGcm9tRG9jdW1lbnQocXVlcnkuX3F1ZXJ5LCBxdWVyeS5maXJlc3RvcmUuX2RhdGFiYXNlSWQsIG1ldGhvZE5hbWUsIGRvY09yRmllbGRzWzBdLl9kb2N1bWVudCwgaW5jbHVzaXZlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKHF1ZXJ5LmZpcmVzdG9yZSk7XG4gICAgICAgIHJldHVybiBuZXdRdWVyeUJvdW5kRnJvbUZpZWxkcyhxdWVyeS5fcXVlcnksIHF1ZXJ5LmZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgcmVhZGVyLCBtZXRob2ROYW1lLCBkb2NPckZpZWxkcywgaW5jbHVzaXZlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdRdWVyeUZpbHRlcihxdWVyeSwgbWV0aG9kTmFtZSwgZGF0YVJlYWRlciwgZGF0YWJhc2VJZCwgZmllbGRQYXRoLCBvcCwgdmFsdWUpIHtcbiAgICBsZXQgZmllbGRWYWx1ZTtcbiAgICBpZiAoZmllbGRQYXRoLmlzS2V5RmllbGQoKSkge1xuICAgICAgICBpZiAob3AgPT09IFwiYXJyYXktY29udGFpbnNcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOUyAqLyB8fCBvcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBPcGVyYXRvci5BUlJBWV9DT05UQUlOU19BTlkgKi8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIFF1ZXJ5LiBZb3UgY2FuJ3QgcGVyZm9ybSAnJHtvcH0nIHF1ZXJpZXMgb24gZG9jdW1lbnRJZCgpLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wID09PSBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8gfHwgb3AgPT09IFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZURpc2p1bmN0aXZlRmlsdGVyRWxlbWVudHModmFsdWUsIG9wKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZUxpc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXJyYXlWYWx1ZSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUxpc3QucHVzaChwYXJzZURvY3VtZW50SWRWYWx1ZShkYXRhYmFzZUlkLCBxdWVyeSwgYXJyYXlWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHsgYXJyYXlWYWx1ZTogeyB2YWx1ZXM6IHJlZmVyZW5jZUxpc3QgfSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHBhcnNlRG9jdW1lbnRJZFZhbHVlKGRhdGFiYXNlSWQsIHF1ZXJ5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovIHx8XG4gICAgICAgICAgICBvcCA9PT0gXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8gfHxcbiAgICAgICAgICAgIG9wID09PSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLykge1xuICAgICAgICAgICAgdmFsaWRhdGVEaXNqdW5jdGl2ZUZpbHRlckVsZW1lbnRzKHZhbHVlLCBvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRWYWx1ZSA9IHBhcnNlUXVlcnlWYWx1ZShkYXRhUmVhZGVyLCBtZXRob2ROYW1lLCB2YWx1ZSwgXG4gICAgICAgIC8qIGFsbG93QXJyYXlzPSAqLyBvcCA9PT0gXCJpblwiIC8qIE9wZXJhdG9yLklOICovIHx8IG9wID09PSBcIm5vdC1pblwiIC8qIE9wZXJhdG9yLk5PVF9JTiAqLyk7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlciA9IEZpZWxkRmlsdGVyLmNyZWF0ZShmaWVsZFBhdGgsIG9wLCBmaWVsZFZhbHVlKTtcbiAgICByZXR1cm4gZmlsdGVyO1xufVxuZnVuY3Rpb24gbmV3UXVlcnlPcmRlckJ5KHF1ZXJ5LCBmaWVsZFBhdGgsIGRpcmVjdGlvbikge1xuICAgIGlmIChxdWVyeS5zdGFydEF0ICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIHF1ZXJ5LiBZb3UgbXVzdCBub3QgY2FsbCBzdGFydEF0KCkgb3Igc3RhcnRBZnRlcigpIGJlZm9yZSAnICtcbiAgICAgICAgICAgICdjYWxsaW5nIG9yZGVyQnkoKS4nKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmVuZEF0ICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIHF1ZXJ5LiBZb3UgbXVzdCBub3QgY2FsbCBlbmRBdCgpIG9yIGVuZEJlZm9yZSgpIGJlZm9yZSAnICtcbiAgICAgICAgICAgICdjYWxsaW5nIG9yZGVyQnkoKS4nKTtcbiAgICB9XG4gICAgY29uc3Qgb3JkZXJCeSA9IG5ldyBPcmRlckJ5KGZpZWxkUGF0aCwgZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gb3JkZXJCeTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgYEJvdW5kYCBmcm9tIGEgcXVlcnkgYW5kIGEgZG9jdW1lbnQuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBgQm91bmRgIHdpbGwgYWx3YXlzIGluY2x1ZGUgdGhlIGtleSBvZiB0aGUgZG9jdW1lbnRcbiAqIGFuZCBzbyBvbmx5IHRoZSBwcm92aWRlZCBkb2N1bWVudCB3aWxsIGNvbXBhcmUgZXF1YWwgdG8gdGhlIHJldHVybmVkXG4gKiBwb3NpdGlvbi5cbiAqXG4gKiBXaWxsIHRocm93IGlmIHRoZSBkb2N1bWVudCBkb2VzIG5vdCBjb250YWluIGFsbCBmaWVsZHMgb2YgdGhlIG9yZGVyIGJ5XG4gKiBvZiB0aGUgcXVlcnkgb3IgaWYgYW55IG9mIHRoZSBmaWVsZHMgaW4gdGhlIG9yZGVyIGJ5IGFyZSBhbiB1bmNvbW1pdHRlZFxuICogc2VydmVyIHRpbWVzdGFtcC5cbiAqL1xuZnVuY3Rpb24gbmV3UXVlcnlCb3VuZEZyb21Eb2N1bWVudChxdWVyeSwgZGF0YWJhc2VJZCwgbWV0aG9kTmFtZSwgZG9jLCBpbmNsdXNpdmUpIHtcbiAgICBpZiAoIWRvYykge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5OT1RfRk9VTkQsIGBDYW4ndCB1c2UgYSBEb2N1bWVudFNuYXBzaG90IHRoYXQgZG9lc24ndCBleGlzdCBmb3IgYCArXG4gICAgICAgICAgICBgJHttZXRob2ROYW1lfSgpLmApO1xuICAgIH1cbiAgICBjb25zdCBjb21wb25lbnRzID0gW107XG4gICAgLy8gQmVjYXVzZSBwZW9wbGUgZXhwZWN0IHRvIGNvbnRpbnVlL2VuZCBhIHF1ZXJ5IGF0IHRoZSBleGFjdCBkb2N1bWVudFxuICAgIC8vIHByb3ZpZGVkLCB3ZSBuZWVkIHRvIHVzZSB0aGUgaW1wbGljaXQgc29ydCBvcmRlciByYXRoZXIgdGhhbiB0aGUgZXhwbGljaXRcbiAgICAvLyBzb3J0IG9yZGVyLCBiZWNhdXNlIGl0J3MgZ3VhcmFudGVlZCB0byBjb250YWluIHRoZSBkb2N1bWVudCBrZXkuIFRoYXQgd2F5XG4gICAgLy8gdGhlIHBvc2l0aW9uIGJlY29tZXMgdW5hbWJpZ3VvdXMgYW5kIHRoZSBxdWVyeSBjb250aW51ZXMvZW5kcyBleGFjdGx5IGF0XG4gICAgLy8gdGhlIHByb3ZpZGVkIGRvY3VtZW50LiBXaXRob3V0IHRoZSBrZXkgKGJ5IHVzaW5nIHRoZSBleHBsaWNpdCBzb3J0XG4gICAgLy8gb3JkZXJzKSwgbXVsdGlwbGUgZG9jdW1lbnRzIGNvdWxkIG1hdGNoIHRoZSBwb3NpdGlvbiwgeWllbGRpbmcgZHVwbGljYXRlXG4gICAgLy8gcmVzdWx0cy5cbiAgICBmb3IgKGNvbnN0IG9yZGVyQnkgb2YgcXVlcnlOb3JtYWxpemVkT3JkZXJCeShxdWVyeSkpIHtcbiAgICAgICAgaWYgKG9yZGVyQnkuZmllbGQuaXNLZXlGaWVsZCgpKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnB1c2gocmVmVmFsdWUoZGF0YWJhc2VJZCwgZG9jLmtleSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkb2MuZGF0YS5maWVsZChvcmRlckJ5LmZpZWxkKTtcbiAgICAgICAgICAgIGlmIChpc1NlcnZlclRpbWVzdGFtcCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBxdWVyeS4gWW91IGFyZSB0cnlpbmcgdG8gc3RhcnQgb3IgZW5kIGEgcXVlcnkgdXNpbmcgYSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2RvY3VtZW50IGZvciB3aGljaCB0aGUgZmllbGQgXCInICtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJCeS5maWVsZCArXG4gICAgICAgICAgICAgICAgICAgICdcIiBpcyBhbiB1bmNvbW1pdHRlZCBzZXJ2ZXIgdGltZXN0YW1wLiAoU2luY2UgdGhlIHZhbHVlIG9mICcgK1xuICAgICAgICAgICAgICAgICAgICAndGhpcyBmaWVsZCBpcyB1bmtub3duLCB5b3UgY2Fubm90IHN0YXJ0L2VuZCBhIHF1ZXJ5IHdpdGggaXQuKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBvcmRlckJ5LmZpZWxkLmNhbm9uaWNhbFN0cmluZygpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBZb3UgYXJlIHRyeWluZyB0byBzdGFydCBvciBlbmQgYSBxdWVyeSB1c2luZyBhIGAgK1xuICAgICAgICAgICAgICAgICAgICBgZG9jdW1lbnQgZm9yIHdoaWNoIHRoZSBmaWVsZCAnJHtmaWVsZH0nICh1c2VkIGFzIHRoZSBgICtcbiAgICAgICAgICAgICAgICAgICAgYG9yZGVyQnkpIGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQm91bmQoY29tcG9uZW50cywgaW5jbHVzaXZlKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBsaXN0IG9mIGZpZWxkIHZhbHVlcyB0byBhIGBCb3VuZGAgZm9yIHRoZSBnaXZlbiBxdWVyeS5cbiAqL1xuZnVuY3Rpb24gbmV3UXVlcnlCb3VuZEZyb21GaWVsZHMocXVlcnksIGRhdGFiYXNlSWQsIGRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIHZhbHVlcywgaW5jbHVzaXZlKSB7XG4gICAgLy8gVXNlIGV4cGxpY2l0IG9yZGVyIGJ5J3MgYmVjYXVzZSBpdCBoYXMgdG8gbWF0Y2ggdGhlIHF1ZXJ5IHRoZSB1c2VyIG1hZGVcbiAgICBjb25zdCBvcmRlckJ5ID0gcXVlcnkuZXhwbGljaXRPcmRlckJ5O1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gb3JkZXJCeS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYFRvbyBtYW55IGFyZ3VtZW50cyBwcm92aWRlZCB0byAke21ldGhvZE5hbWV9KCkuIGAgK1xuICAgICAgICAgICAgYFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBgICtcbiAgICAgICAgICAgIGBudW1iZXIgb2Ygb3JkZXJCeSgpIGNsYXVzZXNgKTtcbiAgICB9XG4gICAgY29uc3QgY29tcG9uZW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJhd1ZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICBjb25zdCBvcmRlckJ5Q29tcG9uZW50ID0gb3JkZXJCeVtpXTtcbiAgICAgICAgaWYgKG9yZGVyQnlDb21wb25lbnQuZmllbGQuaXNLZXlGaWVsZCgpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJhd1ZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBFeHBlY3RlZCBhIHN0cmluZyBmb3IgZG9jdW1lbnQgSUQgaW4gYCArXG4gICAgICAgICAgICAgICAgICAgIGAke21ldGhvZE5hbWV9KCksIGJ1dCBnb3QgYSAke3R5cGVvZiByYXdWYWx1ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNDb2xsZWN0aW9uR3JvdXBRdWVyeShxdWVyeSkgJiYgcmF3VmFsdWUuaW5kZXhPZignLycpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIGEgY29sbGVjdGlvbiBhbmQgb3JkZXJpbmcgYnkgZG9jdW1lbnRJZCgpLCBgICtcbiAgICAgICAgICAgICAgICAgICAgYHRoZSB2YWx1ZSBwYXNzZWQgdG8gJHttZXRob2ROYW1lfSgpIG11c3QgYmUgYSBwbGFpbiBkb2N1bWVudCBJRCwgYnV0IGAgK1xuICAgICAgICAgICAgICAgICAgICBgJyR7cmF3VmFsdWV9JyBjb250YWlucyBhIHNsYXNoLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHF1ZXJ5LnBhdGguY2hpbGQoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocmF3VmFsdWUpKTtcbiAgICAgICAgICAgIGlmICghRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShwYXRoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIGEgY29sbGVjdGlvbiBncm91cCBhbmQgb3JkZXJpbmcgYnkgYCArXG4gICAgICAgICAgICAgICAgICAgIGBkb2N1bWVudElkKCksIHRoZSB2YWx1ZSBwYXNzZWQgdG8gJHttZXRob2ROYW1lfSgpIG11c3QgcmVzdWx0IGluIGEgYCArXG4gICAgICAgICAgICAgICAgICAgIGB2YWxpZCBkb2N1bWVudCBwYXRoLCBidXQgJyR7cGF0aH0nIGlzIG5vdCBiZWNhdXNlIGl0IGNvbnRhaW5zIGFuIG9kZCBudW1iZXIgYCArXG4gICAgICAgICAgICAgICAgICAgIGBvZiBzZWdtZW50cy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IG5ldyBEb2N1bWVudEtleShwYXRoKTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChyZWZWYWx1ZShkYXRhYmFzZUlkLCBrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZWQgPSBwYXJzZVF1ZXJ5VmFsdWUoZGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgcmF3VmFsdWUpO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHdyYXBwZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQm91bmQoY29tcG9uZW50cywgaW5jbHVzaXZlKTtcbn1cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiBgZG9jdW1lbnRJZFZhbHVlYCBpbnRvIGEgYFJlZmVyZW5jZVZhbHVlYCwgdGhyb3dpbmdcbiAqIGFwcHJvcHJpYXRlIGVycm9ycyBpZiB0aGUgdmFsdWUgaXMgYW55dGhpbmcgb3RoZXIgdGhhbiBhIGBEb2N1bWVudFJlZmVyZW5jZWBcbiAqIG9yIGBzdHJpbmdgLCBvciBpZiB0aGUgc3RyaW5nIGlzIG1hbGZvcm1lZC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VEb2N1bWVudElkVmFsdWUoZGF0YWJhc2VJZCwgcXVlcnksIGRvY3VtZW50SWRWYWx1ZSkge1xuICAgIGRvY3VtZW50SWRWYWx1ZSA9IGdldE1vZHVsYXJJbnN0YW5jZShkb2N1bWVudElkVmFsdWUpO1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnRJZFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZG9jdW1lbnRJZFZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ludmFsaWQgcXVlcnkuIFdoZW4gcXVlcnlpbmcgd2l0aCBkb2N1bWVudElkKCksIHlvdSAnICtcbiAgICAgICAgICAgICAgICAnbXVzdCBwcm92aWRlIGEgdmFsaWQgZG9jdW1lbnQgSUQsIGJ1dCBpdCB3YXMgYW4gZW1wdHkgc3RyaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNDb2xsZWN0aW9uR3JvdXBRdWVyeShxdWVyeSkgJiYgZG9jdW1lbnRJZFZhbHVlLmluZGV4T2YoJy8nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIGEgY29sbGVjdGlvbiBieSBgICtcbiAgICAgICAgICAgICAgICBgZG9jdW1lbnRJZCgpLCB5b3UgbXVzdCBwcm92aWRlIGEgcGxhaW4gZG9jdW1lbnQgSUQsIGJ1dCBgICtcbiAgICAgICAgICAgICAgICBgJyR7ZG9jdW1lbnRJZFZhbHVlfScgY29udGFpbnMgYSAnLycgY2hhcmFjdGVyLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBxdWVyeS5wYXRoLmNoaWxkKFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKGRvY3VtZW50SWRWYWx1ZSkpO1xuICAgICAgICBpZiAoIURvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkocGF0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIGEgY29sbGVjdGlvbiBncm91cCBieSBgICtcbiAgICAgICAgICAgICAgICBgZG9jdW1lbnRJZCgpLCB0aGUgdmFsdWUgcHJvdmlkZWQgbXVzdCByZXN1bHQgaW4gYSB2YWxpZCBkb2N1bWVudCBwYXRoLCBgICtcbiAgICAgICAgICAgICAgICBgYnV0ICcke3BhdGh9JyBpcyBub3QgYmVjYXVzZSBpdCBoYXMgYW4gb2RkIG51bWJlciBvZiBzZWdtZW50cyAoJHtwYXRoLmxlbmd0aH0pLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWZWYWx1ZShkYXRhYmFzZUlkLCBuZXcgRG9jdW1lbnRLZXkocGF0aCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb2N1bWVudElkVmFsdWUgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gcmVmVmFsdWUoZGF0YWJhc2VJZCwgZG9jdW1lbnRJZFZhbHVlLl9rZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIFdoZW4gcXVlcnlpbmcgd2l0aCBkb2N1bWVudElkKCksIHlvdSBtdXN0IHByb3ZpZGUgYSB2YWxpZCBgICtcbiAgICAgICAgICAgIGBzdHJpbmcgb3IgYSBEb2N1bWVudFJlZmVyZW5jZSwgYnV0IGl0IHdhczogYCArXG4gICAgICAgICAgICBgJHt2YWx1ZURlc2NyaXB0aW9uKGRvY3VtZW50SWRWYWx1ZSl9LmApO1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIHBhc3NlZCBpbnRvIGEgZGlzanVuY3RpdmUgZmlsdGVyIHNhdGlzZmllcyBhbGxcbiAqIGFycmF5IHJlcXVpcmVtZW50cy5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVEaXNqdW5jdGl2ZUZpbHRlckVsZW1lbnRzKHZhbHVlLCBvcGVyYXRvcikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIFF1ZXJ5LiBBIG5vbi1lbXB0eSBhcnJheSBpcyByZXF1aXJlZCBmb3IgJyArXG4gICAgICAgICAgICBgJyR7b3BlcmF0b3IudG9TdHJpbmcoKX0nIGZpbHRlcnMuYCk7XG4gICAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBvcGVyYXRvciwgcmV0dXJucyB0aGUgc2V0IG9mIG9wZXJhdG9ycyB0aGF0IGNhbm5vdCBiZSB1c2VkIHdpdGggaXQuXG4gKlxuICogVGhpcyBpcyBub3QgYSBjb21wcmVoZW5zaXZlIGNoZWNrLCBhbmQgdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgcmVtb3ZlZCBpbiB0aGVcbiAqIGxvbmcgdGVybS4gVmFsaWRhdGlvbnMgc2hvdWxkIG9jY3VyIGluIHRoZSBGaXJlc3RvcmUgYmFja2VuZC5cbiAqXG4gKiBPcGVyYXRvcnMgaW4gYSBxdWVyeSBtdXN0IGFkaGVyZSB0byB0aGUgZm9sbG93aW5nIHNldCBvZiBydWxlczpcbiAqIDEuIE9ubHkgb25lIGluZXF1YWxpdHkgcGVyIHF1ZXJ5LlxuICogMi4gYE5PVF9JTmAgY2Fubm90IGJlIHVzZWQgd2l0aCBhcnJheSwgZGlzanVuY3RpdmUsIG9yIGBOT1RfRVFVQUxgIG9wZXJhdG9ycy5cbiAqL1xuZnVuY3Rpb24gY29uZmxpY3RpbmdPcHMob3ApIHtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgIGNhc2UgXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLzpcbiAgICAgICAgICAgIHJldHVybiBbXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqLywgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi9dO1xuICAgICAgICBjYXNlIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogT3BlcmF0b3IuQVJSQVlfQ09OVEFJTlNfQU5ZICovOlxuICAgICAgICBjYXNlIFwiaW5cIiAvKiBPcGVyYXRvci5JTiAqLzpcbiAgICAgICAgICAgIHJldHVybiBbXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi9dO1xuICAgICAgICBjYXNlIFwibm90LWluXCIgLyogT3BlcmF0b3IuTk9UX0lOICovOlxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIE9wZXJhdG9yLkFSUkFZX0NPTlRBSU5TX0FOWSAqLyxcbiAgICAgICAgICAgICAgICBcImluXCIgLyogT3BlcmF0b3IuSU4gKi8sXG4gICAgICAgICAgICAgICAgXCJub3QtaW5cIiAvKiBPcGVyYXRvci5OT1RfSU4gKi8sXG4gICAgICAgICAgICAgICAgXCIhPVwiIC8qIE9wZXJhdG9yLk5PVF9FUVVBTCAqL1xuICAgICAgICAgICAgXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU5ld0ZpZWxkRmlsdGVyKHF1ZXJ5LCBmaWVsZEZpbHRlcikge1xuICAgIGNvbnN0IGNvbmZsaWN0aW5nT3AgPSBmaW5kT3BJbnNpZGVGaWx0ZXJzKHF1ZXJ5LmZpbHRlcnMsIGNvbmZsaWN0aW5nT3BzKGZpZWxkRmlsdGVyLm9wKSk7XG4gICAgaWYgKGNvbmZsaWN0aW5nT3AgIT09IG51bGwpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHdoZW4gaXQncyBhIGR1cGxpY2F0ZSBvcCB0byBnaXZlIGEgc2xpZ2h0bHkgY2xlYXJlciBlcnJvciBtZXNzYWdlLlxuICAgICAgICBpZiAoY29uZmxpY3RpbmdPcCA9PT0gZmllbGRGaWx0ZXIub3ApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIHF1ZXJ5LiBZb3UgY2Fubm90IHVzZSBtb3JlIHRoYW4gb25lICcgK1xuICAgICAgICAgICAgICAgIGAnJHtmaWVsZEZpbHRlci5vcC50b1N0cmluZygpfScgZmlsdGVyLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIFlvdSBjYW5ub3QgdXNlICcke2ZpZWxkRmlsdGVyLm9wLnRvU3RyaW5nKCl9JyBmaWx0ZXJzIGAgK1xuICAgICAgICAgICAgICAgIGB3aXRoICcke2NvbmZsaWN0aW5nT3AudG9TdHJpbmcoKX0nIGZpbHRlcnMuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU5ld0ZpbHRlcihxdWVyeSwgZmlsdGVyKSB7XG4gICAgbGV0IHRlc3RRdWVyeSA9IHF1ZXJ5O1xuICAgIGNvbnN0IHN1YkZpbHRlcnMgPSBmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpO1xuICAgIGZvciAoY29uc3Qgc3ViRmlsdGVyIG9mIHN1YkZpbHRlcnMpIHtcbiAgICAgICAgdmFsaWRhdGVOZXdGaWVsZEZpbHRlcih0ZXN0UXVlcnksIHN1YkZpbHRlcik7XG4gICAgICAgIHRlc3RRdWVyeSA9IHF1ZXJ5V2l0aEFkZGVkRmlsdGVyKHRlc3RRdWVyeSwgc3ViRmlsdGVyKTtcbiAgICB9XG59XG4vLyBDaGVja3MgaWYgYW55IG9mIHRoZSBwcm92aWRlZCBmaWx0ZXIgb3BlcmF0b3JzIGFyZSBpbmNsdWRlZCBpbiB0aGUgZ2l2ZW4gbGlzdCBvZiBmaWx0ZXJzIGFuZFxuLy8gcmV0dXJucyB0aGUgZmlyc3Qgb25lIHRoYXQgaXMsIG9yIG51bGwgaWYgbm9uZSBhcmUuXG5mdW5jdGlvbiBmaW5kT3BJbnNpZGVGaWx0ZXJzKGZpbHRlcnMsIG9wZXJhdG9ycykge1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZEZpbHRlciBvZiBmaWx0ZXIuZ2V0RmxhdHRlbmVkRmlsdGVycygpKSB7XG4gICAgICAgICAgICBpZiAob3BlcmF0b3JzLmluZGV4T2YoZmllbGRGaWx0ZXIub3ApID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRGaWx0ZXIub3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVF1ZXJ5RmlsdGVyQ29uc3RyYWludChmdW5jdGlvbk5hbWUsIHF1ZXJ5Q29uc3RyYWludCkge1xuICAgIGlmICghKHF1ZXJ5Q29uc3RyYWludCBpbnN0YW5jZW9mIFF1ZXJ5RmllbGRGaWx0ZXJDb25zdHJhaW50KSAmJlxuICAgICAgICAhKHF1ZXJ5Q29uc3RyYWludCBpbnN0YW5jZW9mIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfSgpIHJlcXVpcmVzIEFwcGxpYWJsZUNvbnN0cmFpbnRzIGNyZWF0ZWQgd2l0aCBhIGNhbGwgdG8gJ3doZXJlKC4uLiknLCAnb3IoLi4uKScsIG9yICdhbmQoLi4uKScuYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVRdWVyeUNvbnN0cmFpbnRBcnJheShxdWVyeUNvbnN0cmFpbnQpIHtcbiAgICBjb25zdCBjb21wb3NpdGVGaWx0ZXJDb3VudCA9IHF1ZXJ5Q29uc3RyYWludC5maWx0ZXIoZmlsdGVyID0+IGZpbHRlciBpbnN0YW5jZW9mIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCkubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkRmlsdGVyQ291bnQgPSBxdWVyeUNvbnN0cmFpbnQuZmlsdGVyKGZpbHRlciA9PiBmaWx0ZXIgaW5zdGFuY2VvZiBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludCkubGVuZ3RoO1xuICAgIGlmIChjb21wb3NpdGVGaWx0ZXJDb3VudCA+IDEgfHxcbiAgICAgICAgKGNvbXBvc2l0ZUZpbHRlckNvdW50ID4gMCAmJiBmaWVsZEZpbHRlckNvdW50ID4gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ludmFsaWRRdWVyeS4gV2hlbiB1c2luZyBjb21wb3NpdGUgZmlsdGVycywgeW91IGNhbm5vdCB1c2UgJyArXG4gICAgICAgICAgICAnbW9yZSB0aGFuIG9uZSBmaWx0ZXIgYXQgdGhlIHRvcCBsZXZlbC4gQ29uc2lkZXIgbmVzdGluZyB0aGUgbXVsdGlwbGUgJyArXG4gICAgICAgICAgICAnZmlsdGVycyB3aXRoaW4gYW4gYGFuZCguLi4pYCBzdGF0ZW1lbnQuIEZvciBleGFtcGxlOiAnICtcbiAgICAgICAgICAgICdjaGFuZ2UgYHF1ZXJ5KHF1ZXJ5LCB3aGVyZSguLi4pLCBvciguLi4pKWAgdG8gJyArXG4gICAgICAgICAgICAnYHF1ZXJ5KHF1ZXJ5LCBhbmQod2hlcmUoLi4uKSwgb3IoLi4uKSkpYC4nKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENvbnZlcnRzIEZpcmVzdG9yZSdzIGludGVybmFsIHR5cGVzIHRvIHRoZSBKYXZhU2NyaXB0IHR5cGVzIHRoYXQgd2UgZXhwb3NlXG4gKiB0byB0aGUgdXNlci5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQWJzdHJhY3RVc2VyRGF0YVdyaXRlciB7XG4gICAgY29udmVydFZhbHVlKHZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvciA9ICdub25lJykge1xuICAgICAgICBzd2l0Y2ggKHR5cGVPcmRlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBUeXBlT3JkZXIuTnVsbFZhbHVlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSAxIC8qIFR5cGVPcmRlci5Cb29sZWFuVmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmJvb2xlYW5WYWx1ZTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBUeXBlT3JkZXIuTnVtYmVyVmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5pbnRlZ2VyVmFsdWUgfHwgdmFsdWUuZG91YmxlVmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFR5cGVPcmRlci5UaW1lc3RhbXBWYWx1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VGltZXN0YW1wKHZhbHVlLnRpbWVzdGFtcFZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgNCAvKiBUeXBlT3JkZXIuU2VydmVyVGltZXN0YW1wVmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNlcnZlclRpbWVzdGFtcCh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xuICAgICAgICAgICAgY2FzZSA1IC8qIFR5cGVPcmRlci5TdHJpbmdWYWx1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc3RyaW5nVmFsdWU7XG4gICAgICAgICAgICBjYXNlIDYgLyogVHlwZU9yZGVyLkJsb2JWYWx1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0Qnl0ZXMobm9ybWFsaXplQnl0ZVN0cmluZyh2YWx1ZS5ieXRlc1ZhbHVlKSk7XG4gICAgICAgICAgICBjYXNlIDcgLyogVHlwZU9yZGVyLlJlZlZhbHVlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRSZWZlcmVuY2UodmFsdWUucmVmZXJlbmNlVmFsdWUpO1xuICAgICAgICAgICAgY2FzZSA4IC8qIFR5cGVPcmRlci5HZW9Qb2ludFZhbHVlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRHZW9Qb2ludCh2YWx1ZS5nZW9Qb2ludFZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgOSAvKiBUeXBlT3JkZXIuQXJyYXlWYWx1ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0QXJyYXkodmFsdWUuYXJyYXlWYWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xuICAgICAgICAgICAgY2FzZSAxMSAvKiBUeXBlT3JkZXIuT2JqZWN0VmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydE9iamVjdCh2YWx1ZS5tYXBWYWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xuICAgICAgICAgICAgY2FzZSAxMCAvKiBUeXBlT3JkZXIuVmVjdG9yVmFsdWUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFZlY3RvclZhbHVlKHZhbHVlLm1hcFZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnZlcnRPYmplY3QobWFwVmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRPYmplY3RNYXAobWFwVmFsdWUuZmllbGRzLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnZlcnRPYmplY3RNYXAoZmllbGRzLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvciA9ICdub25lJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yRWFjaChmaWVsZHMsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHRoaXMuY29udmVydFZhbHVlKHZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb252ZXJ0VmVjdG9yVmFsdWUobWFwVmFsdWUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IChfYyA9IChfYiA9IChfYSA9IG1hcFZhbHVlLmZpZWxkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1ZFQ1RPUl9NQVBfVkVDVE9SU19LRVldLmFycmF5VmFsdWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52YWx1ZXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tYXAodmFsdWUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5kb3VibGVWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvclZhbHVlKHZhbHVlcyk7XG4gICAgfVxuICAgIGNvbnZlcnRHZW9Qb2ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEdlb1BvaW50KG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5sYXRpdHVkZSksIG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5sb25naXR1ZGUpKTtcbiAgICB9XG4gICAgY29udmVydEFycmF5KGFycmF5VmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKSB7XG4gICAgICAgIHJldHVybiAoYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pLm1hcCh2YWx1ZSA9PiB0aGlzLmNvbnZlcnRWYWx1ZSh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpKTtcbiAgICB9XG4gICAgY29udmVydFNlcnZlclRpbWVzdGFtcCh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpIHtcbiAgICAgICAgc3dpdGNoIChzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcikge1xuICAgICAgICAgICAgY2FzZSAncHJldmlvdXMnOlxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBnZXRQcmV2aW91c1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VmFsdWUocHJldmlvdXNWYWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xuICAgICAgICAgICAgY2FzZSAnZXN0aW1hdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRUaW1lc3RhbXAoZ2V0TG9jYWxXcml0ZVRpbWUodmFsdWUpKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29udmVydFRpbWVzdGFtcCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSBub3JtYWxpemVUaW1lc3RhbXAodmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChub3JtYWxpemVkVmFsdWUuc2Vjb25kcywgbm9ybWFsaXplZFZhbHVlLm5hbm9zKTtcbiAgICB9XG4gICAgY29udmVydERvY3VtZW50S2V5KG5hbWUsIGV4cGVjdGVkRGF0YWJhc2VJZCkge1xuICAgICAgICBjb25zdCByZXNvdXJjZVBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhuYW1lKTtcbiAgICAgICAgaGFyZEFzc2VydChpc1ZhbGlkUmVzb3VyY2VOYW1lKHJlc291cmNlUGF0aCkpO1xuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gbmV3IERhdGFiYXNlSWQocmVzb3VyY2VQYXRoLmdldCgxKSwgcmVzb3VyY2VQYXRoLmdldCgzKSk7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBEb2N1bWVudEtleShyZXNvdXJjZVBhdGgucG9wRmlyc3QoNSkpO1xuICAgICAgICBpZiAoIWRhdGFiYXNlSWQuaXNFcXVhbChleHBlY3RlZERhdGFiYXNlSWQpKSB7XG4gICAgICAgICAgICAvLyBUT0RPKGIvNjQxMzAyMDIpOiBTb21laG93IHN1cHBvcnQgZm9yZWlnbiByZWZlcmVuY2VzLlxuICAgICAgICAgICAgbG9nRXJyb3IoYERvY3VtZW50ICR7a2V5fSBjb250YWlucyBhIGRvY3VtZW50IGAgK1xuICAgICAgICAgICAgICAgIGByZWZlcmVuY2Ugd2l0aGluIGEgZGlmZmVyZW50IGRhdGFiYXNlIChgICtcbiAgICAgICAgICAgICAgICBgJHtkYXRhYmFzZUlkLnByb2plY3RJZH0vJHtkYXRhYmFzZUlkLmRhdGFiYXNlfSkgd2hpY2ggaXMgbm90IGAgK1xuICAgICAgICAgICAgICAgIGBzdXBwb3J0ZWQuIEl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHJlZmVyZW5jZSBpbiB0aGUgY3VycmVudCBgICtcbiAgICAgICAgICAgICAgICBgZGF0YWJhc2UgKCR7ZXhwZWN0ZWREYXRhYmFzZUlkLnByb2plY3RJZH0vJHtleHBlY3RlZERhdGFiYXNlSWQuZGF0YWJhc2V9KSBgICtcbiAgICAgICAgICAgICAgICBgaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ29udmVydHMgY3VzdG9tIG1vZGVsIG9iamVjdCBvZiB0eXBlIFQgaW50byBgRG9jdW1lbnREYXRhYCBieSBhcHBseWluZyB0aGVcbiAqIGNvbnZlcnRlciBpZiBpdCBleGlzdHMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHdoZW4gY29udmVydGluZyB1c2VyIG9iamVjdHMgdG8gYERvY3VtZW50RGF0YWBcbiAqIGJlY2F1c2Ugd2Ugd2FudCB0byBwcm92aWRlIHRoZSB1c2VyIHdpdGggYSBtb3JlIHNwZWNpZmljIGVycm9yIG1lc3NhZ2UgaWZcbiAqIHRoZWlyIGBzZXQoKWAgb3IgZmFpbHMgZHVlIHRvIGludmFsaWQgZGF0YSBvcmlnaW5hdGluZyBmcm9tIGEgYHRvRmlyZXN0b3JlKClgXG4gKiBjYWxsLlxuICovXG5mdW5jdGlvbiBhcHBseUZpcmVzdG9yZURhdGFDb252ZXJ0ZXIoY29udmVydGVyLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGxldCBjb252ZXJ0ZWRWYWx1ZTtcbiAgICBpZiAoY29udmVydGVyKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIChvcHRpb25zLm1lcmdlIHx8IG9wdGlvbnMubWVyZ2VGaWVsZHMpKSB7XG4gICAgICAgICAgICAvLyBDYXN0IHRvIGBhbnlgIGluIG9yZGVyIHRvIHNhdGlzZnkgdGhlIHVuaW9uIHR5cGUgY29uc3RyYWludCBvblxuICAgICAgICAgICAgLy8gdG9GaXJlc3RvcmUoKS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBjb252ZXJ0ZWRWYWx1ZSA9IGNvbnZlcnRlci50b0ZpcmVzdG9yZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb252ZXJ0ZWRWYWx1ZSA9IGNvbnZlcnRlci50b0ZpcmVzdG9yZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnZlcnRlZFZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0ZWRWYWx1ZTtcbn1cbmNsYXNzIExpdGVVc2VyRGF0YVdyaXRlciBleHRlbmRzIEFic3RyYWN0VXNlckRhdGFXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpcmVzdG9yZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpcmVzdG9yZSA9IGZpcmVzdG9yZTtcbiAgICB9XG4gICAgY29udmVydEJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnl0ZXMoYnl0ZXMpO1xuICAgIH1cbiAgICBjb252ZXJ0UmVmZXJlbmNlKG5hbWUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5jb252ZXJ0RG9jdW1lbnRLZXkobmFtZSwgdGhpcy5maXJlc3RvcmUuX2RhdGFiYXNlSWQpO1xuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHRoaXMuZmlyZXN0b3JlLCAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIGtleSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDcmVhdGUgYW4gQWdncmVnYXRlRmllbGQgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgc3VtIG9mXG4gKiBhIHNwZWNpZmllZCBmaWVsZCBvdmVyIGEgcmFuZ2Ugb2YgZG9jdW1lbnRzIGluIHRoZSByZXN1bHQgc2V0IG9mIGEgcXVlcnkuXG4gKiBAcGFyYW0gZmllbGQgU3BlY2lmaWVzIHRoZSBmaWVsZCB0byBzdW0gYWNyb3NzIHRoZSByZXN1bHQgc2V0LlxuICovXG5mdW5jdGlvbiBzdW0oZmllbGQpIHtcbiAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0ZUZpZWxkKCdzdW0nLCBmaWVsZFBhdGhGcm9tQXJndW1lbnQkMSgnc3VtJywgZmllbGQpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIEFnZ3JlZ2F0ZUZpZWxkIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGF2ZXJhZ2Ugb2ZcbiAqIGEgc3BlY2lmaWVkIGZpZWxkIG92ZXIgYSByYW5nZSBvZiBkb2N1bWVudHMgaW4gdGhlIHJlc3VsdCBzZXQgb2YgYSBxdWVyeS5cbiAqIEBwYXJhbSBmaWVsZCBTcGVjaWZpZXMgdGhlIGZpZWxkIHRvIGF2ZXJhZ2UgYWNyb3NzIHRoZSByZXN1bHQgc2V0LlxuICovXG5mdW5jdGlvbiBhdmVyYWdlKGZpZWxkKSB7XG4gICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGVGaWVsZCgnYXZnJywgZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEoJ2F2ZXJhZ2UnLCBmaWVsZCkpO1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gQWdncmVnYXRlRmllbGQgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgY291bnQgb2ZcbiAqIGRvY3VtZW50cyBpbiB0aGUgcmVzdWx0IHNldCBvZiBhIHF1ZXJ5LlxuICovXG5mdW5jdGlvbiBjb3VudCgpIHtcbiAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0ZUZpZWxkKCdjb3VudCcpO1xufVxuLyoqXG4gKiBDb21wYXJlcyB0d28gJ0FnZ3JlZ2F0ZUZpZWxkYCBpbnN0YW5jZXMgZm9yIGVxdWFsaXR5LlxuICpcbiAqIEBwYXJhbSBsZWZ0IENvbXBhcmUgdGhpcyBBZ2dyZWdhdGVGaWVsZCB0byB0aGUgYHJpZ2h0YC5cbiAqIEBwYXJhbSByaWdodCBDb21wYXJlIHRoaXMgQWdncmVnYXRlRmllbGQgdG8gdGhlIGBsZWZ0YC5cbiAqL1xuZnVuY3Rpb24gYWdncmVnYXRlRmllbGRFcXVhbChsZWZ0LCByaWdodCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChsZWZ0IGluc3RhbmNlb2YgQWdncmVnYXRlRmllbGQgJiZcbiAgICAgICAgcmlnaHQgaW5zdGFuY2VvZiBBZ2dyZWdhdGVGaWVsZCAmJlxuICAgICAgICBsZWZ0LmFnZ3JlZ2F0ZVR5cGUgPT09IHJpZ2h0LmFnZ3JlZ2F0ZVR5cGUgJiZcbiAgICAgICAgKChfYSA9IGxlZnQuX2ludGVybmFsRmllbGRQYXRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2Fub25pY2FsU3RyaW5nKCkpID09PVxuICAgICAgICAgICAgKChfYiA9IHJpZ2h0Ll9pbnRlcm5hbEZpZWxkUGF0aCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbm9uaWNhbFN0cmluZygpKSk7XG59XG4vKipcbiAqIENvbXBhcmVzIHR3byBgQWdncmVnYXRlUXVlcnlTbmFwc2hvdGAgaW5zdGFuY2VzIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBUd28gYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgIGluc3RhbmNlcyBhcmUgY29uc2lkZXJlZCBcImVxdWFsXCIgaWYgdGhleSBoYXZlXG4gKiB1bmRlcmx5aW5nIHF1ZXJpZXMgdGhhdCBjb21wYXJlIGVxdWFsLCBhbmQgdGhlIHNhbWUgZGF0YS5cbiAqXG4gKiBAcGFyYW0gbGVmdCAtIFRoZSBmaXJzdCBgQWdncmVnYXRlUXVlcnlTbmFwc2hvdGAgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSByaWdodCAtIFRoZSBzZWNvbmQgYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgIHRvIGNvbXBhcmUuXG4gKlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBcImVxdWFsXCIsIGFzIGRlZmluZWQgYWJvdmUsIG9yIGBmYWxzZWBcbiAqIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gYWdncmVnYXRlUXVlcnlTbmFwc2hvdEVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIChxdWVyeUVxdWFsKGxlZnQucXVlcnksIHJpZ2h0LnF1ZXJ5KSAmJiBkZWVwRXF1YWwobGVmdC5kYXRhKCksIHJpZ2h0LmRhdGEoKSkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gaXNQYXJ0aWFsT2JzZXJ2ZXIob2JqKSB7XG4gICAgcmV0dXJuIGltcGxlbWVudHNBbnlNZXRob2RzKG9iaiwgWyduZXh0JywgJ2Vycm9yJywgJ2NvbXBsZXRlJ10pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGFuIG9iamVjdCBhbmQgY29udGFpbnMgYXQgbGVhc3Qgb25lIG9mIHRoZSBzcGVjaWZpZWRcbiAqIG1ldGhvZHMuXG4gKi9cbmZ1bmN0aW9uIGltcGxlbWVudHNBbnlNZXRob2RzKG9iaiwgbWV0aG9kcykge1xuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvYmplY3QgPSBvYmo7XG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xuICAgICAgICBpZiAobWV0aG9kIGluIG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogTWV0YWRhdGEgYWJvdXQgYSBzbmFwc2hvdCwgZGVzY3JpYmluZyB0aGUgc3RhdGUgb2YgdGhlIHNuYXBzaG90LlxuICovXG5jbGFzcyBTbmFwc2hvdE1ldGFkYXRhIHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xuICAgIGNvbnN0cnVjdG9yKGhhc1BlbmRpbmdXcml0ZXMsIGZyb21DYWNoZSkge1xuICAgICAgICB0aGlzLmhhc1BlbmRpbmdXcml0ZXMgPSBoYXNQZW5kaW5nV3JpdGVzO1xuICAgICAgICB0aGlzLmZyb21DYWNoZSA9IGZyb21DYWNoZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYFNuYXBzaG90TWV0YWRhdGFgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgYFNuYXBzaG90TWV0YWRhdGFgIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYFNuYXBzaG90TWV0YWRhdGFgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICovXG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gKHRoaXMuaGFzUGVuZGluZ1dyaXRlcyA9PT0gb3RoZXIuaGFzUGVuZGluZ1dyaXRlcyAmJlxuICAgICAgICAgICAgdGhpcy5mcm9tQ2FjaGUgPT09IG90aGVyLmZyb21DYWNoZSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGBEb2N1bWVudFNuYXBzaG90YCBjb250YWlucyBkYXRhIHJlYWQgZnJvbSBhIGRvY3VtZW50IGluIHlvdXIgRmlyZXN0b3JlXG4gKiBkYXRhYmFzZS4gVGhlIGRhdGEgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGAuZGF0YSgpYCBvciBgLmdldCg8ZmllbGQ+KWAgdG9cbiAqIGdldCBhIHNwZWNpZmljIGZpZWxkLlxuICpcbiAqIEZvciBhIGBEb2N1bWVudFNuYXBzaG90YCB0aGF0IHBvaW50cyB0byBhIG5vbi1leGlzdGluZyBkb2N1bWVudCwgYW55IGRhdGFcbiAqIGFjY2VzcyB3aWxsIHJldHVybiAndW5kZWZpbmVkJy4gWW91IGNhbiB1c2UgdGhlIGBleGlzdHMoKWAgbWV0aG9kIHRvXG4gKiBleHBsaWNpdGx5IHZlcmlmeSBhIGRvY3VtZW50J3MgZXhpc3RlbmNlLlxuICovXG5jbGFzcyBEb2N1bWVudFNuYXBzaG90IGV4dGVuZHMgRG9jdW1lbnRTbmFwc2hvdCQxIHtcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciBwcm90ZWN0ZWQgKi9cbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwga2V5LCBkb2N1bWVudCwgbWV0YWRhdGEsIGNvbnZlcnRlcikge1xuICAgICAgICBzdXBlcihfZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwga2V5LCBkb2N1bWVudCwgY29udmVydGVyKTtcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlID0gX2ZpcmVzdG9yZTtcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlSW1wbCA9IF9maXJlc3RvcmU7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZGF0YSBleGlzdHMuIFRydWUgaWYgdGhlIGRvY3VtZW50IGV4aXN0cy5cbiAgICAgKi9cbiAgICBleGlzdHMoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5leGlzdHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IGFzIGFuIGBPYmplY3RgLiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmXG4gICAgICogdGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBgc2VydmVyVGltZXN0YW1wKClgIHZhbHVlcyB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gICAgICogc2V0IHRvIHRoZWlyIGZpbmFsIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgYXMgYG51bGxgLiBZb3UgY2FuIG92ZXJyaWRlXG4gICAgICogdGhpcyBieSBwYXNzaW5nIGFuIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdCB0byBjb25maWd1cmUgaG93IGRhdGEgaXMgcmV0cmlldmVkIGZyb21cbiAgICAgKiB0aGUgc25hcHNob3QgKGZvciBleGFtcGxlIHRoZSBkZXNpcmVkIGJlaGF2aW9yIGZvciBzZXJ2ZXIgdGltZXN0YW1wcyB0aGF0XG4gICAgICogaGF2ZSBub3QgeWV0IGJlZW4gc2V0IHRvIHRoZWlyIGZpbmFsIHZhbHVlKS5cbiAgICAgKiBAcmV0dXJucyBBbiBgT2JqZWN0YCBjb250YWluaW5nIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IG9yIGB1bmRlZmluZWRgIGlmXG4gICAgICogdGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QuXG4gICAgICovXG4gICAgZGF0YShvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9jb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB1c2UgdGhlIGNvbnZlcnRlciBhbmQgY3JlYXRlIGEgbmV3IERvY3VtZW50U25hcHNob3RcbiAgICAgICAgICAgIC8vIGlmIGEgY29udmVydGVyIGhhcyBiZWVuIHByb3ZpZGVkLlxuICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBuZXcgUXVlcnlEb2N1bWVudFNuYXBzaG90KHRoaXMuX2ZpcmVzdG9yZSwgdGhpcy5fdXNlckRhdGFXcml0ZXIsIHRoaXMuX2tleSwgdGhpcy5fZG9jdW1lbnQsIHRoaXMubWV0YWRhdGEsIFxuICAgICAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0ZXIuZnJvbUZpcmVzdG9yZShzbmFwc2hvdCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlckRhdGFXcml0ZXIuY29udmVydFZhbHVlKHRoaXMuX2RvY3VtZW50LmRhdGEudmFsdWUsIG9wdGlvbnMuc2VydmVyVGltZXN0YW1wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBmaWVsZCBzcGVjaWZpZWQgYnkgYGZpZWxkUGF0aGAuIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlXG4gICAgICogZG9jdW1lbnQgb3IgZmllbGQgZG9lc24ndCBleGlzdC5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIGEgYHNlcnZlclRpbWVzdGFtcCgpYCB0aGF0IGhhcyBub3QgeWV0IGJlZW4gc2V0IHRvXG4gICAgICogaXRzIGZpbmFsIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgYXMgYG51bGxgLiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgYnlcbiAgICAgKiBwYXNzaW5nIGFuIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpZWxkUGF0aCAtIFRoZSBwYXRoIChmb3IgZXhhbXBsZSAnZm9vJyBvciAnZm9vLmJhcicpIHRvIGEgc3BlY2lmaWNcbiAgICAgKiBmaWVsZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRvIGNvbmZpZ3VyZSBob3cgdGhlIGZpZWxkIGlzIHJldHJpZXZlZFxuICAgICAqIGZyb20gdGhlIHNuYXBzaG90IChmb3IgZXhhbXBsZSB0aGUgZGVzaXJlZCBiZWhhdmlvciBmb3Igc2VydmVyIHRpbWVzdGFtcHNcbiAgICAgKiB0aGF0IGhhdmUgbm90IHlldCBiZWVuIHNldCB0byB0aGVpciBmaW5hbCB2YWx1ZSkuXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgYXQgdGhlIHNwZWNpZmllZCBmaWVsZCBsb2NhdGlvbiBvciB1bmRlZmluZWQgaWYgbm8gc3VjaFxuICAgICAqIGZpZWxkIGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgLy8gV2UgYXJlIHVzaW5nIGBhbnlgIGhlcmUgdG8gYXZvaWQgYW4gZXhwbGljaXQgY2FzdCBieSBvdXIgdXNlcnMuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBnZXQoZmllbGRQYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuX2RvY3VtZW50KSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2RvY3VtZW50LmRhdGEuZmllbGQoZmllbGRQYXRoRnJvbUFyZ3VtZW50KCdEb2N1bWVudFNuYXBzaG90LmdldCcsIGZpZWxkUGF0aCkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhV3JpdGVyLmNvbnZlcnRWYWx1ZSh2YWx1ZSwgb3B0aW9ucy5zZXJ2ZXJUaW1lc3RhbXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogQSBgUXVlcnlEb2N1bWVudFNuYXBzaG90YCBjb250YWlucyBkYXRhIHJlYWQgZnJvbSBhIGRvY3VtZW50IGluIHlvdXJcbiAqIEZpcmVzdG9yZSBkYXRhYmFzZSBhcyBwYXJ0IG9mIGEgcXVlcnkuIFRoZSBkb2N1bWVudCBpcyBndWFyYW50ZWVkIHRvIGV4aXN0XG4gKiBhbmQgaXRzIGRhdGEgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGAuZGF0YSgpYCBvciBgLmdldCg8ZmllbGQ+KWAgdG8gZ2V0IGFcbiAqIHNwZWNpZmljIGZpZWxkLlxuICpcbiAqIEEgYFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdGAgb2ZmZXJzIHRoZSBzYW1lIEFQSSBzdXJmYWNlIGFzIGFcbiAqIGBEb2N1bWVudFNuYXBzaG90YC4gU2luY2UgcXVlcnkgcmVzdWx0cyBjb250YWluIG9ubHkgZXhpc3RpbmcgZG9jdW1lbnRzLCB0aGVcbiAqIGBleGlzdHNgIHByb3BlcnR5IHdpbGwgYWx3YXlzIGJlIHRydWUgYW5kIGBkYXRhKClgIHdpbGwgbmV2ZXIgcmV0dXJuXG4gKiAndW5kZWZpbmVkJy5cbiAqL1xuY2xhc3MgUXVlcnlEb2N1bWVudFNuYXBzaG90IGV4dGVuZHMgRG9jdW1lbnRTbmFwc2hvdCB7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBmaWVsZHMgaW4gdGhlIGRvY3VtZW50IGFzIGFuIGBPYmplY3RgLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgYHNlcnZlclRpbWVzdGFtcCgpYCB2YWx1ZXMgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlblxuICAgICAqIHNldCB0byB0aGVpciBmaW5hbCB2YWx1ZSB3aWxsIGJlIHJldHVybmVkIGFzIGBudWxsYC4gWW91IGNhbiBvdmVycmlkZVxuICAgICAqIHRoaXMgYnkgcGFzc2luZyBhbiBvcHRpb25zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9ucyBvYmplY3QgdG8gY29uZmlndXJlIGhvdyBkYXRhIGlzIHJldHJpZXZlZCBmcm9tXG4gICAgICogdGhlIHNuYXBzaG90IChmb3IgZXhhbXBsZSB0aGUgZGVzaXJlZCBiZWhhdmlvciBmb3Igc2VydmVyIHRpbWVzdGFtcHMgdGhhdFxuICAgICAqIGhhdmUgbm90IHlldCBiZWVuIHNldCB0byB0aGVpciBmaW5hbCB2YWx1ZSkuXG4gICAgICogQHJldHVybnMgQW4gYE9iamVjdGAgY29udGFpbmluZyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBkYXRhKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZGF0YShvcHRpb25zKTtcbiAgICB9XG59XG4vKipcbiAqIEEgYFF1ZXJ5U25hcHNob3RgIGNvbnRhaW5zIHplcm8gb3IgbW9yZSBgRG9jdW1lbnRTbmFwc2hvdGAgb2JqZWN0c1xuICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHRzIG9mIGEgcXVlcnkuIFRoZSBkb2N1bWVudHMgY2FuIGJlIGFjY2Vzc2VkIGFzIGFuXG4gKiBhcnJheSB2aWEgdGhlIGBkb2NzYCBwcm9wZXJ0eSBvciBlbnVtZXJhdGVkIHVzaW5nIHRoZSBgZm9yRWFjaGAgbWV0aG9kLiBUaGVcbiAqIG51bWJlciBvZiBkb2N1bWVudHMgY2FuIGJlIGRldGVybWluZWQgdmlhIHRoZSBgZW1wdHlgIGFuZCBgc2l6ZWBcbiAqIHByb3BlcnRpZXMuXG4gKi9cbmNsYXNzIFF1ZXJ5U25hcHNob3Qge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSwgX3VzZXJEYXRhV3JpdGVyLCBxdWVyeSwgX3NuYXBzaG90KSB7XG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XG4gICAgICAgIHRoaXMuX3VzZXJEYXRhV3JpdGVyID0gX3VzZXJEYXRhV3JpdGVyO1xuICAgICAgICB0aGlzLl9zbmFwc2hvdCA9IF9zbmFwc2hvdDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBTbmFwc2hvdE1ldGFkYXRhKF9zbmFwc2hvdC5oYXNQZW5kaW5nV3JpdGVzLCBfc25hcHNob3QuZnJvbUNhY2hlKTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgIH1cbiAgICAvKiogQW4gYXJyYXkgb2YgYWxsIHRoZSBkb2N1bWVudHMgaW4gdGhlIGBRdWVyeVNuYXBzaG90YC4gKi9cbiAgICBnZXQgZG9jcygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaChkb2MgPT4gcmVzdWx0LnB1c2goZG9jKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGRvY3VtZW50cyBpbiB0aGUgYFF1ZXJ5U25hcHNob3RgLiAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc25hcHNob3QuZG9jcy5zaXplO1xuICAgIH1cbiAgICAvKiogVHJ1ZSBpZiB0aGVyZSBhcmUgbm8gZG9jdW1lbnRzIGluIHRoZSBgUXVlcnlTbmFwc2hvdGAuICovXG4gICAgZ2V0IGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnVtZXJhdGVzIGFsbCBvZiB0aGUgZG9jdW1lbnRzIGluIHRoZSBgUXVlcnlTbmFwc2hvdGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aXRoIGEgYFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdGAgZm9yXG4gICAgICogZWFjaCBkb2N1bWVudCBpbiB0aGUgc25hcHNob3QuXG4gICAgICogQHBhcmFtIHRoaXNBcmcgLSBUaGUgYHRoaXNgIGJpbmRpbmcgZm9yIHRoZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIHRoaXMuX3NuYXBzaG90LmRvY3MuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBuZXcgUXVlcnlEb2N1bWVudFNuYXBzaG90KHRoaXMuX2ZpcmVzdG9yZSwgdGhpcy5fdXNlckRhdGFXcml0ZXIsIGRvYy5rZXksIGRvYywgbmV3IFNuYXBzaG90TWV0YWRhdGEodGhpcy5fc25hcHNob3QubXV0YXRlZEtleXMuaGFzKGRvYy5rZXkpLCB0aGlzLl9zbmFwc2hvdC5mcm9tQ2FjaGUpLCB0aGlzLnF1ZXJ5LmNvbnZlcnRlcikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgZG9jdW1lbnRzIGNoYW5nZXMgc2luY2UgdGhlIGxhc3Qgc25hcHNob3QuIElmIHRoaXNcbiAgICAgKiBpcyB0aGUgZmlyc3Qgc25hcHNob3QsIGFsbCBkb2N1bWVudHMgd2lsbCBiZSBpbiB0aGUgbGlzdCBhcyAnYWRkZWQnXG4gICAgICogY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gYFNuYXBzaG90TGlzdGVuT3B0aW9uc2AgdGhhdCBjb250cm9sIHdoZXRoZXIgbWV0YWRhdGEtb25seVxuICAgICAqIGNoYW5nZXMgKGkuZS4gb25seSBgRG9jdW1lbnRTbmFwc2hvdC5tZXRhZGF0YWAgY2hhbmdlZCkgc2hvdWxkIHRyaWdnZXJcbiAgICAgKiBzbmFwc2hvdCBldmVudHMuXG4gICAgICovXG4gICAgZG9jQ2hhbmdlcyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyA9ICEhb3B0aW9ucy5pbmNsdWRlTWV0YWRhdGFDaGFuZ2VzO1xuICAgICAgICBpZiAoaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyAmJiB0aGlzLl9zbmFwc2hvdC5leGNsdWRlc01ldGFkYXRhQ2hhbmdlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RvIGluY2x1ZGUgbWV0YWRhdGEgY2hhbmdlcyB3aXRoIHlvdXIgZG9jdW1lbnQgY2hhbmdlcywgeW91IG11c3QgJyArXG4gICAgICAgICAgICAgICAgJ2Fsc28gcGFzcyB7IGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM6dHJ1ZSB9IHRvIG9uU25hcHNob3QoKS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlZENoYW5nZXMgfHxcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZENoYW5nZXNJbmNsdWRlTWV0YWRhdGFDaGFuZ2VzICE9PSBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRDaGFuZ2VzID0gY2hhbmdlc0Zyb21TbmFwc2hvdCh0aGlzLCBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzKTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZENoYW5nZXNJbmNsdWRlTWV0YWRhdGFDaGFuZ2VzID0gaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkQ2hhbmdlcztcbiAgICB9XG59XG4vKiogQ2FsY3VsYXRlcyB0aGUgYXJyYXkgb2YgYERvY3VtZW50Q2hhbmdlYHMgZm9yIGEgZ2l2ZW4gYFZpZXdTbmFwc2hvdGAuICovXG5mdW5jdGlvbiBjaGFuZ2VzRnJvbVNuYXBzaG90KHF1ZXJ5U25hcHNob3QsIGluY2x1ZGVNZXRhZGF0YUNoYW5nZXMpIHtcbiAgICBpZiAocXVlcnlTbmFwc2hvdC5fc25hcHNob3Qub2xkRG9jcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5U25hcHNob3QuX3NuYXBzaG90LmRvY0NoYW5nZXMubWFwKGNoYW5nZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSBuZXcgUXVlcnlEb2N1bWVudFNuYXBzaG90KHF1ZXJ5U25hcHNob3QuX2ZpcmVzdG9yZSwgcXVlcnlTbmFwc2hvdC5fdXNlckRhdGFXcml0ZXIsIGNoYW5nZS5kb2Mua2V5LCBjaGFuZ2UuZG9jLCBuZXcgU25hcHNob3RNZXRhZGF0YShxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5tdXRhdGVkS2V5cy5oYXMoY2hhbmdlLmRvYy5rZXkpLCBxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5mcm9tQ2FjaGUpLCBxdWVyeVNuYXBzaG90LnF1ZXJ5LmNvbnZlcnRlcik7XG4gICAgICAgICAgICBjaGFuZ2UuZG9jO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkZWQnLFxuICAgICAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgICAgICBvbGRJbmRleDogLTEsXG4gICAgICAgICAgICAgICAgbmV3SW5kZXg6IGluZGV4KytcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQSBgRG9jdW1lbnRTZXRgIHRoYXQgaXMgdXBkYXRlZCBpbmNyZW1lbnRhbGx5IGFzIGNoYW5nZXMgYXJlIGFwcGxpZWQgdG8gdXNlXG4gICAgICAgIC8vIHRvIGxvb2t1cCB0aGUgaW5kZXggb2YgYSBkb2N1bWVudC5cbiAgICAgICAgbGV0IGluZGV4VHJhY2tlciA9IHF1ZXJ5U25hcHNob3QuX3NuYXBzaG90Lm9sZERvY3M7XG4gICAgICAgIHJldHVybiBxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5kb2NDaGFuZ2VzXG4gICAgICAgICAgICAuZmlsdGVyKGNoYW5nZSA9PiBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzIHx8IGNoYW5nZS50eXBlICE9PSAzIC8qIENoYW5nZVR5cGUuTWV0YWRhdGEgKi8pXG4gICAgICAgICAgICAubWFwKGNoYW5nZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSBuZXcgUXVlcnlEb2N1bWVudFNuYXBzaG90KHF1ZXJ5U25hcHNob3QuX2ZpcmVzdG9yZSwgcXVlcnlTbmFwc2hvdC5fdXNlckRhdGFXcml0ZXIsIGNoYW5nZS5kb2Mua2V5LCBjaGFuZ2UuZG9jLCBuZXcgU25hcHNob3RNZXRhZGF0YShxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5tdXRhdGVkS2V5cy5oYXMoY2hhbmdlLmRvYy5rZXkpLCBxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5mcm9tQ2FjaGUpLCBxdWVyeVNuYXBzaG90LnF1ZXJ5LmNvbnZlcnRlcik7XG4gICAgICAgICAgICBsZXQgb2xkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGxldCBuZXdJbmRleCA9IC0xO1xuICAgICAgICAgICAgaWYgKGNoYW5nZS50eXBlICE9PSAwIC8qIENoYW5nZVR5cGUuQWRkZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBvbGRJbmRleCA9IGluZGV4VHJhY2tlci5pbmRleE9mKGNoYW5nZS5kb2Mua2V5KTtcbiAgICAgICAgICAgICAgICBpbmRleFRyYWNrZXIgPSBpbmRleFRyYWNrZXIuZGVsZXRlKGNoYW5nZS5kb2Mua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2UudHlwZSAhPT0gMSAvKiBDaGFuZ2VUeXBlLlJlbW92ZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBpbmRleFRyYWNrZXIgPSBpbmRleFRyYWNrZXIuYWRkKGNoYW5nZS5kb2MpO1xuICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gaW5kZXhUcmFja2VyLmluZGV4T2YoY2hhbmdlLmRvYy5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiByZXN1bHRDaGFuZ2VUeXBlKGNoYW5nZS50eXBlKSxcbiAgICAgICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICAgICAgb2xkSW5kZXgsXG4gICAgICAgICAgICAgICAgbmV3SW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc3VsdENoYW5nZVR5cGUodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIDAgLyogQ2hhbmdlVHlwZS5BZGRlZCAqLzpcbiAgICAgICAgICAgIHJldHVybiAnYWRkZWQnO1xuICAgICAgICBjYXNlIDIgLyogQ2hhbmdlVHlwZS5Nb2RpZmllZCAqLzpcbiAgICAgICAgY2FzZSAzIC8qIENoYW5nZVR5cGUuTWV0YWRhdGEgKi86XG4gICAgICAgICAgICByZXR1cm4gJ21vZGlmaWVkJztcbiAgICAgICAgY2FzZSAxIC8qIENoYW5nZVR5cGUuUmVtb3ZlZCAqLzpcbiAgICAgICAgICAgIHJldHVybiAncmVtb3ZlZCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xuICAgIH1cbn1cbi8vIFRPRE8oZmlyZXN0b3JlZXhwKTogQWRkIHRlc3RzIGZvciBzbmFwc2hvdEVxdWFsIHdpdGggZGlmZmVyZW50IHNuYXBzaG90XG4vLyBtZXRhZGF0YVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHNuYXBzaG90cyBhcmUgZXF1YWwuXG4gKlxuICogQHBhcmFtIGxlZnQgLSBBIHNuYXBzaG90IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gcmlnaHQgLSBBIHNuYXBzaG90IHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzbmFwc2hvdHMgYXJlIGVxdWFsLlxuICovXG5mdW5jdGlvbiBzbmFwc2hvdEVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBEb2N1bWVudFNuYXBzaG90ICYmIHJpZ2h0IGluc3RhbmNlb2YgRG9jdW1lbnRTbmFwc2hvdCkge1xuICAgICAgICByZXR1cm4gKGxlZnQuX2ZpcmVzdG9yZSA9PT0gcmlnaHQuX2ZpcmVzdG9yZSAmJlxuICAgICAgICAgICAgbGVmdC5fa2V5LmlzRXF1YWwocmlnaHQuX2tleSkgJiZcbiAgICAgICAgICAgIChsZWZ0Ll9kb2N1bWVudCA9PT0gbnVsbFxuICAgICAgICAgICAgICAgID8gcmlnaHQuX2RvY3VtZW50ID09PSBudWxsXG4gICAgICAgICAgICAgICAgOiBsZWZ0Ll9kb2N1bWVudC5pc0VxdWFsKHJpZ2h0Ll9kb2N1bWVudCkpICYmXG4gICAgICAgICAgICBsZWZ0Ll9jb252ZXJ0ZXIgPT09IHJpZ2h0Ll9jb252ZXJ0ZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZWZ0IGluc3RhbmNlb2YgUXVlcnlTbmFwc2hvdCAmJiByaWdodCBpbnN0YW5jZW9mIFF1ZXJ5U25hcHNob3QpIHtcbiAgICAgICAgcmV0dXJuIChsZWZ0Ll9maXJlc3RvcmUgPT09IHJpZ2h0Ll9maXJlc3RvcmUgJiZcbiAgICAgICAgICAgIHF1ZXJ5RXF1YWwobGVmdC5xdWVyeSwgcmlnaHQucXVlcnkpICYmXG4gICAgICAgICAgICBsZWZ0Lm1ldGFkYXRhLmlzRXF1YWwocmlnaHQubWV0YWRhdGEpICYmXG4gICAgICAgICAgICBsZWZ0Ll9zbmFwc2hvdC5pc0VxdWFsKHJpZ2h0Ll9zbmFwc2hvdCkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcnJlZCB0byBieSB0aGlzIGBEb2N1bWVudFJlZmVyZW5jZWAuXG4gKlxuICogTm90ZTogYGdldERvYygpYCBhdHRlbXB0cyB0byBwcm92aWRlIHVwLXRvLWRhdGUgZGF0YSB3aGVuIHBvc3NpYmxlIGJ5IHdhaXRpbmdcbiAqIGZvciBkYXRhIGZyb20gdGhlIHNlcnZlciwgYnV0IGl0IG1heSByZXR1cm4gY2FjaGVkIGRhdGEgb3IgZmFpbCBpZiB5b3UgYXJlXG4gKiBvZmZsaW5lIGFuZCB0aGUgc2VydmVyIGNhbm5vdCBiZSByZWFjaGVkLiBUbyBzcGVjaWZ5IHRoaXMgYmVoYXZpb3IsIGludm9rZVxuICoge0BsaW5rIGdldERvY0Zyb21DYWNoZX0gb3Ige0BsaW5rIGdldERvY0Zyb21TZXJ2ZXJ9LlxuICpcbiAqIEBwYXJhbSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIG9mIHRoZSBkb2N1bWVudCB0byBmZXRjaC5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGEgYERvY3VtZW50U25hcHNob3RgIGNvbnRhaW5pbmcgdGhlXG4gKiBjdXJyZW50IGRvY3VtZW50IGNvbnRlbnRzLlxuICovXG5mdW5jdGlvbiBnZXREb2MocmVmZXJlbmNlKSB7XG4gICAgcmVmZXJlbmNlID0gY2FzdChyZWZlcmVuY2UsIERvY3VtZW50UmVmZXJlbmNlKTtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudFZpYVNuYXBzaG90TGlzdGVuZXIoY2xpZW50LCByZWZlcmVuY2UuX2tleSkudGhlbihzbmFwc2hvdCA9PiBjb252ZXJ0VG9Eb2NTbmFwc2hvdChmaXJlc3RvcmUsIHJlZmVyZW5jZSwgc25hcHNob3QpKTtcbn1cbmNsYXNzIEV4cFVzZXJEYXRhV3JpdGVyIGV4dGVuZHMgQWJzdHJhY3RVc2VyRGF0YVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmlyZXN0b3JlID0gZmlyZXN0b3JlO1xuICAgIH1cbiAgICBjb252ZXJ0Qnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlcyhieXRlcyk7XG4gICAgfVxuICAgIGNvbnZlcnRSZWZlcmVuY2UobmFtZSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmNvbnZlcnREb2N1bWVudEtleShuYW1lLCB0aGlzLmZpcmVzdG9yZS5fZGF0YWJhc2VJZCk7XG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UodGhpcy5maXJlc3RvcmUsIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwga2V5KTtcbiAgICB9XG59XG4vKipcbiAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcnJlZCB0byBieSB0aGlzIGBEb2N1bWVudFJlZmVyZW5jZWAgZnJvbSBjYWNoZS5cbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgdGhlIGRvY3VtZW50IGlzIG5vdCBjdXJyZW50bHkgY2FjaGVkLlxuICpcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHJlc29sdmVkIHdpdGggYSBgRG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbmluZyB0aGVcbiAqIGN1cnJlbnQgZG9jdW1lbnQgY29udGVudHMuXG4gKi9cbmZ1bmN0aW9uIGdldERvY0Zyb21DYWNoZShyZWZlcmVuY2UpIHtcbiAgICByZWZlcmVuY2UgPSBjYXN0KHJlZmVyZW5jZSwgRG9jdW1lbnRSZWZlcmVuY2UpO1xuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocmVmZXJlbmNlLmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRGcm9tTG9jYWxDYWNoZShjbGllbnQsIHJlZmVyZW5jZS5fa2V5KS50aGVuKGRvYyA9PiBuZXcgRG9jdW1lbnRTbmFwc2hvdChmaXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCByZWZlcmVuY2UuX2tleSwgZG9jLCBuZXcgU25hcHNob3RNZXRhZGF0YShkb2MgIT09IG51bGwgJiYgZG9jLmhhc0xvY2FsTXV0YXRpb25zLCBcbiAgICAvKiBmcm9tQ2FjaGU9ICovIHRydWUpLCByZWZlcmVuY2UuY29udmVydGVyKSk7XG59XG4vKipcbiAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcnJlZCB0byBieSB0aGlzIGBEb2N1bWVudFJlZmVyZW5jZWAgZnJvbSB0aGUgc2VydmVyLlxuICogUmV0dXJucyBhbiBlcnJvciBpZiB0aGUgbmV0d29yayBpcyBub3QgYXZhaWxhYmxlLlxuICpcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHJlc29sdmVkIHdpdGggYSBgRG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbmluZyB0aGVcbiAqIGN1cnJlbnQgZG9jdW1lbnQgY29udGVudHMuXG4gKi9cbmZ1bmN0aW9uIGdldERvY0Zyb21TZXJ2ZXIocmVmZXJlbmNlKSB7XG4gICAgcmVmZXJlbmNlID0gY2FzdChyZWZlcmVuY2UsIERvY3VtZW50UmVmZXJlbmNlKTtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudFZpYVNuYXBzaG90TGlzdGVuZXIoY2xpZW50LCByZWZlcmVuY2UuX2tleSwge1xuICAgICAgICBzb3VyY2U6ICdzZXJ2ZXInXG4gICAgfSkudGhlbihzbmFwc2hvdCA9PiBjb252ZXJ0VG9Eb2NTbmFwc2hvdChmaXJlc3RvcmUsIHJlZmVyZW5jZSwgc25hcHNob3QpKTtcbn1cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5IGFuZCByZXR1cm5zIHRoZSByZXN1bHRzIGFzIGEgYFF1ZXJ5U25hcHNob3RgLlxuICpcbiAqIE5vdGU6IGBnZXREb2NzKClgIGF0dGVtcHRzIHRvIHByb3ZpZGUgdXAtdG8tZGF0ZSBkYXRhIHdoZW4gcG9zc2libGUgYnlcbiAqIHdhaXRpbmcgZm9yIGRhdGEgZnJvbSB0aGUgc2VydmVyLCBidXQgaXQgbWF5IHJldHVybiBjYWNoZWQgZGF0YSBvciBmYWlsIGlmXG4gKiB5b3UgYXJlIG9mZmxpbmUgYW5kIHRoZSBzZXJ2ZXIgY2Fubm90IGJlIHJlYWNoZWQuIFRvIHNwZWNpZnkgdGhpcyBiZWhhdmlvcixcbiAqIGludm9rZSB7QGxpbmsgZ2V0RG9jc0Zyb21DYWNoZX0gb3Ige0BsaW5rIGdldERvY3NGcm9tU2VydmVyfS5cbiAqXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiB0aGUgcXVlcnkuXG4gKi9cbmZ1bmN0aW9uIGdldERvY3MocXVlcnkpIHtcbiAgICBxdWVyeSA9IGNhc3QocXVlcnksIFF1ZXJ5KTtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHF1ZXJ5LmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcbiAgICB2YWxpZGF0ZUhhc0V4cGxpY2l0T3JkZXJCeUZvckxpbWl0VG9MYXN0KHF1ZXJ5Ll9xdWVyeSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50c1ZpYVNuYXBzaG90TGlzdGVuZXIoY2xpZW50LCBxdWVyeS5fcXVlcnkpLnRoZW4oc25hcHNob3QgPT4gbmV3IFF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcXVlcnksIHNuYXBzaG90KSk7XG59XG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cyBhcyBhIGBRdWVyeVNuYXBzaG90YCBmcm9tIGNhY2hlLlxuICogUmV0dXJucyBhbiBlbXB0eSByZXN1bHQgc2V0IGlmIG5vIGRvY3VtZW50cyBtYXRjaGluZyB0aGUgcXVlcnkgYXJlIGN1cnJlbnRseVxuICogY2FjaGVkLlxuICpcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeS5cbiAqL1xuZnVuY3Rpb24gZ2V0RG9jc0Zyb21DYWNoZShxdWVyeSkge1xuICAgIHF1ZXJ5ID0gY2FzdChxdWVyeSwgUXVlcnkpO1xuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocXVlcnkuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcihmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNGcm9tTG9jYWxDYWNoZShjbGllbnQsIHF1ZXJ5Ll9xdWVyeSkudGhlbihzbmFwc2hvdCA9PiBuZXcgUXVlcnlTbmFwc2hvdChmaXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCBxdWVyeSwgc25hcHNob3QpKTtcbn1cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5IGFuZCByZXR1cm5zIHRoZSByZXN1bHRzIGFzIGEgYFF1ZXJ5U25hcHNob3RgIGZyb20gdGhlXG4gKiBzZXJ2ZXIuIFJldHVybnMgYW4gZXJyb3IgaWYgdGhlIG5ldHdvcmsgaXMgbm90IGF2YWlsYWJsZS5cbiAqXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiB0aGUgcXVlcnkuXG4gKi9cbmZ1bmN0aW9uIGdldERvY3NGcm9tU2VydmVyKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBjYXN0KHF1ZXJ5LCBRdWVyeSk7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKGZpcmVzdG9yZSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50c1ZpYVNuYXBzaG90TGlzdGVuZXIoY2xpZW50LCBxdWVyeS5fcXVlcnksIHtcbiAgICAgICAgc291cmNlOiAnc2VydmVyJ1xuICAgIH0pLnRoZW4oc25hcHNob3QgPT4gbmV3IFF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcXVlcnksIHNuYXBzaG90KSk7XG59XG5mdW5jdGlvbiBzZXREb2MocmVmZXJlbmNlLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgcmVmZXJlbmNlID0gY2FzdChyZWZlcmVuY2UsIERvY3VtZW50UmVmZXJlbmNlKTtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBhcHBseUZpcmVzdG9yZURhdGFDb252ZXJ0ZXIocmVmZXJlbmNlLmNvbnZlcnRlciwgZGF0YSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKGZpcmVzdG9yZSk7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VTZXREYXRhKGRhdGFSZWFkZXIsICdzZXREb2MnLCByZWZlcmVuY2UuX2tleSwgY29udmVydGVkVmFsdWUsIHJlZmVyZW5jZS5jb252ZXJ0ZXIgIT09IG51bGwsIG9wdGlvbnMpO1xuICAgIGNvbnN0IG11dGF0aW9uID0gcGFyc2VkLnRvTXV0YXRpb24ocmVmZXJlbmNlLl9rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpO1xuICAgIHJldHVybiBleGVjdXRlV3JpdGUoZmlyZXN0b3JlLCBbbXV0YXRpb25dKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZURvYyhyZWZlcmVuY2UsIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgLi4ubW9yZUZpZWxkc0FuZFZhbHVlcykge1xuICAgIHJlZmVyZW5jZSA9IGNhc3QocmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSk7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGRhdGFSZWFkZXIgPSBuZXdVc2VyRGF0YVJlYWRlcihmaXJlc3RvcmUpO1xuICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXG4gICAgLy8gcGVyZm9ybWluZyB2YWxpZGF0aW9uLlxuICAgIGZpZWxkT3JVcGRhdGVEYXRhID0gZ2V0TW9kdWxhckluc3RhbmNlKGZpZWxkT3JVcGRhdGVEYXRhKTtcbiAgICBsZXQgcGFyc2VkO1xuICAgIGlmICh0eXBlb2YgZmllbGRPclVwZGF0ZURhdGEgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIGZpZWxkT3JVcGRhdGVEYXRhIGluc3RhbmNlb2YgRmllbGRQYXRoKSB7XG4gICAgICAgIHBhcnNlZCA9IHBhcnNlVXBkYXRlVmFyYXJncyhkYXRhUmVhZGVyLCAndXBkYXRlRG9jJywgcmVmZXJlbmNlLl9rZXksIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgbW9yZUZpZWxkc0FuZFZhbHVlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZURhdGEoZGF0YVJlYWRlciwgJ3VwZGF0ZURvYycsIHJlZmVyZW5jZS5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IG11dGF0aW9uID0gcGFyc2VkLnRvTXV0YXRpb24ocmVmZXJlbmNlLl9rZXksIFByZWNvbmRpdGlvbi5leGlzdHModHJ1ZSkpO1xuICAgIHJldHVybiBleGVjdXRlV3JpdGUoZmlyZXN0b3JlLCBbbXV0YXRpb25dKTtcbn1cbi8qKlxuICogRGVsZXRlcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhlIHNwZWNpZmllZCBgRG9jdW1lbnRSZWZlcmVuY2VgLlxuICpcbiAqIEBwYXJhbSByZWZlcmVuY2UgLSBBIHJlZmVyZW5jZSB0byB0aGUgZG9jdW1lbnQgdG8gZGVsZXRlLlxuICogQHJldHVybnMgQSBQcm9taXNlIHJlc29sdmVkIG9uY2UgdGhlIGRvY3VtZW50IGhhcyBiZWVuIHN1Y2Nlc3NmdWxseVxuICogZGVsZXRlZCBmcm9tIHRoZSBiYWNrZW5kIChub3RlIHRoYXQgaXQgd29uJ3QgcmVzb2x2ZSB3aGlsZSB5b3UncmUgb2ZmbGluZSkuXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZURvYyhyZWZlcmVuY2UpIHtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgbXV0YXRpb25zID0gW25ldyBEZWxldGVNdXRhdGlvbihyZWZlcmVuY2UuX2tleSwgUHJlY29uZGl0aW9uLm5vbmUoKSldO1xuICAgIHJldHVybiBleGVjdXRlV3JpdGUoZmlyZXN0b3JlLCBtdXRhdGlvbnMpO1xufVxuLyoqXG4gKiBBZGQgYSBuZXcgZG9jdW1lbnQgdG8gc3BlY2lmaWVkIGBDb2xsZWN0aW9uUmVmZXJlbmNlYCB3aXRoIHRoZSBnaXZlbiBkYXRhLFxuICogYXNzaWduaW5nIGl0IGEgZG9jdW1lbnQgSUQgYXV0b21hdGljYWxseS5cbiAqXG4gKiBAcGFyYW0gcmVmZXJlbmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIGNvbGxlY3Rpb24gdG8gYWRkIHRoaXMgZG9jdW1lbnQgdG8uXG4gKiBAcGFyYW0gZGF0YSAtIEFuIE9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhIGZvciB0aGUgbmV3IGRvY3VtZW50LlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgcmVzb2x2ZWQgd2l0aCBhIGBEb2N1bWVudFJlZmVyZW5jZWAgcG9pbnRpbmcgdG8gdGhlXG4gKiBuZXdseSBjcmVhdGVkIGRvY3VtZW50IGFmdGVyIGl0IGhhcyBiZWVuIHdyaXR0ZW4gdG8gdGhlIGJhY2tlbmQgKE5vdGUgdGhhdCBpdFxuICogd29uJ3QgcmVzb2x2ZSB3aGlsZSB5b3UncmUgb2ZmbGluZSkuXG4gKi9cbmZ1bmN0aW9uIGFkZERvYyhyZWZlcmVuY2UsIGRhdGEpIHtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgZG9jUmVmID0gZG9jKHJlZmVyZW5jZSk7XG4gICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBhcHBseUZpcmVzdG9yZURhdGFDb252ZXJ0ZXIocmVmZXJlbmNlLmNvbnZlcnRlciwgZGF0YSk7XG4gICAgY29uc3QgZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKHJlZmVyZW5jZS5maXJlc3RvcmUpO1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2V0RGF0YShkYXRhUmVhZGVyLCAnYWRkRG9jJywgZG9jUmVmLl9rZXksIGNvbnZlcnRlZFZhbHVlLCByZWZlcmVuY2UuY29udmVydGVyICE9PSBudWxsLCB7fSk7XG4gICAgY29uc3QgbXV0YXRpb24gPSBwYXJzZWQudG9NdXRhdGlvbihkb2NSZWYuX2tleSwgUHJlY29uZGl0aW9uLmV4aXN0cyhmYWxzZSkpO1xuICAgIHJldHVybiBleGVjdXRlV3JpdGUoZmlyZXN0b3JlLCBbbXV0YXRpb25dKS50aGVuKCgpID0+IGRvY1JlZik7XG59XG5mdW5jdGlvbiBvblNuYXBzaG90KHJlZmVyZW5jZSwgLi4uYXJncykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJlZmVyZW5jZSA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWZlcmVuY2UpO1xuICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzOiBmYWxzZSxcbiAgICAgICAgc291cmNlOiAnZGVmYXVsdCdcbiAgICB9O1xuICAgIGxldCBjdXJyQXJnID0gMDtcbiAgICBpZiAodHlwZW9mIGFyZ3NbY3VyckFyZ10gPT09ICdvYmplY3QnICYmICFpc1BhcnRpYWxPYnNlcnZlcihhcmdzW2N1cnJBcmddKSkge1xuICAgICAgICBvcHRpb25zID0gYXJnc1tjdXJyQXJnXTtcbiAgICAgICAgY3VyckFyZysrO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcm5hbE9wdGlvbnMgPSB7XG4gICAgICAgIGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM6IG9wdGlvbnMuaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyxcbiAgICAgICAgc291cmNlOiBvcHRpb25zLnNvdXJjZVxuICAgIH07XG4gICAgaWYgKGlzUGFydGlhbE9ic2VydmVyKGFyZ3NbY3VyckFyZ10pKSB7XG4gICAgICAgIGNvbnN0IHVzZXJPYnNlcnZlciA9IGFyZ3NbY3VyckFyZ107XG4gICAgICAgIGFyZ3NbY3VyckFyZ10gPSAoX2EgPSB1c2VyT2JzZXJ2ZXIubmV4dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJpbmQodXNlck9ic2VydmVyKTtcbiAgICAgICAgYXJnc1tjdXJyQXJnICsgMV0gPSAoX2IgPSB1c2VyT2JzZXJ2ZXIuZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5iaW5kKHVzZXJPYnNlcnZlcik7XG4gICAgICAgIGFyZ3NbY3VyckFyZyArIDJdID0gKF9jID0gdXNlck9ic2VydmVyLmNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmluZCh1c2VyT2JzZXJ2ZXIpO1xuICAgIH1cbiAgICBsZXQgb2JzZXJ2ZXI7XG4gICAgbGV0IGZpcmVzdG9yZTtcbiAgICBsZXQgaW50ZXJuYWxRdWVyeTtcbiAgICBpZiAocmVmZXJlbmNlIGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpIHtcbiAgICAgICAgZmlyZXN0b3JlID0gY2FzdChyZWZlcmVuY2UuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgICAgICBpbnRlcm5hbFF1ZXJ5ID0gbmV3UXVlcnlGb3JQYXRoKHJlZmVyZW5jZS5fa2V5LnBhdGgpO1xuICAgICAgICBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgIG5leHQ6IHNuYXBzaG90ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnc1tjdXJyQXJnXSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW2N1cnJBcmddKGNvbnZlcnRUb0RvY1NuYXBzaG90KGZpcmVzdG9yZSwgcmVmZXJlbmNlLCBzbmFwc2hvdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogYXJnc1tjdXJyQXJnICsgMV0sXG4gICAgICAgICAgICBjb21wbGV0ZTogYXJnc1tjdXJyQXJnICsgMl1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gY2FzdChyZWZlcmVuY2UsIFF1ZXJ5KTtcbiAgICAgICAgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgICAgIGludGVybmFsUXVlcnkgPSBxdWVyeS5fcXVlcnk7XG4gICAgICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKGZpcmVzdG9yZSk7XG4gICAgICAgIG9ic2VydmVyID0ge1xuICAgICAgICAgICAgbmV4dDogc25hcHNob3QgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzW2N1cnJBcmddKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbY3VyckFyZ10obmV3IFF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcXVlcnksIHNuYXBzaG90KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBhcmdzW2N1cnJBcmcgKyAxXSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBhcmdzW2N1cnJBcmcgKyAyXVxuICAgICAgICB9O1xuICAgICAgICB2YWxpZGF0ZUhhc0V4cGxpY2l0T3JkZXJCeUZvckxpbWl0VG9MYXN0KHJlZmVyZW5jZS5fcXVlcnkpO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudExpc3RlbihjbGllbnQsIGludGVybmFsUXVlcnksIGludGVybmFsT3B0aW9ucywgb2JzZXJ2ZXIpO1xufVxuZnVuY3Rpb24gb25TbmFwc2hvdHNJblN5bmMoZmlyZXN0b3JlLCBhcmcpIHtcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBpc1BhcnRpYWxPYnNlcnZlcihhcmcpXG4gICAgICAgID8gYXJnXG4gICAgICAgIDoge1xuICAgICAgICAgICAgbmV4dDogYXJnXG4gICAgICAgIH07XG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEFkZFNuYXBzaG90c0luU3luY0xpc3RlbmVyKGNsaWVudCwgb2JzZXJ2ZXIpO1xufVxuLyoqXG4gKiBMb2NhbGx5IHdyaXRlcyBgbXV0YXRpb25zYCBvbiB0aGUgYXN5bmMgcXVldWUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgbXV0YXRpb25zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRXcml0ZShjbGllbnQsIG11dGF0aW9ucyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIFZpZXdTbmFwc2hvdH0gdGhhdCBjb250YWlucyB0aGUgc2luZ2xlIGRvY3VtZW50IHNwZWNpZmllZCBieSBgcmVmYFxuICogdG8gYSB7QGxpbmsgRG9jdW1lbnRTbmFwc2hvdH0uXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb0RvY1NuYXBzaG90KGZpcmVzdG9yZSwgcmVmLCBzbmFwc2hvdCkge1xuICAgIGNvbnN0IGRvYyA9IHNuYXBzaG90LmRvY3MuZ2V0KHJlZi5fa2V5KTtcbiAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcihmaXJlc3RvcmUpO1xuICAgIHJldHVybiBuZXcgRG9jdW1lbnRTbmFwc2hvdChmaXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCByZWYuX2tleSwgZG9jLCBuZXcgU25hcHNob3RNZXRhZGF0YShzbmFwc2hvdC5oYXNQZW5kaW5nV3JpdGVzLCBzbmFwc2hvdC5mcm9tQ2FjaGUpLCByZWYuY29udmVydGVyKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBpbiB0aGUgcmVzdWx0IHNldCBvZiB0aGUgZ2l2ZW4gcXVlcnlcbiAqIHdpdGhvdXQgYWN0dWFsbHkgZG93bmxvYWRpbmcgdGhlIGRvY3VtZW50cy5cbiAqXG4gKiBVc2luZyB0aGlzIGZ1bmN0aW9uIHRvIGNvdW50IHRoZSBkb2N1bWVudHMgaXMgZWZmaWNpZW50IGJlY2F1c2Ugb25seSB0aGVcbiAqIGZpbmFsIGNvdW50LCBub3QgdGhlIGRvY3VtZW50cycgZGF0YSwgaXMgZG93bmxvYWRlZC4gVGhpcyBmdW5jdGlvbiBjYW5cbiAqIGNvdW50IHRoZSBkb2N1bWVudHMgaW4gY2FzZXMgd2hlcmUgdGhlIHJlc3VsdCBzZXQgaXMgcHJvaGliaXRpdmVseSBsYXJnZSB0b1xuICogZG93bmxvYWQgZW50aXJlbHkgKHRob3VzYW5kcyBvZiBkb2N1bWVudHMpLlxuICpcbiAqIFRoZSByZXN1bHQgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIGlzIHByZXNlbnRlZCwgdW5hbHRlcmVkLCB3aXRob3V0XG4gKiBjb25zaWRlcmluZyBhbnkgbG9jYWwgc3RhdGUuIFRoYXQgaXMsIGRvY3VtZW50cyBpbiB0aGUgbG9jYWwgY2FjaGUgYXJlIG5vdFxuICogdGFrZW4gaW50byBjb25zaWRlcmF0aW9uLCBuZWl0aGVyIGFyZSBsb2NhbCBtb2RpZmljYXRpb25zIG5vdCB5ZXRcbiAqIHN5bmNocm9uaXplZCB3aXRoIHRoZSBzZXJ2ZXIuIFByZXZpb3VzbHktZG93bmxvYWRlZCByZXN1bHRzLCBpZiBhbnksIGFyZSBub3RcbiAqIHVzZWQuIEV2ZXJ5IGludm9jYXRpb24gb2YgdGhpcyBmdW5jdGlvbiBuZWNlc3NhcmlseSBpbnZvbHZlcyBhIHJvdW5kIHRyaXAgdG9cbiAqIHRoZSBzZXJ2ZXIuXG4gKlxuICogQHBhcmFtIHF1ZXJ5IFRoZSBxdWVyeSB3aG9zZSByZXN1bHQgc2V0IHNpemUgaXMgY2FsY3VsYXRlZC5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgY291bnQ7IHRoZSBjb3VudCBjYW4gYmVcbiAqIHJldHJpZXZlZCBmcm9tIGBzbmFwc2hvdC5kYXRhKCkuY291bnRgLCB3aGVyZSBgc25hcHNob3RgIGlzIHRoZVxuICogYEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3RgIHRvIHdoaWNoIHRoZSByZXR1cm5lZCBQcm9taXNlIHJlc29sdmVzLlxuICovXG5mdW5jdGlvbiBnZXRDb3VudEZyb21TZXJ2ZXIocXVlcnkpIHtcbiAgICBjb25zdCBjb3VudFF1ZXJ5U3BlYyA9IHtcbiAgICAgICAgY291bnQ6IGNvdW50KClcbiAgICB9O1xuICAgIHJldHVybiBnZXRBZ2dyZWdhdGVGcm9tU2VydmVyKHF1ZXJ5LCBjb3VudFF1ZXJ5U3BlYyk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNwZWNpZmllZCBhZ2dyZWdhdGlvbnMgb3ZlciB0aGUgZG9jdW1lbnRzIGluIHRoZSByZXN1bHRcbiAqIHNldCBvZiB0aGUgZ2l2ZW4gcXVlcnkgd2l0aG91dCBhY3R1YWxseSBkb3dubG9hZGluZyB0aGUgZG9jdW1lbnRzLlxuICpcbiAqIFVzaW5nIHRoaXMgZnVuY3Rpb24gdG8gcGVyZm9ybSBhZ2dyZWdhdGlvbnMgaXMgZWZmaWNpZW50IGJlY2F1c2Ugb25seSB0aGVcbiAqIGZpbmFsIGFnZ3JlZ2F0aW9uIHZhbHVlcywgbm90IHRoZSBkb2N1bWVudHMnIGRhdGEsIGFyZSBkb3dubG9hZGVkLiBUaGlzXG4gKiBmdW5jdGlvbiBjYW4gcGVyZm9ybSBhZ2dyZWdhdGlvbnMgb2YgdGhlIGRvY3VtZW50cyBpbiBjYXNlcyB3aGVyZSB0aGUgcmVzdWx0XG4gKiBzZXQgaXMgcHJvaGliaXRpdmVseSBsYXJnZSB0byBkb3dubG9hZCBlbnRpcmVseSAodGhvdXNhbmRzIG9mIGRvY3VtZW50cykuXG4gKlxuICogVGhlIHJlc3VsdCByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgaXMgcHJlc2VudGVkLCB1bmFsdGVyZWQsIHdpdGhvdXRcbiAqIGNvbnNpZGVyaW5nIGFueSBsb2NhbCBzdGF0ZS4gVGhhdCBpcywgZG9jdW1lbnRzIGluIHRoZSBsb2NhbCBjYWNoZSBhcmUgbm90XG4gKiB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb24sIG5laXRoZXIgYXJlIGxvY2FsIG1vZGlmaWNhdGlvbnMgbm90IHlldFxuICogc3luY2hyb25pemVkIHdpdGggdGhlIHNlcnZlci4gUHJldmlvdXNseS1kb3dubG9hZGVkIHJlc3VsdHMsIGlmIGFueSwgYXJlIG5vdFxuICogdXNlZC4gRXZlcnkgaW52b2NhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIG5lY2Vzc2FyaWx5IGludm9sdmVzIGEgcm91bmQgdHJpcCB0b1xuICogdGhlIHNlcnZlci5cbiAqXG4gKiBAcGFyYW0gcXVlcnkgVGhlIHF1ZXJ5IHdob3NlIHJlc3VsdCBzZXQgaXMgYWdncmVnYXRlZCBvdmVyLlxuICogQHBhcmFtIGFnZ3JlZ2F0ZVNwZWMgQW4gYEFnZ3JlZ2F0ZVNwZWNgIG9iamVjdCB0aGF0IHNwZWNpZmllcyB0aGUgYWdncmVnYXRlc1xuICogdG8gcGVyZm9ybSBvdmVyIHRoZSByZXN1bHQgc2V0LiBUaGUgQWdncmVnYXRlU3BlYyBzcGVjaWZpZXMgYWxpYXNlcyBmb3IgZWFjaFxuICogYWdncmVnYXRlLCB3aGljaCBjYW4gYmUgdXNlZCB0byByZXRyaWV2ZSB0aGUgYWdncmVnYXRlIHJlc3VsdC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBhZ2dyZWdhdGVTbmFwc2hvdCA9IGF3YWl0IGdldEFnZ3JlZ2F0ZUZyb21TZXJ2ZXIocXVlcnksIHtcbiAqICAgY291bnRPZkRvY3M6IGNvdW50KCksXG4gKiAgIHRvdGFsSG91cnM6IHN1bSgnaG91cnMnKSxcbiAqICAgYXZlcmFnZVNjb3JlOiBhdmVyYWdlKCdzY29yZScpXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBjb3VudE9mRG9jczogbnVtYmVyID0gYWdncmVnYXRlU25hcHNob3QuZGF0YSgpLmNvdW50T2ZEb2NzO1xuICogY29uc3QgdG90YWxIb3VyczogbnVtYmVyID0gYWdncmVnYXRlU25hcHNob3QuZGF0YSgpLnRvdGFsSG91cnM7XG4gKiBjb25zdCBhdmVyYWdlU2NvcmU6IG51bWJlciB8IG51bGwgPSBhZ2dyZWdhdGVTbmFwc2hvdC5kYXRhKCkuYXZlcmFnZVNjb3JlO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGdldEFnZ3JlZ2F0ZUZyb21TZXJ2ZXIocXVlcnksIGFnZ3JlZ2F0ZVNwZWMpIHtcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHF1ZXJ5LmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgY29uc3QgaW50ZXJuYWxBZ2dyZWdhdGVzID0gbWFwVG9BcnJheShhZ2dyZWdhdGVTcGVjLCAoYWdncmVnYXRlLCBhbGlhcykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0ZUltcGwoYWxpYXMsIGFnZ3JlZ2F0ZS5hZ2dyZWdhdGVUeXBlLCBhZ2dyZWdhdGUuX2ludGVybmFsRmllbGRQYXRoKTtcbiAgICB9KTtcbiAgICAvLyBSdW4gdGhlIGFnZ3JlZ2F0aW9uIGFuZCBjb252ZXJ0IHRoZSByZXN1bHRzXG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudFJ1bkFnZ3JlZ2F0ZVF1ZXJ5KGNsaWVudCwgcXVlcnkuX3F1ZXJ5LCBpbnRlcm5hbEFnZ3JlZ2F0ZXMpLnRoZW4oYWdncmVnYXRlUmVzdWx0ID0+IGNvbnZlcnRUb0FnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCBxdWVyeSwgYWdncmVnYXRlUmVzdWx0KSk7XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBjb3JlIGFnZ3JlZ2F0aW9uIHJlc3VsdCB0byBhbiBgQWdncmVnYXRlUXVlcnlTbmFwc2hvdGBcbiAqIHRoYXQgY2FuIGJlIHJldHVybmVkIHRvIHRoZSBjb25zdW1lci5cbiAqIEBwYXJhbSBxdWVyeVxuICogQHBhcmFtIGFnZ3JlZ2F0ZVJlc3VsdCBDb3JlIGFnZ3JlZ2F0aW9uIHJlc3VsdFxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb0FnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCBxdWVyeSwgYWdncmVnYXRlUmVzdWx0KSB7XG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gbmV3IEFnZ3JlZ2F0ZVF1ZXJ5U25hcHNob3QocXVlcnksIHVzZXJEYXRhV3JpdGVyLCBhZ2dyZWdhdGVSZXN1bHQpO1xuICAgIHJldHVybiBxdWVyeVNuYXBzaG90O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTWVtb3J5TG9jYWxDYWNoZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdtZW1vcnknO1xuICAgICAgICB0aGlzLl9vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IE9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnByb3ZpZGVyO1xuICAgICAgICBpZiAoc2V0dGluZ3MgPT09IG51bGwgfHwgc2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldHRpbmdzLmdhcmJhZ2VDb2xsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX29mZmxpbmVDb21wb25lbnRQcm92aWRlciA9XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZ2FyYmFnZUNvbGxlY3Rvci5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyID0ge1xuICAgICAgICAgICAgICAgIGJ1aWxkOiAoKSA9PiBuZXcgTHJ1R2NNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIodW5kZWZpbmVkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQ6IHRoaXMua2luZCB9O1xuICAgIH1cbn1cbmNsYXNzIFBlcnNpc3RlbnRMb2NhbENhY2hlSW1wbCB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5raW5kID0gJ3BlcnNpc3RlbnQnO1xuICAgICAgICBsZXQgdGFiTWFuYWdlcjtcbiAgICAgICAgaWYgKHNldHRpbmdzID09PSBudWxsIHx8IHNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXR0aW5ncy50YWJNYW5hZ2VyKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy50YWJNYW5hZ2VyLl9pbml0aWFsaXplKHNldHRpbmdzKTtcbiAgICAgICAgICAgIHRhYk1hbmFnZXIgPSBzZXR0aW5ncy50YWJNYW5hZ2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFiTWFuYWdlciA9IHBlcnNpc3RlbnRTaW5nbGVUYWJNYW5hZ2VyKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB0YWJNYW5hZ2VyLl9pbml0aWFsaXplKHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IHRhYk1hbmFnZXIuX29ubGluZUNvbXBvbmVudFByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSB0YWJNYW5hZ2VyLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXI7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsga2luZDogdGhpcy5raW5kIH07XG4gICAgfVxufVxuY2xhc3MgTWVtb3J5RWFnZXJHYXJiYWdlQ29sbGVjdG9ySW1wbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdtZW1vcnlFYWdlcic7XG4gICAgICAgIHRoaXMuX29mZmxpbmVDb21wb25lbnRQcm92aWRlciA9IE1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlci5wcm92aWRlcjtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBraW5kOiB0aGlzLmtpbmQgfTtcbiAgICB9XG59XG5jbGFzcyBNZW1vcnlMcnVHYXJiYWdlQ29sbGVjdG9ySW1wbCB7XG4gICAgY29uc3RydWN0b3IoY2FjaGVTaXplKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdtZW1vcnlMcnUnO1xuICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSB7XG4gICAgICAgICAgICBidWlsZDogKCkgPT4gbmV3IExydUdjTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKGNhY2hlU2l6ZSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBraW5kOiB0aGlzLmtpbmQgfTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYE1lbW9yeUVhZ2VyR2FyYmFnZUNvbGxlY3RvcmAuIFRoaXMgaXMgYWxzbyB0aGVcbiAqIGRlZmF1bHQgZ2FyYmFnZSBjb2xsZWN0b3IgdW5sZXNzIGl0IGlzIGV4cGxpY2l0bHkgc3BlY2lmaWVkIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gbWVtb3J5RWFnZXJHYXJiYWdlQ29sbGVjdG9yKCkge1xuICAgIHJldHVybiBuZXcgTWVtb3J5RWFnZXJHYXJiYWdlQ29sbGVjdG9ySW1wbCgpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBNZW1vcnlMcnVHYXJiYWdlQ29sbGVjdG9yYC5cbiAqXG4gKiBBIHRhcmdldCBzaXplIGNhbiBiZSBzcGVjaWZpZWQgYXMgcGFydCBvZiB0aGUgc2V0dGluZyBwYXJhbWV0ZXIuIFRoZVxuICogY29sbGVjdG9yIHdpbGwgc3RhcnQgZGVsZXRpbmcgZG9jdW1lbnRzIG9uY2UgdGhlIGNhY2hlIHNpemUgZXhjZWVkc1xuICogdGhlIGdpdmVuIHNpemUuIFRoZSBkZWZhdWx0IGNhY2hlIHNpemUgaXMgNDBNQiAoNDAgKiAxMDI0ICogMTAyNCBieXRlcykuXG4gKi9cbmZ1bmN0aW9uIG1lbW9yeUxydUdhcmJhZ2VDb2xsZWN0b3Ioc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IE1lbW9yeUxydUdhcmJhZ2VDb2xsZWN0b3JJbXBsKHNldHRpbmdzID09PSBudWxsIHx8IHNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYE1lbW9yeUxvY2FsQ2FjaGVgLiBUaGUgaW5zdGFuY2UgY2FuIGJlIHNldCB0b1xuICogYEZpcmVzdG9yZVNldHRpbmdzLmNhY2hlYCB0byB0ZWxsIHRoZSBTREsgd2hpY2ggY2FjaGUgbGF5ZXIgdG8gdXNlLlxuICovXG5mdW5jdGlvbiBtZW1vcnlMb2NhbENhY2hlKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBNZW1vcnlMb2NhbENhY2hlSW1wbChzZXR0aW5ncyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYFBlcnNpc3RlbnRMb2NhbENhY2hlYC4gVGhlIGluc3RhbmNlIGNhbiBiZSBzZXQgdG9cbiAqIGBGaXJlc3RvcmVTZXR0aW5ncy5jYWNoZWAgdG8gdGVsbCB0aGUgU0RLIHdoaWNoIGNhY2hlIGxheWVyIHRvIHVzZS5cbiAqXG4gKiBQZXJzaXN0ZW50IGNhY2hlIGNhbm5vdCBiZSB1c2VkIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudC5cbiAqL1xuZnVuY3Rpb24gcGVyc2lzdGVudExvY2FsQ2FjaGUoc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IFBlcnNpc3RlbnRMb2NhbENhY2hlSW1wbChzZXR0aW5ncyk7XG59XG5jbGFzcyBTaW5nbGVUYWJNYW5hZ2VySW1wbCB7XG4gICAgY29uc3RydWN0b3IoZm9yY2VPd25lcnNoaXApIHtcbiAgICAgICAgdGhpcy5mb3JjZU93bmVyc2hpcCA9IGZvcmNlT3duZXJzaGlwO1xuICAgICAgICB0aGlzLmtpbmQgPSAncGVyc2lzdGVudFNpbmdsZVRhYic7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsga2luZDogdGhpcy5raW5kIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9pbml0aWFsaXplKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuX29ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gT25saW5lQ29tcG9uZW50UHJvdmlkZXIucHJvdmlkZXI7XG4gICAgICAgIHRoaXMuX29mZmxpbmVDb21wb25lbnRQcm92aWRlciA9IHtcbiAgICAgICAgICAgIGJ1aWxkOiAob25saW5lQ29tcG9uZW50cykgPT4gbmV3IEluZGV4ZWREYk9mZmxpbmVDb21wb25lbnRQcm92aWRlcihvbmxpbmVDb21wb25lbnRzLCBzZXR0aW5ncyA9PT0gbnVsbCB8fCBzZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMsIHRoaXMuZm9yY2VPd25lcnNoaXApXG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgTXVsdGlUYWJNYW5hZ2VySW1wbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdQZXJzaXN0ZW50TXVsdGlwbGVUYWInO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQ6IHRoaXMua2luZCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZShzZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IE9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9vZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSB7XG4gICAgICAgICAgICBidWlsZDogKG9ubGluZUNvbXBvbmVudHMpID0+IG5ldyBNdWx0aVRhYk9mZmxpbmVDb21wb25lbnRQcm92aWRlcihvbmxpbmVDb21wb25lbnRzLCBzZXR0aW5ncyA9PT0gbnVsbCB8fCBzZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMpXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBQZXJzaXN0ZW50U2luZ2xlVGFiTWFuYWdlcmAuXG4gKlxuICogQHBhcmFtIHNldHRpbmdzIENvbmZpZ3VyZXMgdGhlIGNyZWF0ZWQgdGFiIG1hbmFnZXIuXG4gKi9cbmZ1bmN0aW9uIHBlcnNpc3RlbnRTaW5nbGVUYWJNYW5hZ2VyKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBTaW5nbGVUYWJNYW5hZ2VySW1wbChzZXR0aW5ncyA9PT0gbnVsbCB8fCBzZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0dGluZ3MuZm9yY2VPd25lcnNoaXApO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBQZXJzaXN0ZW50TXVsdGlwbGVUYWJNYW5hZ2VyYC5cbiAqL1xuZnVuY3Rpb24gcGVyc2lzdGVudE11bHRpcGxlVGFiTWFuYWdlcigpIHtcbiAgICByZXR1cm4gbmV3IE11bHRpVGFiTWFuYWdlckltcGwoKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERFRkFVTFRfVFJBTlNBQ1RJT05fT1BUSU9OUyA9IHtcbiAgICBtYXhBdHRlbXB0czogNVxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlVHJhbnNhY3Rpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5tYXhBdHRlbXB0cyA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ01heCBhdHRlbXB0cyBtdXN0IGJlIGF0IGxlYXN0IDEnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgd3JpdGUgYmF0Y2gsIHVzZWQgdG8gcGVyZm9ybSBtdWx0aXBsZSB3cml0ZXMgYXMgYSBzaW5nbGUgYXRvbWljIHVuaXQuXG4gKlxuICogQSBgV3JpdGVCYXRjaGAgb2JqZWN0IGNhbiBiZSBhY3F1aXJlZCBieSBjYWxsaW5nIHtAbGluayB3cml0ZUJhdGNofS4gSXRcbiAqIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGFkZGluZyB3cml0ZXMgdG8gdGhlIHdyaXRlIGJhdGNoLiBOb25lIG9mIHRoZSB3cml0ZXNcbiAqIHdpbGwgYmUgY29tbWl0dGVkIChvciB2aXNpYmxlIGxvY2FsbHkpIHVudGlsIHtAbGluayBXcml0ZUJhdGNoLmNvbW1pdH0gaXNcbiAqIGNhbGxlZC5cbiAqL1xuY2xhc3MgV3JpdGVCYXRjaCB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlLCBfY29tbWl0SGFuZGxlcikge1xuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xuICAgICAgICB0aGlzLl9jb21taXRIYW5kbGVyID0gX2NvbW1pdEhhbmRsZXI7XG4gICAgICAgIHRoaXMuX211dGF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9jb21taXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKF9maXJlc3RvcmUpO1xuICAgIH1cbiAgICBzZXQoZG9jdW1lbnRSZWYsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5Tm90Q29tbWl0dGVkKCk7XG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGFwcGx5RmlyZXN0b3JlRGF0YUNvbnZlcnRlcihyZWYuY29udmVydGVyLCBkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTZXREYXRhKHRoaXMuX2RhdGFSZWFkZXIsICdXcml0ZUJhdGNoLnNldCcsIHJlZi5fa2V5LCBjb252ZXJ0ZWRWYWx1ZSwgcmVmLmNvbnZlcnRlciAhPT0gbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX211dGF0aW9ucy5wdXNoKHBhcnNlZC50b011dGF0aW9uKHJlZi5fa2V5LCBQcmVjb25kaXRpb24ubm9uZSgpKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1cGRhdGUoZG9jdW1lbnRSZWYsIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgLi4ubW9yZUZpZWxkc0FuZFZhbHVlcykge1xuICAgICAgICB0aGlzLl92ZXJpZnlOb3RDb21taXR0ZWQoKTtcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XG4gICAgICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXG4gICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cbiAgICAgICAgZmllbGRPclVwZGF0ZURhdGEgPSBnZXRNb2R1bGFySW5zdGFuY2UoZmllbGRPclVwZGF0ZURhdGEpO1xuICAgICAgICBsZXQgcGFyc2VkO1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkT3JVcGRhdGVEYXRhID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgZmllbGRPclVwZGF0ZURhdGEgaW5zdGFuY2VvZiBGaWVsZFBhdGgpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlVXBkYXRlVmFyYXJncyh0aGlzLl9kYXRhUmVhZGVyLCAnV3JpdGVCYXRjaC51cGRhdGUnLCByZWYuX2tleSwgZmllbGRPclVwZGF0ZURhdGEsIHZhbHVlLCBtb3JlRmllbGRzQW5kVmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlVXBkYXRlRGF0YSh0aGlzLl9kYXRhUmVhZGVyLCAnV3JpdGVCYXRjaC51cGRhdGUnLCByZWYuX2tleSwgZmllbGRPclVwZGF0ZURhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX211dGF0aW9ucy5wdXNoKHBhcnNlZC50b011dGF0aW9uKHJlZi5fa2V5LCBQcmVjb25kaXRpb24uZXhpc3RzKHRydWUpKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBkb2N1bWVudCByZWZlcnJlZCB0byBieSB0aGUgcHJvdmlkZWQge0BsaW5rIERvY3VtZW50UmVmZXJlbmNlfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb2N1bWVudFJlZiAtIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0byBiZSBkZWxldGVkLlxuICAgICAqIEByZXR1cm5zIFRoaXMgYFdyaXRlQmF0Y2hgIGluc3RhbmNlLiBVc2VkIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgZGVsZXRlKGRvY3VtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3ZlcmlmeU5vdENvbW1pdHRlZCgpO1xuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcbiAgICAgICAgdGhpcy5fbXV0YXRpb25zID0gdGhpcy5fbXV0YXRpb25zLmNvbmNhdChuZXcgRGVsZXRlTXV0YXRpb24ocmVmLl9rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbW1pdHMgYWxsIG9mIHRoZSB3cml0ZXMgaW4gdGhpcyB3cml0ZSBiYXRjaCBhcyBhIHNpbmdsZSBhdG9taWMgdW5pdC5cbiAgICAgKlxuICAgICAqIFRoZSByZXN1bHQgb2YgdGhlc2Ugd3JpdGVzIHdpbGwgb25seSBiZSByZWZsZWN0ZWQgaW4gZG9jdW1lbnQgcmVhZHMgdGhhdFxuICAgICAqIG9jY3VyIGFmdGVyIHRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzLiBJZiB0aGUgY2xpZW50IGlzIG9mZmxpbmUsIHRoZVxuICAgICAqIHdyaXRlIGZhaWxzLiBJZiB5b3Ugd291bGQgbGlrZSB0byBzZWUgbG9jYWwgbW9kaWZpY2F0aW9ucyBvciBidWZmZXIgd3JpdGVzXG4gICAgICogdW50aWwgdGhlIGNsaWVudCBpcyBvbmxpbmUsIHVzZSB0aGUgZnVsbCBGaXJlc3RvcmUgU0RLLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBgUHJvbWlzZWAgcmVzb2x2ZWQgb25jZSBhbGwgb2YgdGhlIHdyaXRlcyBpbiB0aGUgYmF0Y2ggaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4gdG8gdGhlIGJhY2tlbmQgYXMgYW4gYXRvbWljIHVuaXQgKG5vdGUgdGhhdCBpdCB3b24ndFxuICAgICAqIHJlc29sdmUgd2hpbGUgeW91J3JlIG9mZmxpbmUpLlxuICAgICAqL1xuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5Tm90Q29tbWl0dGVkKCk7XG4gICAgICAgIHRoaXMuX2NvbW1pdHRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9tdXRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1pdEhhbmRsZXIodGhpcy5fbXV0YXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIF92ZXJpZnlOb3RDb21taXR0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21taXR0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdBIHdyaXRlIGJhdGNoIGNhbiBubyBsb25nZXIgYmUgdXNlZCBhZnRlciBjb21taXQoKSAnICtcbiAgICAgICAgICAgICAgICAnaGFzIGJlZW4gY2FsbGVkLicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIGZpcmVzdG9yZSkge1xuICAgIGRvY3VtZW50UmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKGRvY3VtZW50UmVmKTtcbiAgICBpZiAoZG9jdW1lbnRSZWYuZmlyZXN0b3JlICE9PSBmaXJlc3RvcmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1Byb3ZpZGVkIGRvY3VtZW50IHJlZmVyZW5jZSBpcyBmcm9tIGEgZGlmZmVyZW50IEZpcmVzdG9yZSBpbnN0YW5jZS4nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudFJlZjtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBUT0RPKG1yc2NobWlkdCkgQ29uc2lkZXIgdXNpbmcgYEJhc2VUcmFuc2FjdGlvbmAgYXMgdGhlIGJhc2UgY2xhc3MgaW4gdGhlXG4vLyBsZWdhY3kgU0RLLlxuLyoqXG4gKiBBIHJlZmVyZW5jZSB0byBhIHRyYW5zYWN0aW9uLlxuICpcbiAqIFRoZSBgVHJhbnNhY3Rpb25gIG9iamVjdCBwYXNzZWQgdG8gYSB0cmFuc2FjdGlvbidzIGB1cGRhdGVGdW5jdGlvbmAgcHJvdmlkZXNcbiAqIHRoZSBtZXRob2RzIHRvIHJlYWQgYW5kIHdyaXRlIGRhdGEgd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBjb250ZXh0LiBTZWVcbiAqIHtAbGluayBydW5UcmFuc2FjdGlvbn0uXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uJDEge1xuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSwgX3RyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gX3RyYW5zYWN0aW9uO1xuICAgICAgICB0aGlzLl9kYXRhUmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIoX2ZpcmVzdG9yZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcmVuY2VkIGJ5IHRoZSBwcm92aWRlZCB7QGxpbmsgRG9jdW1lbnRSZWZlcmVuY2V9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50UmVmIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGJlIHJlYWQuXG4gICAgICogQHJldHVybnMgQSBgRG9jdW1lbnRTbmFwc2hvdGAgd2l0aCB0aGUgcmVhZCBkYXRhLlxuICAgICAqL1xuICAgIGdldChkb2N1bWVudFJlZikge1xuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcbiAgICAgICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgTGl0ZVVzZXJEYXRhV3JpdGVyKHRoaXMuX2ZpcmVzdG9yZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbi5sb29rdXAoW3JlZi5fa2V5XSkudGhlbihkb2NzID0+IHtcbiAgICAgICAgICAgIGlmICghZG9jcyB8fCBkb2NzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkb2MgPSBkb2NzWzBdO1xuICAgICAgICAgICAgaWYgKGRvYy5pc0ZvdW5kRG9jdW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRTbmFwc2hvdCQxKHRoaXMuX2ZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIGRvYy5rZXksIGRvYywgcmVmLmNvbnZlcnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb2MuaXNOb0RvY3VtZW50KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50U25hcHNob3QkMSh0aGlzLl9maXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCByZWYuX2tleSwgbnVsbCwgcmVmLmNvbnZlcnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBmYWlsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXQoZG9jdW1lbnRSZWYsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGFwcGx5RmlyZXN0b3JlRGF0YUNvbnZlcnRlcihyZWYuY29udmVydGVyLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2V0RGF0YSh0aGlzLl9kYXRhUmVhZGVyLCAnVHJhbnNhY3Rpb24uc2V0JywgcmVmLl9rZXksIGNvbnZlcnRlZFZhbHVlLCByZWYuY29udmVydGVyICE9PSBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24uc2V0KHJlZi5fa2V5LCBwYXJzZWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdXBkYXRlKGRvY3VtZW50UmVmLCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIC4uLm1vcmVGaWVsZHNBbmRWYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XG4gICAgICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXG4gICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cbiAgICAgICAgZmllbGRPclVwZGF0ZURhdGEgPSBnZXRNb2R1bGFySW5zdGFuY2UoZmllbGRPclVwZGF0ZURhdGEpO1xuICAgICAgICBsZXQgcGFyc2VkO1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkT3JVcGRhdGVEYXRhID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgZmllbGRPclVwZGF0ZURhdGEgaW5zdGFuY2VvZiBGaWVsZFBhdGgpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlVXBkYXRlVmFyYXJncyh0aGlzLl9kYXRhUmVhZGVyLCAnVHJhbnNhY3Rpb24udXBkYXRlJywgcmVmLl9rZXksIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgbW9yZUZpZWxkc0FuZFZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZURhdGEodGhpcy5fZGF0YVJlYWRlciwgJ1RyYW5zYWN0aW9uLnVwZGF0ZScsIHJlZi5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24udXBkYXRlKHJlZi5fa2V5LCBwYXJzZWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhlIHByb3ZpZGVkIHtAbGluayBEb2N1bWVudFJlZmVyZW5jZX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRSZWYgLSBBIHJlZmVyZW5jZSB0byB0aGUgZG9jdW1lbnQgdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGlzIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIFVzZWQgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICAgKi9cbiAgICBkZWxldGUoZG9jdW1lbnRSZWYpIHtcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uLmRlbGV0ZShyZWYuX2tleSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSByZWZlcmVuY2UgdG8gYSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBUaGUgYFRyYW5zYWN0aW9uYCBvYmplY3QgcGFzc2VkIHRvIGEgdHJhbnNhY3Rpb24ncyBgdXBkYXRlRnVuY3Rpb25gIHByb3ZpZGVzXG4gKiB0aGUgbWV0aG9kcyB0byByZWFkIGFuZCB3cml0ZSBkYXRhIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24gY29udGV4dC4gU2VlXG4gKiB7QGxpbmsgcnVuVHJhbnNhY3Rpb259LlxuICovXG5jbGFzcyBUcmFuc2FjdGlvbiBleHRlbmRzIFRyYW5zYWN0aW9uJDEge1xuICAgIC8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB0aGUgc2FtZSBsb2dpYyBhcyB0aGUgVHJhbnNhY3Rpb24gQVBJIGluIHRoZSBMaXRlIFNES1xuICAgIC8vIGJ1dCBpcyBzdWJjbGFzc2VkIGluIG9yZGVyIHRvIHJldHVybiBpdHMgb3duIERvY3VtZW50U25hcHNob3QgdHlwZXMuXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlLCBfdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgc3VwZXIoX2ZpcmVzdG9yZSwgX3RyYW5zYWN0aW9uKTtcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlID0gX2ZpcmVzdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIGRvY3VtZW50IHJlZmVyZW5jZWQgYnkgdGhlIHByb3ZpZGVkIHtAbGluayBEb2N1bWVudFJlZmVyZW5jZX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRSZWYgLSBBIHJlZmVyZW5jZSB0byB0aGUgZG9jdW1lbnQgdG8gYmUgcmVhZC5cbiAgICAgKiBAcmV0dXJucyBBIGBEb2N1bWVudFNuYXBzaG90YCB3aXRoIHRoZSByZWFkIGRhdGEuXG4gICAgICovXG4gICAgZ2V0KGRvY3VtZW50UmVmKSB7XG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcih0aGlzLl9maXJlc3RvcmUpO1xuICAgICAgICByZXR1cm4gc3VwZXJcbiAgICAgICAgICAgIC5nZXQoZG9jdW1lbnRSZWYpXG4gICAgICAgICAgICAudGhlbihsaXRlRG9jdW1lbnRTbmFwc2hvdCA9PiBuZXcgRG9jdW1lbnRTbmFwc2hvdCh0aGlzLl9maXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCByZWYuX2tleSwgbGl0ZURvY3VtZW50U25hcHNob3QuX2RvY3VtZW50LCBuZXcgU25hcHNob3RNZXRhZGF0YShcbiAgICAgICAgLyogaGFzUGVuZGluZ1dyaXRlcz0gKi8gZmFsc2UsIFxuICAgICAgICAvKiBmcm9tQ2FjaGU9ICovIGZhbHNlKSwgcmVmLmNvbnZlcnRlcikpO1xuICAgIH1cbn1cbi8qKlxuICogRXhlY3V0ZXMgdGhlIGdpdmVuIGB1cGRhdGVGdW5jdGlvbmAgYW5kIHRoZW4gYXR0ZW1wdHMgdG8gY29tbWl0IHRoZSBjaGFuZ2VzXG4gKiBhcHBsaWVkIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24uIElmIGFueSBkb2N1bWVudCByZWFkIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb25cbiAqIGhhcyBjaGFuZ2VkLCBDbG91ZCBGaXJlc3RvcmUgcmV0cmllcyB0aGUgYHVwZGF0ZUZ1bmN0aW9uYC4gSWYgaXQgZmFpbHMgdG9cbiAqIGNvbW1pdCBhZnRlciA1IGF0dGVtcHRzLCB0aGUgdHJhbnNhY3Rpb24gZmFpbHMuXG4gKlxuICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHdyaXRlcyBhbGxvd2VkIGluIGEgc2luZ2xlIHRyYW5zYWN0aW9uIGlzIDUwMC5cbiAqXG4gKiBAcGFyYW0gZmlyZXN0b3JlIC0gQSByZWZlcmVuY2UgdG8gdGhlIEZpcmVzdG9yZSBkYXRhYmFzZSB0byBydW4gdGhpc1xuICogdHJhbnNhY3Rpb24gYWdhaW5zdC5cbiAqIEBwYXJhbSB1cGRhdGVGdW5jdGlvbiAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb25cbiAqIGNvbnRleHQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRvIGNvbmZpZ3VyZSBtYXhpbXVtIG51bWJlciBvZiBhdHRlbXB0cyB0b1xuICogY29tbWl0LlxuICogQHJldHVybnMgSWYgdGhlIHRyYW5zYWN0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkgb3Igd2FzIGV4cGxpY2l0bHkgYWJvcnRlZFxuICogKHRoZSBgdXBkYXRlRnVuY3Rpb25gIHJldHVybmVkIGEgZmFpbGVkIHByb21pc2UpLCB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGVcbiAqIGB1cGRhdGVGdW5jdGlvbiBgaXMgcmV0dXJuZWQgaGVyZS4gT3RoZXJ3aXNlLCBpZiB0aGUgdHJhbnNhY3Rpb24gZmFpbGVkLCBhXG4gKiByZWplY3RlZCBwcm9taXNlIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgZmFpbHVyZSBlcnJvciBpcyByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gcnVuVHJhbnNhY3Rpb24oZmlyZXN0b3JlLCB1cGRhdGVGdW5jdGlvbiwgb3B0aW9ucykge1xuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IG9wdGlvbnNXaXRoRGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfVFJBTlNBQ1RJT05fT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgIHZhbGlkYXRlVHJhbnNhY3Rpb25PcHRpb25zKG9wdGlvbnNXaXRoRGVmYXVsdHMpO1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50VHJhbnNhY3Rpb24oY2xpZW50LCBpbnRlcm5hbFRyYW5zYWN0aW9uID0+IHVwZGF0ZUZ1bmN0aW9uKG5ldyBUcmFuc2FjdGlvbihmaXJlc3RvcmUsIGludGVybmFsVHJhbnNhY3Rpb24pKSwgb3B0aW9uc1dpdGhEZWZhdWx0cyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJldHVybnMgYSBzZW50aW5lbCBmb3IgdXNlIHdpdGgge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSModXBkYXRlRG9jOjEpfSBvclxuICoge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSMoc2V0RG9jOjEpfSB3aXRoIGB7bWVyZ2U6IHRydWV9YCB0byBtYXJrIGEgZmllbGQgZm9yIGRlbGV0aW9uLlxuICovXG5mdW5jdGlvbiBkZWxldGVGaWVsZCgpIHtcbiAgICByZXR1cm4gbmV3IERlbGV0ZUZpZWxkVmFsdWVJbXBsKCdkZWxldGVGaWVsZCcpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc2VudGluZWwgdXNlZCB3aXRoIHtAbGluayBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHNldERvYzoxKX0gb3Ige0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSModXBkYXRlRG9jOjEpfSB0b1xuICogaW5jbHVkZSBhIHNlcnZlci1nZW5lcmF0ZWQgdGltZXN0YW1wIGluIHRoZSB3cml0dGVuIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHNlcnZlclRpbWVzdGFtcCgpIHtcbiAgICByZXR1cm4gbmV3IFNlcnZlclRpbWVzdGFtcEZpZWxkVmFsdWVJbXBsKCdzZXJ2ZXJUaW1lc3RhbXAnKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNwZWNpYWwgdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHtAbGluayBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHNldERvYzoxKX0gb3Ige0BsaW5rXG4gKiBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHVwZGF0ZURvYzoxKX0gdGhhdCB0ZWxscyB0aGUgc2VydmVyIHRvIHVuaW9uIHRoZSBnaXZlbiBlbGVtZW50cyB3aXRoIGFueSBhcnJheVxuICogdmFsdWUgdGhhdCBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgc2VydmVyLiBFYWNoIHNwZWNpZmllZCBlbGVtZW50IHRoYXQgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdCBpbiB0aGUgYXJyYXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgZW5kLiBJZiB0aGUgZmllbGQgYmVpbmdcbiAqIG1vZGlmaWVkIGlzIG5vdCBhbHJlYWR5IGFuIGFycmF5IGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCBhbiBhcnJheVxuICogY29udGFpbmluZyBleGFjdGx5IHRoZSBzcGVjaWZpZWQgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIGVsZW1lbnRzIC0gVGhlIGVsZW1lbnRzIHRvIHVuaW9uIGludG8gdGhlIGFycmF5LlxuICogQHJldHVybnMgVGhlIGBGaWVsZFZhbHVlYCBzZW50aW5lbCBmb3IgdXNlIGluIGEgY2FsbCB0byBgc2V0RG9jKClgIG9yXG4gKiBgdXBkYXRlRG9jKClgLlxuICovXG5mdW5jdGlvbiBhcnJheVVuaW9uKC4uLmVsZW1lbnRzKSB7XG4gICAgLy8gTk9URTogV2UgZG9uJ3QgYWN0dWFsbHkgcGFyc2UgdGhlIGRhdGEgdW50aWwgaXQncyB1c2VkIGluIHNldCgpIG9yXG4gICAgLy8gdXBkYXRlKCkgc2luY2Ugd2UnZCBuZWVkIHRoZSBGaXJlc3RvcmUgaW5zdGFuY2UgdG8gZG8gdGhpcy5cbiAgICByZXR1cm4gbmV3IEFycmF5VW5pb25GaWVsZFZhbHVlSW1wbCgnYXJyYXlVbmlvbicsIGVsZW1lbnRzKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNwZWNpYWwgdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHtAbGluayAoc2V0RG9jOjEpfSBvciB7QGxpbmtcbiAqIHVwZGF0ZURvYzoxfSB0aGF0IHRlbGxzIHRoZSBzZXJ2ZXIgdG8gcmVtb3ZlIHRoZSBnaXZlbiBlbGVtZW50cyBmcm9tIGFueVxuICogYXJyYXkgdmFsdWUgdGhhdCBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgc2VydmVyLiBBbGwgaW5zdGFuY2VzIG9mIGVhY2ggZWxlbWVudFxuICogc3BlY2lmaWVkIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBhcnJheS4gSWYgdGhlIGZpZWxkIGJlaW5nIG1vZGlmaWVkIGlzIG5vdFxuICogYWxyZWFkeSBhbiBhcnJheSBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggYW4gZW1wdHkgYXJyYXkuXG4gKlxuICogQHBhcmFtIGVsZW1lbnRzIC0gVGhlIGVsZW1lbnRzIHRvIHJlbW92ZSBmcm9tIHRoZSBhcnJheS5cbiAqIEByZXR1cm5zIFRoZSBgRmllbGRWYWx1ZWAgc2VudGluZWwgZm9yIHVzZSBpbiBhIGNhbGwgdG8gYHNldERvYygpYCBvclxuICogYHVwZGF0ZURvYygpYFxuICovXG5mdW5jdGlvbiBhcnJheVJlbW92ZSguLi5lbGVtZW50cykge1xuICAgIC8vIE5PVEU6IFdlIGRvbid0IGFjdHVhbGx5IHBhcnNlIHRoZSBkYXRhIHVudGlsIGl0J3MgdXNlZCBpbiBzZXQoKSBvclxuICAgIC8vIHVwZGF0ZSgpIHNpbmNlIHdlJ2QgbmVlZCB0aGUgRmlyZXN0b3JlIGluc3RhbmNlIHRvIGRvIHRoaXMuXG4gICAgcmV0dXJuIG5ldyBBcnJheVJlbW92ZUZpZWxkVmFsdWVJbXBsKCdhcnJheVJlbW92ZScsIGVsZW1lbnRzKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNwZWNpYWwgdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHtAbGluayBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHNldERvYzoxKX0gb3Ige0BsaW5rXG4gKiBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHVwZGF0ZURvYzoxKX0gdGhhdCB0ZWxscyB0aGUgc2VydmVyIHRvIGluY3JlbWVudCB0aGUgZmllbGQncyBjdXJyZW50IHZhbHVlIGJ5XG4gKiB0aGUgZ2l2ZW4gdmFsdWUuXG4gKlxuICogSWYgZWl0aGVyIHRoZSBvcGVyYW5kIG9yIHRoZSBjdXJyZW50IGZpZWxkIHZhbHVlIHVzZXMgZmxvYXRpbmcgcG9pbnRcbiAqIHByZWNpc2lvbiwgYWxsIGFyaXRobWV0aWMgZm9sbG93cyBJRUVFIDc1NCBzZW1hbnRpY3MuIElmIGJvdGggdmFsdWVzIGFyZVxuICogaW50ZWdlcnMsIHZhbHVlcyBvdXRzaWRlIG9mIEphdmFTY3JpcHQncyBzYWZlIG51bWJlciByYW5nZVxuICogKGBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUmAgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYCkgYXJlIGFsc28gc3ViamVjdCB0b1xuICogcHJlY2lzaW9uIGxvc3MuIEZ1cnRoZXJtb3JlLCBvbmNlIHByb2Nlc3NlZCBieSB0aGUgRmlyZXN0b3JlIGJhY2tlbmQsIGFsbFxuICogaW50ZWdlciBvcGVyYXRpb25zIGFyZSBjYXBwZWQgYmV0d2VlbiAtMl42MyBhbmQgMl42My0xLlxuICpcbiAqIElmIHRoZSBjdXJyZW50IGZpZWxkIHZhbHVlIGlzIG5vdCBvZiB0eXBlIGBudW1iZXJgLCBvciBpZiB0aGUgZmllbGQgZG9lcyBub3RcbiAqIHlldCBleGlzdCwgdGhlIHRyYW5zZm9ybWF0aW9uIHNldHMgdGhlIGZpZWxkIHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gbiAtIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgYnkuXG4gKiBAcmV0dXJucyBUaGUgYEZpZWxkVmFsdWVgIHNlbnRpbmVsIGZvciB1c2UgaW4gYSBjYWxsIHRvIGBzZXREb2MoKWAgb3JcbiAqIGB1cGRhdGVEb2MoKWBcbiAqL1xuZnVuY3Rpb24gaW5jcmVtZW50KG4pIHtcbiAgICByZXR1cm4gbmV3IE51bWVyaWNJbmNyZW1lbnRGaWVsZFZhbHVlSW1wbCgnaW5jcmVtZW50Jywgbik7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYFZlY3RvclZhbHVlYCBjb25zdHJ1Y3RlZCB3aXRoIGEgY29weSBvZiB0aGUgZ2l2ZW4gYXJyYXkgb2YgbnVtYmVycy5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gQ3JlYXRlIGEgYFZlY3RvclZhbHVlYCBpbnN0YW5jZSB3aXRoIGEgY29weSBvZiB0aGlzIGFycmF5IG9mIG51bWJlcnMuXG4gKlxuICogQHJldHVybnMgQSBuZXcgYFZlY3RvclZhbHVlYCBjb25zdHJ1Y3RlZCB3aXRoIGEgY29weSBvZiB0aGUgZ2l2ZW4gYXJyYXkgb2YgbnVtYmVycy5cbiAqL1xuZnVuY3Rpb24gdmVjdG9yKHZhbHVlcykge1xuICAgIHJldHVybiBuZXcgVmVjdG9yVmFsdWUodmFsdWVzKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ3JlYXRlcyBhIHdyaXRlIGJhdGNoLCB1c2VkIGZvciBwZXJmb3JtaW5nIG11bHRpcGxlIHdyaXRlcyBhcyBhIHNpbmdsZVxuICogYXRvbWljIG9wZXJhdGlvbi4gVGhlIG1heGltdW0gbnVtYmVyIG9mIHdyaXRlcyBhbGxvd2VkIGluIGEgc2luZ2xlIHtAbGluayBXcml0ZUJhdGNofVxuICogaXMgNTAwLlxuICpcbiAqIFVubGlrZSB0cmFuc2FjdGlvbnMsIHdyaXRlIGJhdGNoZXMgYXJlIHBlcnNpc3RlZCBvZmZsaW5lIGFuZCB0aGVyZWZvcmUgYXJlXG4gKiBwcmVmZXJhYmxlIHdoZW4geW91IGRvbid0IG5lZWQgdG8gY29uZGl0aW9uIHlvdXIgd3JpdGVzIG9uIHJlYWQgZGF0YS5cbiAqXG4gKiBAcmV0dXJucyBBIHtAbGluayBXcml0ZUJhdGNofSB0aGF0IGNhbiBiZSB1c2VkIHRvIGF0b21pY2FsbHkgZXhlY3V0ZSBtdWx0aXBsZVxuICogd3JpdGVzLlxuICovXG5mdW5jdGlvbiB3cml0ZUJhdGNoKGZpcmVzdG9yZSkge1xuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICByZXR1cm4gbmV3IFdyaXRlQmF0Y2goZmlyZXN0b3JlLCBtdXRhdGlvbnMgPT4gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgbXV0YXRpb25zKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBzZXRJbmRleENvbmZpZ3VyYXRpb24oZmlyZXN0b3JlLCBqc29uT3JDb25maWd1cmF0aW9uKSB7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGlmICghY2xpZW50Ll91bmluaXRpYWxpemVkQ29tcG9uZW50c1Byb3ZpZGVyIHx8XG4gICAgICAgIGNsaWVudC5fdW5pbml0aWFsaXplZENvbXBvbmVudHNQcm92aWRlci5fb2ZmbGluZS5raW5kID09PSAnbWVtb3J5Jykge1xuICAgICAgICAvLyBQT1JUSU5HIE5PVEU6IFdlIGRvbid0IHJldHVybiBhbiBlcnJvciBpZiB0aGUgdXNlciBoYXMgbm90IGVuYWJsZWRcbiAgICAgICAgLy8gcGVyc2lzdGVuY2Ugc2luY2UgYGVuYWJsZUluZGV4ZWRkYlBlcnNpc3RlbmNlKClgIGNhbiBmYWlsIG9uIHRoZSBXZWIuXG4gICAgICAgIGxvZ1dhcm4oJ0Nhbm5vdCBlbmFibGUgaW5kZXhlcyB3aGVuIHBlcnNpc3RlbmNlIGlzIGRpc2FibGVkJyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkSW5kZXhlcyA9IHBhcnNlSW5kZXhlcyhqc29uT3JDb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50U2V0SW5kZXhDb25maWd1cmF0aW9uKGNsaWVudCwgcGFyc2VkSW5kZXhlcyk7XG59XG5mdW5jdGlvbiBwYXJzZUluZGV4ZXMoanNvbk9yQ29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGluZGV4Q29uZmlndXJhdGlvbiA9IHR5cGVvZiBqc29uT3JDb25maWd1cmF0aW9uID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHRyeVBhcnNlSnNvbihqc29uT3JDb25maWd1cmF0aW9uKVxuICAgICAgICA6IGpzb25PckNvbmZpZ3VyYXRpb247XG4gICAgY29uc3QgcGFyc2VkSW5kZXhlcyA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGluZGV4Q29uZmlndXJhdGlvbi5pbmRleGVzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4Q29uZmlndXJhdGlvbi5pbmRleGVzKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uR3JvdXAgPSB0cnlHZXRTdHJpbmcoaW5kZXgsICdjb2xsZWN0aW9uR3JvdXAnKTtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRzID0gW107XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleC5maWVsZHMpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBpbmRleC5maWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRQYXRoU3RyaW5nID0gdHJ5R2V0U3RyaW5nKGZpZWxkLCAnZmllbGRQYXRoJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkUGF0aCA9IGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcoJ3NldEluZGV4Q29uZmlndXJhdGlvbicsIGZpZWxkUGF0aFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5hcnJheUNvbmZpZyA9PT0gJ0NPTlRBSU5TJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChuZXcgSW5kZXhTZWdtZW50KGZpZWxkUGF0aCwgMiAvKiBJbmRleEtpbmQuQ09OVEFJTlMgKi8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5vcmRlciA9PT0gJ0FTQ0VORElORycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEluZGV4U2VnbWVudChmaWVsZFBhdGgsIDAgLyogSW5kZXhLaW5kLkFTQ0VORElORyAqLykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLm9yZGVyID09PSAnREVTQ0VORElORycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEluZGV4U2VnbWVudChmaWVsZFBhdGgsIDEgLyogSW5kZXhLaW5kLkRFU0NFTkRJTkcgKi8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlZEluZGV4ZXMucHVzaChuZXcgRmllbGRJbmRleChGaWVsZEluZGV4LlVOS05PV05fSUQsIGNvbGxlY3Rpb25Hcm91cCwgc2VnbWVudHMsIEluZGV4U3RhdGUuZW1wdHkoKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWRJbmRleGVzO1xufVxuZnVuY3Rpb24gdHJ5UGFyc2VKc29uKGpzb24pIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ZhaWxlZCB0byBwYXJzZSBKU09OOiAnICsgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJ5R2V0U3RyaW5nKGRhdGEsIHByb3BlcnR5KSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhW3Byb3BlcnR5XSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ01pc3Npbmcgc3RyaW5nIHZhbHVlIGZvcjogJyArIHByb3BlcnR5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFbcHJvcGVydHldO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGBQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXJgIGZvciBjb25maWd1cmluZyBwZXJzaXN0ZW50IGNhY2hlIGluZGV4ZXMgdXNlZFxuICogZm9yIGxvY2FsIHF1ZXJ5IGV4ZWN1dGlvbi5cbiAqXG4gKiBUbyB1c2UsIGNhbGwgYGdldFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcigpYCB0byBnZXQgYW4gaW5zdGFuY2UuXG4gKi9cbmNsYXNzIFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlciB7XG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XG4gICAgICAgIC8qKiBBIHR5cGUgc3RyaW5nIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzLiAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnUGVyc2lzdGVudENhY2hlSW5kZXhNYW5hZ2VyJztcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIFBlcnNpc3RlbnRDYWNoZSBJbmRleCBNYW5hZ2VyIHVzZWQgYnkgdGhlIGdpdmVuIGBGaXJlc3RvcmVgXG4gKiBvYmplY3QuXG4gKlxuICogQHJldHVybiBUaGUgYFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcmAgaW5zdGFuY2UsIG9yIGBudWxsYCBpZiBsb2NhbFxuICogcGVyc2lzdGVudCBzdG9yYWdlIGlzIG5vdCBpbiB1c2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlcihmaXJlc3RvcmUpIHtcbiAgICB2YXIgX2E7XG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2FjaGVkSW5zdGFuY2UgPSBwZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXJCeUZpcmVzdG9yZS5nZXQoZmlyZXN0b3JlKTtcbiAgICBpZiAoY2FjaGVkSW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEluc3RhbmNlO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XG4gICAgaWYgKCgoX2EgPSBjbGllbnQuX3VuaW5pdGlhbGl6ZWRDb21wb25lbnRzUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fb2ZmbGluZS5raW5kKSAhPT0gJ3BlcnNpc3RlbnQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXIoZmlyZXN0b3JlKTtcbiAgICBwZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXJCeUZpcmVzdG9yZS5zZXQoZmlyZXN0b3JlLCBpbnN0YW5jZSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuLyoqXG4gKiBFbmFibGVzIHRoZSBTREsgdG8gY3JlYXRlIHBlcnNpc3RlbnQgY2FjaGUgaW5kZXhlcyBhdXRvbWF0aWNhbGx5IGZvciBsb2NhbFxuICogcXVlcnkgZXhlY3V0aW9uIHdoZW4gdGhlIFNESyBiZWxpZXZlcyBjYWNoZSBpbmRleGVzIGNhbiBoZWxwIGltcHJvdmVcbiAqIHBlcmZvcm1hbmNlLlxuICpcbiAqIFRoaXMgZmVhdHVyZSBpcyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICovXG5mdW5jdGlvbiBlbmFibGVQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbihpbmRleE1hbmFnZXIpIHtcbiAgICBzZXRQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQoaW5kZXhNYW5hZ2VyLCB0cnVlKTtcbn1cbi8qKlxuICogU3RvcHMgY3JlYXRpbmcgcGVyc2lzdGVudCBjYWNoZSBpbmRleGVzIGF1dG9tYXRpY2FsbHkgZm9yIGxvY2FsIHF1ZXJ5XG4gKiBleGVjdXRpb24uIFRoZSBpbmRleGVzIHdoaWNoIGhhdmUgYmVlbiBjcmVhdGVkIGJ5IGNhbGxpbmdcbiAqIGBlbmFibGVQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbigpYCBzdGlsbCB0YWtlIGVmZmVjdC5cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZVBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uKGluZGV4TWFuYWdlcikge1xuICAgIHNldFBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZChpbmRleE1hbmFnZXIsIGZhbHNlKTtcbn1cbi8qKlxuICogUmVtb3ZlcyBhbGwgcGVyc2lzdGVudCBjYWNoZSBpbmRleGVzLlxuICpcbiAqIFBsZWFzZSBub3RlIHRoaXMgZnVuY3Rpb24gd2lsbCBhbHNvIGRlbGV0ZXMgaW5kZXhlcyBnZW5lcmF0ZWQgYnlcbiAqIGBzZXRJbmRleENvbmZpZ3VyYXRpb24oKWAsIHdoaWNoIGlzIGRlcHJlY2F0ZWQuXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZUFsbFBlcnNpc3RlbnRDYWNoZUluZGV4ZXMoaW5kZXhNYW5hZ2VyKSB7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChpbmRleE1hbmFnZXIuX2ZpcmVzdG9yZSk7XG4gICAgY29uc3QgcHJvbWlzZSA9IGZpcmVzdG9yZUNsaWVudERlbGV0ZUFsbEZpZWxkSW5kZXhlcyhjbGllbnQpO1xuICAgIHByb21pc2VcbiAgICAgICAgLnRoZW4oXyA9PiBsb2dEZWJ1ZygnZGVsZXRpbmcgYWxsIHBlcnNpc3RlbnQgY2FjaGUgaW5kZXhlcyBzdWNjZWVkZWQnKSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IGxvZ1dhcm4oJ2RlbGV0aW5nIGFsbCBwZXJzaXN0ZW50IGNhY2hlIGluZGV4ZXMgZmFpbGVkJywgZXJyb3IpKTtcbn1cbmZ1bmN0aW9uIHNldFBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uRW5hYmxlZChpbmRleE1hbmFnZXIsIGlzRW5hYmxlZCkge1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoaW5kZXhNYW5hZ2VyLl9maXJlc3RvcmUpO1xuICAgIGNvbnN0IHByb21pc2UgPSBmaXJlc3RvcmVDbGllbnRTZXRQZXJzaXN0ZW50Q2FjaGVJbmRleEF1dG9DcmVhdGlvbkVuYWJsZWQoY2xpZW50LCBpc0VuYWJsZWQpO1xuICAgIHByb21pc2VcbiAgICAgICAgLnRoZW4oXyA9PiBsb2dEZWJ1Zyhgc2V0dGluZyBwZXJzaXN0ZW50IGNhY2hlIGluZGV4IGF1dG8gY3JlYXRpb24gYCArXG4gICAgICAgIGBpc0VuYWJsZWQ9JHtpc0VuYWJsZWR9IHN1Y2NlZWRlZGApKVxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4gbG9nV2Fybihgc2V0dGluZyBwZXJzaXN0ZW50IGNhY2hlIGluZGV4IGF1dG8gY3JlYXRpb24gYCArXG4gICAgICAgIGBpc0VuYWJsZWQ9JHtpc0VuYWJsZWR9IGZhaWxlZGAsIGVycm9yKSk7XG59XG4vKipcbiAqIE1hcHMgYEZpcmVzdG9yZWAgaW5zdGFuY2VzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqIGBQZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXJgIGluc3RhbmNlcy5cbiAqXG4gKiBVc2UgYSBgV2Vha01hcGAgc28gdGhhdCB0aGUgbWFwcGluZyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZHJvcHBlZCB3aGVuIHRoZVxuICogYEZpcmVzdG9yZWAgaW5zdGFuY2UgaXMgZ2FyYmFnZSBjb2xsZWN0ZWQuIFRoaXMgZW11bGF0ZXMgYSBwcml2YXRlIG1lbWJlclxuICogYXMgZGVzY3JpYmVkIGluIGh0dHBzOi8vZ29vLmdsZS80NTR5dnVnLlxuICovXG5jb25zdCBwZXJzaXN0ZW50Q2FjaGVJbmRleE1hbmFnZXJCeUZpcmVzdG9yZSA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQHByaXZhdGVcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBSZXR1cm5zIHRoZSBgUXVlcnlUYXJnZXRgIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBxdWVyeS4gUmV0dXJucyBgbnVsbGBcbiAqIGlmIHRoZSBGaXJlc3RvcmUgY2xpZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcXVlcnkgaGFzIG5vdCBiZWVuXG4gKiBpbml0aWFsaXplZCBvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICpcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBRdWVyeSB0byBjb252ZXJ0IHRvIHByb3RvIHJlcHJlc2VudGF0aW9uLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gX2ludGVybmFsUXVlcnlUb1Byb3RvUXVlcnlUYXJnZXQocXVlcnkpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSAoX2EgPSBjbGllbnQuX29ubGluZUNvbXBvbmVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhc3RvcmUuc2VyaWFsaXplcjtcbiAgICBpZiAoc2VyaWFsaXplciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdG9RdWVyeVRhcmdldChzZXJpYWxpemVyLCBxdWVyeVRvVGFyZ2V0KHF1ZXJ5Ll9xdWVyeSkpLnF1ZXJ5VGFyZ2V0O1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBwcml2YXRlXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gKlxuICogUmV0dXJucyBgUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3RgIHdoaWNoIGNvbnRhaW5zIHRoZSBwcm90byByZXByZXNlbnRhdGlvblxuICogb2YgdGhlIGdpdmVuIGFnZ3JlZ2F0aW9uIHF1ZXJ5IHJlcXVlc3QuIFJldHVybnMgbnVsbCBpZiB0aGUgRmlyZXN0b3JlIGNsaWVudFxuICogYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBxdWVyeSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgb3IgaGFzIGJlZW5cbiAqIHRlcm1pbmF0ZWQuXG4gKlxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIFF1ZXJ5IHRvIGNvbnZlcnQgdG8gcHJvdG8gcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0gYWdncmVnYXRlU3BlYyAtIFRoZSBzZXQgb2YgYWdncmVnYXRpb25zIGFuZCB0aGVpciBhbGlhc2VzLlxuICovXG5mdW5jdGlvbiBfaW50ZXJuYWxBZ2dyZWdhdGlvblF1ZXJ5VG9Qcm90b1J1bkFnZ3JlZ2F0aW9uUXVlcnlSZXF1ZXN0KHF1ZXJ5LCBhZ2dyZWdhdGVTcGVjKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFnZ3JlZ2F0ZXMgPSBtYXBUb0FycmF5KGFnZ3JlZ2F0ZVNwZWMsIChhZ2dyZWdhdGUsIGFsaWFzKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgQWdncmVnYXRlSW1wbChhbGlhcywgYWdncmVnYXRlLmFnZ3JlZ2F0ZVR5cGUsIGFnZ3JlZ2F0ZS5faW50ZXJuYWxGaWVsZFBhdGgpO1xuICAgIH0pO1xuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocXVlcnkuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcbiAgICBjb25zdCBzZXJpYWxpemVyID0gKF9hID0gY2xpZW50Ll9vbmxpbmVDb21wb25lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YXN0b3JlLnNlcmlhbGl6ZXI7XG4gICAgaWYgKHNlcmlhbGl6ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRvUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3Qoc2VyaWFsaXplciwgcXVlcnlUb0FnZ3JlZ2F0ZVRhcmdldChxdWVyeS5fcXVlcnkpLCBhZ2dyZWdhdGVzLCBcbiAgICAvKiBza2lwQWxpYXNpbmc9ICovIHRydWUpLnJlcXVlc3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRlc3RpbmcgaG9va3MgZm9yIHVzZSBieSBGaXJlc3RvcmUncyBpbnRlZ3JhdGlvbiB0ZXN0IHN1aXRlIHRvIHJlYWNoIGludG8gdGhlXG4gKiBTREsgaW50ZXJuYWxzIHRvIHZhbGlkYXRlIGxvZ2ljIGFuZCBiZWhhdmlvciB0aGF0IGlzIG5vdCB2aXNpYmxlIGZyb20gdGhlXG4gKiBwdWJsaWMgQVBJIHN1cmZhY2UuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFRlc3RpbmdIb29rcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSBjcmVhdGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIG5vdGlmaWVkIHdoZW4gYW4gZXhpc3RlbmNlIGZpbHRlciBtaXNtYXRjaFxuICAgICAqIG9jY3VycyBpbiB0aGUgV2F0Y2ggbGlzdGVuIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIFRoZSByZWxhdGl2ZSBvcmRlciBpbiB3aGljaCBjYWxsYmFja3MgYXJlIG5vdGlmaWVkIGlzIHVuc3BlY2lmaWVkOyBkbyBub3RcbiAgICAgKiByZWx5IG9uIGFueSBwYXJ0aWN1bGFyIG9yZGVyaW5nLiBJZiBhIGdpdmVuIGNhbGxiYWNrIGlzIHJlZ2lzdGVyZWQgbXVsdGlwbGVcbiAgICAgKiB0aW1lcyB0aGVuIGl0IHdpbGwgYmUgbm90aWZpZWQgbXVsdGlwbGUgdGltZXMsIG9uY2UgcGVyIHJlZ2lzdHJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIHVwb24gZXhpc3RlbmNlIGZpbHRlciBtaXNtYXRjaC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgdW5yZWdpc3RlcnMgdGhlIGdpdmVuIGNhbGxiYWNrOyBvbmx5XG4gICAgICogdGhlIGZpcnN0IGludm9jYXRpb24gb2YgdGhlIHJldHVybmVkIGZ1bmN0aW9uIGRvZXMgYW55dGhpbmc7IGFsbCBzdWJzZXF1ZW50XG4gICAgICogaW52b2NhdGlvbnMgZG8gbm90aGluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgb25FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gVGVzdGluZ0hvb2tzU3BpSW1wbC5pbnN0YW5jZS5vbkV4aXN0ZW5jZUZpbHRlck1pc21hdGNoKGNhbGxiYWNrKTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBgVGVzdGluZ0hvb2tzU3BpYC5cbiAqL1xuY2xhc3MgVGVzdGluZ0hvb2tzU3BpSW1wbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2hDYWxsYmFja3NCeUlkID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGluc3RhbmNlKCkge1xuICAgICAgICBpZiAoIXRlc3RpbmdIb29rc1NwaUltcGxJbnN0YW5jZSkge1xuICAgICAgICAgICAgdGVzdGluZ0hvb2tzU3BpSW1wbEluc3RhbmNlID0gbmV3IFRlc3RpbmdIb29rc1NwaUltcGwoKTtcbiAgICAgICAgICAgIHNldFRlc3RpbmdIb29rc1NwaSh0ZXN0aW5nSG9va3NTcGlJbXBsSW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXN0aW5nSG9va3NTcGlJbXBsSW5zdGFuY2U7XG4gICAgfVxuICAgIG5vdGlmeU9uRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2goaW5mbykge1xuICAgICAgICB0aGlzLmV4aXN0ZW5jZUZpbHRlck1pc21hdGNoQ2FsbGJhY2tzQnlJZC5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGluZm8pKTtcbiAgICB9XG4gICAgb25FeGlzdGVuY2VGaWx0ZXJNaXNtYXRjaChjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBpZCA9IFN5bWJvbCgpO1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmV4aXN0ZW5jZUZpbHRlck1pc21hdGNoQ2FsbGJhY2tzQnlJZDtcbiAgICAgICAgY2FsbGJhY2tzLnNldChpZCwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4gY2FsbGJhY2tzLmRlbGV0ZShpZCk7XG4gICAgfVxufVxubGV0IHRlc3RpbmdIb29rc1NwaUltcGxJbnN0YW5jZSA9IG51bGw7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5yZWdpc3RlckZpcmVzdG9yZSgnbm9kZScpO1xuXG5leHBvcnQgeyBBYnN0cmFjdFVzZXJEYXRhV3JpdGVyLCBBZ2dyZWdhdGVGaWVsZCwgQWdncmVnYXRlUXVlcnlTbmFwc2hvdCwgQnl0ZXMsIENBQ0hFX1NJWkVfVU5MSU1JVEVELCBDb2xsZWN0aW9uUmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSwgRG9jdW1lbnRTbmFwc2hvdCwgRmllbGRQYXRoLCBGaWVsZFZhbHVlLCBGaXJlc3RvcmUsIEZpcmVzdG9yZUVycm9yLCBHZW9Qb2ludCwgTG9hZEJ1bmRsZVRhc2ssIFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlciwgUXVlcnksIFF1ZXJ5Q29tcG9zaXRlRmlsdGVyQ29uc3RyYWludCwgUXVlcnlDb25zdHJhaW50LCBRdWVyeURvY3VtZW50U25hcHNob3QsIFF1ZXJ5RW5kQXRDb25zdHJhaW50LCBRdWVyeUZpZWxkRmlsdGVyQ29uc3RyYWludCwgUXVlcnlMaW1pdENvbnN0cmFpbnQsIFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnQsIFF1ZXJ5U25hcHNob3QsIFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQsIFNuYXBzaG90TWV0YWRhdGEsIFRpbWVzdGFtcCwgVHJhbnNhY3Rpb24sIFZlY3RvclZhbHVlLCBXcml0ZUJhdGNoLCBBdXRvSWQgYXMgX0F1dG9JZCwgQnl0ZVN0cmluZyBhcyBfQnl0ZVN0cmluZywgRGF0YWJhc2VJZCBhcyBfRGF0YWJhc2VJZCwgRG9jdW1lbnRLZXkgYXMgX0RvY3VtZW50S2V5LCBFbXB0eUFwcENoZWNrVG9rZW5Qcm92aWRlciBhcyBfRW1wdHlBcHBDaGVja1Rva2VuUHJvdmlkZXIsIEVtcHR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIgYXMgX0VtcHR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIsIEZpZWxkUGF0aCQxIGFzIF9GaWVsZFBhdGgsIFRlc3RpbmdIb29rcyBhcyBfVGVzdGluZ0hvb2tzLCBjYXN0IGFzIF9jYXN0LCBkZWJ1Z0Fzc2VydCBhcyBfZGVidWdBc3NlcnQsIF9pbnRlcm5hbEFnZ3JlZ2F0aW9uUXVlcnlUb1Byb3RvUnVuQWdncmVnYXRpb25RdWVyeVJlcXVlc3QsIF9pbnRlcm5hbFF1ZXJ5VG9Qcm90b1F1ZXJ5VGFyZ2V0LCBpc0Jhc2U2NEF2YWlsYWJsZSBhcyBfaXNCYXNlNjRBdmFpbGFibGUsIGxvZ1dhcm4gYXMgX2xvZ1dhcm4sIHZhbGlkYXRlSXNOb3RVc2VkVG9nZXRoZXIgYXMgX3ZhbGlkYXRlSXNOb3RVc2VkVG9nZXRoZXIsIGFkZERvYywgYWdncmVnYXRlRmllbGRFcXVhbCwgYWdncmVnYXRlUXVlcnlTbmFwc2hvdEVxdWFsLCBhbmQsIGFycmF5UmVtb3ZlLCBhcnJheVVuaW9uLCBhdmVyYWdlLCBjbGVhckluZGV4ZWREYlBlcnNpc3RlbmNlLCBjb2xsZWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvciwgY291bnQsIGRlbGV0ZUFsbFBlcnNpc3RlbnRDYWNoZUluZGV4ZXMsIGRlbGV0ZURvYywgZGVsZXRlRmllbGQsIGRpc2FibGVOZXR3b3JrLCBkaXNhYmxlUGVyc2lzdGVudENhY2hlSW5kZXhBdXRvQ3JlYXRpb24sIGRvYywgZG9jdW1lbnRJZCwgZW5hYmxlSW5kZXhlZERiUGVyc2lzdGVuY2UsIGVuYWJsZU11bHRpVGFiSW5kZXhlZERiUGVyc2lzdGVuY2UsIGVuYWJsZU5ldHdvcmssIGVuYWJsZVBlcnNpc3RlbnRDYWNoZUluZGV4QXV0b0NyZWF0aW9uLCBlbmRBdCwgZW5kQmVmb3JlLCBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkLCBleGVjdXRlV3JpdGUsIGdldEFnZ3JlZ2F0ZUZyb21TZXJ2ZXIsIGdldENvdW50RnJvbVNlcnZlciwgZ2V0RG9jLCBnZXREb2NGcm9tQ2FjaGUsIGdldERvY0Zyb21TZXJ2ZXIsIGdldERvY3MsIGdldERvY3NGcm9tQ2FjaGUsIGdldERvY3NGcm9tU2VydmVyLCBnZXRGaXJlc3RvcmUsIGdldFBlcnNpc3RlbnRDYWNoZUluZGV4TWFuYWdlciwgaW5jcmVtZW50LCBpbml0aWFsaXplRmlyZXN0b3JlLCBsaW1pdCwgbGltaXRUb0xhc3QsIGxvYWRCdW5kbGUsIG1lbW9yeUVhZ2VyR2FyYmFnZUNvbGxlY3RvciwgbWVtb3J5TG9jYWxDYWNoZSwgbWVtb3J5THJ1R2FyYmFnZUNvbGxlY3RvciwgbmFtZWRRdWVyeSwgb25TbmFwc2hvdCwgb25TbmFwc2hvdHNJblN5bmMsIG9yLCBvcmRlckJ5LCBwZXJzaXN0ZW50TG9jYWxDYWNoZSwgcGVyc2lzdGVudE11bHRpcGxlVGFiTWFuYWdlciwgcGVyc2lzdGVudFNpbmdsZVRhYk1hbmFnZXIsIHF1ZXJ5LCBxdWVyeUVxdWFsLCByZWZFcXVhbCwgcnVuVHJhbnNhY3Rpb24sIHNlcnZlclRpbWVzdGFtcCwgc2V0RG9jLCBzZXRJbmRleENvbmZpZ3VyYXRpb24sIHNldExvZ0xldmVsLCBzbmFwc2hvdEVxdWFsLCBzdGFydEFmdGVyLCBzdGFydEF0LCBzdW0sIHRlcm1pbmF0ZSwgdXBkYXRlRG9jLCB2ZWN0b3IsIHdhaXRGb3JQZW5kaW5nV3JpdGVzLCB3aGVyZSwgd3JpdGVCYXRjaCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@firebase/firestore/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/@firebase/logger/dist/esm/index.esm2017.js":
/*!******************************************************************!*\
  !*** ../node_modules/@firebase/logger/dist/esm/index.esm2017.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setUserLogHandler: () => (/* binding */ setUserLogHandler)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A container for all of the Logger instances\n */\nconst instances = [];\n/**\n * The JS SDK supports 5 log levels and also allows a user the ability to\n * silence the logs altogether.\n *\n * The order is a follows:\n * DEBUG < VERBOSE < INFO < WARN < ERROR\n *\n * All of the log types above the current log level will be captured (i.e. if\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\n * `VERBOSE` logs will not)\n */\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nconst levelStringToEnum = {\n    'debug': LogLevel.DEBUG,\n    'verbose': LogLevel.VERBOSE,\n    'info': LogLevel.INFO,\n    'warn': LogLevel.WARN,\n    'error': LogLevel.ERROR,\n    'silent': LogLevel.SILENT\n};\n/**\n * The default log level\n */\nconst defaultLogLevel = LogLevel.INFO;\n/**\n * By default, `console.debug` is not displayed in the developer console (in\n * chrome). To avoid forcing users to have to opt-in to these logs twice\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\n * logs to the `console.log` function.\n */\nconst ConsoleMethod = {\n    [LogLevel.DEBUG]: 'log',\n    [LogLevel.VERBOSE]: 'log',\n    [LogLevel.INFO]: 'info',\n    [LogLevel.WARN]: 'warn',\n    [LogLevel.ERROR]: 'error'\n};\n/**\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\n * messages on to their corresponding console counterparts (if the log method\n * is supported by the current log level)\n */\nconst defaultLogHandler = (instance, logType, ...args) => {\n    if (logType < instance.logLevel) {\n        return;\n    }\n    const now = new Date().toISOString();\n    const method = ConsoleMethod[logType];\n    if (method) {\n        console[method](`[${now}]  ${instance.name}:`, ...args);\n    }\n    else {\n        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\n    }\n};\nclass Logger {\n    /**\n     * Gives you an instance of a Logger to capture messages according to\n     * Firebase's logging scheme.\n     *\n     * @param name The name that the logs will be associated with\n     */\n    constructor(name) {\n        this.name = name;\n        /**\n         * The log level of the given Logger instance.\n         */\n        this._logLevel = defaultLogLevel;\n        /**\n         * The main (internal) log handler for the Logger instance.\n         * Can be set to a new function in internal package code but not by user.\n         */\n        this._logHandler = defaultLogHandler;\n        /**\n         * The optional, additional, user-defined log handler for the Logger instance.\n         */\n        this._userLogHandler = null;\n        /**\n         * Capture the current instance for later use\n         */\n        instances.push(this);\n    }\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(val) {\n        if (!(val in LogLevel)) {\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n        }\n        this._logLevel = val;\n    }\n    // Workaround for setter/getter having to be the same type.\n    setLogLevel(val) {\n        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;\n    }\n    get logHandler() {\n        return this._logHandler;\n    }\n    set logHandler(val) {\n        if (typeof val !== 'function') {\n            throw new TypeError('Value assigned to `logHandler` must be a function');\n        }\n        this._logHandler = val;\n    }\n    get userLogHandler() {\n        return this._userLogHandler;\n    }\n    set userLogHandler(val) {\n        this._userLogHandler = val;\n    }\n    /**\n     * The functions below are all based on the `console` interface\n     */\n    debug(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\n        this._logHandler(this, LogLevel.DEBUG, ...args);\n    }\n    log(...args) {\n        this._userLogHandler &&\n            this._userLogHandler(this, LogLevel.VERBOSE, ...args);\n        this._logHandler(this, LogLevel.VERBOSE, ...args);\n    }\n    info(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\n        this._logHandler(this, LogLevel.INFO, ...args);\n    }\n    warn(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\n        this._logHandler(this, LogLevel.WARN, ...args);\n    }\n    error(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\n        this._logHandler(this, LogLevel.ERROR, ...args);\n    }\n}\nfunction setLogLevel(level) {\n    instances.forEach(inst => {\n        inst.setLogLevel(level);\n    });\n}\nfunction setUserLogHandler(logCallback, options) {\n    for (const instance of instances) {\n        let customLogLevel = null;\n        if (options && options.level) {\n            customLogLevel = levelStringToEnum[options.level];\n        }\n        if (logCallback === null) {\n            instance.userLogHandler = null;\n        }\n        else {\n            instance.userLogHandler = (instance, level, ...args) => {\n                const message = args\n                    .map(arg => {\n                    if (arg == null) {\n                        return null;\n                    }\n                    else if (typeof arg === 'string') {\n                        return arg;\n                    }\n                    else if (typeof arg === 'number' || typeof arg === 'boolean') {\n                        return arg.toString();\n                    }\n                    else if (arg instanceof Error) {\n                        return arg.message;\n                    }\n                    else {\n                        try {\n                            return JSON.stringify(arg);\n                        }\n                        catch (ignored) {\n                            return null;\n                        }\n                    }\n                })\n                    .filter(arg => arg)\n                    .join(' ');\n                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\n                    logCallback({\n                        level: LogLevel[level].toLowerCase(),\n                        message,\n                        args,\n                        type: instance.name\n                    });\n                }\n            };\n        }\n    }\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9sb2dnZXIvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSSxLQUFLLGNBQWM7QUFDbkQ7QUFDQTtBQUNBLHNGQUFzRixRQUFRO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELElBQUk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTREO0FBQzVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGFsa190b190ZXh0Ly4uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbG9nZ2VyL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanM/YzE3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgYWxsIG9mIHRoZSBMb2dnZXIgaW5zdGFuY2VzXG4gKi9cbmNvbnN0IGluc3RhbmNlcyA9IFtdO1xuLyoqXG4gKiBUaGUgSlMgU0RLIHN1cHBvcnRzIDUgbG9nIGxldmVscyBhbmQgYWxzbyBhbGxvd3MgYSB1c2VyIHRoZSBhYmlsaXR5IHRvXG4gKiBzaWxlbmNlIHRoZSBsb2dzIGFsdG9nZXRoZXIuXG4gKlxuICogVGhlIG9yZGVyIGlzIGEgZm9sbG93czpcbiAqIERFQlVHIDwgVkVSQk9TRSA8IElORk8gPCBXQVJOIDwgRVJST1JcbiAqXG4gKiBBbGwgb2YgdGhlIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgd2lsbCBiZSBjYXB0dXJlZCAoaS5lLiBpZlxuICogeW91IHNldCB0aGUgbG9nIGxldmVsIHRvIGBJTkZPYCwgZXJyb3JzIHdpbGwgc3RpbGwgYmUgbG9nZ2VkLCBidXQgYERFQlVHYCBhbmRcbiAqIGBWRVJCT1NFYCBsb2dzIHdpbGwgbm90KVxuICovXG52YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJERUJVR1wiXSA9IDBdID0gXCJERUJVR1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiVkVSQk9TRVwiXSA9IDFdID0gXCJWRVJCT1NFXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJTkZPXCJdID0gMl0gPSBcIklORk9cIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldBUk5cIl0gPSAzXSA9IFwiV0FSTlwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRVJST1JcIl0gPSA0XSA9IFwiRVJST1JcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlNJTEVOVFwiXSA9IDVdID0gXCJTSUxFTlRcIjtcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XG5jb25zdCBsZXZlbFN0cmluZ1RvRW51bSA9IHtcbiAgICAnZGVidWcnOiBMb2dMZXZlbC5ERUJVRyxcbiAgICAndmVyYm9zZSc6IExvZ0xldmVsLlZFUkJPU0UsXG4gICAgJ2luZm8nOiBMb2dMZXZlbC5JTkZPLFxuICAgICd3YXJuJzogTG9nTGV2ZWwuV0FSTixcbiAgICAnZXJyb3InOiBMb2dMZXZlbC5FUlJPUixcbiAgICAnc2lsZW50JzogTG9nTGV2ZWwuU0lMRU5UXG59O1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBsb2cgbGV2ZWxcbiAqL1xuY29uc3QgZGVmYXVsdExvZ0xldmVsID0gTG9nTGV2ZWwuSU5GTztcbi8qKlxuICogQnkgZGVmYXVsdCwgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBkaXNwbGF5ZWQgaW4gdGhlIGRldmVsb3BlciBjb25zb2xlIChpblxuICogY2hyb21lKS4gVG8gYXZvaWQgZm9yY2luZyB1c2VycyB0byBoYXZlIHRvIG9wdC1pbiB0byB0aGVzZSBsb2dzIHR3aWNlXG4gKiAoaS5lLiBvbmNlIGZvciBmaXJlYmFzZSwgYW5kIG9uY2UgaW4gdGhlIGNvbnNvbGUpLCB3ZSBhcmUgc2VuZGluZyBgREVCVUdgXG4gKiBsb2dzIHRvIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uLlxuICovXG5jb25zdCBDb25zb2xlTWV0aG9kID0ge1xuICAgIFtMb2dMZXZlbC5ERUJVR106ICdsb2cnLFxuICAgIFtMb2dMZXZlbC5WRVJCT1NFXTogJ2xvZycsXG4gICAgW0xvZ0xldmVsLklORk9dOiAnaW5mbycsXG4gICAgW0xvZ0xldmVsLldBUk5dOiAnd2FybicsXG4gICAgW0xvZ0xldmVsLkVSUk9SXTogJ2Vycm9yJ1xufTtcbi8qKlxuICogVGhlIGRlZmF1bHQgbG9nIGhhbmRsZXIgd2lsbCBmb3J3YXJkIERFQlVHLCBWRVJCT1NFLCBJTkZPLCBXQVJOLCBhbmQgRVJST1JcbiAqIG1lc3NhZ2VzIG9uIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgY29uc29sZSBjb3VudGVycGFydHMgKGlmIHRoZSBsb2cgbWV0aG9kXG4gKiBpcyBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgbG9nIGxldmVsKVxuICovXG5jb25zdCBkZWZhdWx0TG9nSGFuZGxlciA9IChpbnN0YW5jZSwgbG9nVHlwZSwgLi4uYXJncykgPT4ge1xuICAgIGlmIChsb2dUeXBlIDwgaW5zdGFuY2UubG9nTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgY29uc3QgbWV0aG9kID0gQ29uc29sZU1ldGhvZFtsb2dUeXBlXTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIGNvbnNvbGVbbWV0aG9kXShgWyR7bm93fV0gICR7aW5zdGFuY2UubmFtZX06YCwgLi4uYXJncyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byBsb2cgYSBtZXNzYWdlIHdpdGggYW4gaW52YWxpZCBsb2dUeXBlICh2YWx1ZTogJHtsb2dUeXBlfSlgKTtcbiAgICB9XG59O1xuY2xhc3MgTG9nZ2VyIHtcbiAgICAvKipcbiAgICAgKiBHaXZlcyB5b3UgYW4gaW5zdGFuY2Ugb2YgYSBMb2dnZXIgdG8gY2FwdHVyZSBtZXNzYWdlcyBhY2NvcmRpbmcgdG9cbiAgICAgKiBGaXJlYmFzZSdzIGxvZ2dpbmcgc2NoZW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgdGhhdCB0aGUgbG9ncyB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2cgbGV2ZWwgb2YgdGhlIGdpdmVuIExvZ2dlciBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gZGVmYXVsdExvZ0xldmVsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1haW4gKGludGVybmFsKSBsb2cgaGFuZGxlciBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cbiAgICAgICAgICogQ2FuIGJlIHNldCB0byBhIG5ldyBmdW5jdGlvbiBpbiBpbnRlcm5hbCBwYWNrYWdlIGNvZGUgYnV0IG5vdCBieSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlciA9IGRlZmF1bHRMb2dIYW5kbGVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9wdGlvbmFsLCBhZGRpdGlvbmFsLCB1c2VyLWRlZmluZWQgbG9nIGhhbmRsZXIgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXB0dXJlIHRoZSBjdXJyZW50IGluc3RhbmNlIGZvciBsYXRlciB1c2VcbiAgICAgICAgICovXG4gICAgICAgIGluc3RhbmNlcy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgbG9nTGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dMZXZlbDtcbiAgICB9XG4gICAgc2V0IGxvZ0xldmVsKHZhbCkge1xuICAgICAgICBpZiAoISh2YWwgaW4gTG9nTGV2ZWwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHZhbHVlIFwiJHt2YWx9XCIgYXNzaWduZWQgdG8gXFxgbG9nTGV2ZWxcXGBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IHZhbDtcbiAgICB9XG4gICAgLy8gV29ya2Fyb3VuZCBmb3Igc2V0dGVyL2dldHRlciBoYXZpbmcgdG8gYmUgdGhlIHNhbWUgdHlwZS5cbiAgICBzZXRMb2dMZXZlbCh2YWwpIHtcbiAgICAgICAgdGhpcy5fbG9nTGV2ZWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/IGxldmVsU3RyaW5nVG9FbnVtW3ZhbF0gOiB2YWw7XG4gICAgfVxuICAgIGdldCBsb2dIYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9nSGFuZGxlcjtcbiAgICB9XG4gICAgc2V0IGxvZ0hhbmRsZXIodmFsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBhc3NpZ25lZCB0byBgbG9nSGFuZGxlcmAgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlciA9IHZhbDtcbiAgICB9XG4gICAgZ2V0IHVzZXJMb2dIYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXNlckxvZ0hhbmRsZXI7XG4gICAgfVxuICAgIHNldCB1c2VyTG9nSGFuZGxlcih2YWwpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbnMgYmVsb3cgYXJlIGFsbCBiYXNlZCBvbiB0aGUgYGNvbnNvbGVgIGludGVyZmFjZVxuICAgICAqL1xuICAgIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuREVCVUcsIC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgbG9nKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiZcbiAgICAgICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLlZFUkJPU0UsIC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLlZFUkJPU0UsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XG4gICAgfVxuICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgZXJyb3IoLi4uYXJncykge1xuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5FUlJPUiwgLi4uYXJncyk7XG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuRVJST1IsIC4uLmFyZ3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XG4gICAgaW5zdGFuY2VzLmZvckVhY2goaW5zdCA9PiB7XG4gICAgICAgIGluc3Quc2V0TG9nTGV2ZWwobGV2ZWwpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0VXNlckxvZ0hhbmRsZXIobG9nQ2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgICBsZXQgY3VzdG9tTG9nTGV2ZWwgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxldmVsKSB7XG4gICAgICAgICAgICBjdXN0b21Mb2dMZXZlbCA9IGxldmVsU3RyaW5nVG9FbnVtW29wdGlvbnMubGV2ZWxdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2dDYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2UudXNlckxvZ0hhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFuY2UudXNlckxvZ0hhbmRsZXIgPSAoaW5zdGFuY2UsIGxldmVsLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgLm1hcChhcmcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8IHR5cGVvZiBhcmcgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoYXJnID0+IGFyZylcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPj0gKGN1c3RvbUxvZ0xldmVsICE9PSBudWxsICYmIGN1c3RvbUxvZ0xldmVsICE9PSB2b2lkIDAgPyBjdXN0b21Mb2dMZXZlbCA6IGluc3RhbmNlLmxvZ0xldmVsKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogTG9nTGV2ZWxbbGV2ZWxdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGluc3RhbmNlLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgTG9nTGV2ZWwsIExvZ2dlciwgc2V0TG9nTGV2ZWwsIHNldFVzZXJMb2dIYW5kbGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@firebase/logger/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@firebase/storage/dist/node-esm/index.node.esm.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@firebase/storage/dist/node-esm/index.node.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageError: () => (/* binding */ StorageError),\n/* harmony export */   StorageErrorCode: () => (/* binding */ StorageErrorCode),\n/* harmony export */   StringFormat: () => (/* binding */ StringFormat),\n/* harmony export */   _FbsBlob: () => (/* binding */ FbsBlob),\n/* harmony export */   _Location: () => (/* binding */ Location),\n/* harmony export */   _TaskEvent: () => (/* binding */ TaskEvent),\n/* harmony export */   _TaskState: () => (/* binding */ TaskState),\n/* harmony export */   _UploadTask: () => (/* binding */ UploadTask),\n/* harmony export */   _dataFromString: () => (/* binding */ dataFromString),\n/* harmony export */   _getChild: () => (/* binding */ _getChild),\n/* harmony export */   _invalidArgument: () => (/* binding */ invalidArgument),\n/* harmony export */   _invalidRootOperation: () => (/* binding */ invalidRootOperation),\n/* harmony export */   connectStorageEmulator: () => (/* binding */ connectStorageEmulator),\n/* harmony export */   deleteObject: () => (/* binding */ deleteObject),\n/* harmony export */   getBlob: () => (/* binding */ getBlob),\n/* harmony export */   getBytes: () => (/* binding */ getBytes),\n/* harmony export */   getDownloadURL: () => (/* binding */ getDownloadURL),\n/* harmony export */   getMetadata: () => (/* binding */ getMetadata),\n/* harmony export */   getStorage: () => (/* binding */ getStorage),\n/* harmony export */   getStream: () => (/* binding */ getStream),\n/* harmony export */   list: () => (/* binding */ list),\n/* harmony export */   listAll: () => (/* binding */ listAll),\n/* harmony export */   ref: () => (/* binding */ ref),\n/* harmony export */   updateMetadata: () => (/* binding */ updateMetadata),\n/* harmony export */   uploadBytes: () => (/* binding */ uploadBytes),\n/* harmony export */   uploadBytesResumable: () => (/* binding */ uploadBytesResumable),\n/* harmony export */   uploadString: () => (/* binding */ uploadString)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/../node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/../node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/../node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n\n\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Constants used in the Firebase Storage library.\n */\n/**\n * Domain name for firebase storage.\n */\nconst DEFAULT_HOST = 'firebasestorage.googleapis.com';\n/**\n * The key in Firebase config json for the storage bucket.\n */\nconst CONFIG_STORAGE_BUCKET_KEY = 'storageBucket';\n/**\n * 2 minutes\n *\n * The timeout for all operations except upload.\n */\nconst DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1000;\n/**\n * 10 minutes\n *\n * The timeout for upload.\n */\nconst DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1000;\n/**\n * 1 second\n */\nconst DEFAULT_MIN_SLEEP_TIME_MILLIS = 1000;\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An error returned by the Firebase Storage SDK.\n * @public\n */\nclass StorageError extends _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError {\n    /**\n     * @param code - A `StorageErrorCode` string to be prefixed with 'storage/' and\n     *  added to the end of the message.\n     * @param message  - Error message.\n     * @param status_ - Corresponding HTTP Status Code\n     */\n    constructor(code, message, status_ = 0) {\n        super(prependCode(code), `Firebase Storage: ${message} (${prependCode(code)})`);\n        this.status_ = status_;\n        /**\n         * Stores custom error data unique to the `StorageError`.\n         */\n        this.customData = { serverResponse: null };\n        this._baseMessage = this.message;\n        // Without this, `instanceof StorageError`, in tests for example,\n        // returns false.\n        Object.setPrototypeOf(this, StorageError.prototype);\n    }\n    get status() {\n        return this.status_;\n    }\n    set status(status) {\n        this.status_ = status;\n    }\n    /**\n     * Compares a `StorageErrorCode` against this error's code, filtering out the prefix.\n     */\n    _codeEquals(code) {\n        return prependCode(code) === this.code;\n    }\n    /**\n     * Optional response message that was added by the server.\n     */\n    get serverResponse() {\n        return this.customData.serverResponse;\n    }\n    set serverResponse(serverResponse) {\n        this.customData.serverResponse = serverResponse;\n        if (this.customData.serverResponse) {\n            this.message = `${this._baseMessage}\\n${this.customData.serverResponse}`;\n        }\n        else {\n            this.message = this._baseMessage;\n        }\n    }\n}\n/**\n * @public\n * Error codes that can be attached to `StorageError` objects.\n */\nvar StorageErrorCode;\n(function (StorageErrorCode) {\n    // Shared between all platforms\n    StorageErrorCode[\"UNKNOWN\"] = \"unknown\";\n    StorageErrorCode[\"OBJECT_NOT_FOUND\"] = \"object-not-found\";\n    StorageErrorCode[\"BUCKET_NOT_FOUND\"] = \"bucket-not-found\";\n    StorageErrorCode[\"PROJECT_NOT_FOUND\"] = \"project-not-found\";\n    StorageErrorCode[\"QUOTA_EXCEEDED\"] = \"quota-exceeded\";\n    StorageErrorCode[\"UNAUTHENTICATED\"] = \"unauthenticated\";\n    StorageErrorCode[\"UNAUTHORIZED\"] = \"unauthorized\";\n    StorageErrorCode[\"UNAUTHORIZED_APP\"] = \"unauthorized-app\";\n    StorageErrorCode[\"RETRY_LIMIT_EXCEEDED\"] = \"retry-limit-exceeded\";\n    StorageErrorCode[\"INVALID_CHECKSUM\"] = \"invalid-checksum\";\n    StorageErrorCode[\"CANCELED\"] = \"canceled\";\n    // JS specific\n    StorageErrorCode[\"INVALID_EVENT_NAME\"] = \"invalid-event-name\";\n    StorageErrorCode[\"INVALID_URL\"] = \"invalid-url\";\n    StorageErrorCode[\"INVALID_DEFAULT_BUCKET\"] = \"invalid-default-bucket\";\n    StorageErrorCode[\"NO_DEFAULT_BUCKET\"] = \"no-default-bucket\";\n    StorageErrorCode[\"CANNOT_SLICE_BLOB\"] = \"cannot-slice-blob\";\n    StorageErrorCode[\"SERVER_FILE_WRONG_SIZE\"] = \"server-file-wrong-size\";\n    StorageErrorCode[\"NO_DOWNLOAD_URL\"] = \"no-download-url\";\n    StorageErrorCode[\"INVALID_ARGUMENT\"] = \"invalid-argument\";\n    StorageErrorCode[\"INVALID_ARGUMENT_COUNT\"] = \"invalid-argument-count\";\n    StorageErrorCode[\"APP_DELETED\"] = \"app-deleted\";\n    StorageErrorCode[\"INVALID_ROOT_OPERATION\"] = \"invalid-root-operation\";\n    StorageErrorCode[\"INVALID_FORMAT\"] = \"invalid-format\";\n    StorageErrorCode[\"INTERNAL_ERROR\"] = \"internal-error\";\n    StorageErrorCode[\"UNSUPPORTED_ENVIRONMENT\"] = \"unsupported-environment\";\n})(StorageErrorCode || (StorageErrorCode = {}));\nfunction prependCode(code) {\n    return 'storage/' + code;\n}\nfunction unknown() {\n    const message = 'An unknown error occurred, please check the error payload for ' +\n        'server response.';\n    return new StorageError(StorageErrorCode.UNKNOWN, message);\n}\nfunction objectNotFound(path) {\n    return new StorageError(StorageErrorCode.OBJECT_NOT_FOUND, \"Object '\" + path + \"' does not exist.\");\n}\nfunction quotaExceeded(bucket) {\n    return new StorageError(StorageErrorCode.QUOTA_EXCEEDED, \"Quota for bucket '\" +\n        bucket +\n        \"' exceeded, please view quota on \" +\n        'https://firebase.google.com/pricing/.');\n}\nfunction unauthenticated() {\n    const message = 'User is not authenticated, please authenticate using Firebase ' +\n        'Authentication and try again.';\n    return new StorageError(StorageErrorCode.UNAUTHENTICATED, message);\n}\nfunction unauthorizedApp() {\n    return new StorageError(StorageErrorCode.UNAUTHORIZED_APP, 'This app does not have permission to access Firebase Storage on this project.');\n}\nfunction unauthorized(path) {\n    return new StorageError(StorageErrorCode.UNAUTHORIZED, \"User does not have permission to access '\" + path + \"'.\");\n}\nfunction retryLimitExceeded() {\n    return new StorageError(StorageErrorCode.RETRY_LIMIT_EXCEEDED, 'Max retry time for operation exceeded, please try again.');\n}\nfunction canceled() {\n    return new StorageError(StorageErrorCode.CANCELED, 'User canceled the upload/download.');\n}\nfunction invalidUrl(url) {\n    return new StorageError(StorageErrorCode.INVALID_URL, \"Invalid URL '\" + url + \"'.\");\n}\nfunction invalidDefaultBucket(bucket) {\n    return new StorageError(StorageErrorCode.INVALID_DEFAULT_BUCKET, \"Invalid default bucket '\" + bucket + \"'.\");\n}\nfunction noDefaultBucket() {\n    return new StorageError(StorageErrorCode.NO_DEFAULT_BUCKET, 'No default bucket ' +\n        \"found. Did you set the '\" +\n        CONFIG_STORAGE_BUCKET_KEY +\n        \"' property when initializing the app?\");\n}\nfunction cannotSliceBlob() {\n    return new StorageError(StorageErrorCode.CANNOT_SLICE_BLOB, 'Cannot slice blob for upload. Please retry the upload.');\n}\nfunction serverFileWrongSize() {\n    return new StorageError(StorageErrorCode.SERVER_FILE_WRONG_SIZE, 'Server recorded incorrect upload file size, please retry the upload.');\n}\nfunction noDownloadURL() {\n    return new StorageError(StorageErrorCode.NO_DOWNLOAD_URL, 'The given file does not have any download URLs.');\n}\n/**\n * @internal\n */\nfunction invalidArgument(message) {\n    return new StorageError(StorageErrorCode.INVALID_ARGUMENT, message);\n}\nfunction appDeleted() {\n    return new StorageError(StorageErrorCode.APP_DELETED, 'The Firebase app was deleted.');\n}\n/**\n * @param name - The name of the operation that was invalid.\n *\n * @internal\n */\nfunction invalidRootOperation(name) {\n    return new StorageError(StorageErrorCode.INVALID_ROOT_OPERATION, \"The operation '\" +\n        name +\n        \"' cannot be performed on a root reference, create a non-root \" +\n        \"reference using child, such as .child('file.png').\");\n}\n/**\n * @param format - The format that was not valid.\n * @param message - A message describing the format violation.\n */\nfunction invalidFormat(format, message) {\n    return new StorageError(StorageErrorCode.INVALID_FORMAT, \"String does not match format '\" + format + \"': \" + message);\n}\n/**\n * @param message - A message describing the internal error.\n */\nfunction internalError(message) {\n    throw new StorageError(StorageErrorCode.INTERNAL_ERROR, 'Internal error: ' + message);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Firebase Storage location data.\n *\n * @internal\n */\nclass Location {\n    constructor(bucket, path) {\n        this.bucket = bucket;\n        this.path_ = path;\n    }\n    get path() {\n        return this.path_;\n    }\n    get isRoot() {\n        return this.path.length === 0;\n    }\n    fullServerUrl() {\n        const encode = encodeURIComponent;\n        return '/b/' + encode(this.bucket) + '/o/' + encode(this.path);\n    }\n    bucketOnlyServerUrl() {\n        const encode = encodeURIComponent;\n        return '/b/' + encode(this.bucket) + '/o';\n    }\n    static makeFromBucketSpec(bucketString, host) {\n        let bucketLocation;\n        try {\n            bucketLocation = Location.makeFromUrl(bucketString, host);\n        }\n        catch (e) {\n            // Not valid URL, use as-is. This lets you put bare bucket names in\n            // config.\n            return new Location(bucketString, '');\n        }\n        if (bucketLocation.path === '') {\n            return bucketLocation;\n        }\n        else {\n            throw invalidDefaultBucket(bucketString);\n        }\n    }\n    static makeFromUrl(url, host) {\n        let location = null;\n        const bucketDomain = '([A-Za-z0-9.\\\\-_]+)';\n        function gsModify(loc) {\n            if (loc.path.charAt(loc.path.length - 1) === '/') {\n                loc.path_ = loc.path_.slice(0, -1);\n            }\n        }\n        const gsPath = '(/(.*))?$';\n        const gsRegex = new RegExp('^gs://' + bucketDomain + gsPath, 'i');\n        const gsIndices = { bucket: 1, path: 3 };\n        function httpModify(loc) {\n            loc.path_ = decodeURIComponent(loc.path);\n        }\n        const version = 'v[A-Za-z0-9_]+';\n        const firebaseStorageHost = host.replace(/[.]/g, '\\\\.');\n        const firebaseStoragePath = '(/([^?#]*).*)?$';\n        const firebaseStorageRegExp = new RegExp(`^https?://${firebaseStorageHost}/${version}/b/${bucketDomain}/o${firebaseStoragePath}`, 'i');\n        const firebaseStorageIndices = { bucket: 1, path: 3 };\n        const cloudStorageHost = host === DEFAULT_HOST\n            ? '(?:storage.googleapis.com|storage.cloud.google.com)'\n            : host;\n        const cloudStoragePath = '([^?#]*)';\n        const cloudStorageRegExp = new RegExp(`^https?://${cloudStorageHost}/${bucketDomain}/${cloudStoragePath}`, 'i');\n        const cloudStorageIndices = { bucket: 1, path: 2 };\n        const groups = [\n            { regex: gsRegex, indices: gsIndices, postModify: gsModify },\n            {\n                regex: firebaseStorageRegExp,\n                indices: firebaseStorageIndices,\n                postModify: httpModify\n            },\n            {\n                regex: cloudStorageRegExp,\n                indices: cloudStorageIndices,\n                postModify: httpModify\n            }\n        ];\n        for (let i = 0; i < groups.length; i++) {\n            const group = groups[i];\n            const captures = group.regex.exec(url);\n            if (captures) {\n                const bucketValue = captures[group.indices.bucket];\n                let pathValue = captures[group.indices.path];\n                if (!pathValue) {\n                    pathValue = '';\n                }\n                location = new Location(bucketValue, pathValue);\n                group.postModify(location);\n                break;\n            }\n        }\n        if (location == null) {\n            throw invalidUrl(url);\n        }\n        return location;\n    }\n}\n\n/**\n * A request whose promise always fails.\n */\nclass FailRequest {\n    constructor(error) {\n        this.promise_ = Promise.reject(error);\n    }\n    /** @inheritDoc */\n    getPromise() {\n        return this.promise_;\n    }\n    /** @inheritDoc */\n    cancel(_appDelete = false) { }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Accepts a callback for an action to perform (`doRequest`),\n * and then a callback for when the backoff has completed (`backoffCompleteCb`).\n * The callback sent to start requires an argument to call (`onRequestComplete`).\n * When `start` calls `doRequest`, it passes a callback for when the request has\n * completed, `onRequestComplete`. Based on this, the backoff continues, with\n * another call to `doRequest` and the above loop continues until the timeout\n * is hit, or a successful response occurs.\n * @description\n * @param doRequest Callback to perform request\n * @param backoffCompleteCb Callback to call when backoff has been completed\n */\nfunction start(doRequest, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nbackoffCompleteCb, timeout) {\n    // TODO(andysoto): make this code cleaner (probably refactor into an actual\n    // type instead of a bunch of functions with state shared in the closure)\n    let waitSeconds = 1;\n    // Would type this as \"number\" but that doesn't work for Node so ¯\\_(ツ)_/¯\n    // TODO: find a way to exclude Node type definition for storage because storage only works in browser\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let retryTimeoutId = null;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let globalTimeoutId = null;\n    let hitTimeout = false;\n    let cancelState = 0;\n    function canceled() {\n        return cancelState === 2;\n    }\n    let triggeredCallback = false;\n    function triggerCallback(...args) {\n        if (!triggeredCallback) {\n            triggeredCallback = true;\n            backoffCompleteCb.apply(null, args);\n        }\n    }\n    function callWithDelay(millis) {\n        retryTimeoutId = setTimeout(() => {\n            retryTimeoutId = null;\n            doRequest(responseHandler, canceled());\n        }, millis);\n    }\n    function clearGlobalTimeout() {\n        if (globalTimeoutId) {\n            clearTimeout(globalTimeoutId);\n        }\n    }\n    function responseHandler(success, ...args) {\n        if (triggeredCallback) {\n            clearGlobalTimeout();\n            return;\n        }\n        if (success) {\n            clearGlobalTimeout();\n            triggerCallback.call(null, success, ...args);\n            return;\n        }\n        const mustStop = canceled() || hitTimeout;\n        if (mustStop) {\n            clearGlobalTimeout();\n            triggerCallback.call(null, success, ...args);\n            return;\n        }\n        if (waitSeconds < 64) {\n            /* TODO(andysoto): don't back off so quickly if we know we're offline. */\n            waitSeconds *= 2;\n        }\n        let waitMillis;\n        if (cancelState === 1) {\n            cancelState = 2;\n            waitMillis = 0;\n        }\n        else {\n            waitMillis = (waitSeconds + Math.random()) * 1000;\n        }\n        callWithDelay(waitMillis);\n    }\n    let stopped = false;\n    function stop(wasTimeout) {\n        if (stopped) {\n            return;\n        }\n        stopped = true;\n        clearGlobalTimeout();\n        if (triggeredCallback) {\n            return;\n        }\n        if (retryTimeoutId !== null) {\n            if (!wasTimeout) {\n                cancelState = 2;\n            }\n            clearTimeout(retryTimeoutId);\n            callWithDelay(0);\n        }\n        else {\n            if (!wasTimeout) {\n                cancelState = 1;\n            }\n        }\n    }\n    callWithDelay(0);\n    globalTimeoutId = setTimeout(() => {\n        hitTimeout = true;\n        stop(true);\n    }, timeout);\n    return stop;\n}\n/**\n * Stops the retry loop from repeating.\n * If the function is currently \"in between\" retries, it is invoked immediately\n * with the second parameter as \"true\". Otherwise, it will be invoked once more\n * after the current invocation finishes iff the current invocation would have\n * triggered another retry.\n */\nfunction stop(id) {\n    id(false);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isJustDef(p) {\n    return p !== void 0;\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isFunction(p) {\n    return typeof p === 'function';\n}\nfunction isNonArrayObject(p) {\n    return typeof p === 'object' && !Array.isArray(p);\n}\nfunction isString(p) {\n    return typeof p === 'string' || p instanceof String;\n}\nfunction isNativeBlob(p) {\n    return isNativeBlobDefined() && p instanceof Blob;\n}\nfunction isNativeBlobDefined() {\n    return typeof Blob !== 'undefined';\n}\nfunction validateNumber(argument, minValue, maxValue, value) {\n    if (value < minValue) {\n        throw invalidArgument(`Invalid value for '${argument}'. Expected ${minValue} or greater.`);\n    }\n    if (value > maxValue) {\n        throw invalidArgument(`Invalid value for '${argument}'. Expected ${maxValue} or less.`);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction makeUrl(urlPart, host, protocol) {\n    let origin = host;\n    if (protocol == null) {\n        origin = `https://${host}`;\n    }\n    return `${protocol}://${origin}/v0${urlPart}`;\n}\nfunction makeQueryString(params) {\n    const encode = encodeURIComponent;\n    let queryPart = '?';\n    for (const key in params) {\n        if (params.hasOwnProperty(key)) {\n            const nextPart = encode(key) + '=' + encode(params[key]);\n            queryPart = queryPart + nextPart + '&';\n        }\n    }\n    // Chop off the extra '&' or '?' on the end\n    queryPart = queryPart.slice(0, -1);\n    return queryPart;\n}\n\n/**\n * Error codes for requests made by the XhrIo wrapper.\n */\nvar ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[ErrorCode[\"NO_ERROR\"] = 0] = \"NO_ERROR\";\n    ErrorCode[ErrorCode[\"NETWORK_ERROR\"] = 1] = \"NETWORK_ERROR\";\n    ErrorCode[ErrorCode[\"ABORT\"] = 2] = \"ABORT\";\n})(ErrorCode || (ErrorCode = {}));\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Checks the status code to see if the action should be retried.\n *\n * @param status Current HTTP status code returned by server.\n * @param additionalRetryCodes additional retry codes to check against\n */\nfunction isRetryStatusCode(status, additionalRetryCodes) {\n    // The codes for which to retry came from this page:\n    // https://cloud.google.com/storage/docs/exponential-backoff\n    const isFiveHundredCode = status >= 500 && status < 600;\n    const extraRetryCodes = [\n        // Request Timeout: web server didn't receive full request in time.\n        408,\n        // Too Many Requests: you're getting rate-limited, basically.\n        429\n    ];\n    const isExtraRetryCode = extraRetryCodes.indexOf(status) !== -1;\n    const isAdditionalRetryCode = additionalRetryCodes.indexOf(status) !== -1;\n    return isFiveHundredCode || isExtraRetryCode || isAdditionalRetryCode;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Handles network logic for all Storage Requests, including error reporting and\n * retries with backoff.\n *\n * @param I - the type of the backend's network response.\n * @param - O the output type used by the rest of the SDK. The conversion\n * happens in the specified `callback_`.\n */\nclass NetworkRequest {\n    constructor(url_, method_, headers_, body_, successCodes_, additionalRetryCodes_, callback_, errorCallback_, timeout_, progressCallback_, connectionFactory_, retry = true) {\n        this.url_ = url_;\n        this.method_ = method_;\n        this.headers_ = headers_;\n        this.body_ = body_;\n        this.successCodes_ = successCodes_;\n        this.additionalRetryCodes_ = additionalRetryCodes_;\n        this.callback_ = callback_;\n        this.errorCallback_ = errorCallback_;\n        this.timeout_ = timeout_;\n        this.progressCallback_ = progressCallback_;\n        this.connectionFactory_ = connectionFactory_;\n        this.retry = retry;\n        this.pendingConnection_ = null;\n        this.backoffId_ = null;\n        this.canceled_ = false;\n        this.appDelete_ = false;\n        this.promise_ = new Promise((resolve, reject) => {\n            this.resolve_ = resolve;\n            this.reject_ = reject;\n            this.start_();\n        });\n    }\n    /**\n     * Actually starts the retry loop.\n     */\n    start_() {\n        const doTheRequest = (backoffCallback, canceled) => {\n            if (canceled) {\n                backoffCallback(false, new RequestEndStatus(false, null, true));\n                return;\n            }\n            const connection = this.connectionFactory_();\n            this.pendingConnection_ = connection;\n            const progressListener = progressEvent => {\n                const loaded = progressEvent.loaded;\n                const total = progressEvent.lengthComputable ? progressEvent.total : -1;\n                if (this.progressCallback_ !== null) {\n                    this.progressCallback_(loaded, total);\n                }\n            };\n            if (this.progressCallback_ !== null) {\n                connection.addUploadProgressListener(progressListener);\n            }\n            // connection.send() never rejects, so we don't need to have a error handler or use catch on the returned promise.\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            connection\n                .send(this.url_, this.method_, this.body_, this.headers_)\n                .then(() => {\n                if (this.progressCallback_ !== null) {\n                    connection.removeUploadProgressListener(progressListener);\n                }\n                this.pendingConnection_ = null;\n                const hitServer = connection.getErrorCode() === ErrorCode.NO_ERROR;\n                const status = connection.getStatus();\n                if (!hitServer ||\n                    (isRetryStatusCode(status, this.additionalRetryCodes_) &&\n                        this.retry)) {\n                    const wasCanceled = connection.getErrorCode() === ErrorCode.ABORT;\n                    backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));\n                    return;\n                }\n                const successCode = this.successCodes_.indexOf(status) !== -1;\n                backoffCallback(true, new RequestEndStatus(successCode, connection));\n            });\n        };\n        /**\n         * @param requestWentThrough - True if the request eventually went\n         *     through, false if it hit the retry limit or was canceled.\n         */\n        const backoffDone = (requestWentThrough, status) => {\n            const resolve = this.resolve_;\n            const reject = this.reject_;\n            const connection = status.connection;\n            if (status.wasSuccessCode) {\n                try {\n                    const result = this.callback_(connection, connection.getResponse());\n                    if (isJustDef(result)) {\n                        resolve(result);\n                    }\n                    else {\n                        resolve();\n                    }\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }\n            else {\n                if (connection !== null) {\n                    const err = unknown();\n                    err.serverResponse = connection.getErrorText();\n                    if (this.errorCallback_) {\n                        reject(this.errorCallback_(connection, err));\n                    }\n                    else {\n                        reject(err);\n                    }\n                }\n                else {\n                    if (status.canceled) {\n                        const err = this.appDelete_ ? appDeleted() : canceled();\n                        reject(err);\n                    }\n                    else {\n                        const err = retryLimitExceeded();\n                        reject(err);\n                    }\n                }\n            }\n        };\n        if (this.canceled_) {\n            backoffDone(false, new RequestEndStatus(false, null, true));\n        }\n        else {\n            this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);\n        }\n    }\n    /** @inheritDoc */\n    getPromise() {\n        return this.promise_;\n    }\n    /** @inheritDoc */\n    cancel(appDelete) {\n        this.canceled_ = true;\n        this.appDelete_ = appDelete || false;\n        if (this.backoffId_ !== null) {\n            stop(this.backoffId_);\n        }\n        if (this.pendingConnection_ !== null) {\n            this.pendingConnection_.abort();\n        }\n    }\n}\n/**\n * A collection of information about the result of a network request.\n * @param opt_canceled - Defaults to false.\n */\nclass RequestEndStatus {\n    constructor(wasSuccessCode, connection, canceled) {\n        this.wasSuccessCode = wasSuccessCode;\n        this.connection = connection;\n        this.canceled = !!canceled;\n    }\n}\nfunction addAuthHeader_(headers, authToken) {\n    if (authToken !== null && authToken.length > 0) {\n        headers['Authorization'] = 'Firebase ' + authToken;\n    }\n}\nfunction addVersionHeader_(headers, firebaseVersion) {\n    headers['X-Firebase-Storage-Version'] =\n        'webjs/' + (firebaseVersion !== null && firebaseVersion !== void 0 ? firebaseVersion : 'AppManager');\n}\nfunction addGmpidHeader_(headers, appId) {\n    if (appId) {\n        headers['X-Firebase-GMPID'] = appId;\n    }\n}\nfunction addAppCheckHeader_(headers, appCheckToken) {\n    if (appCheckToken !== null) {\n        headers['X-Firebase-AppCheck'] = appCheckToken;\n    }\n}\nfunction makeRequest(requestInfo, appId, authToken, appCheckToken, requestFactory, firebaseVersion, retry = true) {\n    const queryPart = makeQueryString(requestInfo.urlParams);\n    const url = requestInfo.url + queryPart;\n    const headers = Object.assign({}, requestInfo.headers);\n    addGmpidHeader_(headers, appId);\n    addAuthHeader_(headers, authToken);\n    addVersionHeader_(headers, firebaseVersion);\n    addAppCheckHeader_(headers, appCheckToken);\n    return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, requestFactory, retry);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getBlobBuilder() {\n    if (typeof BlobBuilder !== 'undefined') {\n        return BlobBuilder;\n    }\n    else if (typeof WebKitBlobBuilder !== 'undefined') {\n        return WebKitBlobBuilder;\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * Concatenates one or more values together and converts them to a Blob.\n *\n * @param args The values that will make up the resulting blob.\n * @return The blob.\n */\nfunction getBlob$1(...args) {\n    const BlobBuilder = getBlobBuilder();\n    if (BlobBuilder !== undefined) {\n        const bb = new BlobBuilder();\n        for (let i = 0; i < args.length; i++) {\n            bb.append(args[i]);\n        }\n        return bb.getBlob();\n    }\n    else {\n        if (isNativeBlobDefined()) {\n            return new Blob(args);\n        }\n        else {\n            throw new StorageError(StorageErrorCode.UNSUPPORTED_ENVIRONMENT, \"This browser doesn't seem to support creating Blobs\");\n        }\n    }\n}\n/**\n * Slices the blob. The returned blob contains data from the start byte\n * (inclusive) till the end byte (exclusive). Negative indices cannot be used.\n *\n * @param blob The blob to be sliced.\n * @param start Index of the starting byte.\n * @param end Index of the ending byte.\n * @return The blob slice or null if not supported.\n */\nfunction sliceBlob(blob, start, end) {\n    if (blob.webkitSlice) {\n        return blob.webkitSlice(start, end);\n    }\n    else if (blob.mozSlice) {\n        return blob.mozSlice(start, end);\n    }\n    else if (blob.slice) {\n        return blob.slice(start, end);\n    }\n    return null;\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Converts a Base64 encoded string to a binary string. */\nfunction decodeBase64(encoded) {\n    // Node actually doesn't validate base64 strings.\n    // A quick sanity check that is not a fool-proof validation\n    if (/[^-A-Za-z0-9+/=]/.test(encoded)) {\n        throw invalidFormat('base64', 'Invalid character found');\n    }\n    return Buffer.from(encoded, 'base64').toString('binary');\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An enumeration of the possible string formats for upload.\n * @public\n */\nconst StringFormat = {\n    /**\n     * Indicates the string should be interpreted \"raw\", that is, as normal text.\n     * The string will be interpreted as UTF-16, then uploaded as a UTF-8 byte\n     * sequence.\n     * Example: The string 'Hello! \\\\ud83d\\\\ude0a' becomes the byte sequence\n     * 48 65 6c 6c 6f 21 20 f0 9f 98 8a\n     */\n    RAW: 'raw',\n    /**\n     * Indicates the string should be interpreted as base64-encoded data.\n     * Padding characters (trailing '='s) are optional.\n     * Example: The string 'rWmO++E6t7/rlw==' becomes the byte sequence\n     * ad 69 8e fb e1 3a b7 bf eb 97\n     */\n    BASE64: 'base64',\n    /**\n     * Indicates the string should be interpreted as base64url-encoded data.\n     * Padding characters (trailing '='s) are optional.\n     * Example: The string 'rWmO--E6t7_rlw==' becomes the byte sequence\n     * ad 69 8e fb e1 3a b7 bf eb 97\n     */\n    BASE64URL: 'base64url',\n    /**\n     * Indicates the string is a data URL, such as one obtained from\n     * canvas.toDataURL().\n     * Example: the string 'data:application/octet-stream;base64,aaaa'\n     * becomes the byte sequence\n     * 69 a6 9a\n     * (the content-type \"application/octet-stream\" is also applied, but can\n     * be overridden in the metadata object).\n     */\n    DATA_URL: 'data_url'\n};\nclass StringData {\n    constructor(data, contentType) {\n        this.data = data;\n        this.contentType = contentType || null;\n    }\n}\n/**\n * @internal\n */\nfunction dataFromString(format, stringData) {\n    switch (format) {\n        case StringFormat.RAW:\n            return new StringData(utf8Bytes_(stringData));\n        case StringFormat.BASE64:\n        case StringFormat.BASE64URL:\n            return new StringData(base64Bytes_(format, stringData));\n        case StringFormat.DATA_URL:\n            return new StringData(dataURLBytes_(stringData), dataURLContentType_(stringData));\n        // do nothing\n    }\n    // assert(false);\n    throw unknown();\n}\nfunction utf8Bytes_(value) {\n    const b = [];\n    for (let i = 0; i < value.length; i++) {\n        let c = value.charCodeAt(i);\n        if (c <= 127) {\n            b.push(c);\n        }\n        else {\n            if (c <= 2047) {\n                b.push(192 | (c >> 6), 128 | (c & 63));\n            }\n            else {\n                if ((c & 64512) === 55296) {\n                    // The start of a surrogate pair.\n                    const valid = i < value.length - 1 && (value.charCodeAt(i + 1) & 64512) === 56320;\n                    if (!valid) {\n                        // The second surrogate wasn't there.\n                        b.push(239, 191, 189);\n                    }\n                    else {\n                        const hi = c;\n                        const lo = value.charCodeAt(++i);\n                        c = 65536 | ((hi & 1023) << 10) | (lo & 1023);\n                        b.push(240 | (c >> 18), 128 | ((c >> 12) & 63), 128 | ((c >> 6) & 63), 128 | (c & 63));\n                    }\n                }\n                else {\n                    if ((c & 64512) === 56320) {\n                        // Invalid low surrogate.\n                        b.push(239, 191, 189);\n                    }\n                    else {\n                        b.push(224 | (c >> 12), 128 | ((c >> 6) & 63), 128 | (c & 63));\n                    }\n                }\n            }\n        }\n    }\n    return new Uint8Array(b);\n}\nfunction percentEncodedBytes_(value) {\n    let decoded;\n    try {\n        decoded = decodeURIComponent(value);\n    }\n    catch (e) {\n        throw invalidFormat(StringFormat.DATA_URL, 'Malformed data URL.');\n    }\n    return utf8Bytes_(decoded);\n}\nfunction base64Bytes_(format, value) {\n    switch (format) {\n        case StringFormat.BASE64: {\n            const hasMinus = value.indexOf('-') !== -1;\n            const hasUnder = value.indexOf('_') !== -1;\n            if (hasMinus || hasUnder) {\n                const invalidChar = hasMinus ? '-' : '_';\n                throw invalidFormat(format, \"Invalid character '\" +\n                    invalidChar +\n                    \"' found: is it base64url encoded?\");\n            }\n            break;\n        }\n        case StringFormat.BASE64URL: {\n            const hasPlus = value.indexOf('+') !== -1;\n            const hasSlash = value.indexOf('/') !== -1;\n            if (hasPlus || hasSlash) {\n                const invalidChar = hasPlus ? '+' : '/';\n                throw invalidFormat(format, \"Invalid character '\" + invalidChar + \"' found: is it base64 encoded?\");\n            }\n            value = value.replace(/-/g, '+').replace(/_/g, '/');\n            break;\n        }\n        // do nothing\n    }\n    let bytes;\n    try {\n        bytes = decodeBase64(value);\n    }\n    catch (e) {\n        if (e.message.includes('polyfill')) {\n            throw e;\n        }\n        throw invalidFormat(format, 'Invalid character found');\n    }\n    const array = new Uint8Array(bytes.length);\n    for (let i = 0; i < bytes.length; i++) {\n        array[i] = bytes.charCodeAt(i);\n    }\n    return array;\n}\nclass DataURLParts {\n    constructor(dataURL) {\n        this.base64 = false;\n        this.contentType = null;\n        const matches = dataURL.match(/^data:([^,]+)?,/);\n        if (matches === null) {\n            throw invalidFormat(StringFormat.DATA_URL, \"Must be formatted 'data:[<mediatype>][;base64],<data>\");\n        }\n        const middle = matches[1] || null;\n        if (middle != null) {\n            this.base64 = endsWith(middle, ';base64');\n            this.contentType = this.base64\n                ? middle.substring(0, middle.length - ';base64'.length)\n                : middle;\n        }\n        this.rest = dataURL.substring(dataURL.indexOf(',') + 1);\n    }\n}\nfunction dataURLBytes_(dataUrl) {\n    const parts = new DataURLParts(dataUrl);\n    if (parts.base64) {\n        return base64Bytes_(StringFormat.BASE64, parts.rest);\n    }\n    else {\n        return percentEncodedBytes_(parts.rest);\n    }\n}\nfunction dataURLContentType_(dataUrl) {\n    const parts = new DataURLParts(dataUrl);\n    return parts.contentType;\n}\nfunction endsWith(s, end) {\n    const longEnough = s.length >= end.length;\n    if (!longEnough) {\n        return false;\n    }\n    return s.substring(s.length - end.length) === end;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param opt_elideCopy - If true, doesn't copy mutable input data\n *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be\n *     modified after this blob's construction.\n *\n * @internal\n */\nclass FbsBlob {\n    constructor(data, elideCopy) {\n        let size = 0;\n        let blobType = '';\n        if (isNativeBlob(data)) {\n            this.data_ = data;\n            size = data.size;\n            blobType = data.type;\n        }\n        else if (data instanceof ArrayBuffer) {\n            if (elideCopy) {\n                this.data_ = new Uint8Array(data);\n            }\n            else {\n                this.data_ = new Uint8Array(data.byteLength);\n                this.data_.set(new Uint8Array(data));\n            }\n            size = this.data_.length;\n        }\n        else if (data instanceof Uint8Array) {\n            if (elideCopy) {\n                this.data_ = data;\n            }\n            else {\n                this.data_ = new Uint8Array(data.length);\n                this.data_.set(data);\n            }\n            size = data.length;\n        }\n        this.size_ = size;\n        this.type_ = blobType;\n    }\n    size() {\n        return this.size_;\n    }\n    type() {\n        return this.type_;\n    }\n    slice(startByte, endByte) {\n        if (isNativeBlob(this.data_)) {\n            const realBlob = this.data_;\n            const sliced = sliceBlob(realBlob, startByte, endByte);\n            if (sliced === null) {\n                return null;\n            }\n            return new FbsBlob(sliced);\n        }\n        else {\n            const slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);\n            return new FbsBlob(slice, true);\n        }\n    }\n    static getBlob(...args) {\n        if (isNativeBlobDefined()) {\n            const blobby = args.map((val) => {\n                if (val instanceof FbsBlob) {\n                    return val.data_;\n                }\n                else {\n                    return val;\n                }\n            });\n            return new FbsBlob(getBlob$1.apply(null, blobby));\n        }\n        else {\n            const uint8Arrays = args.map((val) => {\n                if (isString(val)) {\n                    return dataFromString(StringFormat.RAW, val).data;\n                }\n                else {\n                    // Blobs don't exist, so this has to be a Uint8Array.\n                    return val.data_;\n                }\n            });\n            let finalLength = 0;\n            uint8Arrays.forEach((array) => {\n                finalLength += array.byteLength;\n            });\n            const merged = new Uint8Array(finalLength);\n            let index = 0;\n            uint8Arrays.forEach((array) => {\n                for (let i = 0; i < array.length; i++) {\n                    merged[index++] = array[i];\n                }\n            });\n            return new FbsBlob(merged, true);\n        }\n    }\n    uploadData() {\n        return this.data_;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns the Object resulting from parsing the given JSON, or null if the\n * given string does not represent a JSON object.\n */\nfunction jsonObjectOrNull(s) {\n    let obj;\n    try {\n        obj = JSON.parse(s);\n    }\n    catch (e) {\n        return null;\n    }\n    if (isNonArrayObject(obj)) {\n        return obj;\n    }\n    else {\n        return null;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Contains helper methods for manipulating paths.\n */\n/**\n * @return Null if the path is already at the root.\n */\nfunction parent(path) {\n    if (path.length === 0) {\n        return null;\n    }\n    const index = path.lastIndexOf('/');\n    if (index === -1) {\n        return '';\n    }\n    const newPath = path.slice(0, index);\n    return newPath;\n}\nfunction child(path, childPath) {\n    const canonicalChildPath = childPath\n        .split('/')\n        .filter(component => component.length > 0)\n        .join('/');\n    if (path.length === 0) {\n        return canonicalChildPath;\n    }\n    else {\n        return path + '/' + canonicalChildPath;\n    }\n}\n/**\n * Returns the last component of a path.\n * '/foo/bar' -> 'bar'\n * '/foo/bar/baz/' -> 'baz/'\n * '/a' -> 'a'\n */\nfunction lastComponent(path) {\n    const index = path.lastIndexOf('/', path.length - 2);\n    if (index === -1) {\n        return path;\n    }\n    else {\n        return path.slice(index + 1);\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction noXform_(metadata, value) {\n    return value;\n}\nclass Mapping {\n    constructor(server, local, writable, xform) {\n        this.server = server;\n        this.local = local || server;\n        this.writable = !!writable;\n        this.xform = xform || noXform_;\n    }\n}\nlet mappings_ = null;\nfunction xformPath(fullPath) {\n    if (!isString(fullPath) || fullPath.length < 2) {\n        return fullPath;\n    }\n    else {\n        return lastComponent(fullPath);\n    }\n}\nfunction getMappings() {\n    if (mappings_) {\n        return mappings_;\n    }\n    const mappings = [];\n    mappings.push(new Mapping('bucket'));\n    mappings.push(new Mapping('generation'));\n    mappings.push(new Mapping('metageneration'));\n    mappings.push(new Mapping('name', 'fullPath', true));\n    function mappingsXformPath(_metadata, fullPath) {\n        return xformPath(fullPath);\n    }\n    const nameMapping = new Mapping('name');\n    nameMapping.xform = mappingsXformPath;\n    mappings.push(nameMapping);\n    /**\n     * Coerces the second param to a number, if it is defined.\n     */\n    function xformSize(_metadata, size) {\n        if (size !== undefined) {\n            return Number(size);\n        }\n        else {\n            return size;\n        }\n    }\n    const sizeMapping = new Mapping('size');\n    sizeMapping.xform = xformSize;\n    mappings.push(sizeMapping);\n    mappings.push(new Mapping('timeCreated'));\n    mappings.push(new Mapping('updated'));\n    mappings.push(new Mapping('md5Hash', null, true));\n    mappings.push(new Mapping('cacheControl', null, true));\n    mappings.push(new Mapping('contentDisposition', null, true));\n    mappings.push(new Mapping('contentEncoding', null, true));\n    mappings.push(new Mapping('contentLanguage', null, true));\n    mappings.push(new Mapping('contentType', null, true));\n    mappings.push(new Mapping('metadata', 'customMetadata', true));\n    mappings_ = mappings;\n    return mappings_;\n}\nfunction addRef(metadata, service) {\n    function generateRef() {\n        const bucket = metadata['bucket'];\n        const path = metadata['fullPath'];\n        const loc = new Location(bucket, path);\n        return service._makeStorageReference(loc);\n    }\n    Object.defineProperty(metadata, 'ref', { get: generateRef });\n}\nfunction fromResource(service, resource, mappings) {\n    const metadata = {};\n    metadata['type'] = 'file';\n    const len = mappings.length;\n    for (let i = 0; i < len; i++) {\n        const mapping = mappings[i];\n        metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);\n    }\n    addRef(metadata, service);\n    return metadata;\n}\nfunction fromResourceString(service, resourceString, mappings) {\n    const obj = jsonObjectOrNull(resourceString);\n    if (obj === null) {\n        return null;\n    }\n    const resource = obj;\n    return fromResource(service, resource, mappings);\n}\nfunction downloadUrlFromResourceString(metadata, resourceString, host, protocol) {\n    const obj = jsonObjectOrNull(resourceString);\n    if (obj === null) {\n        return null;\n    }\n    if (!isString(obj['downloadTokens'])) {\n        // This can happen if objects are uploaded through GCS and retrieved\n        // through list, so we don't want to throw an Error.\n        return null;\n    }\n    const tokens = obj['downloadTokens'];\n    if (tokens.length === 0) {\n        return null;\n    }\n    const encode = encodeURIComponent;\n    const tokensList = tokens.split(',');\n    const urls = tokensList.map((token) => {\n        const bucket = metadata['bucket'];\n        const path = metadata['fullPath'];\n        const urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);\n        const base = makeUrl(urlPart, host, protocol);\n        const queryString = makeQueryString({\n            alt: 'media',\n            token\n        });\n        return base + queryString;\n    });\n    return urls[0];\n}\nfunction toResourceString(metadata, mappings) {\n    const resource = {};\n    const len = mappings.length;\n    for (let i = 0; i < len; i++) {\n        const mapping = mappings[i];\n        if (mapping.writable) {\n            resource[mapping.server] = metadata[mapping.local];\n        }\n    }\n    return JSON.stringify(resource);\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst PREFIXES_KEY = 'prefixes';\nconst ITEMS_KEY = 'items';\nfunction fromBackendResponse(service, bucket, resource) {\n    const listResult = {\n        prefixes: [],\n        items: [],\n        nextPageToken: resource['nextPageToken']\n    };\n    if (resource[PREFIXES_KEY]) {\n        for (const path of resource[PREFIXES_KEY]) {\n            const pathWithoutTrailingSlash = path.replace(/\\/$/, '');\n            const reference = service._makeStorageReference(new Location(bucket, pathWithoutTrailingSlash));\n            listResult.prefixes.push(reference);\n        }\n    }\n    if (resource[ITEMS_KEY]) {\n        for (const item of resource[ITEMS_KEY]) {\n            const reference = service._makeStorageReference(new Location(bucket, item['name']));\n            listResult.items.push(reference);\n        }\n    }\n    return listResult;\n}\nfunction fromResponseString(service, bucket, resourceString) {\n    const obj = jsonObjectOrNull(resourceString);\n    if (obj === null) {\n        return null;\n    }\n    const resource = obj;\n    return fromBackendResponse(service, bucket, resource);\n}\n\n/**\n * Contains a fully specified request.\n *\n * @param I - the type of the backend's network response.\n * @param O - the output response type used by the rest of the SDK.\n */\nclass RequestInfo {\n    constructor(url, method, \n    /**\n     * Returns the value with which to resolve the request's promise. Only called\n     * if the request is successful. Throw from this function to reject the\n     * returned Request's promise with the thrown error.\n     * Note: The XhrIo passed to this function may be reused after this callback\n     * returns. Do not keep a reference to it in any way.\n     */\n    handler, timeout) {\n        this.url = url;\n        this.method = method;\n        this.handler = handler;\n        this.timeout = timeout;\n        this.urlParams = {};\n        this.headers = {};\n        this.body = null;\n        this.errorHandler = null;\n        /**\n         * Called with the current number of bytes uploaded and total size (-1 if not\n         * computable) of the request body (i.e. used to report upload progress).\n         */\n        this.progressCallback = null;\n        this.successCodes = [200];\n        this.additionalRetryCodes = [];\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Throws the UNKNOWN StorageError if cndn is false.\n */\nfunction handlerCheck(cndn) {\n    if (!cndn) {\n        throw unknown();\n    }\n}\nfunction metadataHandler(service, mappings) {\n    function handler(xhr, text) {\n        const metadata = fromResourceString(service, text, mappings);\n        handlerCheck(metadata !== null);\n        return metadata;\n    }\n    return handler;\n}\nfunction listHandler(service, bucket) {\n    function handler(xhr, text) {\n        const listResult = fromResponseString(service, bucket, text);\n        handlerCheck(listResult !== null);\n        return listResult;\n    }\n    return handler;\n}\nfunction downloadUrlHandler(service, mappings) {\n    function handler(xhr, text) {\n        const metadata = fromResourceString(service, text, mappings);\n        handlerCheck(metadata !== null);\n        return downloadUrlFromResourceString(metadata, text, service.host, service._protocol);\n    }\n    return handler;\n}\nfunction sharedErrorHandler(location) {\n    function errorHandler(xhr, err) {\n        let newErr;\n        if (xhr.getStatus() === 401) {\n            if (\n            // This exact message string is the only consistent part of the\n            // server's error response that identifies it as an App Check error.\n            xhr.getErrorText().includes('Firebase App Check token is invalid')) {\n                newErr = unauthorizedApp();\n            }\n            else {\n                newErr = unauthenticated();\n            }\n        }\n        else {\n            if (xhr.getStatus() === 402) {\n                newErr = quotaExceeded(location.bucket);\n            }\n            else {\n                if (xhr.getStatus() === 403) {\n                    newErr = unauthorized(location.path);\n                }\n                else {\n                    newErr = err;\n                }\n            }\n        }\n        newErr.status = xhr.getStatus();\n        newErr.serverResponse = err.serverResponse;\n        return newErr;\n    }\n    return errorHandler;\n}\nfunction objectErrorHandler(location) {\n    const shared = sharedErrorHandler(location);\n    function errorHandler(xhr, err) {\n        let newErr = shared(xhr, err);\n        if (xhr.getStatus() === 404) {\n            newErr = objectNotFound(location.path);\n        }\n        newErr.serverResponse = err.serverResponse;\n        return newErr;\n    }\n    return errorHandler;\n}\nfunction getMetadata$2(service, location, mappings) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'GET';\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nfunction list$2(service, location, delimiter, pageToken, maxResults) {\n    const urlParams = {};\n    if (location.isRoot) {\n        urlParams['prefix'] = '';\n    }\n    else {\n        urlParams['prefix'] = location.path + '/';\n    }\n    if (delimiter && delimiter.length > 0) {\n        urlParams['delimiter'] = delimiter;\n    }\n    if (pageToken) {\n        urlParams['pageToken'] = pageToken;\n    }\n    if (maxResults) {\n        urlParams['maxResults'] = maxResults;\n    }\n    const urlPart = location.bucketOnlyServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'GET';\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, listHandler(service, location.bucket), timeout);\n    requestInfo.urlParams = urlParams;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\nfunction getBytes$1(service, location, maxDownloadSizeBytes) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol) + '?alt=media';\n    const method = 'GET';\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, (_, data) => data, timeout);\n    requestInfo.errorHandler = objectErrorHandler(location);\n    if (maxDownloadSizeBytes !== undefined) {\n        requestInfo.headers['Range'] = `bytes=0-${maxDownloadSizeBytes}`;\n        requestInfo.successCodes = [200 /* OK */, 206 /* Partial Content */];\n    }\n    return requestInfo;\n}\nfunction getDownloadUrl(service, location, mappings) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'GET';\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, downloadUrlHandler(service, mappings), timeout);\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nfunction updateMetadata$2(service, location, metadata, mappings) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'PATCH';\n    const body = toResourceString(metadata, mappings);\n    const headers = { 'Content-Type': 'application/json; charset=utf-8' };\n    const timeout = service.maxOperationRetryTime;\n    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);\n    requestInfo.headers = headers;\n    requestInfo.body = body;\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nfunction deleteObject$2(service, location) {\n    const urlPart = location.fullServerUrl();\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'DELETE';\n    const timeout = service.maxOperationRetryTime;\n    function handler(_xhr, _text) { }\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.successCodes = [200, 204];\n    requestInfo.errorHandler = objectErrorHandler(location);\n    return requestInfo;\n}\nfunction determineContentType_(metadata, blob) {\n    return ((metadata && metadata['contentType']) ||\n        (blob && blob.type()) ||\n        'application/octet-stream');\n}\nfunction metadataForUpload_(location, blob, metadata) {\n    const metadataClone = Object.assign({}, metadata);\n    metadataClone['fullPath'] = location.path;\n    metadataClone['size'] = blob.size();\n    if (!metadataClone['contentType']) {\n        metadataClone['contentType'] = determineContentType_(null, blob);\n    }\n    return metadataClone;\n}\n/**\n * Prepare RequestInfo for uploads as Content-Type: multipart.\n */\nfunction multipartUpload(service, location, mappings, blob, metadata) {\n    const urlPart = location.bucketOnlyServerUrl();\n    const headers = {\n        'X-Goog-Upload-Protocol': 'multipart'\n    };\n    function genBoundary() {\n        let str = '';\n        for (let i = 0; i < 2; i++) {\n            str = str + Math.random().toString().slice(2);\n        }\n        return str;\n    }\n    const boundary = genBoundary();\n    headers['Content-Type'] = 'multipart/related; boundary=' + boundary;\n    const metadata_ = metadataForUpload_(location, blob, metadata);\n    const metadataString = toResourceString(metadata_, mappings);\n    const preBlobPart = '--' +\n        boundary +\n        '\\r\\n' +\n        'Content-Type: application/json; charset=utf-8\\r\\n\\r\\n' +\n        metadataString +\n        '\\r\\n--' +\n        boundary +\n        '\\r\\n' +\n        'Content-Type: ' +\n        metadata_['contentType'] +\n        '\\r\\n\\r\\n';\n    const postBlobPart = '\\r\\n--' + boundary + '--';\n    const body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);\n    if (body === null) {\n        throw cannotSliceBlob();\n    }\n    const urlParams = { name: metadata_['fullPath'] };\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'POST';\n    const timeout = service.maxUploadRetryTime;\n    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);\n    requestInfo.urlParams = urlParams;\n    requestInfo.headers = headers;\n    requestInfo.body = body.uploadData();\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\n * @param current The number of bytes that have been uploaded so far.\n * @param total The total number of bytes in the upload.\n * @param opt_finalized True if the server has finished the upload.\n * @param opt_metadata The upload metadata, should\n *     only be passed if opt_finalized is true.\n */\nclass ResumableUploadStatus {\n    constructor(current, total, finalized, metadata) {\n        this.current = current;\n        this.total = total;\n        this.finalized = !!finalized;\n        this.metadata = metadata || null;\n    }\n}\nfunction checkResumeHeader_(xhr, allowed) {\n    let status = null;\n    try {\n        status = xhr.getResponseHeader('X-Goog-Upload-Status');\n    }\n    catch (e) {\n        handlerCheck(false);\n    }\n    const allowedStatus = allowed || ['active'];\n    handlerCheck(!!status && allowedStatus.indexOf(status) !== -1);\n    return status;\n}\nfunction createResumableUpload(service, location, mappings, blob, metadata) {\n    const urlPart = location.bucketOnlyServerUrl();\n    const metadataForUpload = metadataForUpload_(location, blob, metadata);\n    const urlParams = { name: metadataForUpload['fullPath'] };\n    const url = makeUrl(urlPart, service.host, service._protocol);\n    const method = 'POST';\n    const headers = {\n        'X-Goog-Upload-Protocol': 'resumable',\n        'X-Goog-Upload-Command': 'start',\n        'X-Goog-Upload-Header-Content-Length': `${blob.size()}`,\n        'X-Goog-Upload-Header-Content-Type': metadataForUpload['contentType'],\n        'Content-Type': 'application/json; charset=utf-8'\n    };\n    const body = toResourceString(metadataForUpload, mappings);\n    const timeout = service.maxUploadRetryTime;\n    function handler(xhr) {\n        checkResumeHeader_(xhr);\n        let url;\n        try {\n            url = xhr.getResponseHeader('X-Goog-Upload-URL');\n        }\n        catch (e) {\n            handlerCheck(false);\n        }\n        handlerCheck(isString(url));\n        return url;\n    }\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.urlParams = urlParams;\n    requestInfo.headers = headers;\n    requestInfo.body = body;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n */\nfunction getResumableUploadStatus(service, location, url, blob) {\n    const headers = { 'X-Goog-Upload-Command': 'query' };\n    function handler(xhr) {\n        const status = checkResumeHeader_(xhr, ['active', 'final']);\n        let sizeString = null;\n        try {\n            sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');\n        }\n        catch (e) {\n            handlerCheck(false);\n        }\n        if (!sizeString) {\n            // null or empty string\n            handlerCheck(false);\n        }\n        const size = Number(sizeString);\n        handlerCheck(!isNaN(size));\n        return new ResumableUploadStatus(size, blob.size(), status === 'final');\n    }\n    const method = 'POST';\n    const timeout = service.maxUploadRetryTime;\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.headers = headers;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n/**\n * Any uploads via the resumable upload API must transfer a number of bytes\n * that is a multiple of this number.\n */\nconst RESUMABLE_UPLOAD_CHUNK_SIZE = 256 * 1024;\n/**\n * @param url From a call to fbs.requests.createResumableUpload.\n * @param chunkSize Number of bytes to upload.\n * @param status The previous status.\n *     If not passed or null, we start from the beginning.\n * @throws fbs.Error If the upload is already complete, the passed in status\n *     has a final size inconsistent with the blob, or the blob cannot be sliced\n *     for upload.\n */\nfunction continueResumableUpload(location, service, url, blob, chunkSize, mappings, status, progressCallback) {\n    // TODO(andysoto): standardize on internal asserts\n    // assert(!(opt_status && opt_status.finalized));\n    const status_ = new ResumableUploadStatus(0, 0);\n    if (status) {\n        status_.current = status.current;\n        status_.total = status.total;\n    }\n    else {\n        status_.current = 0;\n        status_.total = blob.size();\n    }\n    if (blob.size() !== status_.total) {\n        throw serverFileWrongSize();\n    }\n    const bytesLeft = status_.total - status_.current;\n    let bytesToUpload = bytesLeft;\n    if (chunkSize > 0) {\n        bytesToUpload = Math.min(bytesToUpload, chunkSize);\n    }\n    const startByte = status_.current;\n    const endByte = startByte + bytesToUpload;\n    let uploadCommand = '';\n    if (bytesToUpload === 0) {\n        uploadCommand = 'finalize';\n    }\n    else if (bytesLeft === bytesToUpload) {\n        uploadCommand = 'upload, finalize';\n    }\n    else {\n        uploadCommand = 'upload';\n    }\n    const headers = {\n        'X-Goog-Upload-Command': uploadCommand,\n        'X-Goog-Upload-Offset': `${status_.current}`\n    };\n    const body = blob.slice(startByte, endByte);\n    if (body === null) {\n        throw cannotSliceBlob();\n    }\n    function handler(xhr, text) {\n        // TODO(andysoto): Verify the MD5 of each uploaded range:\n        // the 'x-range-md5' header comes back with status code 308 responses.\n        // We'll only be able to bail out though, because you can't re-upload a\n        // range that you previously uploaded.\n        const uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);\n        const newCurrent = status_.current + bytesToUpload;\n        const size = blob.size();\n        let metadata;\n        if (uploadStatus === 'final') {\n            metadata = metadataHandler(service, mappings)(xhr, text);\n        }\n        else {\n            metadata = null;\n        }\n        return new ResumableUploadStatus(newCurrent, size, uploadStatus === 'final', metadata);\n    }\n    const method = 'POST';\n    const timeout = service.maxUploadRetryTime;\n    const requestInfo = new RequestInfo(url, method, handler, timeout);\n    requestInfo.headers = headers;\n    requestInfo.body = body.uploadData();\n    requestInfo.progressCallback = progressCallback || null;\n    requestInfo.errorHandler = sharedErrorHandler(location);\n    return requestInfo;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An event that is triggered on a task.\n * @internal\n */\nconst TaskEvent = {\n    /**\n     * For this event,\n     * <ul>\n     *   <li>The `next` function is triggered on progress updates and when the\n     *       task is paused/resumed with an `UploadTaskSnapshot` as the first\n     *       argument.</li>\n     *   <li>The `error` function is triggered if the upload is canceled or fails\n     *       for another reason.</li>\n     *   <li>The `complete` function is triggered if the upload completes\n     *       successfully.</li>\n     * </ul>\n     */\n    STATE_CHANGED: 'state_changed'\n};\n// type keys = keyof TaskState\n/**\n * Represents the current state of a running upload.\n * @internal\n */\nconst TaskState = {\n    /** The task is currently transferring data. */\n    RUNNING: 'running',\n    /** The task was paused by the user. */\n    PAUSED: 'paused',\n    /** The task completed successfully. */\n    SUCCESS: 'success',\n    /** The task was canceled. */\n    CANCELED: 'canceled',\n    /** The task failed with an error. */\n    ERROR: 'error'\n};\nfunction taskStateFromInternalTaskState(state) {\n    switch (state) {\n        case \"running\" /* InternalTaskState.RUNNING */:\n        case \"pausing\" /* InternalTaskState.PAUSING */:\n        case \"canceling\" /* InternalTaskState.CANCELING */:\n            return TaskState.RUNNING;\n        case \"paused\" /* InternalTaskState.PAUSED */:\n            return TaskState.PAUSED;\n        case \"success\" /* InternalTaskState.SUCCESS */:\n            return TaskState.SUCCESS;\n        case \"canceled\" /* InternalTaskState.CANCELED */:\n            return TaskState.CANCELED;\n        case \"error\" /* InternalTaskState.ERROR */:\n            return TaskState.ERROR;\n        default:\n            // TODO(andysoto): assert(false);\n            return TaskState.ERROR;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Observer {\n    constructor(nextOrObserver, error, complete) {\n        const asFunctions = isFunction(nextOrObserver) || error != null || complete != null;\n        if (asFunctions) {\n            this.next = nextOrObserver;\n            this.error = error !== null && error !== void 0 ? error : undefined;\n            this.complete = complete !== null && complete !== void 0 ? complete : undefined;\n        }\n        else {\n            const observer = nextOrObserver;\n            this.next = observer.next;\n            this.error = observer.error;\n            this.complete = observer.complete;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a function that invokes f with its arguments asynchronously as a\n * microtask, i.e. as soon as possible after the current script returns back\n * into browser code.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction async(f) {\n    return (...argsToForward) => {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Promise.resolve().then(() => f(...argsToForward));\n    };\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** An override for the text-based Connection. Used in tests. */\nlet textFactoryOverride = null;\n/**\n * Network layer that works in Node.\n *\n * This network implementation should not be used in browsers as it does not\n * support progress updates.\n */\nclass FetchConnection {\n    constructor() {\n        this.errorText_ = '';\n        this.sent_ = false;\n        this.errorCode_ = ErrorCode.NO_ERROR;\n    }\n    async send(url, method, body, headers) {\n        if (this.sent_) {\n            throw internalError('cannot .send() more than once');\n        }\n        this.sent_ = true;\n        try {\n            const response = await fetch(url, {\n                method,\n                headers: headers || {},\n                body: body\n            });\n            this.headers_ = response.headers;\n            this.statusCode_ = response.status;\n            this.errorCode_ = ErrorCode.NO_ERROR;\n            this.body_ = await response.arrayBuffer();\n        }\n        catch (e) {\n            this.errorText_ = e === null || e === void 0 ? void 0 : e.message;\n            // emulate XHR which sets status to 0 when encountering a network error\n            this.statusCode_ = 0;\n            this.errorCode_ = ErrorCode.NETWORK_ERROR;\n        }\n    }\n    getErrorCode() {\n        if (this.errorCode_ === undefined) {\n            throw internalError('cannot .getErrorCode() before receiving response');\n        }\n        return this.errorCode_;\n    }\n    getStatus() {\n        if (this.statusCode_ === undefined) {\n            throw internalError('cannot .getStatus() before receiving response');\n        }\n        return this.statusCode_;\n    }\n    getErrorText() {\n        return this.errorText_;\n    }\n    abort() {\n        // Not supported\n    }\n    getResponseHeader(header) {\n        if (!this.headers_) {\n            throw internalError('cannot .getResponseHeader() before receiving response');\n        }\n        return this.headers_.get(header);\n    }\n    addUploadProgressListener(listener) {\n        // Not supported\n    }\n    removeUploadProgressListener(listener) {\n        // Not supported\n    }\n}\nclass FetchTextConnection extends FetchConnection {\n    getResponse() {\n        if (!this.body_) {\n            throw internalError('cannot .getResponse() before receiving response');\n        }\n        return Buffer.from(this.body_).toString('utf-8');\n    }\n}\nfunction newTextConnection() {\n    return textFactoryOverride\n        ? textFactoryOverride()\n        : new FetchTextConnection();\n}\nclass FetchBytesConnection extends FetchConnection {\n    getResponse() {\n        if (!this.body_) {\n            throw internalError('cannot .getResponse() before sending');\n        }\n        return this.body_;\n    }\n}\nfunction newBytesConnection() {\n    return new FetchBytesConnection();\n}\nclass FetchStreamConnection extends FetchConnection {\n    constructor() {\n        super(...arguments);\n        this.stream_ = null;\n    }\n    async send(url, method, body, headers) {\n        if (this.sent_) {\n            throw internalError('cannot .send() more than once');\n        }\n        this.sent_ = true;\n        try {\n            const response = await fetch(url, {\n                method,\n                headers: headers || {},\n                body: body\n            });\n            this.headers_ = response.headers;\n            this.statusCode_ = response.status;\n            this.errorCode_ = ErrorCode.NO_ERROR;\n            this.stream_ = response.body;\n        }\n        catch (e) {\n            this.errorText_ = e === null || e === void 0 ? void 0 : e.message;\n            // emulate XHR which sets status to 0 when encountering a network error\n            this.statusCode_ = 0;\n            this.errorCode_ = ErrorCode.NETWORK_ERROR;\n        }\n    }\n    getResponse() {\n        if (!this.stream_) {\n            throw internalError('cannot .getResponse() before sending');\n        }\n        return this.stream_;\n    }\n}\nfunction newStreamConnection() {\n    return new FetchStreamConnection();\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents a blob being uploaded. Can be used to pause/resume/cancel the\n * upload and manage callbacks for various events.\n * @internal\n */\nclass UploadTask {\n    isExponentialBackoffExpired() {\n        return this.sleepTime > this.maxSleepTime;\n    }\n    /**\n     * @param ref - The firebaseStorage.Reference object this task came\n     *     from, untyped to avoid cyclic dependencies.\n     * @param blob - The blob to upload.\n     */\n    constructor(ref, blob, metadata = null) {\n        /**\n         * Number of bytes transferred so far.\n         */\n        this._transferred = 0;\n        this._needToFetchStatus = false;\n        this._needToFetchMetadata = false;\n        this._observers = [];\n        this._error = undefined;\n        this._uploadUrl = undefined;\n        this._request = undefined;\n        this._chunkMultiplier = 1;\n        this._resolve = undefined;\n        this._reject = undefined;\n        this._ref = ref;\n        this._blob = blob;\n        this._metadata = metadata;\n        this._mappings = getMappings();\n        this._resumable = this._shouldDoResumable(this._blob);\n        this._state = \"running\" /* InternalTaskState.RUNNING */;\n        this._errorHandler = error => {\n            this._request = undefined;\n            this._chunkMultiplier = 1;\n            if (error._codeEquals(StorageErrorCode.CANCELED)) {\n                this._needToFetchStatus = true;\n                this.completeTransitions_();\n            }\n            else {\n                const backoffExpired = this.isExponentialBackoffExpired();\n                if (isRetryStatusCode(error.status, [])) {\n                    if (backoffExpired) {\n                        error = retryLimitExceeded();\n                    }\n                    else {\n                        this.sleepTime = Math.max(this.sleepTime * 2, DEFAULT_MIN_SLEEP_TIME_MILLIS);\n                        this._needToFetchStatus = true;\n                        this.completeTransitions_();\n                        return;\n                    }\n                }\n                this._error = error;\n                this._transition(\"error\" /* InternalTaskState.ERROR */);\n            }\n        };\n        this._metadataErrorHandler = error => {\n            this._request = undefined;\n            if (error._codeEquals(StorageErrorCode.CANCELED)) {\n                this.completeTransitions_();\n            }\n            else {\n                this._error = error;\n                this._transition(\"error\" /* InternalTaskState.ERROR */);\n            }\n        };\n        this.sleepTime = 0;\n        this.maxSleepTime = this._ref.storage.maxUploadRetryTime;\n        this._promise = new Promise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n            this._start();\n        });\n        // Prevent uncaught rejections on the internal promise from bubbling out\n        // to the top level with a dummy handler.\n        this._promise.then(null, () => { });\n    }\n    _makeProgressCallback() {\n        const sizeBefore = this._transferred;\n        return loaded => this._updateProgress(sizeBefore + loaded);\n    }\n    _shouldDoResumable(blob) {\n        return blob.size() > 256 * 1024;\n    }\n    _start() {\n        if (this._state !== \"running\" /* InternalTaskState.RUNNING */) {\n            // This can happen if someone pauses us in a resume callback, for example.\n            return;\n        }\n        if (this._request !== undefined) {\n            return;\n        }\n        if (this._resumable) {\n            if (this._uploadUrl === undefined) {\n                this._createResumable();\n            }\n            else {\n                if (this._needToFetchStatus) {\n                    this._fetchStatus();\n                }\n                else {\n                    if (this._needToFetchMetadata) {\n                        // Happens if we miss the metadata on upload completion.\n                        this._fetchMetadata();\n                    }\n                    else {\n                        this.pendingTimeout = setTimeout(() => {\n                            this.pendingTimeout = undefined;\n                            this._continueUpload();\n                        }, this.sleepTime);\n                    }\n                }\n            }\n        }\n        else {\n            this._oneShotUpload();\n        }\n    }\n    _resolveToken(callback) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Promise.all([\n            this._ref.storage._getAuthToken(),\n            this._ref.storage._getAppCheckToken()\n        ]).then(([authToken, appCheckToken]) => {\n            switch (this._state) {\n                case \"running\" /* InternalTaskState.RUNNING */:\n                    callback(authToken, appCheckToken);\n                    break;\n                case \"canceling\" /* InternalTaskState.CANCELING */:\n                    this._transition(\"canceled\" /* InternalTaskState.CANCELED */);\n                    break;\n                case \"pausing\" /* InternalTaskState.PAUSING */:\n                    this._transition(\"paused\" /* InternalTaskState.PAUSED */);\n                    break;\n            }\n        });\n    }\n    // TODO(andysoto): assert false\n    _createResumable() {\n        this._resolveToken((authToken, appCheckToken) => {\n            const requestInfo = createResumableUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);\n            const createRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\n            this._request = createRequest;\n            createRequest.getPromise().then((url) => {\n                this._request = undefined;\n                this._uploadUrl = url;\n                this._needToFetchStatus = false;\n                this.completeTransitions_();\n            }, this._errorHandler);\n        });\n    }\n    _fetchStatus() {\n        // TODO(andysoto): assert(this.uploadUrl_ !== null);\n        const url = this._uploadUrl;\n        this._resolveToken((authToken, appCheckToken) => {\n            const requestInfo = getResumableUploadStatus(this._ref.storage, this._ref._location, url, this._blob);\n            const statusRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\n            this._request = statusRequest;\n            statusRequest.getPromise().then(status => {\n                status = status;\n                this._request = undefined;\n                this._updateProgress(status.current);\n                this._needToFetchStatus = false;\n                if (status.finalized) {\n                    this._needToFetchMetadata = true;\n                }\n                this.completeTransitions_();\n            }, this._errorHandler);\n        });\n    }\n    _continueUpload() {\n        const chunkSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;\n        const status = new ResumableUploadStatus(this._transferred, this._blob.size());\n        // TODO(andysoto): assert(this.uploadUrl_ !== null);\n        const url = this._uploadUrl;\n        this._resolveToken((authToken, appCheckToken) => {\n            let requestInfo;\n            try {\n                requestInfo = continueResumableUpload(this._ref._location, this._ref.storage, url, this._blob, chunkSize, this._mappings, status, this._makeProgressCallback());\n            }\n            catch (e) {\n                this._error = e;\n                this._transition(\"error\" /* InternalTaskState.ERROR */);\n                return;\n            }\n            const uploadRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken, \n            /*retry=*/ false // Upload requests should not be retried as each retry should be preceded by another query request. Which is handled in this file.\n            );\n            this._request = uploadRequest;\n            uploadRequest.getPromise().then((newStatus) => {\n                this._increaseMultiplier();\n                this._request = undefined;\n                this._updateProgress(newStatus.current);\n                if (newStatus.finalized) {\n                    this._metadata = newStatus.metadata;\n                    this._transition(\"success\" /* InternalTaskState.SUCCESS */);\n                }\n                else {\n                    this.completeTransitions_();\n                }\n            }, this._errorHandler);\n        });\n    }\n    _increaseMultiplier() {\n        const currentSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;\n        // Max chunk size is 32M.\n        if (currentSize * 2 < 32 * 1024 * 1024) {\n            this._chunkMultiplier *= 2;\n        }\n    }\n    _fetchMetadata() {\n        this._resolveToken((authToken, appCheckToken) => {\n            const requestInfo = getMetadata$2(this._ref.storage, this._ref._location, this._mappings);\n            const metadataRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\n            this._request = metadataRequest;\n            metadataRequest.getPromise().then(metadata => {\n                this._request = undefined;\n                this._metadata = metadata;\n                this._transition(\"success\" /* InternalTaskState.SUCCESS */);\n            }, this._metadataErrorHandler);\n        });\n    }\n    _oneShotUpload() {\n        this._resolveToken((authToken, appCheckToken) => {\n            const requestInfo = multipartUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);\n            const multipartRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);\n            this._request = multipartRequest;\n            multipartRequest.getPromise().then(metadata => {\n                this._request = undefined;\n                this._metadata = metadata;\n                this._updateProgress(this._blob.size());\n                this._transition(\"success\" /* InternalTaskState.SUCCESS */);\n            }, this._errorHandler);\n        });\n    }\n    _updateProgress(transferred) {\n        const old = this._transferred;\n        this._transferred = transferred;\n        // A progress update can make the \"transferred\" value smaller (e.g. a\n        // partial upload not completed by server, after which the \"transferred\"\n        // value may reset to the value at the beginning of the request).\n        if (this._transferred !== old) {\n            this._notifyObservers();\n        }\n    }\n    _transition(state) {\n        if (this._state === state) {\n            return;\n        }\n        switch (state) {\n            case \"canceling\" /* InternalTaskState.CANCELING */:\n            case \"pausing\" /* InternalTaskState.PAUSING */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING);\n                this._state = state;\n                if (this._request !== undefined) {\n                    this._request.cancel();\n                }\n                else if (this.pendingTimeout) {\n                    clearTimeout(this.pendingTimeout);\n                    this.pendingTimeout = undefined;\n                    this.completeTransitions_();\n                }\n                break;\n            case \"running\" /* InternalTaskState.RUNNING */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSED ||\n                //        this.state_ === InternalTaskState.PAUSING);\n                const wasPaused = this._state === \"paused\" /* InternalTaskState.PAUSED */;\n                this._state = state;\n                if (wasPaused) {\n                    this._notifyObservers();\n                    this._start();\n                }\n                break;\n            case \"paused\" /* InternalTaskState.PAUSED */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSING);\n                this._state = state;\n                this._notifyObservers();\n                break;\n            case \"canceled\" /* InternalTaskState.CANCELED */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.PAUSED ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this._error = canceled();\n                this._state = state;\n                this._notifyObservers();\n                break;\n            case \"error\" /* InternalTaskState.ERROR */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this._state = state;\n                this._notifyObservers();\n                break;\n            case \"success\" /* InternalTaskState.SUCCESS */:\n                // TODO(andysoto):\n                // assert(this.state_ === InternalTaskState.RUNNING ||\n                //        this.state_ === InternalTaskState.PAUSING ||\n                //        this.state_ === InternalTaskState.CANCELING);\n                this._state = state;\n                this._notifyObservers();\n                break;\n        }\n    }\n    completeTransitions_() {\n        switch (this._state) {\n            case \"pausing\" /* InternalTaskState.PAUSING */:\n                this._transition(\"paused\" /* InternalTaskState.PAUSED */);\n                break;\n            case \"canceling\" /* InternalTaskState.CANCELING */:\n                this._transition(\"canceled\" /* InternalTaskState.CANCELED */);\n                break;\n            case \"running\" /* InternalTaskState.RUNNING */:\n                this._start();\n                break;\n        }\n    }\n    /**\n     * A snapshot of the current task state.\n     */\n    get snapshot() {\n        const externalState = taskStateFromInternalTaskState(this._state);\n        return {\n            bytesTransferred: this._transferred,\n            totalBytes: this._blob.size(),\n            state: externalState,\n            metadata: this._metadata,\n            task: this,\n            ref: this._ref\n        };\n    }\n    /**\n     * Adds a callback for an event.\n     * @param type - The type of event to listen for.\n     * @param nextOrObserver -\n     *     The `next` function, which gets called for each item in\n     *     the event stream, or an observer object with some or all of these three\n     *     properties (`next`, `error`, `complete`).\n     * @param error - A function that gets called with a `StorageError`\n     *     if the event stream ends due to an error.\n     * @param completed - A function that gets called if the\n     *     event stream ends normally.\n     * @returns\n     *     If only the event argument is passed, returns a function you can use to\n     *     add callbacks (see the examples above). If more than just the event\n     *     argument is passed, returns a function you can call to unregister the\n     *     callbacks.\n     */\n    on(type, nextOrObserver, error, completed) {\n        // Note: `type` isn't being used. Its type is also incorrect. TaskEvent should not be a string.\n        const observer = new Observer(nextOrObserver || undefined, error || undefined, completed || undefined);\n        this._addObserver(observer);\n        return () => {\n            this._removeObserver(observer);\n        };\n    }\n    /**\n     * This object behaves like a Promise, and resolves with its snapshot data\n     * when the upload completes.\n     * @param onFulfilled - The fulfillment callback. Promise chaining works as normal.\n     * @param onRejected - The rejection callback.\n     */\n    then(onFulfilled, onRejected) {\n        // These casts are needed so that TypeScript can infer the types of the\n        // resulting Promise.\n        return this._promise.then(onFulfilled, onRejected);\n    }\n    /**\n     * Equivalent to calling `then(null, onRejected)`.\n     */\n    catch(onRejected) {\n        return this.then(null, onRejected);\n    }\n    /**\n     * Adds the given observer.\n     */\n    _addObserver(observer) {\n        this._observers.push(observer);\n        this._notifyObserver(observer);\n    }\n    /**\n     * Removes the given observer.\n     */\n    _removeObserver(observer) {\n        const i = this._observers.indexOf(observer);\n        if (i !== -1) {\n            this._observers.splice(i, 1);\n        }\n    }\n    _notifyObservers() {\n        this._finishPromise();\n        const observers = this._observers.slice();\n        observers.forEach(observer => {\n            this._notifyObserver(observer);\n        });\n    }\n    _finishPromise() {\n        if (this._resolve !== undefined) {\n            let triggered = true;\n            switch (taskStateFromInternalTaskState(this._state)) {\n                case TaskState.SUCCESS:\n                    async(this._resolve.bind(null, this.snapshot))();\n                    break;\n                case TaskState.CANCELED:\n                case TaskState.ERROR:\n                    const toCall = this._reject;\n                    async(toCall.bind(null, this._error))();\n                    break;\n                default:\n                    triggered = false;\n                    break;\n            }\n            if (triggered) {\n                this._resolve = undefined;\n                this._reject = undefined;\n            }\n        }\n    }\n    _notifyObserver(observer) {\n        const externalState = taskStateFromInternalTaskState(this._state);\n        switch (externalState) {\n            case TaskState.RUNNING:\n            case TaskState.PAUSED:\n                if (observer.next) {\n                    async(observer.next.bind(observer, this.snapshot))();\n                }\n                break;\n            case TaskState.SUCCESS:\n                if (observer.complete) {\n                    async(observer.complete.bind(observer))();\n                }\n                break;\n            case TaskState.CANCELED:\n            case TaskState.ERROR:\n                if (observer.error) {\n                    async(observer.error.bind(observer, this._error))();\n                }\n                break;\n            default:\n                // TODO(andysoto): assert(false);\n                if (observer.error) {\n                    async(observer.error.bind(observer, this._error))();\n                }\n        }\n    }\n    /**\n     * Resumes a paused task. Has no effect on a currently running or failed task.\n     * @returns True if the operation took effect, false if ignored.\n     */\n    resume() {\n        const valid = this._state === \"paused\" /* InternalTaskState.PAUSED */ ||\n            this._state === \"pausing\" /* InternalTaskState.PAUSING */;\n        if (valid) {\n            this._transition(\"running\" /* InternalTaskState.RUNNING */);\n        }\n        return valid;\n    }\n    /**\n     * Pauses a currently running task. Has no effect on a paused or failed task.\n     * @returns True if the operation took effect, false if ignored.\n     */\n    pause() {\n        const valid = this._state === \"running\" /* InternalTaskState.RUNNING */;\n        if (valid) {\n            this._transition(\"pausing\" /* InternalTaskState.PAUSING */);\n        }\n        return valid;\n    }\n    /**\n     * Cancels a currently running or paused task. Has no effect on a complete or\n     * failed task.\n     * @returns True if the operation took effect, false if ignored.\n     */\n    cancel() {\n        const valid = this._state === \"running\" /* InternalTaskState.RUNNING */ ||\n            this._state === \"pausing\" /* InternalTaskState.PAUSING */;\n        if (valid) {\n            this._transition(\"canceling\" /* InternalTaskState.CANCELING */);\n        }\n        return valid;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides methods to interact with a bucket in the Firebase Storage service.\n * @internal\n * @param _location - An fbs.location, or the URL at\n *     which to base this object, in one of the following forms:\n *         gs://<bucket>/<object-path>\n *         http[s]://firebasestorage.googleapis.com/\n *                     <api-version>/b/<bucket>/o/<object-path>\n *     Any query or fragment strings will be ignored in the http[s]\n *     format. If no value is passed, the storage object will use a URL based on\n *     the project ID of the base firebase.App instance.\n */\nclass Reference {\n    constructor(_service, location) {\n        this._service = _service;\n        if (location instanceof Location) {\n            this._location = location;\n        }\n        else {\n            this._location = Location.makeFromUrl(location, _service.host);\n        }\n    }\n    /**\n     * Returns the URL for the bucket and path this object references,\n     *     in the form gs://<bucket>/<object-path>\n     * @override\n     */\n    toString() {\n        return 'gs://' + this._location.bucket + '/' + this._location.path;\n    }\n    _newRef(service, location) {\n        return new Reference(service, location);\n    }\n    /**\n     * A reference to the root of this object's bucket.\n     */\n    get root() {\n        const location = new Location(this._location.bucket, '');\n        return this._newRef(this._service, location);\n    }\n    /**\n     * The name of the bucket containing this reference's object.\n     */\n    get bucket() {\n        return this._location.bucket;\n    }\n    /**\n     * The full path of this object.\n     */\n    get fullPath() {\n        return this._location.path;\n    }\n    /**\n     * The short name of this object, which is the last component of the full path.\n     * For example, if fullPath is 'full/path/image.png', name is 'image.png'.\n     */\n    get name() {\n        return lastComponent(this._location.path);\n    }\n    /**\n     * The `StorageService` instance this `StorageReference` is associated with.\n     */\n    get storage() {\n        return this._service;\n    }\n    /**\n     * A `StorageReference` pointing to the parent location of this `StorageReference`, or null if\n     * this reference is the root.\n     */\n    get parent() {\n        const newPath = parent(this._location.path);\n        if (newPath === null) {\n            return null;\n        }\n        const location = new Location(this._location.bucket, newPath);\n        return new Reference(this._service, location);\n    }\n    /**\n     * Utility function to throw an error in methods that do not accept a root reference.\n     */\n    _throwIfRoot(name) {\n        if (this._location.path === '') {\n            throw invalidRootOperation(name);\n        }\n    }\n}\n/**\n * Download the bytes at the object's location.\n * @returns A Promise containing the downloaded bytes.\n */\nfunction getBytesInternal(ref, maxDownloadSizeBytes) {\n    ref._throwIfRoot('getBytes');\n    const requestInfo = getBytes$1(ref.storage, ref._location, maxDownloadSizeBytes);\n    return ref.storage\n        .makeRequestWithTokens(requestInfo, newBytesConnection)\n        .then(bytes => maxDownloadSizeBytes !== undefined\n        ? // GCS may not honor the Range header for small files\n            bytes.slice(0, maxDownloadSizeBytes)\n        : bytes);\n}\n/** Stream the bytes at the object's location. */\nfunction getStreamInternal(ref, maxDownloadSizeBytes) {\n    ref._throwIfRoot('getStream');\n    const requestInfo = getBytes$1(ref.storage, ref._location, maxDownloadSizeBytes);\n    // Transforms the stream so that only `maxDownloadSizeBytes` bytes are piped to the result\n    const newMaxSizeTransform = (n) => {\n        let missingBytes = n;\n        return {\n            transform(chunk, controller) {\n                // GCS may not honor the Range header for small files\n                if (chunk.length < missingBytes) {\n                    controller.enqueue(chunk);\n                    missingBytes -= chunk.length;\n                }\n                else {\n                    controller.enqueue(chunk.slice(0, missingBytes));\n                    controller.terminate();\n                }\n            }\n        };\n    };\n    const result = maxDownloadSizeBytes !== undefined\n        ? new TransformStream(newMaxSizeTransform(maxDownloadSizeBytes))\n        : new TransformStream(); // The default transformer forwards all chunks to its readable side\n    ref.storage\n        .makeRequestWithTokens(requestInfo, newStreamConnection)\n        .then(readableStream => readableStream.pipeThrough(result))\n        .catch(err => result.writable.abort(err));\n    return result.readable;\n}\n/**\n * Uploads data to this object's location.\n * The upload is not resumable.\n *\n * @param ref - StorageReference where data should be uploaded.\n * @param data - The data to upload.\n * @param metadata - Metadata for the newly uploaded data.\n * @returns A Promise containing an UploadResult\n */\nfunction uploadBytes$1(ref, data, metadata) {\n    ref._throwIfRoot('uploadBytes');\n    const requestInfo = multipartUpload(ref.storage, ref._location, getMappings(), new FbsBlob(data, true), metadata);\n    return ref.storage\n        .makeRequestWithTokens(requestInfo, newTextConnection)\n        .then(finalMetadata => {\n        return {\n            metadata: finalMetadata,\n            ref\n        };\n    });\n}\n/**\n * Uploads data to this object's location.\n * The upload can be paused and resumed, and exposes progress updates.\n * @public\n * @param ref - StorageReference where data should be uploaded.\n * @param data - The data to upload.\n * @param metadata - Metadata for the newly uploaded data.\n * @returns An UploadTask\n */\nfunction uploadBytesResumable$1(ref, data, metadata) {\n    ref._throwIfRoot('uploadBytesResumable');\n    return new UploadTask(ref, new FbsBlob(data), metadata);\n}\n/**\n * Uploads a string to this object's location.\n * The upload is not resumable.\n * @public\n * @param ref - StorageReference where string should be uploaded.\n * @param value - The string to upload.\n * @param format - The format of the string to upload.\n * @param metadata - Metadata for the newly uploaded string.\n * @returns A Promise containing an UploadResult\n */\nfunction uploadString$1(ref, value, format = StringFormat.RAW, metadata) {\n    ref._throwIfRoot('uploadString');\n    const data = dataFromString(format, value);\n    const metadataClone = Object.assign({}, metadata);\n    if (metadataClone['contentType'] == null && data.contentType != null) {\n        metadataClone['contentType'] = data.contentType;\n    }\n    return uploadBytes$1(ref, data.data, metadataClone);\n}\n/**\n * List all items (files) and prefixes (folders) under this storage reference.\n *\n * This is a helper method for calling list() repeatedly until there are\n * no more results. The default pagination size is 1000.\n *\n * Note: The results may not be consistent if objects are changed while this\n * operation is running.\n *\n * Warning: listAll may potentially consume too many resources if there are\n * too many results.\n * @public\n * @param ref - StorageReference to get list from.\n *\n * @returns A Promise that resolves with all the items and prefixes under\n *      the current storage reference. `prefixes` contains references to\n *      sub-directories and `items` contains references to objects in this\n *      folder. `nextPageToken` is never returned.\n */\nfunction listAll$1(ref) {\n    const accumulator = {\n        prefixes: [],\n        items: []\n    };\n    return listAllHelper(ref, accumulator).then(() => accumulator);\n}\n/**\n * Separated from listAll because async functions can't use \"arguments\".\n * @param ref\n * @param accumulator\n * @param pageToken\n */\nasync function listAllHelper(ref, accumulator, pageToken) {\n    const opt = {\n        // maxResults is 1000 by default.\n        pageToken\n    };\n    const nextPage = await list$1(ref, opt);\n    accumulator.prefixes.push(...nextPage.prefixes);\n    accumulator.items.push(...nextPage.items);\n    if (nextPage.nextPageToken != null) {\n        await listAllHelper(ref, accumulator, nextPage.nextPageToken);\n    }\n}\n/**\n * List items (files) and prefixes (folders) under this storage reference.\n *\n * List API is only available for Firebase Rules Version 2.\n *\n * GCS is a key-blob store. Firebase Storage imposes the semantic of '/'\n * delimited folder structure.\n * Refer to GCS's List API if you want to learn more.\n *\n * To adhere to Firebase Rules's Semantics, Firebase Storage does not\n * support objects whose paths end with \"/\" or contain two consecutive\n * \"/\"s. Firebase Storage List API will filter these unsupported objects.\n * list() may fail if there are too many unsupported objects in the bucket.\n * @public\n *\n * @param ref - StorageReference to get list from.\n * @param options - See ListOptions for details.\n * @returns A Promise that resolves with the items and prefixes.\n *      `prefixes` contains references to sub-folders and `items`\n *      contains references to objects in this folder. `nextPageToken`\n *      can be used to get the rest of the results.\n */\nfunction list$1(ref, options) {\n    if (options != null) {\n        if (typeof options.maxResults === 'number') {\n            validateNumber('options.maxResults', \n            /* minValue= */ 1, \n            /* maxValue= */ 1000, options.maxResults);\n        }\n    }\n    const op = options || {};\n    const requestInfo = list$2(ref.storage, ref._location, \n    /*delimiter= */ '/', op.pageToken, op.maxResults);\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\n}\n/**\n * A `Promise` that resolves with the metadata for this object. If this\n * object doesn't exist or metadata cannot be retrieved, the promise is\n * rejected.\n * @public\n * @param ref - StorageReference to get metadata from.\n */\nfunction getMetadata$1(ref) {\n    ref._throwIfRoot('getMetadata');\n    const requestInfo = getMetadata$2(ref.storage, ref._location, getMappings());\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\n}\n/**\n * Updates the metadata for this object.\n * @public\n * @param ref - StorageReference to update metadata for.\n * @param metadata - The new metadata for the object.\n *     Only values that have been explicitly set will be changed. Explicitly\n *     setting a value to null will remove the metadata.\n * @returns A `Promise` that resolves\n *     with the new metadata for this object.\n *     See `firebaseStorage.Reference.prototype.getMetadata`\n */\nfunction updateMetadata$1(ref, metadata) {\n    ref._throwIfRoot('updateMetadata');\n    const requestInfo = updateMetadata$2(ref.storage, ref._location, metadata, getMappings());\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\n}\n/**\n * Returns the download URL for the given Reference.\n * @public\n * @returns A `Promise` that resolves with the download\n *     URL for this object.\n */\nfunction getDownloadURL$1(ref) {\n    ref._throwIfRoot('getDownloadURL');\n    const requestInfo = getDownloadUrl(ref.storage, ref._location, getMappings());\n    return ref.storage\n        .makeRequestWithTokens(requestInfo, newTextConnection)\n        .then(url => {\n        if (url === null) {\n            throw noDownloadURL();\n        }\n        return url;\n    });\n}\n/**\n * Deletes the object at this location.\n * @public\n * @param ref - StorageReference for object to delete.\n * @returns A `Promise` that resolves if the deletion succeeds.\n */\nfunction deleteObject$1(ref) {\n    ref._throwIfRoot('deleteObject');\n    const requestInfo = deleteObject$2(ref.storage, ref._location);\n    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);\n}\n/**\n * Returns reference for object obtained by appending `childPath` to `ref`.\n *\n * @param ref - StorageReference to get child of.\n * @param childPath - Child path from provided ref.\n * @returns A reference to the object obtained by\n * appending childPath, removing any duplicate, beginning, or trailing\n * slashes.\n *\n */\nfunction _getChild$1(ref, childPath) {\n    const newPath = child(ref._location.path, childPath);\n    const location = new Location(ref._location.bucket, newPath);\n    return new Reference(ref.storage, location);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isUrl(path) {\n    return /^[A-Za-z]+:\\/\\//.test(path);\n}\n/**\n * Returns a firebaseStorage.Reference for the given url.\n */\nfunction refFromURL(service, url) {\n    return new Reference(service, url);\n}\n/**\n * Returns a firebaseStorage.Reference for the given path in the default\n * bucket.\n */\nfunction refFromPath(ref, path) {\n    if (ref instanceof FirebaseStorageImpl) {\n        const service = ref;\n        if (service._bucket == null) {\n            throw noDefaultBucket();\n        }\n        const reference = new Reference(service, service._bucket);\n        if (path != null) {\n            return refFromPath(reference, path);\n        }\n        else {\n            return reference;\n        }\n    }\n    else {\n        // ref is a Reference\n        if (path !== undefined) {\n            return _getChild$1(ref, path);\n        }\n        else {\n            return ref;\n        }\n    }\n}\nfunction ref$1(serviceOrRef, pathOrUrl) {\n    if (pathOrUrl && isUrl(pathOrUrl)) {\n        if (serviceOrRef instanceof FirebaseStorageImpl) {\n            return refFromURL(serviceOrRef, pathOrUrl);\n        }\n        else {\n            throw invalidArgument('To use ref(service, url), the first argument must be a Storage instance.');\n        }\n    }\n    else {\n        return refFromPath(serviceOrRef, pathOrUrl);\n    }\n}\nfunction extractBucket(host, config) {\n    const bucketString = config === null || config === void 0 ? void 0 : config[CONFIG_STORAGE_BUCKET_KEY];\n    if (bucketString == null) {\n        return null;\n    }\n    return Location.makeFromBucketSpec(bucketString, host);\n}\nfunction connectStorageEmulator$1(storage, host, port, options = {}) {\n    storage.host = `${host}:${port}`;\n    storage._protocol = 'http';\n    const { mockUserToken } = options;\n    if (mockUserToken) {\n        storage._overrideAuthToken =\n            typeof mockUserToken === 'string'\n                ? mockUserToken\n                : (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.createMockUserToken)(mockUserToken, storage.app.options.projectId);\n    }\n}\n/**\n * A service that provides Firebase Storage Reference instances.\n * @param opt_url - gs:// url to a custom Storage Bucket\n *\n * @internal\n */\nclass FirebaseStorageImpl {\n    constructor(\n    /**\n     * FirebaseApp associated with this StorageService instance.\n     */\n    app, _authProvider, \n    /**\n     * @internal\n     */\n    _appCheckProvider, \n    /**\n     * @internal\n     */\n    _url, _firebaseVersion) {\n        this.app = app;\n        this._authProvider = _authProvider;\n        this._appCheckProvider = _appCheckProvider;\n        this._url = _url;\n        this._firebaseVersion = _firebaseVersion;\n        this._bucket = null;\n        /**\n         * This string can be in the formats:\n         * - host\n         * - host:port\n         */\n        this._host = DEFAULT_HOST;\n        this._protocol = 'https';\n        this._appId = null;\n        this._deleted = false;\n        this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME;\n        this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME;\n        this._requests = new Set();\n        if (_url != null) {\n            this._bucket = Location.makeFromBucketSpec(_url, this._host);\n        }\n        else {\n            this._bucket = extractBucket(this._host, this.app.options);\n        }\n    }\n    /**\n     * The host string for this service, in the form of `host` or\n     * `host:port`.\n     */\n    get host() {\n        return this._host;\n    }\n    set host(host) {\n        this._host = host;\n        if (this._url != null) {\n            this._bucket = Location.makeFromBucketSpec(this._url, host);\n        }\n        else {\n            this._bucket = extractBucket(host, this.app.options);\n        }\n    }\n    /**\n     * The maximum time to retry uploads in milliseconds.\n     */\n    get maxUploadRetryTime() {\n        return this._maxUploadRetryTime;\n    }\n    set maxUploadRetryTime(time) {\n        validateNumber('time', \n        /* minValue=*/ 0, \n        /* maxValue= */ Number.POSITIVE_INFINITY, time);\n        this._maxUploadRetryTime = time;\n    }\n    /**\n     * The maximum time to retry operations other than uploads or downloads in\n     * milliseconds.\n     */\n    get maxOperationRetryTime() {\n        return this._maxOperationRetryTime;\n    }\n    set maxOperationRetryTime(time) {\n        validateNumber('time', \n        /* minValue=*/ 0, \n        /* maxValue= */ Number.POSITIVE_INFINITY, time);\n        this._maxOperationRetryTime = time;\n    }\n    async _getAuthToken() {\n        if (this._overrideAuthToken) {\n            return this._overrideAuthToken;\n        }\n        const auth = this._authProvider.getImmediate({ optional: true });\n        if (auth) {\n            const tokenData = await auth.getToken();\n            if (tokenData !== null) {\n                return tokenData.accessToken;\n            }\n        }\n        return null;\n    }\n    async _getAppCheckToken() {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app) && this.app.settings.appCheckToken) {\n            return this.app.settings.appCheckToken;\n        }\n        const appCheck = this._appCheckProvider.getImmediate({ optional: true });\n        if (appCheck) {\n            const result = await appCheck.getToken();\n            // TODO: What do we want to do if there is an error getting the token?\n            // Context: appCheck.getToken() will never throw even if an error happened. In the error case, a dummy token will be\n            // returned along with an error field describing the error. In general, we shouldn't care about the error condition and just use\n            // the token (actual or dummy) to send requests.\n            return result.token;\n        }\n        return null;\n    }\n    /**\n     * Stop running requests and prevent more from being created.\n     */\n    _delete() {\n        if (!this._deleted) {\n            this._deleted = true;\n            this._requests.forEach(request => request.cancel());\n            this._requests.clear();\n        }\n        return Promise.resolve();\n    }\n    /**\n     * Returns a new firebaseStorage.Reference object referencing this StorageService\n     * at the given Location.\n     */\n    _makeStorageReference(loc) {\n        return new Reference(this, loc);\n    }\n    /**\n     * @param requestInfo - HTTP RequestInfo object\n     * @param authToken - Firebase auth token\n     */\n    _makeRequest(requestInfo, requestFactory, authToken, appCheckToken, retry = true) {\n        if (!this._deleted) {\n            const request = makeRequest(requestInfo, this._appId, authToken, appCheckToken, requestFactory, this._firebaseVersion, retry);\n            this._requests.add(request);\n            // Request removes itself from set when complete.\n            request.getPromise().then(() => this._requests.delete(request), () => this._requests.delete(request));\n            return request;\n        }\n        else {\n            return new FailRequest(appDeleted());\n        }\n    }\n    async makeRequestWithTokens(requestInfo, requestFactory) {\n        const [authToken, appCheckToken] = await Promise.all([\n            this._getAuthToken(),\n            this._getAppCheckToken()\n        ]);\n        return this._makeRequest(requestInfo, requestFactory, authToken, appCheckToken).getPromise();\n    }\n}\n\nconst name = \"@firebase/storage\";\nconst version = \"0.13.7\";\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Type constant for Firebase Storage.\n */\nconst STORAGE_TYPE = 'storage';\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Downloads the data at the object's location. Returns an error if the object\n * is not found.\n *\n * To use this functionality, you have to whitelist your app's origin in your\n * Cloud Storage bucket. See also\n * https://cloud.google.com/storage/docs/configuring-cors\n *\n * @public\n * @param ref - StorageReference where data should be downloaded.\n * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to\n * retrieve.\n * @returns A Promise containing the object's bytes\n */\nfunction getBytes(ref, maxDownloadSizeBytes) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return getBytesInternal(ref, maxDownloadSizeBytes);\n}\n/**\n * Uploads data to this object's location.\n * The upload is not resumable.\n * @public\n * @param ref - {@link StorageReference} where data should be uploaded.\n * @param data - The data to upload.\n * @param metadata - Metadata for the data to upload.\n * @returns A Promise containing an UploadResult\n */\nfunction uploadBytes(ref, data, metadata) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return uploadBytes$1(ref, data, metadata);\n}\n/**\n * Uploads a string to this object's location.\n * The upload is not resumable.\n * @public\n * @param ref - {@link StorageReference} where string should be uploaded.\n * @param value - The string to upload.\n * @param format - The format of the string to upload.\n * @param metadata - Metadata for the string to upload.\n * @returns A Promise containing an UploadResult\n */\nfunction uploadString(ref, value, format, metadata) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return uploadString$1(ref, value, format, metadata);\n}\n/**\n * Uploads data to this object's location.\n * The upload can be paused and resumed, and exposes progress updates.\n * @public\n * @param ref - {@link StorageReference} where data should be uploaded.\n * @param data - The data to upload.\n * @param metadata - Metadata for the data to upload.\n * @returns An UploadTask\n */\nfunction uploadBytesResumable(ref, data, metadata) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return uploadBytesResumable$1(ref, data, metadata);\n}\n/**\n * A `Promise` that resolves with the metadata for this object. If this\n * object doesn't exist or metadata cannot be retrieved, the promise is\n * rejected.\n * @public\n * @param ref - {@link StorageReference} to get metadata from.\n */\nfunction getMetadata(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return getMetadata$1(ref);\n}\n/**\n * Updates the metadata for this object.\n * @public\n * @param ref - {@link StorageReference} to update metadata for.\n * @param metadata - The new metadata for the object.\n *     Only values that have been explicitly set will be changed. Explicitly\n *     setting a value to null will remove the metadata.\n * @returns A `Promise` that resolves with the new metadata for this object.\n */\nfunction updateMetadata(ref, metadata) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return updateMetadata$1(ref, metadata);\n}\n/**\n * List items (files) and prefixes (folders) under this storage reference.\n *\n * List API is only available for Firebase Rules Version 2.\n *\n * GCS is a key-blob store. Firebase Storage imposes the semantic of '/'\n * delimited folder structure.\n * Refer to GCS's List API if you want to learn more.\n *\n * To adhere to Firebase Rules's Semantics, Firebase Storage does not\n * support objects whose paths end with \"/\" or contain two consecutive\n * \"/\"s. Firebase Storage List API will filter these unsupported objects.\n * list() may fail if there are too many unsupported objects in the bucket.\n * @public\n *\n * @param ref - {@link StorageReference} to get list from.\n * @param options - See {@link ListOptions} for details.\n * @returns A `Promise` that resolves with the items and prefixes.\n *      `prefixes` contains references to sub-folders and `items`\n *      contains references to objects in this folder. `nextPageToken`\n *      can be used to get the rest of the results.\n */\nfunction list(ref, options) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return list$1(ref, options);\n}\n/**\n * List all items (files) and prefixes (folders) under this storage reference.\n *\n * This is a helper method for calling list() repeatedly until there are\n * no more results. The default pagination size is 1000.\n *\n * Note: The results may not be consistent if objects are changed while this\n * operation is running.\n *\n * Warning: `listAll` may potentially consume too many resources if there are\n * too many results.\n * @public\n * @param ref - {@link StorageReference} to get list from.\n *\n * @returns A `Promise` that resolves with all the items and prefixes under\n *      the current storage reference. `prefixes` contains references to\n *      sub-directories and `items` contains references to objects in this\n *      folder. `nextPageToken` is never returned.\n */\nfunction listAll(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return listAll$1(ref);\n}\n/**\n * Returns the download URL for the given {@link StorageReference}.\n * @public\n * @param ref - {@link StorageReference} to get the download URL for.\n * @returns A `Promise` that resolves with the download\n *     URL for this object.\n */\nfunction getDownloadURL(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return getDownloadURL$1(ref);\n}\n/**\n * Deletes the object at this location.\n * @public\n * @param ref - {@link StorageReference} for object to delete.\n * @returns A `Promise` that resolves if the deletion succeeds.\n */\nfunction deleteObject(ref) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return deleteObject$1(ref);\n}\nfunction ref(serviceOrRef, pathOrUrl) {\n    serviceOrRef = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(serviceOrRef);\n    return ref$1(serviceOrRef, pathOrUrl);\n}\n/**\n * @internal\n */\nfunction _getChild(ref, childPath) {\n    return _getChild$1(ref, childPath);\n}\n/**\n * Gets a {@link FirebaseStorage} instance for the given Firebase app.\n * @public\n * @param app - Firebase app to get {@link FirebaseStorage} instance for.\n * @param bucketUrl - The gs:// url to your Firebase Storage Bucket.\n * If not passed, uses the app's default Storage Bucket.\n * @returns A {@link FirebaseStorage} instance.\n */\nfunction getStorage(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)(), bucketUrl) {\n    app = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(app);\n    const storageProvider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, STORAGE_TYPE);\n    const storageInstance = storageProvider.getImmediate({\n        identifier: bucketUrl\n    });\n    const emulator = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getDefaultEmulatorHostnameAndPort)('storage');\n    if (emulator) {\n        connectStorageEmulator(storageInstance, ...emulator);\n    }\n    return storageInstance;\n}\n/**\n * Modify this {@link FirebaseStorage} instance to communicate with the Cloud Storage emulator.\n *\n * @param storage - The {@link FirebaseStorage} instance\n * @param host - The emulator host (ex: localhost)\n * @param port - The emulator port (ex: 5001)\n * @param options - Emulator options. `options.mockUserToken` is the mock auth\n * token to use for unit testing Security Rules.\n * @public\n */\nfunction connectStorageEmulator(storage, host, port, options = {}) {\n    connectStorageEmulator$1(storage, host, port, options);\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Downloads the data at the object's location. Returns an error if the object\n * is not found.\n *\n * To use this functionality, you have to whitelist your app's origin in your\n * Cloud Storage bucket. See also\n * https://cloud.google.com/storage/docs/configuring-cors\n *\n * This API is not available in Node.\n *\n * @public\n * @param ref - StorageReference where data should be downloaded.\n * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to\n * retrieve.\n * @returns A Promise that resolves with a Blob containing the object's bytes\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction getBlob(ref, maxDownloadSizeBytes) {\n    throw new Error('getBlob() is only available in Browser-like environments');\n}\n/**\n * Downloads the data at the object's location. Raises an error event if the\n * object is not found.\n *\n * This API is only available in Node.\n *\n * @public\n * @param ref - StorageReference where data should be downloaded.\n * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to\n * retrieve.\n * @returns A stream with the object's data as bytes\n */\nfunction getStream(ref, maxDownloadSizeBytes) {\n    ref = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(ref);\n    return getStreamInternal(ref, maxDownloadSizeBytes);\n}\n\n/**\n * Cloud Storage for Firebase\n *\n * @packageDocumentation\n */\nfunction factory(container, { instanceIdentifier: url }) {\n    const app = container.getProvider('app').getImmediate();\n    const authProvider = container.getProvider('auth-internal');\n    const appCheckProvider = container.getProvider('app-check-internal');\n    return new FirebaseStorageImpl(app, authProvider, appCheckProvider, url, _firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION);\n}\nfunction registerStorage() {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(STORAGE_TYPE, factory, \"PUBLIC\" /* ComponentType.PUBLIC */).setMultipleInstances(true));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version);\n}\nregisterStorage();\n\n\n//# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3Qvbm9kZS1lc20vaW5kZXgubm9kZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZIO0FBQ0Y7QUFDM0U7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseURBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUyxHQUFHLGtCQUFrQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtCQUFrQixJQUFJLCtCQUErQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsb0JBQW9CLEdBQUcsUUFBUSxLQUFLLGFBQWEsSUFBSSxvQkFBb0I7QUFDdkkseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGlCQUFpQixHQUFHLGFBQWEsR0FBRyxpQkFBaUI7QUFDaEgsc0NBQXNDO0FBQ3RDO0FBQ0EsY0FBYywwREFBMEQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTLGNBQWMsVUFBVTtBQUNyRjtBQUNBO0FBQ0Esb0RBQW9ELFNBQVMsY0FBYyxVQUFVO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSztBQUNqQztBQUNBLGNBQWMsU0FBUyxLQUFLLE9BQU8sS0FBSyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUNBQW1DO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRSxzQkFBc0IsS0FBSyxHQUFHLEtBQUs7QUFDbkM7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtRUFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtRUFBb0I7QUFDaEM7QUFDQTtBQUNBLCtEQUErRCxnQkFBZ0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtFQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrRUFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQSxxQ0FBcUMsdUJBQXVCO0FBQzVEO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBLDBCQUEwQixxREFBTTtBQUNoQyxVQUFVLGtFQUFrQjtBQUM1Qiw0QkFBNEIsMkRBQVk7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIsaUZBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsc0RBQVc7QUFDeEY7QUFDQTtBQUNBLElBQUksaUVBQWtCLEtBQUssMERBQVM7QUFDcEMsSUFBSSw4REFBZTtBQUNuQjtBQUNBOztBQUVxZjtBQUNyZiIsInNvdXJjZXMiOlsid2VicGFjazovL3RhbGtfdG9fdGV4dC8uLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcz8zMTJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9pc0ZpcmViYXNlU2VydmVyQXBwLCBfZ2V0UHJvdmlkZXIsIGdldEFwcCwgX3JlZ2lzdGVyQ29tcG9uZW50LCByZWdpc3RlclZlcnNpb24sIFNES19WRVJTSU9OIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBGaXJlYmFzZUVycm9yLCBjcmVhdGVNb2NrVXNlclRva2VuLCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnN0YW50cyB1c2VkIGluIHRoZSBGaXJlYmFzZSBTdG9yYWdlIGxpYnJhcnkuXG4gKi9cbi8qKlxuICogRG9tYWluIG5hbWUgZm9yIGZpcmViYXNlIHN0b3JhZ2UuXG4gKi9cbmNvbnN0IERFRkFVTFRfSE9TVCA9ICdmaXJlYmFzZXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20nO1xuLyoqXG4gKiBUaGUga2V5IGluIEZpcmViYXNlIGNvbmZpZyBqc29uIGZvciB0aGUgc3RvcmFnZSBidWNrZXQuXG4gKi9cbmNvbnN0IENPTkZJR19TVE9SQUdFX0JVQ0tFVF9LRVkgPSAnc3RvcmFnZUJ1Y2tldCc7XG4vKipcbiAqIDIgbWludXRlc1xuICpcbiAqIFRoZSB0aW1lb3V0IGZvciBhbGwgb3BlcmF0aW9ucyBleGNlcHQgdXBsb2FkLlxuICovXG5jb25zdCBERUZBVUxUX01BWF9PUEVSQVRJT05fUkVUUllfVElNRSA9IDIgKiA2MCAqIDEwMDA7XG4vKipcbiAqIDEwIG1pbnV0ZXNcbiAqXG4gKiBUaGUgdGltZW91dCBmb3IgdXBsb2FkLlxuICovXG5jb25zdCBERUZBVUxUX01BWF9VUExPQURfUkVUUllfVElNRSA9IDEwICogNjAgKiAxMDAwO1xuLyoqXG4gKiAxIHNlY29uZFxuICovXG5jb25zdCBERUZBVUxUX01JTl9TTEVFUF9USU1FX01JTExJUyA9IDEwMDA7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGVycm9yIHJldHVybmVkIGJ5IHRoZSBGaXJlYmFzZSBTdG9yYWdlIFNESy5cbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgU3RvcmFnZUVycm9yIGV4dGVuZHMgRmlyZWJhc2VFcnJvciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvZGUgLSBBIGBTdG9yYWdlRXJyb3JDb2RlYCBzdHJpbmcgdG8gYmUgcHJlZml4ZWQgd2l0aCAnc3RvcmFnZS8nIGFuZFxuICAgICAqICBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlICAtIEVycm9yIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHN0YXR1c18gLSBDb3JyZXNwb25kaW5nIEhUVFAgU3RhdHVzIENvZGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBzdGF0dXNfID0gMCkge1xuICAgICAgICBzdXBlcihwcmVwZW5kQ29kZShjb2RlKSwgYEZpcmViYXNlIFN0b3JhZ2U6ICR7bWVzc2FnZX0gKCR7cHJlcGVuZENvZGUoY29kZSl9KWApO1xuICAgICAgICB0aGlzLnN0YXR1c18gPSBzdGF0dXNfO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmVzIGN1c3RvbSBlcnJvciBkYXRhIHVuaXF1ZSB0byB0aGUgYFN0b3JhZ2VFcnJvcmAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1c3RvbURhdGEgPSB7IHNlcnZlclJlc3BvbnNlOiBudWxsIH07XG4gICAgICAgIHRoaXMuX2Jhc2VNZXNzYWdlID0gdGhpcy5tZXNzYWdlO1xuICAgICAgICAvLyBXaXRob3V0IHRoaXMsIGBpbnN0YW5jZW9mIFN0b3JhZ2VFcnJvcmAsIGluIHRlc3RzIGZvciBleGFtcGxlLFxuICAgICAgICAvLyByZXR1cm5zIGZhbHNlLlxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgU3RvcmFnZUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1c187XG4gICAgfVxuICAgIHNldCBzdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzXyA9IHN0YXR1cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgYSBgU3RvcmFnZUVycm9yQ29kZWAgYWdhaW5zdCB0aGlzIGVycm9yJ3MgY29kZSwgZmlsdGVyaW5nIG91dCB0aGUgcHJlZml4LlxuICAgICAqL1xuICAgIF9jb2RlRXF1YWxzKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHByZXBlbmRDb2RlKGNvZGUpID09PSB0aGlzLmNvZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIHJlc3BvbnNlIG1lc3NhZ2UgdGhhdCB3YXMgYWRkZWQgYnkgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBnZXQgc2VydmVyUmVzcG9uc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbURhdGEuc2VydmVyUmVzcG9uc2U7XG4gICAgfVxuICAgIHNldCBzZXJ2ZXJSZXNwb25zZShzZXJ2ZXJSZXNwb25zZSkge1xuICAgICAgICB0aGlzLmN1c3RvbURhdGEuc2VydmVyUmVzcG9uc2UgPSBzZXJ2ZXJSZXNwb25zZTtcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tRGF0YS5zZXJ2ZXJSZXNwb25zZSkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gYCR7dGhpcy5fYmFzZU1lc3NhZ2V9XFxuJHt0aGlzLmN1c3RvbURhdGEuc2VydmVyUmVzcG9uc2V9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuX2Jhc2VNZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBAcHVibGljXG4gKiBFcnJvciBjb2RlcyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBgU3RvcmFnZUVycm9yYCBvYmplY3RzLlxuICovXG52YXIgU3RvcmFnZUVycm9yQ29kZTtcbihmdW5jdGlvbiAoU3RvcmFnZUVycm9yQ29kZSkge1xuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIGFsbCBwbGF0Zm9ybXNcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJPQkpFQ1RfTk9UX0ZPVU5EXCJdID0gXCJvYmplY3Qtbm90LWZvdW5kXCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIkJVQ0tFVF9OT1RfRk9VTkRcIl0gPSBcImJ1Y2tldC1ub3QtZm91bmRcIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiUFJPSkVDVF9OT1RfRk9VTkRcIl0gPSBcInByb2plY3Qtbm90LWZvdW5kXCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIlFVT1RBX0VYQ0VFREVEXCJdID0gXCJxdW90YS1leGNlZWRlZFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJVTkFVVEhFTlRJQ0FURURcIl0gPSBcInVuYXV0aGVudGljYXRlZFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJVTkFVVEhPUklaRURcIl0gPSBcInVuYXV0aG9yaXplZFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJVTkFVVEhPUklaRURfQVBQXCJdID0gXCJ1bmF1dGhvcml6ZWQtYXBwXCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIlJFVFJZX0xJTUlUX0VYQ0VFREVEXCJdID0gXCJyZXRyeS1saW1pdC1leGNlZWRlZFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlZBTElEX0NIRUNLU1VNXCJdID0gXCJpbnZhbGlkLWNoZWNrc3VtXCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIkNBTkNFTEVEXCJdID0gXCJjYW5jZWxlZFwiO1xuICAgIC8vIEpTIHNwZWNpZmljXG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVkFMSURfRVZFTlRfTkFNRVwiXSA9IFwiaW52YWxpZC1ldmVudC1uYW1lXCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVkFMSURfVVJMXCJdID0gXCJpbnZhbGlkLXVybFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlZBTElEX0RFRkFVTFRfQlVDS0VUXCJdID0gXCJpbnZhbGlkLWRlZmF1bHQtYnVja2V0XCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIk5PX0RFRkFVTFRfQlVDS0VUXCJdID0gXCJuby1kZWZhdWx0LWJ1Y2tldFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJDQU5OT1RfU0xJQ0VfQkxPQlwiXSA9IFwiY2Fubm90LXNsaWNlLWJsb2JcIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiU0VSVkVSX0ZJTEVfV1JPTkdfU0laRVwiXSA9IFwic2VydmVyLWZpbGUtd3Jvbmctc2l6ZVwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJOT19ET1dOTE9BRF9VUkxcIl0gPSBcIm5vLWRvd25sb2FkLXVybFwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gXCJpbnZhbGlkLWFyZ3VtZW50XCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVkFMSURfQVJHVU1FTlRfQ09VTlRcIl0gPSBcImludmFsaWQtYXJndW1lbnQtY291bnRcIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiQVBQX0RFTEVURURcIl0gPSBcImFwcC1kZWxldGVkXCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVkFMSURfUk9PVF9PUEVSQVRJT05cIl0gPSBcImludmFsaWQtcm9vdC1vcGVyYXRpb25cIjtcbiAgICBTdG9yYWdlRXJyb3JDb2RlW1wiSU5WQUxJRF9GT1JNQVRcIl0gPSBcImludmFsaWQtZm9ybWF0XCI7XG4gICAgU3RvcmFnZUVycm9yQ29kZVtcIklOVEVSTkFMX0VSUk9SXCJdID0gXCJpbnRlcm5hbC1lcnJvclwiO1xuICAgIFN0b3JhZ2VFcnJvckNvZGVbXCJVTlNVUFBPUlRFRF9FTlZJUk9OTUVOVFwiXSA9IFwidW5zdXBwb3J0ZWQtZW52aXJvbm1lbnRcIjtcbn0pKFN0b3JhZ2VFcnJvckNvZGUgfHwgKFN0b3JhZ2VFcnJvckNvZGUgPSB7fSkpO1xuZnVuY3Rpb24gcHJlcGVuZENvZGUoY29kZSkge1xuICAgIHJldHVybiAnc3RvcmFnZS8nICsgY29kZTtcbn1cbmZ1bmN0aW9uIHVua25vd24oKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkLCBwbGVhc2UgY2hlY2sgdGhlIGVycm9yIHBheWxvYWQgZm9yICcgK1xuICAgICAgICAnc2VydmVyIHJlc3BvbnNlLic7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5VTktOT1dOLCBtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIG9iamVjdE5vdEZvdW5kKHBhdGgpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLk9CSkVDVF9OT1RfRk9VTkQsIFwiT2JqZWN0ICdcIiArIHBhdGggKyBcIicgZG9lcyBub3QgZXhpc3QuXCIpO1xufVxuZnVuY3Rpb24gcXVvdGFFeGNlZWRlZChidWNrZXQpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLlFVT1RBX0VYQ0VFREVELCBcIlF1b3RhIGZvciBidWNrZXQgJ1wiICtcbiAgICAgICAgYnVja2V0ICtcbiAgICAgICAgXCInIGV4Y2VlZGVkLCBwbGVhc2UgdmlldyBxdW90YSBvbiBcIiArXG4gICAgICAgICdodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vcHJpY2luZy8uJyk7XG59XG5mdW5jdGlvbiB1bmF1dGhlbnRpY2F0ZWQoKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9ICdVc2VyIGlzIG5vdCBhdXRoZW50aWNhdGVkLCBwbGVhc2UgYXV0aGVudGljYXRlIHVzaW5nIEZpcmViYXNlICcgK1xuICAgICAgICAnQXV0aGVudGljYXRpb24gYW5kIHRyeSBhZ2Fpbi4nO1xuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuVU5BVVRIRU5USUNBVEVELCBtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIHVuYXV0aG9yaXplZEFwcCgpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLlVOQVVUSE9SSVpFRF9BUFAsICdUaGlzIGFwcCBkb2VzIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gYWNjZXNzIEZpcmViYXNlIFN0b3JhZ2Ugb24gdGhpcyBwcm9qZWN0LicpO1xufVxuZnVuY3Rpb24gdW5hdXRob3JpemVkKHBhdGgpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLlVOQVVUSE9SSVpFRCwgXCJVc2VyIGRvZXMgbm90IGhhdmUgcGVybWlzc2lvbiB0byBhY2Nlc3MgJ1wiICsgcGF0aCArIFwiJy5cIik7XG59XG5mdW5jdGlvbiByZXRyeUxpbWl0RXhjZWVkZWQoKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5SRVRSWV9MSU1JVF9FWENFRURFRCwgJ01heCByZXRyeSB0aW1lIGZvciBvcGVyYXRpb24gZXhjZWVkZWQsIHBsZWFzZSB0cnkgYWdhaW4uJyk7XG59XG5mdW5jdGlvbiBjYW5jZWxlZCgpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLkNBTkNFTEVELCAnVXNlciBjYW5jZWxlZCB0aGUgdXBsb2FkL2Rvd25sb2FkLicpO1xufVxuZnVuY3Rpb24gaW52YWxpZFVybCh1cmwpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLklOVkFMSURfVVJMLCBcIkludmFsaWQgVVJMICdcIiArIHVybCArIFwiJy5cIik7XG59XG5mdW5jdGlvbiBpbnZhbGlkRGVmYXVsdEJ1Y2tldChidWNrZXQpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLklOVkFMSURfREVGQVVMVF9CVUNLRVQsIFwiSW52YWxpZCBkZWZhdWx0IGJ1Y2tldCAnXCIgKyBidWNrZXQgKyBcIicuXCIpO1xufVxuZnVuY3Rpb24gbm9EZWZhdWx0QnVja2V0KCkge1xuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuTk9fREVGQVVMVF9CVUNLRVQsICdObyBkZWZhdWx0IGJ1Y2tldCAnICtcbiAgICAgICAgXCJmb3VuZC4gRGlkIHlvdSBzZXQgdGhlICdcIiArXG4gICAgICAgIENPTkZJR19TVE9SQUdFX0JVQ0tFVF9LRVkgK1xuICAgICAgICBcIicgcHJvcGVydHkgd2hlbiBpbml0aWFsaXppbmcgdGhlIGFwcD9cIik7XG59XG5mdW5jdGlvbiBjYW5ub3RTbGljZUJsb2IoKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5DQU5OT1RfU0xJQ0VfQkxPQiwgJ0Nhbm5vdCBzbGljZSBibG9iIGZvciB1cGxvYWQuIFBsZWFzZSByZXRyeSB0aGUgdXBsb2FkLicpO1xufVxuZnVuY3Rpb24gc2VydmVyRmlsZVdyb25nU2l6ZSgpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLlNFUlZFUl9GSUxFX1dST05HX1NJWkUsICdTZXJ2ZXIgcmVjb3JkZWQgaW5jb3JyZWN0IHVwbG9hZCBmaWxlIHNpemUsIHBsZWFzZSByZXRyeSB0aGUgdXBsb2FkLicpO1xufVxuZnVuY3Rpb24gbm9Eb3dubG9hZFVSTCgpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VFcnJvcihTdG9yYWdlRXJyb3JDb2RlLk5PX0RPV05MT0FEX1VSTCwgJ1RoZSBnaXZlbiBmaWxlIGRvZXMgbm90IGhhdmUgYW55IGRvd25sb2FkIFVSTHMuJyk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpbnZhbGlkQXJndW1lbnQobWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuSU5WQUxJRF9BUkdVTUVOVCwgbWVzc2FnZSk7XG59XG5mdW5jdGlvbiBhcHBEZWxldGVkKCkge1xuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuQVBQX0RFTEVURUQsICdUaGUgRmlyZWJhc2UgYXBwIHdhcyBkZWxldGVkLicpO1xufVxuLyoqXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBvcGVyYXRpb24gdGhhdCB3YXMgaW52YWxpZC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaW52YWxpZFJvb3RPcGVyYXRpb24obmFtZSkge1xuICAgIHJldHVybiBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuSU5WQUxJRF9ST09UX09QRVJBVElPTiwgXCJUaGUgb3BlcmF0aW9uICdcIiArXG4gICAgICAgIG5hbWUgK1xuICAgICAgICBcIicgY2Fubm90IGJlIHBlcmZvcm1lZCBvbiBhIHJvb3QgcmVmZXJlbmNlLCBjcmVhdGUgYSBub24tcm9vdCBcIiArXG4gICAgICAgIFwicmVmZXJlbmNlIHVzaW5nIGNoaWxkLCBzdWNoIGFzIC5jaGlsZCgnZmlsZS5wbmcnKS5cIik7XG59XG4vKipcbiAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHRoYXQgd2FzIG5vdCB2YWxpZC5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gQSBtZXNzYWdlIGRlc2NyaWJpbmcgdGhlIGZvcm1hdCB2aW9sYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGludmFsaWRGb3JtYXQoZm9ybWF0LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5JTlZBTElEX0ZPUk1BVCwgXCJTdHJpbmcgZG9lcyBub3QgbWF0Y2ggZm9ybWF0ICdcIiArIGZvcm1hdCArIFwiJzogXCIgKyBtZXNzYWdlKTtcbn1cbi8qKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBBIG1lc3NhZ2UgZGVzY3JpYmluZyB0aGUgaW50ZXJuYWwgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIGludGVybmFsRXJyb3IobWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoU3RvcmFnZUVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiwgJ0ludGVybmFsIGVycm9yOiAnICsgbWVzc2FnZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEZpcmViYXNlIFN0b3JhZ2UgbG9jYXRpb24gZGF0YS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgTG9jYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGJ1Y2tldCwgcGF0aCkge1xuICAgICAgICB0aGlzLmJ1Y2tldCA9IGJ1Y2tldDtcbiAgICAgICAgdGhpcy5wYXRoXyA9IHBhdGg7XG4gICAgfVxuICAgIGdldCBwYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoXztcbiAgICB9XG4gICAgZ2V0IGlzUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGZ1bGxTZXJ2ZXJVcmwoKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuICcvYi8nICsgZW5jb2RlKHRoaXMuYnVja2V0KSArICcvby8nICsgZW5jb2RlKHRoaXMucGF0aCk7XG4gICAgfVxuICAgIGJ1Y2tldE9ubHlTZXJ2ZXJVcmwoKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuICcvYi8nICsgZW5jb2RlKHRoaXMuYnVja2V0KSArICcvbyc7XG4gICAgfVxuICAgIHN0YXRpYyBtYWtlRnJvbUJ1Y2tldFNwZWMoYnVja2V0U3RyaW5nLCBob3N0KSB7XG4gICAgICAgIGxldCBidWNrZXRMb2NhdGlvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJ1Y2tldExvY2F0aW9uID0gTG9jYXRpb24ubWFrZUZyb21VcmwoYnVja2V0U3RyaW5nLCBob3N0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gTm90IHZhbGlkIFVSTCwgdXNlIGFzLWlzLiBUaGlzIGxldHMgeW91IHB1dCBiYXJlIGJ1Y2tldCBuYW1lcyBpblxuICAgICAgICAgICAgLy8gY29uZmlnLlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2NhdGlvbihidWNrZXRTdHJpbmcsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVja2V0TG9jYXRpb24ucGF0aCA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBidWNrZXRMb2NhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGludmFsaWREZWZhdWx0QnVja2V0KGJ1Y2tldFN0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIG1ha2VGcm9tVXJsKHVybCwgaG9zdCkge1xuICAgICAgICBsZXQgbG9jYXRpb24gPSBudWxsO1xuICAgICAgICBjb25zdCBidWNrZXREb21haW4gPSAnKFtBLVphLXowLTkuXFxcXC1fXSspJztcbiAgICAgICAgZnVuY3Rpb24gZ3NNb2RpZnkobG9jKSB7XG4gICAgICAgICAgICBpZiAobG9jLnBhdGguY2hhckF0KGxvYy5wYXRoLmxlbmd0aCAtIDEpID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICBsb2MucGF0aF8gPSBsb2MucGF0aF8uc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdzUGF0aCA9ICcoLyguKikpPyQnO1xuICAgICAgICBjb25zdCBnc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXmdzOi8vJyArIGJ1Y2tldERvbWFpbiArIGdzUGF0aCwgJ2knKTtcbiAgICAgICAgY29uc3QgZ3NJbmRpY2VzID0geyBidWNrZXQ6IDEsIHBhdGg6IDMgfTtcbiAgICAgICAgZnVuY3Rpb24gaHR0cE1vZGlmeShsb2MpIHtcbiAgICAgICAgICAgIGxvYy5wYXRoXyA9IGRlY29kZVVSSUNvbXBvbmVudChsb2MucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyc2lvbiA9ICd2W0EtWmEtejAtOV9dKyc7XG4gICAgICAgIGNvbnN0IGZpcmViYXNlU3RvcmFnZUhvc3QgPSBob3N0LnJlcGxhY2UoL1suXS9nLCAnXFxcXC4nKTtcbiAgICAgICAgY29uc3QgZmlyZWJhc2VTdG9yYWdlUGF0aCA9ICcoLyhbXj8jXSopLiopPyQnO1xuICAgICAgICBjb25zdCBmaXJlYmFzZVN0b3JhZ2VSZWdFeHAgPSBuZXcgUmVnRXhwKGBeaHR0cHM/Oi8vJHtmaXJlYmFzZVN0b3JhZ2VIb3N0fS8ke3ZlcnNpb259L2IvJHtidWNrZXREb21haW59L28ke2ZpcmViYXNlU3RvcmFnZVBhdGh9YCwgJ2knKTtcbiAgICAgICAgY29uc3QgZmlyZWJhc2VTdG9yYWdlSW5kaWNlcyA9IHsgYnVja2V0OiAxLCBwYXRoOiAzIH07XG4gICAgICAgIGNvbnN0IGNsb3VkU3RvcmFnZUhvc3QgPSBob3N0ID09PSBERUZBVUxUX0hPU1RcbiAgICAgICAgICAgID8gJyg/OnN0b3JhZ2UuZ29vZ2xlYXBpcy5jb218c3RvcmFnZS5jbG91ZC5nb29nbGUuY29tKSdcbiAgICAgICAgICAgIDogaG9zdDtcbiAgICAgICAgY29uc3QgY2xvdWRTdG9yYWdlUGF0aCA9ICcoW14/I10qKSc7XG4gICAgICAgIGNvbnN0IGNsb3VkU3RvcmFnZVJlZ0V4cCA9IG5ldyBSZWdFeHAoYF5odHRwcz86Ly8ke2Nsb3VkU3RvcmFnZUhvc3R9LyR7YnVja2V0RG9tYWlufS8ke2Nsb3VkU3RvcmFnZVBhdGh9YCwgJ2knKTtcbiAgICAgICAgY29uc3QgY2xvdWRTdG9yYWdlSW5kaWNlcyA9IHsgYnVja2V0OiAxLCBwYXRoOiAyIH07XG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IFtcbiAgICAgICAgICAgIHsgcmVnZXg6IGdzUmVnZXgsIGluZGljZXM6IGdzSW5kaWNlcywgcG9zdE1vZGlmeTogZ3NNb2RpZnkgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZWdleDogZmlyZWJhc2VTdG9yYWdlUmVnRXhwLFxuICAgICAgICAgICAgICAgIGluZGljZXM6IGZpcmViYXNlU3RvcmFnZUluZGljZXMsXG4gICAgICAgICAgICAgICAgcG9zdE1vZGlmeTogaHR0cE1vZGlmeVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZWdleDogY2xvdWRTdG9yYWdlUmVnRXhwLFxuICAgICAgICAgICAgICAgIGluZGljZXM6IGNsb3VkU3RvcmFnZUluZGljZXMsXG4gICAgICAgICAgICAgICAgcG9zdE1vZGlmeTogaHR0cE1vZGlmeVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlcyA9IGdyb3VwLnJlZ2V4LmV4ZWModXJsKTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1Y2tldFZhbHVlID0gY2FwdHVyZXNbZ3JvdXAuaW5kaWNlcy5idWNrZXRdO1xuICAgICAgICAgICAgICAgIGxldCBwYXRoVmFsdWUgPSBjYXB0dXJlc1tncm91cC5pbmRpY2VzLnBhdGhdO1xuICAgICAgICAgICAgICAgIGlmICghcGF0aFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IG5ldyBMb2NhdGlvbihidWNrZXRWYWx1ZSwgcGF0aFZhbHVlKTtcbiAgICAgICAgICAgICAgICBncm91cC5wb3N0TW9kaWZ5KGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgaW52YWxpZFVybCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9XG59XG5cbi8qKlxuICogQSByZXF1ZXN0IHdob3NlIHByb21pc2UgYWx3YXlzIGZhaWxzLlxuICovXG5jbGFzcyBGYWlsUmVxdWVzdCB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlXyA9IFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgZ2V0UHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZV87XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIGNhbmNlbChfYXBwRGVsZXRlID0gZmFsc2UpIHsgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBY2NlcHRzIGEgY2FsbGJhY2sgZm9yIGFuIGFjdGlvbiB0byBwZXJmb3JtIChgZG9SZXF1ZXN0YCksXG4gKiBhbmQgdGhlbiBhIGNhbGxiYWNrIGZvciB3aGVuIHRoZSBiYWNrb2ZmIGhhcyBjb21wbGV0ZWQgKGBiYWNrb2ZmQ29tcGxldGVDYmApLlxuICogVGhlIGNhbGxiYWNrIHNlbnQgdG8gc3RhcnQgcmVxdWlyZXMgYW4gYXJndW1lbnQgdG8gY2FsbCAoYG9uUmVxdWVzdENvbXBsZXRlYCkuXG4gKiBXaGVuIGBzdGFydGAgY2FsbHMgYGRvUmVxdWVzdGAsIGl0IHBhc3NlcyBhIGNhbGxiYWNrIGZvciB3aGVuIHRoZSByZXF1ZXN0IGhhc1xuICogY29tcGxldGVkLCBgb25SZXF1ZXN0Q29tcGxldGVgLiBCYXNlZCBvbiB0aGlzLCB0aGUgYmFja29mZiBjb250aW51ZXMsIHdpdGhcbiAqIGFub3RoZXIgY2FsbCB0byBgZG9SZXF1ZXN0YCBhbmQgdGhlIGFib3ZlIGxvb3AgY29udGludWVzIHVudGlsIHRoZSB0aW1lb3V0XG4gKiBpcyBoaXQsIG9yIGEgc3VjY2Vzc2Z1bCByZXNwb25zZSBvY2N1cnMuXG4gKiBAZGVzY3JpcHRpb25cbiAqIEBwYXJhbSBkb1JlcXVlc3QgQ2FsbGJhY2sgdG8gcGVyZm9ybSByZXF1ZXN0XG4gKiBAcGFyYW0gYmFja29mZkNvbXBsZXRlQ2IgQ2FsbGJhY2sgdG8gY2FsbCB3aGVuIGJhY2tvZmYgaGFzIGJlZW4gY29tcGxldGVkXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0KGRvUmVxdWVzdCwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuYmFja29mZkNvbXBsZXRlQ2IsIHRpbWVvdXQpIHtcbiAgICAvLyBUT0RPKGFuZHlzb3RvKTogbWFrZSB0aGlzIGNvZGUgY2xlYW5lciAocHJvYmFibHkgcmVmYWN0b3IgaW50byBhbiBhY3R1YWxcbiAgICAvLyB0eXBlIGluc3RlYWQgb2YgYSBidW5jaCBvZiBmdW5jdGlvbnMgd2l0aCBzdGF0ZSBzaGFyZWQgaW4gdGhlIGNsb3N1cmUpXG4gICAgbGV0IHdhaXRTZWNvbmRzID0gMTtcbiAgICAvLyBXb3VsZCB0eXBlIHRoaXMgYXMgXCJudW1iZXJcIiBidXQgdGhhdCBkb2Vzbid0IHdvcmsgZm9yIE5vZGUgc28gwq9cXF8o44OEKV8vwq9cbiAgICAvLyBUT0RPOiBmaW5kIGEgd2F5IHRvIGV4Y2x1ZGUgTm9kZSB0eXBlIGRlZmluaXRpb24gZm9yIHN0b3JhZ2UgYmVjYXVzZSBzdG9yYWdlIG9ubHkgd29ya3MgaW4gYnJvd3NlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbGV0IHJldHJ5VGltZW91dElkID0gbnVsbDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGxldCBnbG9iYWxUaW1lb3V0SWQgPSBudWxsO1xuICAgIGxldCBoaXRUaW1lb3V0ID0gZmFsc2U7XG4gICAgbGV0IGNhbmNlbFN0YXRlID0gMDtcbiAgICBmdW5jdGlvbiBjYW5jZWxlZCgpIHtcbiAgICAgICAgcmV0dXJuIGNhbmNlbFN0YXRlID09PSAyO1xuICAgIH1cbiAgICBsZXQgdHJpZ2dlcmVkQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiB0cmlnZ2VyQ2FsbGJhY2soLi4uYXJncykge1xuICAgICAgICBpZiAoIXRyaWdnZXJlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICB0cmlnZ2VyZWRDYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICBiYWNrb2ZmQ29tcGxldGVDYi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsV2l0aERlbGF5KG1pbGxpcykge1xuICAgICAgICByZXRyeVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmV0cnlUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgZG9SZXF1ZXN0KHJlc3BvbnNlSGFuZGxlciwgY2FuY2VsZWQoKSk7XG4gICAgICAgIH0sIG1pbGxpcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFyR2xvYmFsVGltZW91dCgpIHtcbiAgICAgICAgaWYgKGdsb2JhbFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGdsb2JhbFRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VIYW5kbGVyKHN1Y2Nlc3MsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRyaWdnZXJlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICBjbGVhckdsb2JhbFRpbWVvdXQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgY2xlYXJHbG9iYWxUaW1lb3V0KCk7XG4gICAgICAgICAgICB0cmlnZ2VyQ2FsbGJhY2suY2FsbChudWxsLCBzdWNjZXNzLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtdXN0U3RvcCA9IGNhbmNlbGVkKCkgfHwgaGl0VGltZW91dDtcbiAgICAgICAgaWYgKG11c3RTdG9wKSB7XG4gICAgICAgICAgICBjbGVhckdsb2JhbFRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRyaWdnZXJDYWxsYmFjay5jYWxsKG51bGwsIHN1Y2Nlc3MsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3YWl0U2Vjb25kcyA8IDY0KSB7XG4gICAgICAgICAgICAvKiBUT0RPKGFuZHlzb3RvKTogZG9uJ3QgYmFjayBvZmYgc28gcXVpY2tseSBpZiB3ZSBrbm93IHdlJ3JlIG9mZmxpbmUuICovXG4gICAgICAgICAgICB3YWl0U2Vjb25kcyAqPSAyO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3YWl0TWlsbGlzO1xuICAgICAgICBpZiAoY2FuY2VsU3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAgIGNhbmNlbFN0YXRlID0gMjtcbiAgICAgICAgICAgIHdhaXRNaWxsaXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2FpdE1pbGxpcyA9ICh3YWl0U2Vjb25kcyArIE1hdGgucmFuZG9tKCkpICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgICBjYWxsV2l0aERlbGF5KHdhaXRNaWxsaXMpO1xuICAgIH1cbiAgICBsZXQgc3RvcHBlZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHN0b3Aod2FzVGltZW91dCkge1xuICAgICAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhckdsb2JhbFRpbWVvdXQoKTtcbiAgICAgICAgaWYgKHRyaWdnZXJlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldHJ5VGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIXdhc1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxTdGF0ZSA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQocmV0cnlUaW1lb3V0SWQpO1xuICAgICAgICAgICAgY2FsbFdpdGhEZWxheSgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghd2FzVGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNhbmNlbFN0YXRlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsV2l0aERlbGF5KDApO1xuICAgIGdsb2JhbFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBoaXRUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgc3RvcCh0cnVlKTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgICByZXR1cm4gc3RvcDtcbn1cbi8qKlxuICogU3RvcHMgdGhlIHJldHJ5IGxvb3AgZnJvbSByZXBlYXRpbmcuXG4gKiBJZiB0aGUgZnVuY3Rpb24gaXMgY3VycmVudGx5IFwiaW4gYmV0d2VlblwiIHJldHJpZXMsIGl0IGlzIGludm9rZWQgaW1tZWRpYXRlbHlcbiAqIHdpdGggdGhlIHNlY29uZCBwYXJhbWV0ZXIgYXMgXCJ0cnVlXCIuIE90aGVyd2lzZSwgaXQgd2lsbCBiZSBpbnZva2VkIG9uY2UgbW9yZVxuICogYWZ0ZXIgdGhlIGN1cnJlbnQgaW52b2NhdGlvbiBmaW5pc2hlcyBpZmYgdGhlIGN1cnJlbnQgaW52b2NhdGlvbiB3b3VsZCBoYXZlXG4gKiB0cmlnZ2VyZWQgYW5vdGhlciByZXRyeS5cbiAqL1xuZnVuY3Rpb24gc3RvcChpZCkge1xuICAgIGlkKGZhbHNlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGlzSnVzdERlZihwKSB7XG4gICAgcmV0dXJuIHAgIT09IHZvaWQgMDtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gdHlwZW9mIHAgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc05vbkFycmF5T2JqZWN0KHApIHtcbiAgICByZXR1cm4gdHlwZW9mIHAgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHApO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcocCkge1xuICAgIHJldHVybiB0eXBlb2YgcCA9PT0gJ3N0cmluZycgfHwgcCBpbnN0YW5jZW9mIFN0cmluZztcbn1cbmZ1bmN0aW9uIGlzTmF0aXZlQmxvYihwKSB7XG4gICAgcmV0dXJuIGlzTmF0aXZlQmxvYkRlZmluZWQoKSAmJiBwIGluc3RhbmNlb2YgQmxvYjtcbn1cbmZ1bmN0aW9uIGlzTmF0aXZlQmxvYkRlZmluZWQoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKGFyZ3VtZW50LCBtaW5WYWx1ZSwgbWF4VmFsdWUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIDwgbWluVmFsdWUpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZEFyZ3VtZW50KGBJbnZhbGlkIHZhbHVlIGZvciAnJHthcmd1bWVudH0nLiBFeHBlY3RlZCAke21pblZhbHVlfSBvciBncmVhdGVyLmApO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPiBtYXhWYWx1ZSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkQXJndW1lbnQoYEludmFsaWQgdmFsdWUgZm9yICcke2FyZ3VtZW50fScuIEV4cGVjdGVkICR7bWF4VmFsdWV9IG9yIGxlc3MuYCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gbWFrZVVybCh1cmxQYXJ0LCBob3N0LCBwcm90b2NvbCkge1xuICAgIGxldCBvcmlnaW4gPSBob3N0O1xuICAgIGlmIChwcm90b2NvbCA9PSBudWxsKSB7XG4gICAgICAgIG9yaWdpbiA9IGBodHRwczovLyR7aG9zdH1gO1xuICAgIH1cbiAgICByZXR1cm4gYCR7cHJvdG9jb2x9Oi8vJHtvcmlnaW59L3YwJHt1cmxQYXJ0fWA7XG59XG5mdW5jdGlvbiBtYWtlUXVlcnlTdHJpbmcocGFyYW1zKSB7XG4gICAgY29uc3QgZW5jb2RlID0gZW5jb2RlVVJJQ29tcG9uZW50O1xuICAgIGxldCBxdWVyeVBhcnQgPSAnPyc7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFBhcnQgPSBlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZShwYXJhbXNba2V5XSk7XG4gICAgICAgICAgICBxdWVyeVBhcnQgPSBxdWVyeVBhcnQgKyBuZXh0UGFydCArICcmJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDaG9wIG9mZiB0aGUgZXh0cmEgJyYnIG9yICc/JyBvbiB0aGUgZW5kXG4gICAgcXVlcnlQYXJ0ID0gcXVlcnlQYXJ0LnNsaWNlKDAsIC0xKTtcbiAgICByZXR1cm4gcXVlcnlQYXJ0O1xufVxuXG4vKipcbiAqIEVycm9yIGNvZGVzIGZvciByZXF1ZXN0cyBtYWRlIGJ5IHRoZSBYaHJJbyB3cmFwcGVyLlxuICovXG52YXIgRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChFcnJvckNvZGUpIHtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiTk9fRVJST1JcIl0gPSAwXSA9IFwiTk9fRVJST1JcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiTkVUV09SS19FUlJPUlwiXSA9IDFdID0gXCJORVRXT1JLX0VSUk9SXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkFCT1JUXCJdID0gMl0gPSBcIkFCT1JUXCI7XG59KShFcnJvckNvZGUgfHwgKEVycm9yQ29kZSA9IHt9KSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENoZWNrcyB0aGUgc3RhdHVzIGNvZGUgdG8gc2VlIGlmIHRoZSBhY3Rpb24gc2hvdWxkIGJlIHJldHJpZWQuXG4gKlxuICogQHBhcmFtIHN0YXR1cyBDdXJyZW50IEhUVFAgc3RhdHVzIGNvZGUgcmV0dXJuZWQgYnkgc2VydmVyLlxuICogQHBhcmFtIGFkZGl0aW9uYWxSZXRyeUNvZGVzIGFkZGl0aW9uYWwgcmV0cnkgY29kZXMgdG8gY2hlY2sgYWdhaW5zdFxuICovXG5mdW5jdGlvbiBpc1JldHJ5U3RhdHVzQ29kZShzdGF0dXMsIGFkZGl0aW9uYWxSZXRyeUNvZGVzKSB7XG4gICAgLy8gVGhlIGNvZGVzIGZvciB3aGljaCB0byByZXRyeSBjYW1lIGZyb20gdGhpcyBwYWdlOlxuICAgIC8vIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9zdG9yYWdlL2RvY3MvZXhwb25lbnRpYWwtYmFja29mZlxuICAgIGNvbnN0IGlzRml2ZUh1bmRyZWRDb2RlID0gc3RhdHVzID49IDUwMCAmJiBzdGF0dXMgPCA2MDA7XG4gICAgY29uc3QgZXh0cmFSZXRyeUNvZGVzID0gW1xuICAgICAgICAvLyBSZXF1ZXN0IFRpbWVvdXQ6IHdlYiBzZXJ2ZXIgZGlkbid0IHJlY2VpdmUgZnVsbCByZXF1ZXN0IGluIHRpbWUuXG4gICAgICAgIDQwOCxcbiAgICAgICAgLy8gVG9vIE1hbnkgUmVxdWVzdHM6IHlvdSdyZSBnZXR0aW5nIHJhdGUtbGltaXRlZCwgYmFzaWNhbGx5LlxuICAgICAgICA0MjlcbiAgICBdO1xuICAgIGNvbnN0IGlzRXh0cmFSZXRyeUNvZGUgPSBleHRyYVJldHJ5Q29kZXMuaW5kZXhPZihzdGF0dXMpICE9PSAtMTtcbiAgICBjb25zdCBpc0FkZGl0aW9uYWxSZXRyeUNvZGUgPSBhZGRpdGlvbmFsUmV0cnlDb2Rlcy5pbmRleE9mKHN0YXR1cykgIT09IC0xO1xuICAgIHJldHVybiBpc0ZpdmVIdW5kcmVkQ29kZSB8fCBpc0V4dHJhUmV0cnlDb2RlIHx8IGlzQWRkaXRpb25hbFJldHJ5Q29kZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogSGFuZGxlcyBuZXR3b3JrIGxvZ2ljIGZvciBhbGwgU3RvcmFnZSBSZXF1ZXN0cywgaW5jbHVkaW5nIGVycm9yIHJlcG9ydGluZyBhbmRcbiAqIHJldHJpZXMgd2l0aCBiYWNrb2ZmLlxuICpcbiAqIEBwYXJhbSBJIC0gdGhlIHR5cGUgb2YgdGhlIGJhY2tlbmQncyBuZXR3b3JrIHJlc3BvbnNlLlxuICogQHBhcmFtIC0gTyB0aGUgb3V0cHV0IHR5cGUgdXNlZCBieSB0aGUgcmVzdCBvZiB0aGUgU0RLLiBUaGUgY29udmVyc2lvblxuICogaGFwcGVucyBpbiB0aGUgc3BlY2lmaWVkIGBjYWxsYmFja19gLlxuICovXG5jbGFzcyBOZXR3b3JrUmVxdWVzdCB7XG4gICAgY29uc3RydWN0b3IodXJsXywgbWV0aG9kXywgaGVhZGVyc18sIGJvZHlfLCBzdWNjZXNzQ29kZXNfLCBhZGRpdGlvbmFsUmV0cnlDb2Rlc18sIGNhbGxiYWNrXywgZXJyb3JDYWxsYmFja18sIHRpbWVvdXRfLCBwcm9ncmVzc0NhbGxiYWNrXywgY29ubmVjdGlvbkZhY3RvcnlfLCByZXRyeSA9IHRydWUpIHtcbiAgICAgICAgdGhpcy51cmxfID0gdXJsXztcbiAgICAgICAgdGhpcy5tZXRob2RfID0gbWV0aG9kXztcbiAgICAgICAgdGhpcy5oZWFkZXJzXyA9IGhlYWRlcnNfO1xuICAgICAgICB0aGlzLmJvZHlfID0gYm9keV87XG4gICAgICAgIHRoaXMuc3VjY2Vzc0NvZGVzXyA9IHN1Y2Nlc3NDb2Rlc187XG4gICAgICAgIHRoaXMuYWRkaXRpb25hbFJldHJ5Q29kZXNfID0gYWRkaXRpb25hbFJldHJ5Q29kZXNfO1xuICAgICAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrXztcbiAgICAgICAgdGhpcy5lcnJvckNhbGxiYWNrXyA9IGVycm9yQ2FsbGJhY2tfO1xuICAgICAgICB0aGlzLnRpbWVvdXRfID0gdGltZW91dF87XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NDYWxsYmFja18gPSBwcm9ncmVzc0NhbGxiYWNrXztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uRmFjdG9yeV8gPSBjb25uZWN0aW9uRmFjdG9yeV87XG4gICAgICAgIHRoaXMucmV0cnkgPSByZXRyeTtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ29ubmVjdGlvbl8gPSBudWxsO1xuICAgICAgICB0aGlzLmJhY2tvZmZJZF8gPSBudWxsO1xuICAgICAgICB0aGlzLmNhbmNlbGVkXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFwcERlbGV0ZV8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9taXNlXyA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZV8gPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5yZWplY3RfID0gcmVqZWN0O1xuICAgICAgICAgICAgdGhpcy5zdGFydF8oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjdHVhbGx5IHN0YXJ0cyB0aGUgcmV0cnkgbG9vcC5cbiAgICAgKi9cbiAgICBzdGFydF8oKSB7XG4gICAgICAgIGNvbnN0IGRvVGhlUmVxdWVzdCA9IChiYWNrb2ZmQ2FsbGJhY2ssIGNhbmNlbGVkKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICBiYWNrb2ZmQ2FsbGJhY2soZmFsc2UsIG5ldyBSZXF1ZXN0RW5kU3RhdHVzKGZhbHNlLCBudWxsLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbkZhY3RvcnlfKCk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDb25uZWN0aW9uXyA9IGNvbm5lY3Rpb247XG4gICAgICAgICAgICBjb25zdCBwcm9ncmVzc0xpc3RlbmVyID0gcHJvZ3Jlc3NFdmVudCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9hZGVkID0gcHJvZ3Jlc3NFdmVudC5sb2FkZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdG90YWwgPSBwcm9ncmVzc0V2ZW50Lmxlbmd0aENvbXB1dGFibGUgPyBwcm9ncmVzc0V2ZW50LnRvdGFsIDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvZ3Jlc3NDYWxsYmFja18gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzc0NhbGxiYWNrXyhsb2FkZWQsIHRvdGFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvZ3Jlc3NDYWxsYmFja18gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmFkZFVwbG9hZFByb2dyZXNzTGlzdGVuZXIocHJvZ3Jlc3NMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb25uZWN0aW9uLnNlbmQoKSBuZXZlciByZWplY3RzLCBzbyB3ZSBkb24ndCBuZWVkIHRvIGhhdmUgYSBlcnJvciBoYW5kbGVyIG9yIHVzZSBjYXRjaCBvbiB0aGUgcmV0dXJuZWQgcHJvbWlzZS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgICAgIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAuc2VuZCh0aGlzLnVybF8sIHRoaXMubWV0aG9kXywgdGhpcy5ib2R5XywgdGhpcy5oZWFkZXJzXylcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvZ3Jlc3NDYWxsYmFja18gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVVcGxvYWRQcm9ncmVzc0xpc3RlbmVyKHByb2dyZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDb25uZWN0aW9uXyA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3QgaGl0U2VydmVyID0gY29ubmVjdGlvbi5nZXRFcnJvckNvZGUoKSA9PT0gRXJyb3JDb2RlLk5PX0VSUk9SO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGNvbm5lY3Rpb24uZ2V0U3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFoaXRTZXJ2ZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlzUmV0cnlTdGF0dXNDb2RlKHN0YXR1cywgdGhpcy5hZGRpdGlvbmFsUmV0cnlDb2Rlc18pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJldHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3YXNDYW5jZWxlZCA9IGNvbm5lY3Rpb24uZ2V0RXJyb3JDb2RlKCkgPT09IEVycm9yQ29kZS5BQk9SVDtcbiAgICAgICAgICAgICAgICAgICAgYmFja29mZkNhbGxiYWNrKGZhbHNlLCBuZXcgUmVxdWVzdEVuZFN0YXR1cyhmYWxzZSwgbnVsbCwgd2FzQ2FuY2VsZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzdWNjZXNzQ29kZSA9IHRoaXMuc3VjY2Vzc0NvZGVzXy5pbmRleE9mKHN0YXR1cykgIT09IC0xO1xuICAgICAgICAgICAgICAgIGJhY2tvZmZDYWxsYmFjayh0cnVlLCBuZXcgUmVxdWVzdEVuZFN0YXR1cyhzdWNjZXNzQ29kZSwgY29ubmVjdGlvbikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gcmVxdWVzdFdlbnRUaHJvdWdoIC0gVHJ1ZSBpZiB0aGUgcmVxdWVzdCBldmVudHVhbGx5IHdlbnRcbiAgICAgICAgICogICAgIHRocm91Z2gsIGZhbHNlIGlmIGl0IGhpdCB0aGUgcmV0cnkgbGltaXQgb3Igd2FzIGNhbmNlbGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgYmFja29mZkRvbmUgPSAocmVxdWVzdFdlbnRUaHJvdWdoLCBzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmUgPSB0aGlzLnJlc29sdmVfO1xuICAgICAgICAgICAgY29uc3QgcmVqZWN0ID0gdGhpcy5yZWplY3RfO1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHN0YXR1cy5jb25uZWN0aW9uO1xuICAgICAgICAgICAgaWYgKHN0YXR1cy53YXNTdWNjZXNzQ29kZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY2FsbGJhY2tfKGNvbm5lY3Rpb24sIGNvbm5lY3Rpb24uZ2V0UmVzcG9uc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0p1c3REZWYocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSB1bmtub3duKCk7XG4gICAgICAgICAgICAgICAgICAgIGVyci5zZXJ2ZXJSZXNwb25zZSA9IGNvbm5lY3Rpb24uZ2V0RXJyb3JUZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVycm9yQ2FsbGJhY2tfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QodGhpcy5lcnJvckNhbGxiYWNrXyhjb25uZWN0aW9uLCBlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLmFwcERlbGV0ZV8gPyBhcHBEZWxldGVkKCkgOiBjYW5jZWxlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSByZXRyeUxpbWl0RXhjZWVkZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxlZF8pIHtcbiAgICAgICAgICAgIGJhY2tvZmZEb25lKGZhbHNlLCBuZXcgUmVxdWVzdEVuZFN0YXR1cyhmYWxzZSwgbnVsbCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmSWRfID0gc3RhcnQoZG9UaGVSZXF1ZXN0LCBiYWNrb2ZmRG9uZSwgdGhpcy50aW1lb3V0Xyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgZ2V0UHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZV87XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIGNhbmNlbChhcHBEZWxldGUpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxlZF8gPSB0cnVlO1xuICAgICAgICB0aGlzLmFwcERlbGV0ZV8gPSBhcHBEZWxldGUgfHwgZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmJhY2tvZmZJZF8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0b3AodGhpcy5iYWNrb2ZmSWRfKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ29ubmVjdGlvbl8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0Nvbm5lY3Rpb25fLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVzdWx0IG9mIGEgbmV0d29yayByZXF1ZXN0LlxuICogQHBhcmFtIG9wdF9jYW5jZWxlZCAtIERlZmF1bHRzIHRvIGZhbHNlLlxuICovXG5jbGFzcyBSZXF1ZXN0RW5kU3RhdHVzIHtcbiAgICBjb25zdHJ1Y3Rvcih3YXNTdWNjZXNzQ29kZSwgY29ubmVjdGlvbiwgY2FuY2VsZWQpIHtcbiAgICAgICAgdGhpcy53YXNTdWNjZXNzQ29kZSA9IHdhc1N1Y2Nlc3NDb2RlO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICB0aGlzLmNhbmNlbGVkID0gISFjYW5jZWxlZDtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRBdXRoSGVhZGVyXyhoZWFkZXJzLCBhdXRoVG9rZW4pIHtcbiAgICBpZiAoYXV0aFRva2VuICE9PSBudWxsICYmIGF1dGhUb2tlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9ICdGaXJlYmFzZSAnICsgYXV0aFRva2VuO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFZlcnNpb25IZWFkZXJfKGhlYWRlcnMsIGZpcmViYXNlVmVyc2lvbikge1xuICAgIGhlYWRlcnNbJ1gtRmlyZWJhc2UtU3RvcmFnZS1WZXJzaW9uJ10gPVxuICAgICAgICAnd2VianMvJyArIChmaXJlYmFzZVZlcnNpb24gIT09IG51bGwgJiYgZmlyZWJhc2VWZXJzaW9uICE9PSB2b2lkIDAgPyBmaXJlYmFzZVZlcnNpb24gOiAnQXBwTWFuYWdlcicpO1xufVxuZnVuY3Rpb24gYWRkR21waWRIZWFkZXJfKGhlYWRlcnMsIGFwcElkKSB7XG4gICAgaWYgKGFwcElkKSB7XG4gICAgICAgIGhlYWRlcnNbJ1gtRmlyZWJhc2UtR01QSUQnXSA9IGFwcElkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEFwcENoZWNrSGVhZGVyXyhoZWFkZXJzLCBhcHBDaGVja1Rva2VuKSB7XG4gICAgaWYgKGFwcENoZWNrVG9rZW4gIT09IG51bGwpIHtcbiAgICAgICAgaGVhZGVyc1snWC1GaXJlYmFzZS1BcHBDaGVjayddID0gYXBwQ2hlY2tUb2tlbjtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgYXBwSWQsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgcmVxdWVzdEZhY3RvcnksIGZpcmViYXNlVmVyc2lvbiwgcmV0cnkgPSB0cnVlKSB7XG4gICAgY29uc3QgcXVlcnlQYXJ0ID0gbWFrZVF1ZXJ5U3RyaW5nKHJlcXVlc3RJbmZvLnVybFBhcmFtcyk7XG4gICAgY29uc3QgdXJsID0gcmVxdWVzdEluZm8udXJsICsgcXVlcnlQYXJ0O1xuICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0SW5mby5oZWFkZXJzKTtcbiAgICBhZGRHbXBpZEhlYWRlcl8oaGVhZGVycywgYXBwSWQpO1xuICAgIGFkZEF1dGhIZWFkZXJfKGhlYWRlcnMsIGF1dGhUb2tlbik7XG4gICAgYWRkVmVyc2lvbkhlYWRlcl8oaGVhZGVycywgZmlyZWJhc2VWZXJzaW9uKTtcbiAgICBhZGRBcHBDaGVja0hlYWRlcl8oaGVhZGVycywgYXBwQ2hlY2tUb2tlbik7XG4gICAgcmV0dXJuIG5ldyBOZXR3b3JrUmVxdWVzdCh1cmwsIHJlcXVlc3RJbmZvLm1ldGhvZCwgaGVhZGVycywgcmVxdWVzdEluZm8uYm9keSwgcmVxdWVzdEluZm8uc3VjY2Vzc0NvZGVzLCByZXF1ZXN0SW5mby5hZGRpdGlvbmFsUmV0cnlDb2RlcywgcmVxdWVzdEluZm8uaGFuZGxlciwgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyLCByZXF1ZXN0SW5mby50aW1lb3V0LCByZXF1ZXN0SW5mby5wcm9ncmVzc0NhbGxiYWNrLCByZXF1ZXN0RmFjdG9yeSwgcmV0cnkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QmxvYkJ1aWxkZXIoKSB7XG4gICAgaWYgKHR5cGVvZiBCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIEJsb2JCdWlsZGVyO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgV2ViS2l0QmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBXZWJLaXRCbG9iQnVpbGRlcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBDb25jYXRlbmF0ZXMgb25lIG9yIG1vcmUgdmFsdWVzIHRvZ2V0aGVyIGFuZCBjb252ZXJ0cyB0aGVtIHRvIGEgQmxvYi5cbiAqXG4gKiBAcGFyYW0gYXJncyBUaGUgdmFsdWVzIHRoYXQgd2lsbCBtYWtlIHVwIHRoZSByZXN1bHRpbmcgYmxvYi5cbiAqIEByZXR1cm4gVGhlIGJsb2IuXG4gKi9cbmZ1bmN0aW9uIGdldEJsb2IkMSguLi5hcmdzKSB7XG4gICAgY29uc3QgQmxvYkJ1aWxkZXIgPSBnZXRCbG9iQnVpbGRlcigpO1xuICAgIGlmIChCbG9iQnVpbGRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYmIuYXBwZW5kKGFyZ3NbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYi5nZXRCbG9iKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaXNOYXRpdmVCbG9iRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2IoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RvcmFnZUVycm9yKFN0b3JhZ2VFcnJvckNvZGUuVU5TVVBQT1JURURfRU5WSVJPTk1FTlQsIFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc2VlbSB0byBzdXBwb3J0IGNyZWF0aW5nIEJsb2JzXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBTbGljZXMgdGhlIGJsb2IuIFRoZSByZXR1cm5lZCBibG9iIGNvbnRhaW5zIGRhdGEgZnJvbSB0aGUgc3RhcnQgYnl0ZVxuICogKGluY2x1c2l2ZSkgdGlsbCB0aGUgZW5kIGJ5dGUgKGV4Y2x1c2l2ZSkuIE5lZ2F0aXZlIGluZGljZXMgY2Fubm90IGJlIHVzZWQuXG4gKlxuICogQHBhcmFtIGJsb2IgVGhlIGJsb2IgdG8gYmUgc2xpY2VkLlxuICogQHBhcmFtIHN0YXJ0IEluZGV4IG9mIHRoZSBzdGFydGluZyBieXRlLlxuICogQHBhcmFtIGVuZCBJbmRleCBvZiB0aGUgZW5kaW5nIGJ5dGUuXG4gKiBAcmV0dXJuIFRoZSBibG9iIHNsaWNlIG9yIG51bGwgaWYgbm90IHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gc2xpY2VCbG9iKGJsb2IsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoYmxvYi53ZWJraXRTbGljZSkge1xuICAgICAgICByZXR1cm4gYmxvYi53ZWJraXRTbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmxvYi5tb3pTbGljZSkge1xuICAgICAgICByZXR1cm4gYmxvYi5tb3pTbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmxvYi5zbGljZSkge1xuICAgICAgICByZXR1cm4gYmxvYi5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogQ29udmVydHMgYSBCYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBiaW5hcnkgc3RyaW5nLiAqL1xuZnVuY3Rpb24gZGVjb2RlQmFzZTY0KGVuY29kZWQpIHtcbiAgICAvLyBOb2RlIGFjdHVhbGx5IGRvZXNuJ3QgdmFsaWRhdGUgYmFzZTY0IHN0cmluZ3MuXG4gICAgLy8gQSBxdWljayBzYW5pdHkgY2hlY2sgdGhhdCBpcyBub3QgYSBmb29sLXByb29mIHZhbGlkYXRpb25cbiAgICBpZiAoL1teLUEtWmEtejAtOSsvPV0vLnRlc3QoZW5jb2RlZCkpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZEZvcm1hdCgnYmFzZTY0JywgJ0ludmFsaWQgY2hhcmFjdGVyIGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShlbmNvZGVkLCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB0aGUgcG9zc2libGUgc3RyaW5nIGZvcm1hdHMgZm9yIHVwbG9hZC5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgU3RyaW5nRm9ybWF0ID0ge1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgc3RyaW5nIHNob3VsZCBiZSBpbnRlcnByZXRlZCBcInJhd1wiLCB0aGF0IGlzLCBhcyBub3JtYWwgdGV4dC5cbiAgICAgKiBUaGUgc3RyaW5nIHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgVVRGLTE2LCB0aGVuIHVwbG9hZGVkIGFzIGEgVVRGLTggYnl0ZVxuICAgICAqIHNlcXVlbmNlLlxuICAgICAqIEV4YW1wbGU6IFRoZSBzdHJpbmcgJ0hlbGxvISBcXFxcdWQ4M2RcXFxcdWRlMGEnIGJlY29tZXMgdGhlIGJ5dGUgc2VxdWVuY2VcbiAgICAgKiA0OCA2NSA2YyA2YyA2ZiAyMSAyMCBmMCA5ZiA5OCA4YVxuICAgICAqL1xuICAgIFJBVzogJ3JhdycsXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBzdHJpbmcgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGJhc2U2NC1lbmNvZGVkIGRhdGEuXG4gICAgICogUGFkZGluZyBjaGFyYWN0ZXJzICh0cmFpbGluZyAnPSdzKSBhcmUgb3B0aW9uYWwuXG4gICAgICogRXhhbXBsZTogVGhlIHN0cmluZyAncldtTysrRTZ0Ny9ybHc9PScgYmVjb21lcyB0aGUgYnl0ZSBzZXF1ZW5jZVxuICAgICAqIGFkIDY5IDhlIGZiIGUxIDNhIGI3IGJmIGViIDk3XG4gICAgICovXG4gICAgQkFTRTY0OiAnYmFzZTY0JyxcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIHN0cmluZyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYmFzZTY0dXJsLWVuY29kZWQgZGF0YS5cbiAgICAgKiBQYWRkaW5nIGNoYXJhY3RlcnMgKHRyYWlsaW5nICc9J3MpIGFyZSBvcHRpb25hbC5cbiAgICAgKiBFeGFtcGxlOiBUaGUgc3RyaW5nICdyV21PLS1FNnQ3X3Jsdz09JyBiZWNvbWVzIHRoZSBieXRlIHNlcXVlbmNlXG4gICAgICogYWQgNjkgOGUgZmIgZTEgM2EgYjcgYmYgZWIgOTdcbiAgICAgKi9cbiAgICBCQVNFNjRVUkw6ICdiYXNlNjR1cmwnLFxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgc3RyaW5nIGlzIGEgZGF0YSBVUkwsIHN1Y2ggYXMgb25lIG9idGFpbmVkIGZyb21cbiAgICAgKiBjYW52YXMudG9EYXRhVVJMKCkuXG4gICAgICogRXhhbXBsZTogdGhlIHN0cmluZyAnZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LGFhYWEnXG4gICAgICogYmVjb21lcyB0aGUgYnl0ZSBzZXF1ZW5jZVxuICAgICAqIDY5IGE2IDlhXG4gICAgICogKHRoZSBjb250ZW50LXR5cGUgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiBpcyBhbHNvIGFwcGxpZWQsIGJ1dCBjYW5cbiAgICAgKiBiZSBvdmVycmlkZGVuIGluIHRoZSBtZXRhZGF0YSBvYmplY3QpLlxuICAgICAqL1xuICAgIERBVEFfVVJMOiAnZGF0YV91cmwnXG59O1xuY2xhc3MgU3RyaW5nRGF0YSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgY29udGVudFR5cGUpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlIHx8IG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZGF0YUZyb21TdHJpbmcoZm9ybWF0LCBzdHJpbmdEYXRhKSB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgY2FzZSBTdHJpbmdGb3JtYXQuUkFXOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdEYXRhKHV0ZjhCeXRlc18oc3RyaW5nRGF0YSkpO1xuICAgICAgICBjYXNlIFN0cmluZ0Zvcm1hdC5CQVNFNjQ6XG4gICAgICAgIGNhc2UgU3RyaW5nRm9ybWF0LkJBU0U2NFVSTDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nRGF0YShiYXNlNjRCeXRlc18oZm9ybWF0LCBzdHJpbmdEYXRhKSk7XG4gICAgICAgIGNhc2UgU3RyaW5nRm9ybWF0LkRBVEFfVVJMOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdEYXRhKGRhdGFVUkxCeXRlc18oc3RyaW5nRGF0YSksIGRhdGFVUkxDb250ZW50VHlwZV8oc3RyaW5nRGF0YSkpO1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxuICAgIC8vIGFzc2VydChmYWxzZSk7XG4gICAgdGhyb3cgdW5rbm93bigpO1xufVxuZnVuY3Rpb24gdXRmOEJ5dGVzXyh2YWx1ZSkge1xuICAgIGNvbnN0IGIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjID0gdmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMTI3KSB7XG4gICAgICAgICAgICBiLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYyA8PSAyMDQ3KSB7XG4gICAgICAgICAgICAgICAgYi5wdXNoKDE5MiB8IChjID4+IDYpLCAxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKGMgJiA2NDUxMikgPT09IDU1Mjk2KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzdGFydCBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9IGkgPCB2YWx1ZS5sZW5ndGggLSAxICYmICh2YWx1ZS5jaGFyQ29kZUF0KGkgKyAxKSAmIDY0NTEyKSA9PT0gNTYzMjA7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzZWNvbmQgc3Vycm9nYXRlIHdhc24ndCB0aGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgyMzksIDE5MSwgMTg5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhpID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvID0gdmFsdWUuY2hhckNvZGVBdCgrK2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IDY1NTM2IHwgKChoaSAmIDEwMjMpIDw8IDEwKSB8IChsbyAmIDEwMjMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKDI0MCB8IChjID4+IDE4KSwgMTI4IHwgKChjID4+IDEyKSAmIDYzKSwgMTI4IHwgKChjID4+IDYpICYgNjMpLCAxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoYyAmIDY0NTEyKSA9PT0gNTYzMjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgbG93IHN1cnJvZ2F0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgyMzksIDE5MSwgMTg5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgyMjQgfCAoYyA+PiAxMiksIDEyOCB8ICgoYyA+PiA2KSAmIDYzKSwgMTI4IHwgKGMgJiA2MykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShiKTtcbn1cbmZ1bmN0aW9uIHBlcmNlbnRFbmNvZGVkQnl0ZXNfKHZhbHVlKSB7XG4gICAgbGV0IGRlY29kZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgZGVjb2RlZCA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGludmFsaWRGb3JtYXQoU3RyaW5nRm9ybWF0LkRBVEFfVVJMLCAnTWFsZm9ybWVkIGRhdGEgVVJMLicpO1xuICAgIH1cbiAgICByZXR1cm4gdXRmOEJ5dGVzXyhkZWNvZGVkKTtcbn1cbmZ1bmN0aW9uIGJhc2U2NEJ5dGVzXyhmb3JtYXQsIHZhbHVlKSB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgY2FzZSBTdHJpbmdGb3JtYXQuQkFTRTY0OiB7XG4gICAgICAgICAgICBjb25zdCBoYXNNaW51cyA9IHZhbHVlLmluZGV4T2YoJy0nKSAhPT0gLTE7XG4gICAgICAgICAgICBjb25zdCBoYXNVbmRlciA9IHZhbHVlLmluZGV4T2YoJ18nKSAhPT0gLTE7XG4gICAgICAgICAgICBpZiAoaGFzTWludXMgfHwgaGFzVW5kZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkQ2hhciA9IGhhc01pbnVzID8gJy0nIDogJ18nO1xuICAgICAgICAgICAgICAgIHRocm93IGludmFsaWRGb3JtYXQoZm9ybWF0LCBcIkludmFsaWQgY2hhcmFjdGVyICdcIiArXG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRDaGFyICtcbiAgICAgICAgICAgICAgICAgICAgXCInIGZvdW5kOiBpcyBpdCBiYXNlNjR1cmwgZW5jb2RlZD9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFN0cmluZ0Zvcm1hdC5CQVNFNjRVUkw6IHtcbiAgICAgICAgICAgIGNvbnN0IGhhc1BsdXMgPSB2YWx1ZS5pbmRleE9mKCcrJykgIT09IC0xO1xuICAgICAgICAgICAgY29uc3QgaGFzU2xhc2ggPSB2YWx1ZS5pbmRleE9mKCcvJykgIT09IC0xO1xuICAgICAgICAgICAgaWYgKGhhc1BsdXMgfHwgaGFzU2xhc2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkQ2hhciA9IGhhc1BsdXMgPyAnKycgOiAnLyc7XG4gICAgICAgICAgICAgICAgdGhyb3cgaW52YWxpZEZvcm1hdChmb3JtYXQsIFwiSW52YWxpZCBjaGFyYWN0ZXIgJ1wiICsgaW52YWxpZENoYXIgKyBcIicgZm91bmQ6IGlzIGl0IGJhc2U2NCBlbmNvZGVkP1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvLS9nLCAnKycpLnJlcGxhY2UoL18vZywgJy8nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG4gICAgbGV0IGJ5dGVzO1xuICAgIHRyeSB7XG4gICAgICAgIGJ5dGVzID0gZGVjb2RlQmFzZTY0KHZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUubWVzc2FnZS5pbmNsdWRlcygncG9seWZpbGwnKSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBpbnZhbGlkRm9ybWF0KGZvcm1hdCwgJ0ludmFsaWQgY2hhcmFjdGVyIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZXMuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuY2xhc3MgRGF0YVVSTFBhcnRzIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhVVJMKSB7XG4gICAgICAgIHRoaXMuYmFzZTY0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBudWxsO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gZGF0YVVSTC5tYXRjaCgvXmRhdGE6KFteLF0rKT8sLyk7XG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkRm9ybWF0KFN0cmluZ0Zvcm1hdC5EQVRBX1VSTCwgXCJNdXN0IGJlIGZvcm1hdHRlZCAnZGF0YTpbPG1lZGlhdHlwZT5dWztiYXNlNjRdLDxkYXRhPlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaWRkbGUgPSBtYXRjaGVzWzFdIHx8IG51bGw7XG4gICAgICAgIGlmIChtaWRkbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5iYXNlNjQgPSBlbmRzV2l0aChtaWRkbGUsICc7YmFzZTY0Jyk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gdGhpcy5iYXNlNjRcbiAgICAgICAgICAgICAgICA/IG1pZGRsZS5zdWJzdHJpbmcoMCwgbWlkZGxlLmxlbmd0aCAtICc7YmFzZTY0Jy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgOiBtaWRkbGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXN0ID0gZGF0YVVSTC5zdWJzdHJpbmcoZGF0YVVSTC5pbmRleE9mKCcsJykgKyAxKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkYXRhVVJMQnl0ZXNfKGRhdGFVcmwpIHtcbiAgICBjb25zdCBwYXJ0cyA9IG5ldyBEYXRhVVJMUGFydHMoZGF0YVVybCk7XG4gICAgaWYgKHBhcnRzLmJhc2U2NCkge1xuICAgICAgICByZXR1cm4gYmFzZTY0Qnl0ZXNfKFN0cmluZ0Zvcm1hdC5CQVNFNjQsIHBhcnRzLnJlc3QpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBlcmNlbnRFbmNvZGVkQnl0ZXNfKHBhcnRzLnJlc3QpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRhdGFVUkxDb250ZW50VHlwZV8oZGF0YVVybCkge1xuICAgIGNvbnN0IHBhcnRzID0gbmV3IERhdGFVUkxQYXJ0cyhkYXRhVXJsKTtcbiAgICByZXR1cm4gcGFydHMuY29udGVudFR5cGU7XG59XG5mdW5jdGlvbiBlbmRzV2l0aChzLCBlbmQpIHtcbiAgICBjb25zdCBsb25nRW5vdWdoID0gcy5sZW5ndGggPj0gZW5kLmxlbmd0aDtcbiAgICBpZiAoIWxvbmdFbm91Z2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcy5zdWJzdHJpbmcocy5sZW5ndGggLSBlbmQubGVuZ3RoKSA9PT0gZW5kO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAcGFyYW0gb3B0X2VsaWRlQ29weSAtIElmIHRydWUsIGRvZXNuJ3QgY29weSBtdXRhYmxlIGlucHV0IGRhdGFcbiAqICAgICAoZS5nLiBVaW50OEFycmF5cykuIFBhc3MgdHJ1ZSBvbmx5IGlmIHlvdSBrbm93IHRoZSBvYmplY3RzIHdpbGwgbm90IGJlXG4gKiAgICAgbW9kaWZpZWQgYWZ0ZXIgdGhpcyBibG9iJ3MgY29uc3RydWN0aW9uLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBGYnNCbG9iIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBlbGlkZUNvcHkpIHtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBsZXQgYmxvYlR5cGUgPSAnJztcbiAgICAgICAgaWYgKGlzTmF0aXZlQmxvYihkYXRhKSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhXyA9IGRhdGE7XG4gICAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuICAgICAgICAgICAgYmxvYlR5cGUgPSBkYXRhLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZWxpZGVDb3B5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXyA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXyA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXy5zZXQobmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2l6ZSA9IHRoaXMuZGF0YV8ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICBpZiAoZWxpZGVDb3B5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXyA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFfID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YV8uc2V0KGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2l6ZV8gPSBzaXplO1xuICAgICAgICB0aGlzLnR5cGVfID0gYmxvYlR5cGU7XG4gICAgfVxuICAgIHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemVfO1xuICAgIH1cbiAgICB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlXztcbiAgICB9XG4gICAgc2xpY2Uoc3RhcnRCeXRlLCBlbmRCeXRlKSB7XG4gICAgICAgIGlmIChpc05hdGl2ZUJsb2IodGhpcy5kYXRhXykpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWxCbG9iID0gdGhpcy5kYXRhXztcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlZCA9IHNsaWNlQmxvYihyZWFsQmxvYiwgc3RhcnRCeXRlLCBlbmRCeXRlKTtcbiAgICAgICAgICAgIGlmIChzbGljZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRmJzQmxvYihzbGljZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGFfLmJ1ZmZlciwgc3RhcnRCeXRlLCBlbmRCeXRlIC0gc3RhcnRCeXRlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmJzQmxvYihzbGljZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldEJsb2IoLi4uYXJncykge1xuICAgICAgICBpZiAoaXNOYXRpdmVCbG9iRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBibG9iYnkgPSBhcmdzLm1hcCgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEZic0Jsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5kYXRhXztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZic0Jsb2IoZ2V0QmxvYiQxLmFwcGx5KG51bGwsIGJsb2JieSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdWludDhBcnJheXMgPSBhcmdzLm1hcCgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFGcm9tU3RyaW5nKFN0cmluZ0Zvcm1hdC5SQVcsIHZhbCkuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJsb2JzIGRvbid0IGV4aXN0LCBzbyB0aGlzIGhhcyB0byBiZSBhIFVpbnQ4QXJyYXkuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwuZGF0YV87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgZmluYWxMZW5ndGggPSAwO1xuICAgICAgICAgICAgdWludDhBcnJheXMuZm9yRWFjaCgoYXJyYXkpID0+IHtcbiAgICAgICAgICAgICAgICBmaW5hbExlbmd0aCArPSBhcnJheS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBuZXcgVWludDhBcnJheShmaW5hbExlbmd0aCk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgdWludDhBcnJheXMuZm9yRWFjaCgoYXJyYXkpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFtpbmRleCsrXSA9IGFycmF5W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYnNCbG9iKG1lcmdlZCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBsb2FkRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YV87XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBPYmplY3QgcmVzdWx0aW5nIGZyb20gcGFyc2luZyB0aGUgZ2l2ZW4gSlNPTiwgb3IgbnVsbCBpZiB0aGVcbiAqIGdpdmVuIHN0cmluZyBkb2VzIG5vdCByZXByZXNlbnQgYSBKU09OIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24ganNvbk9iamVjdE9yTnVsbChzKSB7XG4gICAgbGV0IG9iajtcbiAgICB0cnkge1xuICAgICAgICBvYmogPSBKU09OLnBhcnNlKHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGlzTm9uQXJyYXlPYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnRhaW5zIGhlbHBlciBtZXRob2RzIGZvciBtYW5pcHVsYXRpbmcgcGF0aHMuXG4gKi9cbi8qKlxuICogQHJldHVybiBOdWxsIGlmIHRoZSBwYXRoIGlzIGFscmVhZHkgYXQgdGhlIHJvb3QuXG4gKi9cbmZ1bmN0aW9uIHBhcmVudChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY29uc3QgbmV3UGF0aCA9IHBhdGguc2xpY2UoMCwgaW5kZXgpO1xuICAgIHJldHVybiBuZXdQYXRoO1xufVxuZnVuY3Rpb24gY2hpbGQocGF0aCwgY2hpbGRQYXRoKSB7XG4gICAgY29uc3QgY2Fub25pY2FsQ2hpbGRQYXRoID0gY2hpbGRQYXRoXG4gICAgICAgIC5zcGxpdCgnLycpXG4gICAgICAgIC5maWx0ZXIoY29tcG9uZW50ID0+IGNvbXBvbmVudC5sZW5ndGggPiAwKVxuICAgICAgICAuam9pbignLycpO1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY2Fub25pY2FsQ2hpbGRQYXRoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhdGggKyAnLycgKyBjYW5vbmljYWxDaGlsZFBhdGg7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsYXN0IGNvbXBvbmVudCBvZiBhIHBhdGguXG4gKiAnL2Zvby9iYXInIC0+ICdiYXInXG4gKiAnL2Zvby9iYXIvYmF6LycgLT4gJ2Jhei8nXG4gKiAnL2EnIC0+ICdhJ1xuICovXG5mdW5jdGlvbiBsYXN0Q29tcG9uZW50KHBhdGgpIHtcbiAgICBjb25zdCBpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoJy8nLCBwYXRoLmxlbmd0aCAtIDIpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0aC5zbGljZShpbmRleCArIDEpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIG5vWGZvcm1fKG1ldGFkYXRhLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmNsYXNzIE1hcHBpbmcge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlciwgbG9jYWwsIHdyaXRhYmxlLCB4Zm9ybSkge1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsIHx8IHNlcnZlcjtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9ICEhd3JpdGFibGU7XG4gICAgICAgIHRoaXMueGZvcm0gPSB4Zm9ybSB8fCBub1hmb3JtXztcbiAgICB9XG59XG5sZXQgbWFwcGluZ3NfID0gbnVsbDtcbmZ1bmN0aW9uIHhmb3JtUGF0aChmdWxsUGF0aCkge1xuICAgIGlmICghaXNTdHJpbmcoZnVsbFBhdGgpIHx8IGZ1bGxQYXRoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bGxQYXRoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxhc3RDb21wb25lbnQoZnVsbFBhdGgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldE1hcHBpbmdzKCkge1xuICAgIGlmIChtYXBwaW5nc18pIHtcbiAgICAgICAgcmV0dXJuIG1hcHBpbmdzXztcbiAgICB9XG4gICAgY29uc3QgbWFwcGluZ3MgPSBbXTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdidWNrZXQnKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnZ2VuZXJhdGlvbicpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdtZXRhZ2VuZXJhdGlvbicpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCduYW1lJywgJ2Z1bGxQYXRoJywgdHJ1ZSkpO1xuICAgIGZ1bmN0aW9uIG1hcHBpbmdzWGZvcm1QYXRoKF9tZXRhZGF0YSwgZnVsbFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHhmb3JtUGF0aChmdWxsUGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IG5hbWVNYXBwaW5nID0gbmV3IE1hcHBpbmcoJ25hbWUnKTtcbiAgICBuYW1lTWFwcGluZy54Zm9ybSA9IG1hcHBpbmdzWGZvcm1QYXRoO1xuICAgIG1hcHBpbmdzLnB1c2gobmFtZU1hcHBpbmcpO1xuICAgIC8qKlxuICAgICAqIENvZXJjZXMgdGhlIHNlY29uZCBwYXJhbSB0byBhIG51bWJlciwgaWYgaXQgaXMgZGVmaW5lZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB4Zm9ybVNpemUoX21ldGFkYXRhLCBzaXplKSB7XG4gICAgICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzaXplTWFwcGluZyA9IG5ldyBNYXBwaW5nKCdzaXplJyk7XG4gICAgc2l6ZU1hcHBpbmcueGZvcm0gPSB4Zm9ybVNpemU7XG4gICAgbWFwcGluZ3MucHVzaChzaXplTWFwcGluZyk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygndGltZUNyZWF0ZWQnKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygndXBkYXRlZCcpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdtZDVIYXNoJywgbnVsbCwgdHJ1ZSkpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ2NhY2hlQ29udHJvbCcsIG51bGwsIHRydWUpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdjb250ZW50RGlzcG9zaXRpb24nLCBudWxsLCB0cnVlKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnY29udGVudEVuY29kaW5nJywgbnVsbCwgdHJ1ZSkpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ2NvbnRlbnRMYW5ndWFnZScsIG51bGwsIHRydWUpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdjb250ZW50VHlwZScsIG51bGwsIHRydWUpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdtZXRhZGF0YScsICdjdXN0b21NZXRhZGF0YScsIHRydWUpKTtcbiAgICBtYXBwaW5nc18gPSBtYXBwaW5ncztcbiAgICByZXR1cm4gbWFwcGluZ3NfO1xufVxuZnVuY3Rpb24gYWRkUmVmKG1ldGFkYXRhLCBzZXJ2aWNlKSB7XG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVSZWYoKSB7XG4gICAgICAgIGNvbnN0IGJ1Y2tldCA9IG1ldGFkYXRhWydidWNrZXQnXTtcbiAgICAgICAgY29uc3QgcGF0aCA9IG1ldGFkYXRhWydmdWxsUGF0aCddO1xuICAgICAgICBjb25zdCBsb2MgPSBuZXcgTG9jYXRpb24oYnVja2V0LCBwYXRoKTtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2UuX21ha2VTdG9yYWdlUmVmZXJlbmNlKGxvYyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRhZGF0YSwgJ3JlZicsIHsgZ2V0OiBnZW5lcmF0ZVJlZiB9KTtcbn1cbmZ1bmN0aW9uIGZyb21SZXNvdXJjZShzZXJ2aWNlLCByZXNvdXJjZSwgbWFwcGluZ3MpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHt9O1xuICAgIG1ldGFkYXRhWyd0eXBlJ10gPSAnZmlsZSc7XG4gICAgY29uc3QgbGVuID0gbWFwcGluZ3MubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgICBtZXRhZGF0YVttYXBwaW5nLmxvY2FsXSA9IG1hcHBpbmcueGZvcm0obWV0YWRhdGEsIHJlc291cmNlW21hcHBpbmcuc2VydmVyXSk7XG4gICAgfVxuICAgIGFkZFJlZihtZXRhZGF0YSwgc2VydmljZSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xufVxuZnVuY3Rpb24gZnJvbVJlc291cmNlU3RyaW5nKHNlcnZpY2UsIHJlc291cmNlU3RyaW5nLCBtYXBwaW5ncykge1xuICAgIGNvbnN0IG9iaiA9IGpzb25PYmplY3RPck51bGwocmVzb3VyY2VTdHJpbmcpO1xuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc291cmNlID0gb2JqO1xuICAgIHJldHVybiBmcm9tUmVzb3VyY2Uoc2VydmljZSwgcmVzb3VyY2UsIG1hcHBpbmdzKTtcbn1cbmZ1bmN0aW9uIGRvd25sb2FkVXJsRnJvbVJlc291cmNlU3RyaW5nKG1ldGFkYXRhLCByZXNvdXJjZVN0cmluZywgaG9zdCwgcHJvdG9jb2wpIHtcbiAgICBjb25zdCBvYmogPSBqc29uT2JqZWN0T3JOdWxsKHJlc291cmNlU3RyaW5nKTtcbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIWlzU3RyaW5nKG9ialsnZG93bmxvYWRUb2tlbnMnXSkpIHtcbiAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIG9iamVjdHMgYXJlIHVwbG9hZGVkIHRocm91Z2ggR0NTIGFuZCByZXRyaWV2ZWRcbiAgICAgICAgLy8gdGhyb3VnaCBsaXN0LCBzbyB3ZSBkb24ndCB3YW50IHRvIHRocm93IGFuIEVycm9yLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdG9rZW5zID0gb2JqWydkb3dubG9hZFRva2VucyddO1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XG4gICAgY29uc3QgdG9rZW5zTGlzdCA9IHRva2Vucy5zcGxpdCgnLCcpO1xuICAgIGNvbnN0IHVybHMgPSB0b2tlbnNMaXN0Lm1hcCgodG9rZW4pID0+IHtcbiAgICAgICAgY29uc3QgYnVja2V0ID0gbWV0YWRhdGFbJ2J1Y2tldCddO1xuICAgICAgICBjb25zdCBwYXRoID0gbWV0YWRhdGFbJ2Z1bGxQYXRoJ107XG4gICAgICAgIGNvbnN0IHVybFBhcnQgPSAnL2IvJyArIGVuY29kZShidWNrZXQpICsgJy9vLycgKyBlbmNvZGUocGF0aCk7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBtYWtlVXJsKHVybFBhcnQsIGhvc3QsIHByb3RvY29sKTtcbiAgICAgICAgY29uc3QgcXVlcnlTdHJpbmcgPSBtYWtlUXVlcnlTdHJpbmcoe1xuICAgICAgICAgICAgYWx0OiAnbWVkaWEnLFxuICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBiYXNlICsgcXVlcnlTdHJpbmc7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVybHNbMF07XG59XG5mdW5jdGlvbiB0b1Jlc291cmNlU3RyaW5nKG1ldGFkYXRhLCBtYXBwaW5ncykge1xuICAgIGNvbnN0IHJlc291cmNlID0ge307XG4gICAgY29uc3QgbGVuID0gbWFwcGluZ3MubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgICBpZiAobWFwcGluZy53cml0YWJsZSkge1xuICAgICAgICAgICAgcmVzb3VyY2VbbWFwcGluZy5zZXJ2ZXJdID0gbWV0YWRhdGFbbWFwcGluZy5sb2NhbF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc291cmNlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IFBSRUZJWEVTX0tFWSA9ICdwcmVmaXhlcyc7XG5jb25zdCBJVEVNU19LRVkgPSAnaXRlbXMnO1xuZnVuY3Rpb24gZnJvbUJhY2tlbmRSZXNwb25zZShzZXJ2aWNlLCBidWNrZXQsIHJlc291cmNlKSB7XG4gICAgY29uc3QgbGlzdFJlc3VsdCA9IHtcbiAgICAgICAgcHJlZml4ZXM6IFtdLFxuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIG5leHRQYWdlVG9rZW46IHJlc291cmNlWyduZXh0UGFnZVRva2VuJ11cbiAgICB9O1xuICAgIGlmIChyZXNvdXJjZVtQUkVGSVhFU19LRVldKSB7XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiByZXNvdXJjZVtQUkVGSVhFU19LRVldKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoV2l0aG91dFRyYWlsaW5nU2xhc2ggPSBwYXRoLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgICAgICAgICBjb25zdCByZWZlcmVuY2UgPSBzZXJ2aWNlLl9tYWtlU3RvcmFnZVJlZmVyZW5jZShuZXcgTG9jYXRpb24oYnVja2V0LCBwYXRoV2l0aG91dFRyYWlsaW5nU2xhc2gpKTtcbiAgICAgICAgICAgIGxpc3RSZXN1bHQucHJlZml4ZXMucHVzaChyZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZXNvdXJjZVtJVEVNU19LRVldKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiByZXNvdXJjZVtJVEVNU19LRVldKSB7XG4gICAgICAgICAgICBjb25zdCByZWZlcmVuY2UgPSBzZXJ2aWNlLl9tYWtlU3RvcmFnZVJlZmVyZW5jZShuZXcgTG9jYXRpb24oYnVja2V0LCBpdGVtWyduYW1lJ10pKTtcbiAgICAgICAgICAgIGxpc3RSZXN1bHQuaXRlbXMucHVzaChyZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaXN0UmVzdWx0O1xufVxuZnVuY3Rpb24gZnJvbVJlc3BvbnNlU3RyaW5nKHNlcnZpY2UsIGJ1Y2tldCwgcmVzb3VyY2VTdHJpbmcpIHtcbiAgICBjb25zdCBvYmogPSBqc29uT2JqZWN0T3JOdWxsKHJlc291cmNlU3RyaW5nKTtcbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXNvdXJjZSA9IG9iajtcbiAgICByZXR1cm4gZnJvbUJhY2tlbmRSZXNwb25zZShzZXJ2aWNlLCBidWNrZXQsIHJlc291cmNlKTtcbn1cblxuLyoqXG4gKiBDb250YWlucyBhIGZ1bGx5IHNwZWNpZmllZCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBJIC0gdGhlIHR5cGUgb2YgdGhlIGJhY2tlbmQncyBuZXR3b3JrIHJlc3BvbnNlLlxuICogQHBhcmFtIE8gLSB0aGUgb3V0cHV0IHJlc3BvbnNlIHR5cGUgdXNlZCBieSB0aGUgcmVzdCBvZiB0aGUgU0RLLlxuICovXG5jbGFzcyBSZXF1ZXN0SW5mbyB7XG4gICAgY29uc3RydWN0b3IodXJsLCBtZXRob2QsIFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIHdpdGggd2hpY2ggdG8gcmVzb2x2ZSB0aGUgcmVxdWVzdCdzIHByb21pc2UuIE9ubHkgY2FsbGVkXG4gICAgICogaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bC4gVGhyb3cgZnJvbSB0aGlzIGZ1bmN0aW9uIHRvIHJlamVjdCB0aGVcbiAgICAgKiByZXR1cm5lZCBSZXF1ZXN0J3MgcHJvbWlzZSB3aXRoIHRoZSB0aHJvd24gZXJyb3IuXG4gICAgICogTm90ZTogVGhlIFhocklvIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIG1heSBiZSByZXVzZWQgYWZ0ZXIgdGhpcyBjYWxsYmFja1xuICAgICAqIHJldHVybnMuIERvIG5vdCBrZWVwIGEgcmVmZXJlbmNlIHRvIGl0IGluIGFueSB3YXkuXG4gICAgICovXG4gICAgaGFuZGxlciwgdGltZW91dCkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHRoaXMudXJsUGFyYW1zID0ge307XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHt9O1xuICAgICAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2l0aCB0aGUgY3VycmVudCBudW1iZXIgb2YgYnl0ZXMgdXBsb2FkZWQgYW5kIHRvdGFsIHNpemUgKC0xIGlmIG5vdFxuICAgICAgICAgKiBjb21wdXRhYmxlKSBvZiB0aGUgcmVxdWVzdCBib2R5IChpLmUuIHVzZWQgdG8gcmVwb3J0IHVwbG9hZCBwcm9ncmVzcykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb2dyZXNzQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLnN1Y2Nlc3NDb2RlcyA9IFsyMDBdO1xuICAgICAgICB0aGlzLmFkZGl0aW9uYWxSZXRyeUNvZGVzID0gW107XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaHJvd3MgdGhlIFVOS05PV04gU3RvcmFnZUVycm9yIGlmIGNuZG4gaXMgZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZXJDaGVjayhjbmRuKSB7XG4gICAgaWYgKCFjbmRuKSB7XG4gICAgICAgIHRocm93IHVua25vd24oKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtZXRhZGF0YUhhbmRsZXIoc2VydmljZSwgbWFwcGluZ3MpIHtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhociwgdGV4dCkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGZyb21SZXNvdXJjZVN0cmluZyhzZXJ2aWNlLCB0ZXh0LCBtYXBwaW5ncyk7XG4gICAgICAgIGhhbmRsZXJDaGVjayhtZXRhZGF0YSAhPT0gbnVsbCk7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXI7XG59XG5mdW5jdGlvbiBsaXN0SGFuZGxlcihzZXJ2aWNlLCBidWNrZXQpIHtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhociwgdGV4dCkge1xuICAgICAgICBjb25zdCBsaXN0UmVzdWx0ID0gZnJvbVJlc3BvbnNlU3RyaW5nKHNlcnZpY2UsIGJ1Y2tldCwgdGV4dCk7XG4gICAgICAgIGhhbmRsZXJDaGVjayhsaXN0UmVzdWx0ICE9PSBudWxsKTtcbiAgICAgICAgcmV0dXJuIGxpc3RSZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyO1xufVxuZnVuY3Rpb24gZG93bmxvYWRVcmxIYW5kbGVyKHNlcnZpY2UsIG1hcHBpbmdzKSB7XG4gICAgZnVuY3Rpb24gaGFuZGxlcih4aHIsIHRleHQpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBmcm9tUmVzb3VyY2VTdHJpbmcoc2VydmljZSwgdGV4dCwgbWFwcGluZ3MpO1xuICAgICAgICBoYW5kbGVyQ2hlY2sobWV0YWRhdGEgIT09IG51bGwpO1xuICAgICAgICByZXR1cm4gZG93bmxvYWRVcmxGcm9tUmVzb3VyY2VTdHJpbmcobWV0YWRhdGEsIHRleHQsIHNlcnZpY2UuaG9zdCwgc2VydmljZS5fcHJvdG9jb2wpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlcjtcbn1cbmZ1bmN0aW9uIHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbikge1xuICAgIGZ1bmN0aW9uIGVycm9ySGFuZGxlcih4aHIsIGVycikge1xuICAgICAgICBsZXQgbmV3RXJyO1xuICAgICAgICBpZiAoeGhyLmdldFN0YXR1cygpID09PSA0MDEpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIFRoaXMgZXhhY3QgbWVzc2FnZSBzdHJpbmcgaXMgdGhlIG9ubHkgY29uc2lzdGVudCBwYXJ0IG9mIHRoZVxuICAgICAgICAgICAgLy8gc2VydmVyJ3MgZXJyb3IgcmVzcG9uc2UgdGhhdCBpZGVudGlmaWVzIGl0IGFzIGFuIEFwcCBDaGVjayBlcnJvci5cbiAgICAgICAgICAgIHhoci5nZXRFcnJvclRleHQoKS5pbmNsdWRlcygnRmlyZWJhc2UgQXBwIENoZWNrIHRva2VuIGlzIGludmFsaWQnKSkge1xuICAgICAgICAgICAgICAgIG5ld0VyciA9IHVuYXV0aG9yaXplZEFwcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3RXJyID0gdW5hdXRoZW50aWNhdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoeGhyLmdldFN0YXR1cygpID09PSA0MDIpIHtcbiAgICAgICAgICAgICAgICBuZXdFcnIgPSBxdW90YUV4Y2VlZGVkKGxvY2F0aW9uLmJ1Y2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoeGhyLmdldFN0YXR1cygpID09PSA0MDMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RXJyID0gdW5hdXRob3JpemVkKGxvY2F0aW9uLnBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RXJyID0gZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdFcnIuc3RhdHVzID0geGhyLmdldFN0YXR1cygpO1xuICAgICAgICBuZXdFcnIuc2VydmVyUmVzcG9uc2UgPSBlcnIuc2VydmVyUmVzcG9uc2U7XG4gICAgICAgIHJldHVybiBuZXdFcnI7XG4gICAgfVxuICAgIHJldHVybiBlcnJvckhhbmRsZXI7XG59XG5mdW5jdGlvbiBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pIHtcbiAgICBjb25zdCBzaGFyZWQgPSBzaGFyZWRFcnJvckhhbmRsZXIobG9jYXRpb24pO1xuICAgIGZ1bmN0aW9uIGVycm9ySGFuZGxlcih4aHIsIGVycikge1xuICAgICAgICBsZXQgbmV3RXJyID0gc2hhcmVkKHhociwgZXJyKTtcbiAgICAgICAgaWYgKHhoci5nZXRTdGF0dXMoKSA9PT0gNDA0KSB7XG4gICAgICAgICAgICBuZXdFcnIgPSBvYmplY3ROb3RGb3VuZChsb2NhdGlvbi5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdFcnIuc2VydmVyUmVzcG9uc2UgPSBlcnIuc2VydmVyUmVzcG9uc2U7XG4gICAgICAgIHJldHVybiBuZXdFcnI7XG4gICAgfVxuICAgIHJldHVybiBlcnJvckhhbmRsZXI7XG59XG5mdW5jdGlvbiBnZXRNZXRhZGF0YSQyKHNlcnZpY2UsIGxvY2F0aW9uLCBtYXBwaW5ncykge1xuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5mdWxsU2VydmVyVXJsKCk7XG4gICAgY29uc3QgdXJsID0gbWFrZVVybCh1cmxQYXJ0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKTtcbiAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhPcGVyYXRpb25SZXRyeVRpbWU7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBuZXcgUmVxdWVzdEluZm8odXJsLCBtZXRob2QsIG1ldGFkYXRhSGFuZGxlcihzZXJ2aWNlLCBtYXBwaW5ncyksIHRpbWVvdXQpO1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IG9iamVjdEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xufVxuZnVuY3Rpb24gbGlzdCQyKHNlcnZpY2UsIGxvY2F0aW9uLCBkZWxpbWl0ZXIsIHBhZ2VUb2tlbiwgbWF4UmVzdWx0cykge1xuICAgIGNvbnN0IHVybFBhcmFtcyA9IHt9O1xuICAgIGlmIChsb2NhdGlvbi5pc1Jvb3QpIHtcbiAgICAgICAgdXJsUGFyYW1zWydwcmVmaXgnXSA9ICcnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXJsUGFyYW1zWydwcmVmaXgnXSA9IGxvY2F0aW9uLnBhdGggKyAnLyc7XG4gICAgfVxuICAgIGlmIChkZWxpbWl0ZXIgJiYgZGVsaW1pdGVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdXJsUGFyYW1zWydkZWxpbWl0ZXInXSA9IGRlbGltaXRlcjtcbiAgICB9XG4gICAgaWYgKHBhZ2VUb2tlbikge1xuICAgICAgICB1cmxQYXJhbXNbJ3BhZ2VUb2tlbiddID0gcGFnZVRva2VuO1xuICAgIH1cbiAgICBpZiAobWF4UmVzdWx0cykge1xuICAgICAgICB1cmxQYXJhbXNbJ21heFJlc3VsdHMnXSA9IG1heFJlc3VsdHM7XG4gICAgfVxuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5idWNrZXRPbmx5U2VydmVyVXJsKCk7XG4gICAgY29uc3QgdXJsID0gbWFrZVVybCh1cmxQYXJ0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKTtcbiAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhPcGVyYXRpb25SZXRyeVRpbWU7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBuZXcgUmVxdWVzdEluZm8odXJsLCBtZXRob2QsIGxpc3RIYW5kbGVyKHNlcnZpY2UsIGxvY2F0aW9uLmJ1Y2tldCksIHRpbWVvdXQpO1xuICAgIHJlcXVlc3RJbmZvLnVybFBhcmFtcyA9IHVybFBhcmFtcztcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBzaGFyZWRFcnJvckhhbmRsZXIobG9jYXRpb24pO1xuICAgIHJldHVybiByZXF1ZXN0SW5mbztcbn1cbmZ1bmN0aW9uIGdldEJ5dGVzJDEoc2VydmljZSwgbG9jYXRpb24sIG1heERvd25sb2FkU2l6ZUJ5dGVzKSB7XG4gICAgY29uc3QgdXJsUGFydCA9IGxvY2F0aW9uLmZ1bGxTZXJ2ZXJVcmwoKTtcbiAgICBjb25zdCB1cmwgPSBtYWtlVXJsKHVybFBhcnQsIHNlcnZpY2UuaG9zdCwgc2VydmljZS5fcHJvdG9jb2wpICsgJz9hbHQ9bWVkaWEnO1xuICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXJ2aWNlLm1heE9wZXJhdGlvblJldHJ5VGltZTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgKF8sIGRhdGEpID0+IGRhdGEsIHRpbWVvdXQpO1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IG9iamVjdEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgaWYgKG1heERvd25sb2FkU2l6ZUJ5dGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVxdWVzdEluZm8uaGVhZGVyc1snUmFuZ2UnXSA9IGBieXRlcz0wLSR7bWF4RG93bmxvYWRTaXplQnl0ZXN9YDtcbiAgICAgICAgcmVxdWVzdEluZm8uc3VjY2Vzc0NvZGVzID0gWzIwMCAvKiBPSyAqLywgMjA2IC8qIFBhcnRpYWwgQ29udGVudCAqL107XG4gICAgfVxuICAgIHJldHVybiByZXF1ZXN0SW5mbztcbn1cbmZ1bmN0aW9uIGdldERvd25sb2FkVXJsKHNlcnZpY2UsIGxvY2F0aW9uLCBtYXBwaW5ncykge1xuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5mdWxsU2VydmVyVXJsKCk7XG4gICAgY29uc3QgdXJsID0gbWFrZVVybCh1cmxQYXJ0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKTtcbiAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICBjb25zdCB0aW1lb3V0ID0gc2VydmljZS5tYXhPcGVyYXRpb25SZXRyeVRpbWU7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBuZXcgUmVxdWVzdEluZm8odXJsLCBtZXRob2QsIGRvd25sb2FkVXJsSGFuZGxlcihzZXJ2aWNlLCBtYXBwaW5ncyksIHRpbWVvdXQpO1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IG9iamVjdEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xufVxuZnVuY3Rpb24gdXBkYXRlTWV0YWRhdGEkMihzZXJ2aWNlLCBsb2NhdGlvbiwgbWV0YWRhdGEsIG1hcHBpbmdzKSB7XG4gICAgY29uc3QgdXJsUGFydCA9IGxvY2F0aW9uLmZ1bGxTZXJ2ZXJVcmwoKTtcbiAgICBjb25zdCB1cmwgPSBtYWtlVXJsKHVybFBhcnQsIHNlcnZpY2UuaG9zdCwgc2VydmljZS5fcHJvdG9jb2wpO1xuICAgIGNvbnN0IG1ldGhvZCA9ICdQQVRDSCc7XG4gICAgY29uc3QgYm9keSA9IHRvUmVzb3VyY2VTdHJpbmcobWV0YWRhdGEsIG1hcHBpbmdzKTtcbiAgICBjb25zdCBoZWFkZXJzID0geyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLTgnIH07XG4gICAgY29uc3QgdGltZW91dCA9IHNlcnZpY2UubWF4T3BlcmF0aW9uUmV0cnlUaW1lO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBtZXRhZGF0YUhhbmRsZXIoc2VydmljZSwgbWFwcGluZ3MpLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby5oZWFkZXJzID0gaGVhZGVycztcbiAgICByZXF1ZXN0SW5mby5ib2R5ID0gYm9keTtcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pO1xuICAgIHJldHVybiByZXF1ZXN0SW5mbztcbn1cbmZ1bmN0aW9uIGRlbGV0ZU9iamVjdCQyKHNlcnZpY2UsIGxvY2F0aW9uKSB7XG4gICAgY29uc3QgdXJsUGFydCA9IGxvY2F0aW9uLmZ1bGxTZXJ2ZXJVcmwoKTtcbiAgICBjb25zdCB1cmwgPSBtYWtlVXJsKHVybFBhcnQsIHNlcnZpY2UuaG9zdCwgc2VydmljZS5fcHJvdG9jb2wpO1xuICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXJ2aWNlLm1heE9wZXJhdGlvblJldHJ5VGltZTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKF94aHIsIF90ZXh0KSB7IH1cbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgaGFuZGxlciwgdGltZW91dCk7XG4gICAgcmVxdWVzdEluZm8uc3VjY2Vzc0NvZGVzID0gWzIwMCwgMjA0XTtcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pO1xuICAgIHJldHVybiByZXF1ZXN0SW5mbztcbn1cbmZ1bmN0aW9uIGRldGVybWluZUNvbnRlbnRUeXBlXyhtZXRhZGF0YSwgYmxvYikge1xuICAgIHJldHVybiAoKG1ldGFkYXRhICYmIG1ldGFkYXRhWydjb250ZW50VHlwZSddKSB8fFxuICAgICAgICAoYmxvYiAmJiBibG9iLnR5cGUoKSkgfHxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xufVxuZnVuY3Rpb24gbWV0YWRhdGFGb3JVcGxvYWRfKGxvY2F0aW9uLCBibG9iLCBtZXRhZGF0YSkge1xuICAgIGNvbnN0IG1ldGFkYXRhQ2xvbmUgPSBPYmplY3QuYXNzaWduKHt9LCBtZXRhZGF0YSk7XG4gICAgbWV0YWRhdGFDbG9uZVsnZnVsbFBhdGgnXSA9IGxvY2F0aW9uLnBhdGg7XG4gICAgbWV0YWRhdGFDbG9uZVsnc2l6ZSddID0gYmxvYi5zaXplKCk7XG4gICAgaWYgKCFtZXRhZGF0YUNsb25lWydjb250ZW50VHlwZSddKSB7XG4gICAgICAgIG1ldGFkYXRhQ2xvbmVbJ2NvbnRlbnRUeXBlJ10gPSBkZXRlcm1pbmVDb250ZW50VHlwZV8obnVsbCwgYmxvYik7XG4gICAgfVxuICAgIHJldHVybiBtZXRhZGF0YUNsb25lO1xufVxuLyoqXG4gKiBQcmVwYXJlIFJlcXVlc3RJbmZvIGZvciB1cGxvYWRzIGFzIENvbnRlbnQtVHlwZTogbXVsdGlwYXJ0LlxuICovXG5mdW5jdGlvbiBtdWx0aXBhcnRVcGxvYWQoc2VydmljZSwgbG9jYXRpb24sIG1hcHBpbmdzLCBibG9iLCBtZXRhZGF0YSkge1xuICAgIGNvbnN0IHVybFBhcnQgPSBsb2NhdGlvbi5idWNrZXRPbmx5U2VydmVyVXJsKCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgJ1gtR29vZy1VcGxvYWQtUHJvdG9jb2wnOiAnbXVsdGlwYXJ0J1xuICAgIH07XG4gICAgZnVuY3Rpb24gZ2VuQm91bmRhcnkoKSB7XG4gICAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ciArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zbGljZSgyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBjb25zdCBib3VuZGFyeSA9IGdlbkJvdW5kYXJ5KCk7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnbXVsdGlwYXJ0L3JlbGF0ZWQ7IGJvdW5kYXJ5PScgKyBib3VuZGFyeTtcbiAgICBjb25zdCBtZXRhZGF0YV8gPSBtZXRhZGF0YUZvclVwbG9hZF8obG9jYXRpb24sIGJsb2IsIG1ldGFkYXRhKTtcbiAgICBjb25zdCBtZXRhZGF0YVN0cmluZyA9IHRvUmVzb3VyY2VTdHJpbmcobWV0YWRhdGFfLCBtYXBwaW5ncyk7XG4gICAgY29uc3QgcHJlQmxvYlBhcnQgPSAnLS0nICtcbiAgICAgICAgYm91bmRhcnkgK1xuICAgICAgICAnXFxyXFxuJyArXG4gICAgICAgICdDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcXHJcXG5cXHJcXG4nICtcbiAgICAgICAgbWV0YWRhdGFTdHJpbmcgK1xuICAgICAgICAnXFxyXFxuLS0nICtcbiAgICAgICAgYm91bmRhcnkgK1xuICAgICAgICAnXFxyXFxuJyArXG4gICAgICAgICdDb250ZW50LVR5cGU6ICcgK1xuICAgICAgICBtZXRhZGF0YV9bJ2NvbnRlbnRUeXBlJ10gK1xuICAgICAgICAnXFxyXFxuXFxyXFxuJztcbiAgICBjb25zdCBwb3N0QmxvYlBhcnQgPSAnXFxyXFxuLS0nICsgYm91bmRhcnkgKyAnLS0nO1xuICAgIGNvbnN0IGJvZHkgPSBGYnNCbG9iLmdldEJsb2IocHJlQmxvYlBhcnQsIGJsb2IsIHBvc3RCbG9iUGFydCk7XG4gICAgaWYgKGJvZHkgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgY2Fubm90U2xpY2VCbG9iKCk7XG4gICAgfVxuICAgIGNvbnN0IHVybFBhcmFtcyA9IHsgbmFtZTogbWV0YWRhdGFfWydmdWxsUGF0aCddIH07XG4gICAgY29uc3QgdXJsID0gbWFrZVVybCh1cmxQYXJ0LCBzZXJ2aWNlLmhvc3QsIHNlcnZpY2UuX3Byb3RvY29sKTtcbiAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgY29uc3QgdGltZW91dCA9IHNlcnZpY2UubWF4VXBsb2FkUmV0cnlUaW1lO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBtZXRhZGF0YUhhbmRsZXIoc2VydmljZSwgbWFwcGluZ3MpLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby51cmxQYXJhbXMgPSB1cmxQYXJhbXM7XG4gICAgcmVxdWVzdEluZm8uaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgcmVxdWVzdEluZm8uYm9keSA9IGJvZHkudXBsb2FkRGF0YSgpO1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xufVxuLyoqXG4gKiBAcGFyYW0gY3VycmVudCBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgaGF2ZSBiZWVuIHVwbG9hZGVkIHNvIGZhci5cbiAqIEBwYXJhbSB0b3RhbCBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSB1cGxvYWQuXG4gKiBAcGFyYW0gb3B0X2ZpbmFsaXplZCBUcnVlIGlmIHRoZSBzZXJ2ZXIgaGFzIGZpbmlzaGVkIHRoZSB1cGxvYWQuXG4gKiBAcGFyYW0gb3B0X21ldGFkYXRhIFRoZSB1cGxvYWQgbWV0YWRhdGEsIHNob3VsZFxuICogICAgIG9ubHkgYmUgcGFzc2VkIGlmIG9wdF9maW5hbGl6ZWQgaXMgdHJ1ZS5cbiAqL1xuY2xhc3MgUmVzdW1hYmxlVXBsb2FkU3RhdHVzIHtcbiAgICBjb25zdHJ1Y3RvcihjdXJyZW50LCB0b3RhbCwgZmluYWxpemVkLCBtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIHRoaXMuZmluYWxpemVkID0gISFmaW5hbGl6ZWQ7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YSB8fCBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUmVzdW1lSGVhZGVyXyh4aHIsIGFsbG93ZWQpIHtcbiAgICBsZXQgc3RhdHVzID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBzdGF0dXMgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtR29vZy1VcGxvYWQtU3RhdHVzJyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZXJDaGVjayhmYWxzZSk7XG4gICAgfVxuICAgIGNvbnN0IGFsbG93ZWRTdGF0dXMgPSBhbGxvd2VkIHx8IFsnYWN0aXZlJ107XG4gICAgaGFuZGxlckNoZWNrKCEhc3RhdHVzICYmIGFsbG93ZWRTdGF0dXMuaW5kZXhPZihzdGF0dXMpICE9PSAtMSk7XG4gICAgcmV0dXJuIHN0YXR1cztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc3VtYWJsZVVwbG9hZChzZXJ2aWNlLCBsb2NhdGlvbiwgbWFwcGluZ3MsIGJsb2IsIG1ldGFkYXRhKSB7XG4gICAgY29uc3QgdXJsUGFydCA9IGxvY2F0aW9uLmJ1Y2tldE9ubHlTZXJ2ZXJVcmwoKTtcbiAgICBjb25zdCBtZXRhZGF0YUZvclVwbG9hZCA9IG1ldGFkYXRhRm9yVXBsb2FkXyhsb2NhdGlvbiwgYmxvYiwgbWV0YWRhdGEpO1xuICAgIGNvbnN0IHVybFBhcmFtcyA9IHsgbmFtZTogbWV0YWRhdGFGb3JVcGxvYWRbJ2Z1bGxQYXRoJ10gfTtcbiAgICBjb25zdCB1cmwgPSBtYWtlVXJsKHVybFBhcnQsIHNlcnZpY2UuaG9zdCwgc2VydmljZS5fcHJvdG9jb2wpO1xuICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAnWC1Hb29nLVVwbG9hZC1Qcm90b2NvbCc6ICdyZXN1bWFibGUnLFxuICAgICAgICAnWC1Hb29nLVVwbG9hZC1Db21tYW5kJzogJ3N0YXJ0JyxcbiAgICAgICAgJ1gtR29vZy1VcGxvYWQtSGVhZGVyLUNvbnRlbnQtTGVuZ3RoJzogYCR7YmxvYi5zaXplKCl9YCxcbiAgICAgICAgJ1gtR29vZy1VcGxvYWQtSGVhZGVyLUNvbnRlbnQtVHlwZSc6IG1ldGFkYXRhRm9yVXBsb2FkWydjb250ZW50VHlwZSddLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLTgnXG4gICAgfTtcbiAgICBjb25zdCBib2R5ID0gdG9SZXNvdXJjZVN0cmluZyhtZXRhZGF0YUZvclVwbG9hZCwgbWFwcGluZ3MpO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXJ2aWNlLm1heFVwbG9hZFJldHJ5VGltZTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhocikge1xuICAgICAgICBjaGVja1Jlc3VtZUhlYWRlcl8oeGhyKTtcbiAgICAgICAgbGV0IHVybDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVybCA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1Hb29nLVVwbG9hZC1VUkwnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlckNoZWNrKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyQ2hlY2soaXNTdHJpbmcodXJsKSk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBoYW5kbGVyLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby51cmxQYXJhbXMgPSB1cmxQYXJhbXM7XG4gICAgcmVxdWVzdEluZm8uaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgcmVxdWVzdEluZm8uYm9keSA9IGJvZHk7XG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gc2hhcmVkRXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XG59XG4vKipcbiAqIEBwYXJhbSB1cmwgRnJvbSBhIGNhbGwgdG8gZmJzLnJlcXVlc3RzLmNyZWF0ZVJlc3VtYWJsZVVwbG9hZC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVzdW1hYmxlVXBsb2FkU3RhdHVzKHNlcnZpY2UsIGxvY2F0aW9uLCB1cmwsIGJsb2IpIHtcbiAgICBjb25zdCBoZWFkZXJzID0geyAnWC1Hb29nLVVwbG9hZC1Db21tYW5kJzogJ3F1ZXJ5JyB9O1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoeGhyKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGNoZWNrUmVzdW1lSGVhZGVyXyh4aHIsIFsnYWN0aXZlJywgJ2ZpbmFsJ10pO1xuICAgICAgICBsZXQgc2l6ZVN0cmluZyA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzaXplU3RyaW5nID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdYLUdvb2ctVXBsb2FkLVNpemUtUmVjZWl2ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlckNoZWNrKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNpemVTdHJpbmcpIHtcbiAgICAgICAgICAgIC8vIG51bGwgb3IgZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBoYW5kbGVyQ2hlY2soZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpemUgPSBOdW1iZXIoc2l6ZVN0cmluZyk7XG4gICAgICAgIGhhbmRsZXJDaGVjayghaXNOYU4oc2l6ZSkpO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VtYWJsZVVwbG9hZFN0YXR1cyhzaXplLCBibG9iLnNpemUoKSwgc3RhdHVzID09PSAnZmluYWwnKTtcbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXJ2aWNlLm1heFVwbG9hZFJldHJ5VGltZTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgaGFuZGxlciwgdGltZW91dCk7XG4gICAgcmVxdWVzdEluZm8uaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gc2hhcmVkRXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XG59XG4vKipcbiAqIEFueSB1cGxvYWRzIHZpYSB0aGUgcmVzdW1hYmxlIHVwbG9hZCBBUEkgbXVzdCB0cmFuc2ZlciBhIG51bWJlciBvZiBieXRlc1xuICogdGhhdCBpcyBhIG11bHRpcGxlIG9mIHRoaXMgbnVtYmVyLlxuICovXG5jb25zdCBSRVNVTUFCTEVfVVBMT0FEX0NIVU5LX1NJWkUgPSAyNTYgKiAxMDI0O1xuLyoqXG4gKiBAcGFyYW0gdXJsIEZyb20gYSBjYWxsIHRvIGZicy5yZXF1ZXN0cy5jcmVhdGVSZXN1bWFibGVVcGxvYWQuXG4gKiBAcGFyYW0gY2h1bmtTaXplIE51bWJlciBvZiBieXRlcyB0byB1cGxvYWQuXG4gKiBAcGFyYW0gc3RhdHVzIFRoZSBwcmV2aW91cyBzdGF0dXMuXG4gKiAgICAgSWYgbm90IHBhc3NlZCBvciBudWxsLCB3ZSBzdGFydCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gKiBAdGhyb3dzIGZicy5FcnJvciBJZiB0aGUgdXBsb2FkIGlzIGFscmVhZHkgY29tcGxldGUsIHRoZSBwYXNzZWQgaW4gc3RhdHVzXG4gKiAgICAgaGFzIGEgZmluYWwgc2l6ZSBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgYmxvYiwgb3IgdGhlIGJsb2IgY2Fubm90IGJlIHNsaWNlZFxuICogICAgIGZvciB1cGxvYWQuXG4gKi9cbmZ1bmN0aW9uIGNvbnRpbnVlUmVzdW1hYmxlVXBsb2FkKGxvY2F0aW9uLCBzZXJ2aWNlLCB1cmwsIGJsb2IsIGNodW5rU2l6ZSwgbWFwcGluZ3MsIHN0YXR1cywgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgIC8vIFRPRE8oYW5keXNvdG8pOiBzdGFuZGFyZGl6ZSBvbiBpbnRlcm5hbCBhc3NlcnRzXG4gICAgLy8gYXNzZXJ0KCEob3B0X3N0YXR1cyAmJiBvcHRfc3RhdHVzLmZpbmFsaXplZCkpO1xuICAgIGNvbnN0IHN0YXR1c18gPSBuZXcgUmVzdW1hYmxlVXBsb2FkU3RhdHVzKDAsIDApO1xuICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgc3RhdHVzXy5jdXJyZW50ID0gc3RhdHVzLmN1cnJlbnQ7XG4gICAgICAgIHN0YXR1c18udG90YWwgPSBzdGF0dXMudG90YWw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdGF0dXNfLmN1cnJlbnQgPSAwO1xuICAgICAgICBzdGF0dXNfLnRvdGFsID0gYmxvYi5zaXplKCk7XG4gICAgfVxuICAgIGlmIChibG9iLnNpemUoKSAhPT0gc3RhdHVzXy50b3RhbCkge1xuICAgICAgICB0aHJvdyBzZXJ2ZXJGaWxlV3JvbmdTaXplKCk7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzTGVmdCA9IHN0YXR1c18udG90YWwgLSBzdGF0dXNfLmN1cnJlbnQ7XG4gICAgbGV0IGJ5dGVzVG9VcGxvYWQgPSBieXRlc0xlZnQ7XG4gICAgaWYgKGNodW5rU2l6ZSA+IDApIHtcbiAgICAgICAgYnl0ZXNUb1VwbG9hZCA9IE1hdGgubWluKGJ5dGVzVG9VcGxvYWQsIGNodW5rU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0Qnl0ZSA9IHN0YXR1c18uY3VycmVudDtcbiAgICBjb25zdCBlbmRCeXRlID0gc3RhcnRCeXRlICsgYnl0ZXNUb1VwbG9hZDtcbiAgICBsZXQgdXBsb2FkQ29tbWFuZCA9ICcnO1xuICAgIGlmIChieXRlc1RvVXBsb2FkID09PSAwKSB7XG4gICAgICAgIHVwbG9hZENvbW1hbmQgPSAnZmluYWxpemUnO1xuICAgIH1cbiAgICBlbHNlIGlmIChieXRlc0xlZnQgPT09IGJ5dGVzVG9VcGxvYWQpIHtcbiAgICAgICAgdXBsb2FkQ29tbWFuZCA9ICd1cGxvYWQsIGZpbmFsaXplJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVwbG9hZENvbW1hbmQgPSAndXBsb2FkJztcbiAgICB9XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6IHVwbG9hZENvbW1hbmQsXG4gICAgICAgICdYLUdvb2ctVXBsb2FkLU9mZnNldCc6IGAke3N0YXR1c18uY3VycmVudH1gXG4gICAgfTtcbiAgICBjb25zdCBib2R5ID0gYmxvYi5zbGljZShzdGFydEJ5dGUsIGVuZEJ5dGUpO1xuICAgIGlmIChib2R5ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IGNhbm5vdFNsaWNlQmxvYigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhociwgdGV4dCkge1xuICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTogVmVyaWZ5IHRoZSBNRDUgb2YgZWFjaCB1cGxvYWRlZCByYW5nZTpcbiAgICAgICAgLy8gdGhlICd4LXJhbmdlLW1kNScgaGVhZGVyIGNvbWVzIGJhY2sgd2l0aCBzdGF0dXMgY29kZSAzMDggcmVzcG9uc2VzLlxuICAgICAgICAvLyBXZSdsbCBvbmx5IGJlIGFibGUgdG8gYmFpbCBvdXQgdGhvdWdoLCBiZWNhdXNlIHlvdSBjYW4ndCByZS11cGxvYWQgYVxuICAgICAgICAvLyByYW5nZSB0aGF0IHlvdSBwcmV2aW91c2x5IHVwbG9hZGVkLlxuICAgICAgICBjb25zdCB1cGxvYWRTdGF0dXMgPSBjaGVja1Jlc3VtZUhlYWRlcl8oeGhyLCBbJ2FjdGl2ZScsICdmaW5hbCddKTtcbiAgICAgICAgY29uc3QgbmV3Q3VycmVudCA9IHN0YXR1c18uY3VycmVudCArIGJ5dGVzVG9VcGxvYWQ7XG4gICAgICAgIGNvbnN0IHNpemUgPSBibG9iLnNpemUoKTtcbiAgICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgICBpZiAodXBsb2FkU3RhdHVzID09PSAnZmluYWwnKSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IG1ldGFkYXRhSGFuZGxlcihzZXJ2aWNlLCBtYXBwaW5ncykoeGhyLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3VtYWJsZVVwbG9hZFN0YXR1cyhuZXdDdXJyZW50LCBzaXplLCB1cGxvYWRTdGF0dXMgPT09ICdmaW5hbCcsIG1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXJ2aWNlLm1heFVwbG9hZFJldHJ5VGltZTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgaGFuZGxlciwgdGltZW91dCk7XG4gICAgcmVxdWVzdEluZm8uaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgcmVxdWVzdEluZm8uYm9keSA9IGJvZHkudXBsb2FkRGF0YSgpO1xuICAgIHJlcXVlc3RJbmZvLnByb2dyZXNzQ2FsbGJhY2sgPSBwcm9ncmVzc0NhbGxiYWNrIHx8IG51bGw7XG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gc2hhcmVkRXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGV2ZW50IHRoYXQgaXMgdHJpZ2dlcmVkIG9uIGEgdGFzay5cbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBUYXNrRXZlbnQgPSB7XG4gICAgLyoqXG4gICAgICogRm9yIHRoaXMgZXZlbnQsXG4gICAgICogPHVsPlxuICAgICAqICAgPGxpPlRoZSBgbmV4dGAgZnVuY3Rpb24gaXMgdHJpZ2dlcmVkIG9uIHByb2dyZXNzIHVwZGF0ZXMgYW5kIHdoZW4gdGhlXG4gICAgICogICAgICAgdGFzayBpcyBwYXVzZWQvcmVzdW1lZCB3aXRoIGFuIGBVcGxvYWRUYXNrU25hcHNob3RgIGFzIHRoZSBmaXJzdFxuICAgICAqICAgICAgIGFyZ3VtZW50LjwvbGk+XG4gICAgICogICA8bGk+VGhlIGBlcnJvcmAgZnVuY3Rpb24gaXMgdHJpZ2dlcmVkIGlmIHRoZSB1cGxvYWQgaXMgY2FuY2VsZWQgb3IgZmFpbHNcbiAgICAgKiAgICAgICBmb3IgYW5vdGhlciByZWFzb24uPC9saT5cbiAgICAgKiAgIDxsaT5UaGUgYGNvbXBsZXRlYCBmdW5jdGlvbiBpcyB0cmlnZ2VyZWQgaWYgdGhlIHVwbG9hZCBjb21wbGV0ZXNcbiAgICAgKiAgICAgICBzdWNjZXNzZnVsbHkuPC9saT5cbiAgICAgKiA8L3VsPlxuICAgICAqL1xuICAgIFNUQVRFX0NIQU5HRUQ6ICdzdGF0ZV9jaGFuZ2VkJ1xufTtcbi8vIHR5cGUga2V5cyA9IGtleW9mIFRhc2tTdGF0ZVxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIGEgcnVubmluZyB1cGxvYWQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgVGFza1N0YXRlID0ge1xuICAgIC8qKiBUaGUgdGFzayBpcyBjdXJyZW50bHkgdHJhbnNmZXJyaW5nIGRhdGEuICovXG4gICAgUlVOTklORzogJ3J1bm5pbmcnLFxuICAgIC8qKiBUaGUgdGFzayB3YXMgcGF1c2VkIGJ5IHRoZSB1c2VyLiAqL1xuICAgIFBBVVNFRDogJ3BhdXNlZCcsXG4gICAgLyoqIFRoZSB0YXNrIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuICovXG4gICAgU1VDQ0VTUzogJ3N1Y2Nlc3MnLFxuICAgIC8qKiBUaGUgdGFzayB3YXMgY2FuY2VsZWQuICovXG4gICAgQ0FOQ0VMRUQ6ICdjYW5jZWxlZCcsXG4gICAgLyoqIFRoZSB0YXNrIGZhaWxlZCB3aXRoIGFuIGVycm9yLiAqL1xuICAgIEVSUk9SOiAnZXJyb3InXG59O1xuZnVuY3Rpb24gdGFza1N0YXRlRnJvbUludGVybmFsVGFza1N0YXRlKHN0YXRlKSB7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIFwicnVubmluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgKi86XG4gICAgICAgIGNhc2UgXCJwYXVzaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyAqLzpcbiAgICAgICAgY2FzZSBcImNhbmNlbGluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLkNBTkNFTElORyAqLzpcbiAgICAgICAgICAgIHJldHVybiBUYXNrU3RhdGUuUlVOTklORztcbiAgICAgICAgY2FzZSBcInBhdXNlZFwiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNFRCAqLzpcbiAgICAgICAgICAgIHJldHVybiBUYXNrU3RhdGUuUEFVU0VEO1xuICAgICAgICBjYXNlIFwic3VjY2Vzc1wiIC8qIEludGVybmFsVGFza1N0YXRlLlNVQ0NFU1MgKi86XG4gICAgICAgICAgICByZXR1cm4gVGFza1N0YXRlLlNVQ0NFU1M7XG4gICAgICAgIGNhc2UgXCJjYW5jZWxlZFwiIC8qIEludGVybmFsVGFza1N0YXRlLkNBTkNFTEVEICovOlxuICAgICAgICAgICAgcmV0dXJuIFRhc2tTdGF0ZS5DQU5DRUxFRDtcbiAgICAgICAgY2FzZSBcImVycm9yXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuRVJST1IgKi86XG4gICAgICAgICAgICByZXR1cm4gVGFza1N0YXRlLkVSUk9SO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IGFzc2VydChmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gVGFza1N0YXRlLkVSUk9SO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIGNvbnN0IGFzRnVuY3Rpb25zID0gaXNGdW5jdGlvbihuZXh0T3JPYnNlcnZlcikgfHwgZXJyb3IgIT0gbnVsbCB8fCBjb21wbGV0ZSAhPSBudWxsO1xuICAgICAgICBpZiAoYXNGdW5jdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG5leHRPck9ic2VydmVyO1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yICE9PSBudWxsICYmIGVycm9yICE9PSB2b2lkIDAgPyBlcnJvciA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUgPSBjb21wbGV0ZSAhPT0gbnVsbCAmJiBjb21wbGV0ZSAhPT0gdm9pZCAwID8gY29tcGxldGUgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5leHRPck9ic2VydmVyO1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gb2JzZXJ2ZXIubmV4dDtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBvYnNlcnZlci5lcnJvcjtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUgPSBvYnNlcnZlci5jb21wbGV0ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBmIHdpdGggaXRzIGFyZ3VtZW50cyBhc3luY2hyb25vdXNseSBhcyBhXG4gKiBtaWNyb3Rhc2ssIGkuZS4gYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBzY3JpcHQgcmV0dXJucyBiYWNrXG4gKiBpbnRvIGJyb3dzZXIgY29kZS5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmZ1bmN0aW9uIGFzeW5jKGYpIHtcbiAgICByZXR1cm4gKC4uLmFyZ3NUb0ZvcndhcmQpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGYoLi4uYXJnc1RvRm9yd2FyZCkpO1xuICAgIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogQW4gb3ZlcnJpZGUgZm9yIHRoZSB0ZXh0LWJhc2VkIENvbm5lY3Rpb24uIFVzZWQgaW4gdGVzdHMuICovXG5sZXQgdGV4dEZhY3RvcnlPdmVycmlkZSA9IG51bGw7XG4vKipcbiAqIE5ldHdvcmsgbGF5ZXIgdGhhdCB3b3JrcyBpbiBOb2RlLlxuICpcbiAqIFRoaXMgbmV0d29yayBpbXBsZW1lbnRhdGlvbiBzaG91bGQgbm90IGJlIHVzZWQgaW4gYnJvd3NlcnMgYXMgaXQgZG9lcyBub3RcbiAqIHN1cHBvcnQgcHJvZ3Jlc3MgdXBkYXRlcy5cbiAqL1xuY2xhc3MgRmV0Y2hDb25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lcnJvclRleHRfID0gJyc7XG4gICAgICAgIHRoaXMuc2VudF8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lcnJvckNvZGVfID0gRXJyb3JDb2RlLk5PX0VSUk9SO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKHVybCwgbWV0aG9kLCBib2R5LCBoZWFkZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbnRfKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnRlcm5hbEVycm9yKCdjYW5ub3QgLnNlbmQoKSBtb3JlIHRoYW4gb25jZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VudF8gPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyB8fCB7fSxcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc18gPSByZXNwb25zZS5oZWFkZXJzO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlXyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICAgICAgICAgIHRoaXMuZXJyb3JDb2RlXyA9IEVycm9yQ29kZS5OT19FUlJPUjtcbiAgICAgICAgICAgIHRoaXMuYm9keV8gPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yVGV4dF8gPSBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZTtcbiAgICAgICAgICAgIC8vIGVtdWxhdGUgWEhSIHdoaWNoIHNldHMgc3RhdHVzIHRvIDAgd2hlbiBlbmNvdW50ZXJpbmcgYSBuZXR3b3JrIGVycm9yXG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGVfID0gMDtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JDb2RlXyA9IEVycm9yQ29kZS5ORVRXT1JLX0VSUk9SO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEVycm9yQ29kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3JDb2RlXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnRlcm5hbEVycm9yKCdjYW5ub3QgLmdldEVycm9yQ29kZSgpIGJlZm9yZSByZWNlaXZpbmcgcmVzcG9uc2UnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNvZGVfO1xuICAgIH1cbiAgICBnZXRTdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1c0NvZGVfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IGludGVybmFsRXJyb3IoJ2Nhbm5vdCAuZ2V0U3RhdHVzKCkgYmVmb3JlIHJlY2VpdmluZyByZXNwb25zZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1c0NvZGVfO1xuICAgIH1cbiAgICBnZXRFcnJvclRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yVGV4dF87XG4gICAgfVxuICAgIGFib3J0KCkge1xuICAgICAgICAvLyBOb3Qgc3VwcG9ydGVkXG4gICAgfVxuICAgIGdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcikge1xuICAgICAgICBpZiAoIXRoaXMuaGVhZGVyc18pIHtcbiAgICAgICAgICAgIHRocm93IGludGVybmFsRXJyb3IoJ2Nhbm5vdCAuZ2V0UmVzcG9uc2VIZWFkZXIoKSBiZWZvcmUgcmVjZWl2aW5nIHJlc3BvbnNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc18uZ2V0KGhlYWRlcik7XG4gICAgfVxuICAgIGFkZFVwbG9hZFByb2dyZXNzTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgLy8gTm90IHN1cHBvcnRlZFxuICAgIH1cbiAgICByZW1vdmVVcGxvYWRQcm9ncmVzc0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIC8vIE5vdCBzdXBwb3J0ZWRcbiAgICB9XG59XG5jbGFzcyBGZXRjaFRleHRDb25uZWN0aW9uIGV4dGVuZHMgRmV0Y2hDb25uZWN0aW9uIHtcbiAgICBnZXRSZXNwb25zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJvZHlfKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnRlcm5hbEVycm9yKCdjYW5ub3QgLmdldFJlc3BvbnNlKCkgYmVmb3JlIHJlY2VpdmluZyByZXNwb25zZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLmJvZHlfKS50b1N0cmluZygndXRmLTgnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdUZXh0Q29ubmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGV4dEZhY3RvcnlPdmVycmlkZVxuICAgICAgICA/IHRleHRGYWN0b3J5T3ZlcnJpZGUoKVxuICAgICAgICA6IG5ldyBGZXRjaFRleHRDb25uZWN0aW9uKCk7XG59XG5jbGFzcyBGZXRjaEJ5dGVzQ29ubmVjdGlvbiBleHRlbmRzIEZldGNoQ29ubmVjdGlvbiB7XG4gICAgZ2V0UmVzcG9uc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5ib2R5Xykge1xuICAgICAgICAgICAgdGhyb3cgaW50ZXJuYWxFcnJvcignY2Fubm90IC5nZXRSZXNwb25zZSgpIGJlZm9yZSBzZW5kaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keV87XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3Qnl0ZXNDb25uZWN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRmV0Y2hCeXRlc0Nvbm5lY3Rpb24oKTtcbn1cbmNsYXNzIEZldGNoU3RyZWFtQ29ubmVjdGlvbiBleHRlbmRzIEZldGNoQ29ubmVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RyZWFtXyA9IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQodXJsLCBtZXRob2QsIGJvZHksIGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VudF8pIHtcbiAgICAgICAgICAgIHRocm93IGludGVybmFsRXJyb3IoJ2Nhbm5vdCAuc2VuZCgpIG1vcmUgdGhhbiBvbmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW50XyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzIHx8IHt9LFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzXyA9IHJlc3BvbnNlLmhlYWRlcnM7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGVfID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5lcnJvckNvZGVfID0gRXJyb3JDb2RlLk5PX0VSUk9SO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1fID0gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvclRleHRfID0gZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2U7XG4gICAgICAgICAgICAvLyBlbXVsYXRlIFhIUiB3aGljaCBzZXRzIHN0YXR1cyB0byAwIHdoZW4gZW5jb3VudGVyaW5nIGEgbmV0d29yayBlcnJvclxuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlXyA9IDA7XG4gICAgICAgICAgICB0aGlzLmVycm9yQ29kZV8gPSBFcnJvckNvZGUuTkVUV09SS19FUlJPUjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSZXNwb25zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0cmVhbV8pIHtcbiAgICAgICAgICAgIHRocm93IGludGVybmFsRXJyb3IoJ2Nhbm5vdCAuZ2V0UmVzcG9uc2UoKSBiZWZvcmUgc2VuZGluZycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbV87XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3U3RyZWFtQ29ubmVjdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IEZldGNoU3RyZWFtQ29ubmVjdGlvbigpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgYmxvYiBiZWluZyB1cGxvYWRlZC4gQ2FuIGJlIHVzZWQgdG8gcGF1c2UvcmVzdW1lL2NhbmNlbCB0aGVcbiAqIHVwbG9hZCBhbmQgbWFuYWdlIGNhbGxiYWNrcyBmb3IgdmFyaW91cyBldmVudHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgVXBsb2FkVGFzayB7XG4gICAgaXNFeHBvbmVudGlhbEJhY2tvZmZFeHBpcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbGVlcFRpbWUgPiB0aGlzLm1heFNsZWVwVGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHJlZiAtIFRoZSBmaXJlYmFzZVN0b3JhZ2UuUmVmZXJlbmNlIG9iamVjdCB0aGlzIHRhc2sgY2FtZVxuICAgICAqICAgICBmcm9tLCB1bnR5cGVkIHRvIGF2b2lkIGN5Y2xpYyBkZXBlbmRlbmNpZXMuXG4gICAgICogQHBhcmFtIGJsb2IgLSBUaGUgYmxvYiB0byB1cGxvYWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVmLCBibG9iLCBtZXRhZGF0YSA9IG51bGwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBvZiBieXRlcyB0cmFuc2ZlcnJlZCBzbyBmYXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90cmFuc2ZlcnJlZCA9IDA7XG4gICAgICAgIHRoaXMuX25lZWRUb0ZldGNoU3RhdHVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX25lZWRUb0ZldGNoTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzID0gW107XG4gICAgICAgIHRoaXMuX2Vycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl91cGxvYWRVcmwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2NodW5rTXVsdGlwbGllciA9IDE7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcmVmID0gcmVmO1xuICAgICAgICB0aGlzLl9ibG9iID0gYmxvYjtcbiAgICAgICAgdGhpcy5fbWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5fbWFwcGluZ3MgPSBnZXRNYXBwaW5ncygpO1xuICAgICAgICB0aGlzLl9yZXN1bWFibGUgPSB0aGlzLl9zaG91bGREb1Jlc3VtYWJsZSh0aGlzLl9ibG9iKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBcInJ1bm5pbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HICovO1xuICAgICAgICB0aGlzLl9lcnJvckhhbmRsZXIgPSBlcnJvciA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fY2h1bmtNdWx0aXBsaWVyID0gMTtcbiAgICAgICAgICAgIGlmIChlcnJvci5fY29kZUVxdWFscyhTdG9yYWdlRXJyb3JDb2RlLkNBTkNFTEVEKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRUb0ZldGNoU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlVHJhbnNpdGlvbnNfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYWNrb2ZmRXhwaXJlZCA9IHRoaXMuaXNFeHBvbmVudGlhbEJhY2tvZmZFeHBpcmVkKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmV0cnlTdGF0dXNDb2RlKGVycm9yLnN0YXR1cywgW10pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYWNrb2ZmRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSByZXRyeUxpbWl0RXhjZWVkZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2xlZXBUaW1lID0gTWF0aC5tYXgodGhpcy5zbGVlcFRpbWUgKiAyLCBERUZBVUxUX01JTl9TTEVFUF9USU1FX01JTExJUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZWVkVG9GZXRjaFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlVHJhbnNpdGlvbnNfKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwiZXJyb3JcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5FUlJPUiAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX21ldGFkYXRhRXJyb3JIYW5kbGVyID0gZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChlcnJvci5fY29kZUVxdWFscyhTdG9yYWdlRXJyb3JDb2RlLkNBTkNFTEVEKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcImVycm9yXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuRVJST1IgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNsZWVwVGltZSA9IDA7XG4gICAgICAgIHRoaXMubWF4U2xlZXBUaW1lID0gdGhpcy5fcmVmLnN0b3JhZ2UubWF4VXBsb2FkUmV0cnlUaW1lO1xuICAgICAgICB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICB0aGlzLl9zdGFydCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUHJldmVudCB1bmNhdWdodCByZWplY3Rpb25zIG9uIHRoZSBpbnRlcm5hbCBwcm9taXNlIGZyb20gYnViYmxpbmcgb3V0XG4gICAgICAgIC8vIHRvIHRoZSB0b3AgbGV2ZWwgd2l0aCBhIGR1bW15IGhhbmRsZXIuXG4gICAgICAgIHRoaXMuX3Byb21pc2UudGhlbihudWxsLCAoKSA9PiB7IH0pO1xuICAgIH1cbiAgICBfbWFrZVByb2dyZXNzQ2FsbGJhY2soKSB7XG4gICAgICAgIGNvbnN0IHNpemVCZWZvcmUgPSB0aGlzLl90cmFuc2ZlcnJlZDtcbiAgICAgICAgcmV0dXJuIGxvYWRlZCA9PiB0aGlzLl91cGRhdGVQcm9ncmVzcyhzaXplQmVmb3JlICsgbG9hZGVkKTtcbiAgICB9XG4gICAgX3Nob3VsZERvUmVzdW1hYmxlKGJsb2IpIHtcbiAgICAgICAgcmV0dXJuIGJsb2Iuc2l6ZSgpID4gMjU2ICogMTAyNDtcbiAgICB9XG4gICAgX3N0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IFwicnVubmluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgKi8pIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBzb21lb25lIHBhdXNlcyB1cyBpbiBhIHJlc3VtZSBjYWxsYmFjaywgZm9yIGV4YW1wbGUuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZXN1bWFibGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl91cGxvYWRVcmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJlc3VtYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX25lZWRUb0ZldGNoU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZldGNoU3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmVlZFRvRmV0Y2hNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFwcGVucyBpZiB3ZSBtaXNzIHRoZSBtZXRhZGF0YSBvbiB1cGxvYWQgY29tcGxldGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZldGNoTWV0YWRhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRpbnVlVXBsb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnNsZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vbmVTaG90VXBsb2FkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Jlc29sdmVUb2tlbihjYWxsYmFjaykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuX3JlZi5zdG9yYWdlLl9nZXRBdXRoVG9rZW4oKSxcbiAgICAgICAgICAgIHRoaXMuX3JlZi5zdG9yYWdlLl9nZXRBcHBDaGVja1Rva2VuKClcbiAgICAgICAgXSkudGhlbigoW2F1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbl0pID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicnVubmluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgKi86XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcgKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJjYW5jZWxlZFwiIC8qIEludGVybmFsVGFza1N0YXRlLkNBTkNFTEVEICovKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInBhdXNpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwicGF1c2VkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEICovKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUT0RPKGFuZHlzb3RvKTogYXNzZXJ0IGZhbHNlXG4gICAgX2NyZWF0ZVJlc3VtYWJsZSgpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVRva2VuKChhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gY3JlYXRlUmVzdW1hYmxlVXBsb2FkKHRoaXMuX3JlZi5zdG9yYWdlLCB0aGlzLl9yZWYuX2xvY2F0aW9uLCB0aGlzLl9tYXBwaW5ncywgdGhpcy5fYmxvYiwgdGhpcy5fbWV0YWRhdGEpO1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlUmVxdWVzdCA9IHRoaXMuX3JlZi5zdG9yYWdlLl9tYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24sIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdDtcbiAgICAgICAgICAgIGNyZWF0ZVJlcXVlc3QuZ2V0UHJvbWlzZSgpLnRoZW4oKHVybCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkVXJsID0gdXJsO1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRUb0ZldGNoU3RhdHVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVRyYW5zaXRpb25zXygpO1xuICAgICAgICAgICAgfSwgdGhpcy5fZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9mZXRjaFN0YXR1cygpIHtcbiAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IGFzc2VydCh0aGlzLnVwbG9hZFVybF8gIT09IG51bGwpO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLl91cGxvYWRVcmw7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVUb2tlbigoYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SW5mbyA9IGdldFJlc3VtYWJsZVVwbG9hZFN0YXR1cyh0aGlzLl9yZWYuc3RvcmFnZSwgdGhpcy5fcmVmLl9sb2NhdGlvbiwgdXJsLCB0aGlzLl9ibG9iKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c1JlcXVlc3QgPSB0aGlzLl9yZWYuc3RvcmFnZS5fbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHN0YXR1c1JlcXVlc3Q7XG4gICAgICAgICAgICBzdGF0dXNSZXF1ZXN0LmdldFByb21pc2UoKS50aGVuKHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJvZ3Jlc3Moc3RhdHVzLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRUb0ZldGNoU3RhdHVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmVlZFRvRmV0Y2hNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcbiAgICAgICAgICAgIH0sIHRoaXMuX2Vycm9ySGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfY29udGludWVVcGxvYWQoKSB7XG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IFJFU1VNQUJMRV9VUExPQURfQ0hVTktfU0laRSAqIHRoaXMuX2NodW5rTXVsdGlwbGllcjtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFJlc3VtYWJsZVVwbG9hZFN0YXR1cyh0aGlzLl90cmFuc2ZlcnJlZCwgdGhpcy5fYmxvYi5zaXplKCkpO1xuICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTogYXNzZXJ0KHRoaXMudXBsb2FkVXJsXyAhPT0gbnVsbCk7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuX3VwbG9hZFVybDtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVRva2VuKChhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pID0+IHtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0SW5mbztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEluZm8gPSBjb250aW51ZVJlc3VtYWJsZVVwbG9hZCh0aGlzLl9yZWYuX2xvY2F0aW9uLCB0aGlzLl9yZWYuc3RvcmFnZSwgdXJsLCB0aGlzLl9ibG9iLCBjaHVua1NpemUsIHRoaXMuX21hcHBpbmdzLCBzdGF0dXMsIHRoaXMuX21ha2VQcm9ncmVzc0NhbGxiYWNrKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcImVycm9yXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuRVJST1IgKi8pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVwbG9hZFJlcXVlc3QgPSB0aGlzLl9yZWYuc3RvcmFnZS5fbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIFxuICAgICAgICAgICAgLypyZXRyeT0qLyBmYWxzZSAvLyBVcGxvYWQgcmVxdWVzdHMgc2hvdWxkIG5vdCBiZSByZXRyaWVkIGFzIGVhY2ggcmV0cnkgc2hvdWxkIGJlIHByZWNlZGVkIGJ5IGFub3RoZXIgcXVlcnkgcmVxdWVzdC4gV2hpY2ggaXMgaGFuZGxlZCBpbiB0aGlzIGZpbGUuXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHVwbG9hZFJlcXVlc3Q7XG4gICAgICAgICAgICB1cGxvYWRSZXF1ZXN0LmdldFByb21pc2UoKS50aGVuKChuZXdTdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmNyZWFzZU11bHRpcGxpZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVByb2dyZXNzKG5ld1N0YXR1cy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdHVzLmZpbmFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXRhZGF0YSA9IG5ld1N0YXR1cy5tZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcInN1Y2Nlc3NcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5TVUNDRVNTICovKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzLl9lcnJvckhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2luY3JlYXNlTXVsdGlwbGllcigpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFNpemUgPSBSRVNVTUFCTEVfVVBMT0FEX0NIVU5LX1NJWkUgKiB0aGlzLl9jaHVua011bHRpcGxpZXI7XG4gICAgICAgIC8vIE1heCBjaHVuayBzaXplIGlzIDMyTS5cbiAgICAgICAgaWYgKGN1cnJlbnRTaXplICogMiA8IDMyICogMTAyNCAqIDEwMjQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rTXVsdGlwbGllciAqPSAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9mZXRjaE1ldGFkYXRhKCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlVG9rZW4oKGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEluZm8gPSBnZXRNZXRhZGF0YSQyKHRoaXMuX3JlZi5zdG9yYWdlLCB0aGlzLl9yZWYuX2xvY2F0aW9uLCB0aGlzLl9tYXBwaW5ncyk7XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YVJlcXVlc3QgPSB0aGlzLl9yZWYuc3RvcmFnZS5fbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IG1ldGFkYXRhUmVxdWVzdDtcbiAgICAgICAgICAgIG1ldGFkYXRhUmVxdWVzdC5nZXRQcm9taXNlKCkudGhlbihtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJzdWNjZXNzXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuU1VDQ0VTUyAqLyk7XG4gICAgICAgICAgICB9LCB0aGlzLl9tZXRhZGF0YUVycm9ySGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfb25lU2hvdFVwbG9hZCgpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVRva2VuKChhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbXVsdGlwYXJ0VXBsb2FkKHRoaXMuX3JlZi5zdG9yYWdlLCB0aGlzLl9yZWYuX2xvY2F0aW9uLCB0aGlzLl9tYXBwaW5ncywgdGhpcy5fYmxvYiwgdGhpcy5fbWV0YWRhdGEpO1xuICAgICAgICAgICAgY29uc3QgbXVsdGlwYXJ0UmVxdWVzdCA9IHRoaXMuX3JlZi5zdG9yYWdlLl9tYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24sIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gbXVsdGlwYXJ0UmVxdWVzdDtcbiAgICAgICAgICAgIG11bHRpcGFydFJlcXVlc3QuZ2V0UHJvbWlzZSgpLnRoZW4obWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQcm9ncmVzcyh0aGlzLl9ibG9iLnNpemUoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcInN1Y2Nlc3NcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5TVUNDRVNTICovKTtcbiAgICAgICAgICAgIH0sIHRoaXMuX2Vycm9ySGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfdXBkYXRlUHJvZ3Jlc3ModHJhbnNmZXJyZWQpIHtcbiAgICAgICAgY29uc3Qgb2xkID0gdGhpcy5fdHJhbnNmZXJyZWQ7XG4gICAgICAgIHRoaXMuX3RyYW5zZmVycmVkID0gdHJhbnNmZXJyZWQ7XG4gICAgICAgIC8vIEEgcHJvZ3Jlc3MgdXBkYXRlIGNhbiBtYWtlIHRoZSBcInRyYW5zZmVycmVkXCIgdmFsdWUgc21hbGxlciAoZS5nLiBhXG4gICAgICAgIC8vIHBhcnRpYWwgdXBsb2FkIG5vdCBjb21wbGV0ZWQgYnkgc2VydmVyLCBhZnRlciB3aGljaCB0aGUgXCJ0cmFuc2ZlcnJlZFwiXG4gICAgICAgIC8vIHZhbHVlIG1heSByZXNldCB0byB0aGUgdmFsdWUgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVxdWVzdCkuXG4gICAgICAgIGlmICh0aGlzLl90cmFuc2ZlcnJlZCAhPT0gb2xkKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfdHJhbnNpdGlvbihzdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBcImNhbmNlbGluZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLkNBTkNFTElORyAqLzpcbiAgICAgICAgICAgIGNhc2UgXCJwYXVzaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyAqLzpcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTpcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgfHxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgdGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlbmRpbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBlbmRpbmdUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVRyYW5zaXRpb25zXygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLzpcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTpcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlBBVVNFRCB8fFxuICAgICAgICAgICAgICAgIC8vICAgICAgICB0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FzUGF1c2VkID0gdGhpcy5fc3RhdGUgPT09IFwicGF1c2VkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEICovO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHdhc1BhdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicGF1c2VkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEICovOlxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOlxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcnMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxlZFwiIC8qIEludGVybmFsVGFza1N0YXRlLkNBTkNFTEVEICovOlxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOlxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gY2FuY2VsZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMuX25vdGlmeU9ic2VydmVycygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuRVJST1IgKi86XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5T2JzZXJ2ZXJzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiIC8qIEludGVybmFsVGFza1N0YXRlLlNVQ0NFU1MgKi86XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5T2JzZXJ2ZXJzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcGxldGVUcmFuc2l0aW9uc18oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJwYXVzaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyAqLzpcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwicGF1c2VkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEICovKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkcgKi86XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbihcImNhbmNlbGVkXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMRUQgKi8pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJ1bm5pbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HICovOlxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzbmFwc2hvdCBvZiB0aGUgY3VycmVudCB0YXNrIHN0YXRlLlxuICAgICAqL1xuICAgIGdldCBzbmFwc2hvdCgpIHtcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxTdGF0ZSA9IHRhc2tTdGF0ZUZyb21JbnRlcm5hbFRhc2tTdGF0ZSh0aGlzLl9zdGF0ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBieXRlc1RyYW5zZmVycmVkOiB0aGlzLl90cmFuc2ZlcnJlZCxcbiAgICAgICAgICAgIHRvdGFsQnl0ZXM6IHRoaXMuX2Jsb2Iuc2l6ZSgpLFxuICAgICAgICAgICAgc3RhdGU6IGV4dGVybmFsU3RhdGUsXG4gICAgICAgICAgICBtZXRhZGF0YTogdGhpcy5fbWV0YWRhdGEsXG4gICAgICAgICAgICB0YXNrOiB0aGlzLFxuICAgICAgICAgICAgcmVmOiB0aGlzLl9yZWZcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNhbGxiYWNrIGZvciBhbiBldmVudC5cbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIGV2ZW50IHRvIGxpc3RlbiBmb3IuXG4gICAgICogQHBhcmFtIG5leHRPck9ic2VydmVyIC1cbiAgICAgKiAgICAgVGhlIGBuZXh0YCBmdW5jdGlvbiwgd2hpY2ggZ2V0cyBjYWxsZWQgZm9yIGVhY2ggaXRlbSBpblxuICAgICAqICAgICB0aGUgZXZlbnQgc3RyZWFtLCBvciBhbiBvYnNlcnZlciBvYmplY3Qgd2l0aCBzb21lIG9yIGFsbCBvZiB0aGVzZSB0aHJlZVxuICAgICAqICAgICBwcm9wZXJ0aWVzIChgbmV4dGAsIGBlcnJvcmAsIGBjb21wbGV0ZWApLlxuICAgICAqIEBwYXJhbSBlcnJvciAtIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCB3aXRoIGEgYFN0b3JhZ2VFcnJvcmBcbiAgICAgKiAgICAgaWYgdGhlIGV2ZW50IHN0cmVhbSBlbmRzIGR1ZSB0byBhbiBlcnJvci5cbiAgICAgKiBAcGFyYW0gY29tcGxldGVkIC0gQSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGlmIHRoZVxuICAgICAqICAgICBldmVudCBzdHJlYW0gZW5kcyBub3JtYWxseS5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqICAgICBJZiBvbmx5IHRoZSBldmVudCBhcmd1bWVudCBpcyBwYXNzZWQsIHJldHVybnMgYSBmdW5jdGlvbiB5b3UgY2FuIHVzZSB0b1xuICAgICAqICAgICBhZGQgY2FsbGJhY2tzIChzZWUgdGhlIGV4YW1wbGVzIGFib3ZlKS4gSWYgbW9yZSB0aGFuIGp1c3QgdGhlIGV2ZW50XG4gICAgICogICAgIGFyZ3VtZW50IGlzIHBhc3NlZCwgcmV0dXJucyBhIGZ1bmN0aW9uIHlvdSBjYW4gY2FsbCB0byB1bnJlZ2lzdGVyIHRoZVxuICAgICAqICAgICBjYWxsYmFja3MuXG4gICAgICovXG4gICAgb24odHlwZSwgbmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpIHtcbiAgICAgICAgLy8gTm90ZTogYHR5cGVgIGlzbid0IGJlaW5nIHVzZWQuIEl0cyB0eXBlIGlzIGFsc28gaW5jb3JyZWN0LiBUYXNrRXZlbnQgc2hvdWxkIG5vdCBiZSBhIHN0cmluZy5cbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXIobmV4dE9yT2JzZXJ2ZXIgfHwgdW5kZWZpbmVkLCBlcnJvciB8fCB1bmRlZmluZWQsIGNvbXBsZXRlZCB8fCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLl9hZGRPYnNlcnZlcihvYnNlcnZlcik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVPYnNlcnZlcihvYnNlcnZlcik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgb2JqZWN0IGJlaGF2ZXMgbGlrZSBhIFByb21pc2UsIGFuZCByZXNvbHZlcyB3aXRoIGl0cyBzbmFwc2hvdCBkYXRhXG4gICAgICogd2hlbiB0aGUgdXBsb2FkIGNvbXBsZXRlcy5cbiAgICAgKiBAcGFyYW0gb25GdWxmaWxsZWQgLSBUaGUgZnVsZmlsbG1lbnQgY2FsbGJhY2suIFByb21pc2UgY2hhaW5pbmcgd29ya3MgYXMgbm9ybWFsLlxuICAgICAqIEBwYXJhbSBvblJlamVjdGVkIC0gVGhlIHJlamVjdGlvbiBjYWxsYmFjay5cbiAgICAgKi9cbiAgICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIC8vIFRoZXNlIGNhc3RzIGFyZSBuZWVkZWQgc28gdGhhdCBUeXBlU2NyaXB0IGNhbiBpbmZlciB0aGUgdHlwZXMgb2YgdGhlXG4gICAgICAgIC8vIHJlc3VsdGluZyBQcm9taXNlLlxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBjYWxsaW5nIGB0aGVuKG51bGwsIG9uUmVqZWN0ZWQpYC5cbiAgICAgKi9cbiAgICBjYXRjaChvblJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIG9ic2VydmVyLlxuICAgICAqL1xuICAgIF9hZGRPYnNlcnZlcihvYnNlcnZlcikge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHRoaXMuX25vdGlmeU9ic2VydmVyKG9ic2VydmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gb2JzZXJ2ZXIuXG4gICAgICovXG4gICAgX3JlbW92ZU9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLl9vYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcik7XG4gICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfbm90aWZ5T2JzZXJ2ZXJzKCkge1xuICAgICAgICB0aGlzLl9maW5pc2hQcm9taXNlKCk7XG4gICAgICAgIGNvbnN0IG9ic2VydmVycyA9IHRoaXMuX29ic2VydmVycy5zbGljZSgpO1xuICAgICAgICBvYnNlcnZlcnMuZm9yRWFjaChvYnNlcnZlciA9PiB7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlcihvYnNlcnZlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZmluaXNoUHJvbWlzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhc2tTdGF0ZUZyb21JbnRlcm5hbFRhc2tTdGF0ZSh0aGlzLl9zdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5TVUNDRVNTOlxuICAgICAgICAgICAgICAgICAgICBhc3luYyh0aGlzLl9yZXNvbHZlLmJpbmQobnVsbCwgdGhpcy5zbmFwc2hvdCkpKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVGFza1N0YXRlLkNBTkNFTEVEOlxuICAgICAgICAgICAgICAgIGNhc2UgVGFza1N0YXRlLkVSUk9SOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b0NhbGwgPSB0aGlzLl9yZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jKHRvQ2FsbC5iaW5kKG51bGwsIHRoaXMuX2Vycm9yKSkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyaWdnZXJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9ub3RpZnlPYnNlcnZlcihvYnNlcnZlcikge1xuICAgICAgICBjb25zdCBleHRlcm5hbFN0YXRlID0gdGFza1N0YXRlRnJvbUludGVybmFsVGFza1N0YXRlKHRoaXMuX3N0YXRlKTtcbiAgICAgICAgc3dpdGNoIChleHRlcm5hbFN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5SVU5OSU5HOlxuICAgICAgICAgICAgY2FzZSBUYXNrU3RhdGUuUEFVU0VEOlxuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jKG9ic2VydmVyLm5leHQuYmluZChvYnNlcnZlciwgdGhpcy5zbmFwc2hvdCkpKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUYXNrU3RhdGUuU1VDQ0VTUzpcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMob2JzZXJ2ZXIuY29tcGxldGUuYmluZChvYnNlcnZlcikpKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUYXNrU3RhdGUuQ0FOQ0VMRUQ6XG4gICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5FUlJPUjpcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMob2JzZXJ2ZXIuZXJyb3IuYmluZChvYnNlcnZlciwgdGhpcy5fZXJyb3IpKSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IGFzc2VydChmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKG9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jKG9ic2VydmVyLmVycm9yLmJpbmQob2JzZXJ2ZXIsIHRoaXMuX2Vycm9yKSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdW1lcyBhIHBhdXNlZCB0YXNrLiBIYXMgbm8gZWZmZWN0IG9uIGEgY3VycmVudGx5IHJ1bm5pbmcgb3IgZmFpbGVkIHRhc2suXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb3BlcmF0aW9uIHRvb2sgZWZmZWN0LCBmYWxzZSBpZiBpZ25vcmVkLlxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLl9zdGF0ZSA9PT0gXCJwYXVzZWRcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgKi8gfHxcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID09PSBcInBhdXNpbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HICovO1xuICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24oXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgYSBjdXJyZW50bHkgcnVubmluZyB0YXNrLiBIYXMgbm8gZWZmZWN0IG9uIGEgcGF1c2VkIG9yIGZhaWxlZCB0YXNrLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG9wZXJhdGlvbiB0b29rIGVmZmVjdCwgZmFsc2UgaWYgaWdub3JlZC5cbiAgICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLl9zdGF0ZSA9PT0gXCJydW5uaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyAqLztcbiAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwicGF1c2luZ1wiIC8qIEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhIGN1cnJlbnRseSBydW5uaW5nIG9yIHBhdXNlZCB0YXNrLiBIYXMgbm8gZWZmZWN0IG9uIGEgY29tcGxldGUgb3JcbiAgICAgKiBmYWlsZWQgdGFzay5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBvcGVyYXRpb24gdG9vayBlZmZlY3QsIGZhbHNlIGlmIGlnbm9yZWQuXG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMuX3N0YXRlID09PSBcInJ1bm5pbmdcIiAvKiBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HICovIHx8XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9PT0gXCJwYXVzaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyAqLztcbiAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uKFwiY2FuY2VsaW5nXCIgLyogSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMSU5HICovKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlcyBtZXRob2RzIHRvIGludGVyYWN0IHdpdGggYSBidWNrZXQgaW4gdGhlIEZpcmViYXNlIFN0b3JhZ2Ugc2VydmljZS5cbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIF9sb2NhdGlvbiAtIEFuIGZicy5sb2NhdGlvbiwgb3IgdGhlIFVSTCBhdFxuICogICAgIHdoaWNoIHRvIGJhc2UgdGhpcyBvYmplY3QsIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1zOlxuICogICAgICAgICBnczovLzxidWNrZXQ+LzxvYmplY3QtcGF0aD5cbiAqICAgICAgICAgaHR0cFtzXTovL2ZpcmViYXNlc3RvcmFnZS5nb29nbGVhcGlzLmNvbS9cbiAqICAgICAgICAgICAgICAgICAgICAgPGFwaS12ZXJzaW9uPi9iLzxidWNrZXQ+L28vPG9iamVjdC1wYXRoPlxuICogICAgIEFueSBxdWVyeSBvciBmcmFnbWVudCBzdHJpbmdzIHdpbGwgYmUgaWdub3JlZCBpbiB0aGUgaHR0cFtzXVxuICogICAgIGZvcm1hdC4gSWYgbm8gdmFsdWUgaXMgcGFzc2VkLCB0aGUgc3RvcmFnZSBvYmplY3Qgd2lsbCB1c2UgYSBVUkwgYmFzZWQgb25cbiAqICAgICB0aGUgcHJvamVjdCBJRCBvZiB0aGUgYmFzZSBmaXJlYmFzZS5BcHAgaW5zdGFuY2UuXG4gKi9cbmNsYXNzIFJlZmVyZW5jZSB7XG4gICAgY29uc3RydWN0b3IoX3NlcnZpY2UsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuX3NlcnZpY2UgPSBfc2VydmljZTtcbiAgICAgICAgaWYgKGxvY2F0aW9uIGluc3RhbmNlb2YgTG9jYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IExvY2F0aW9uLm1ha2VGcm9tVXJsKGxvY2F0aW9uLCBfc2VydmljZS5ob3N0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBVUkwgZm9yIHRoZSBidWNrZXQgYW5kIHBhdGggdGhpcyBvYmplY3QgcmVmZXJlbmNlcyxcbiAgICAgKiAgICAgaW4gdGhlIGZvcm0gZ3M6Ly88YnVja2V0Pi88b2JqZWN0LXBhdGg+XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnZ3M6Ly8nICsgdGhpcy5fbG9jYXRpb24uYnVja2V0ICsgJy8nICsgdGhpcy5fbG9jYXRpb24ucGF0aDtcbiAgICB9XG4gICAgX25ld1JlZihzZXJ2aWNlLCBsb2NhdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFJlZmVyZW5jZShzZXJ2aWNlLCBsb2NhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSByb290IG9mIHRoaXMgb2JqZWN0J3MgYnVja2V0LlxuICAgICAqL1xuICAgIGdldCByb290KCkge1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG5ldyBMb2NhdGlvbih0aGlzLl9sb2NhdGlvbi5idWNrZXQsICcnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld1JlZih0aGlzLl9zZXJ2aWNlLCBsb2NhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBidWNrZXQgY29udGFpbmluZyB0aGlzIHJlZmVyZW5jZSdzIG9iamVjdC5cbiAgICAgKi9cbiAgICBnZXQgYnVja2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb24uYnVja2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZnVsbCBwYXRoIG9mIHRoaXMgb2JqZWN0LlxuICAgICAqL1xuICAgIGdldCBmdWxsUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLnBhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzaG9ydCBuYW1lIG9mIHRoaXMgb2JqZWN0LCB3aGljaCBpcyB0aGUgbGFzdCBjb21wb25lbnQgb2YgdGhlIGZ1bGwgcGF0aC5cbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgZnVsbFBhdGggaXMgJ2Z1bGwvcGF0aC9pbWFnZS5wbmcnLCBuYW1lIGlzICdpbWFnZS5wbmcnLlxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gbGFzdENvbXBvbmVudCh0aGlzLl9sb2NhdGlvbi5wYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGBTdG9yYWdlU2VydmljZWAgaW5zdGFuY2UgdGhpcyBgU3RvcmFnZVJlZmVyZW5jZWAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgICAqL1xuICAgIGdldCBzdG9yYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VydmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBgU3RvcmFnZVJlZmVyZW5jZWAgcG9pbnRpbmcgdG8gdGhlIHBhcmVudCBsb2NhdGlvbiBvZiB0aGlzIGBTdG9yYWdlUmVmZXJlbmNlYCwgb3IgbnVsbCBpZlxuICAgICAqIHRoaXMgcmVmZXJlbmNlIGlzIHRoZSByb290LlxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIGNvbnN0IG5ld1BhdGggPSBwYXJlbnQodGhpcy5fbG9jYXRpb24ucGF0aCk7XG4gICAgICAgIGlmIChuZXdQYXRoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG5ldyBMb2NhdGlvbih0aGlzLl9sb2NhdGlvbi5idWNrZXQsIG5ld1BhdGgpO1xuICAgICAgICByZXR1cm4gbmV3IFJlZmVyZW5jZSh0aGlzLl9zZXJ2aWNlLCBsb2NhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gdGhyb3cgYW4gZXJyb3IgaW4gbWV0aG9kcyB0aGF0IGRvIG5vdCBhY2NlcHQgYSByb290IHJlZmVyZW5jZS5cbiAgICAgKi9cbiAgICBfdGhyb3dJZlJvb3QobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5fbG9jYXRpb24ucGF0aCA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IGludmFsaWRSb290T3BlcmF0aW9uKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBEb3dubG9hZCB0aGUgYnl0ZXMgYXQgdGhlIG9iamVjdCdzIGxvY2F0aW9uLlxuICogQHJldHVybnMgQSBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIGRvd25sb2FkZWQgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldEJ5dGVzSW50ZXJuYWwocmVmLCBtYXhEb3dubG9hZFNpemVCeXRlcykge1xuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ2dldEJ5dGVzJyk7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBnZXRCeXRlcyQxKHJlZi5zdG9yYWdlLCByZWYuX2xvY2F0aW9uLCBtYXhEb3dubG9hZFNpemVCeXRlcyk7XG4gICAgcmV0dXJuIHJlZi5zdG9yYWdlXG4gICAgICAgIC5tYWtlUmVxdWVzdFdpdGhUb2tlbnMocmVxdWVzdEluZm8sIG5ld0J5dGVzQ29ubmVjdGlvbilcbiAgICAgICAgLnRoZW4oYnl0ZXMgPT4gbWF4RG93bmxvYWRTaXplQnl0ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IC8vIEdDUyBtYXkgbm90IGhvbm9yIHRoZSBSYW5nZSBoZWFkZXIgZm9yIHNtYWxsIGZpbGVzXG4gICAgICAgICAgICBieXRlcy5zbGljZSgwLCBtYXhEb3dubG9hZFNpemVCeXRlcylcbiAgICAgICAgOiBieXRlcyk7XG59XG4vKiogU3RyZWFtIHRoZSBieXRlcyBhdCB0aGUgb2JqZWN0J3MgbG9jYXRpb24uICovXG5mdW5jdGlvbiBnZXRTdHJlYW1JbnRlcm5hbChyZWYsIG1heERvd25sb2FkU2l6ZUJ5dGVzKSB7XG4gICAgcmVmLl90aHJvd0lmUm9vdCgnZ2V0U3RyZWFtJyk7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBnZXRCeXRlcyQxKHJlZi5zdG9yYWdlLCByZWYuX2xvY2F0aW9uLCBtYXhEb3dubG9hZFNpemVCeXRlcyk7XG4gICAgLy8gVHJhbnNmb3JtcyB0aGUgc3RyZWFtIHNvIHRoYXQgb25seSBgbWF4RG93bmxvYWRTaXplQnl0ZXNgIGJ5dGVzIGFyZSBwaXBlZCB0byB0aGUgcmVzdWx0XG4gICAgY29uc3QgbmV3TWF4U2l6ZVRyYW5zZm9ybSA9IChuKSA9PiB7XG4gICAgICAgIGxldCBtaXNzaW5nQnl0ZXMgPSBuO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gR0NTIG1heSBub3QgaG9ub3IgdGhlIFJhbmdlIGhlYWRlciBmb3Igc21hbGwgZmlsZXNcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmsubGVuZ3RoIDwgbWlzc2luZ0J5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmdCeXRlcyAtPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsuc2xpY2UoMCwgbWlzc2luZ0J5dGVzKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0gbWF4RG93bmxvYWRTaXplQnl0ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG5ldyBUcmFuc2Zvcm1TdHJlYW0obmV3TWF4U2l6ZVRyYW5zZm9ybShtYXhEb3dubG9hZFNpemVCeXRlcykpXG4gICAgICAgIDogbmV3IFRyYW5zZm9ybVN0cmVhbSgpOyAvLyBUaGUgZGVmYXVsdCB0cmFuc2Zvcm1lciBmb3J3YXJkcyBhbGwgY2h1bmtzIHRvIGl0cyByZWFkYWJsZSBzaWRlXG4gICAgcmVmLnN0b3JhZ2VcbiAgICAgICAgLm1ha2VSZXF1ZXN0V2l0aFRva2VucyhyZXF1ZXN0SW5mbywgbmV3U3RyZWFtQ29ubmVjdGlvbilcbiAgICAgICAgLnRoZW4ocmVhZGFibGVTdHJlYW0gPT4gcmVhZGFibGVTdHJlYW0ucGlwZVRocm91Z2gocmVzdWx0KSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiByZXN1bHQud3JpdGFibGUuYWJvcnQoZXJyKSk7XG4gICAgcmV0dXJuIHJlc3VsdC5yZWFkYWJsZTtcbn1cbi8qKlxuICogVXBsb2FkcyBkYXRhIHRvIHRoaXMgb2JqZWN0J3MgbG9jYXRpb24uXG4gKiBUaGUgdXBsb2FkIGlzIG5vdCByZXN1bWFibGUuXG4gKlxuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2Ugd2hlcmUgZGF0YSBzaG91bGQgYmUgdXBsb2FkZWQuXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVwbG9hZC5cbiAqIEBwYXJhbSBtZXRhZGF0YSAtIE1ldGFkYXRhIGZvciB0aGUgbmV3bHkgdXBsb2FkZWQgZGF0YS5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSBjb250YWluaW5nIGFuIFVwbG9hZFJlc3VsdFxuICovXG5mdW5jdGlvbiB1cGxvYWRCeXRlcyQxKHJlZiwgZGF0YSwgbWV0YWRhdGEpIHtcbiAgICByZWYuX3Rocm93SWZSb290KCd1cGxvYWRCeXRlcycpO1xuICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gbXVsdGlwYXJ0VXBsb2FkKHJlZi5zdG9yYWdlLCByZWYuX2xvY2F0aW9uLCBnZXRNYXBwaW5ncygpLCBuZXcgRmJzQmxvYihkYXRhLCB0cnVlKSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiByZWYuc3RvcmFnZVxuICAgICAgICAubWFrZVJlcXVlc3RXaXRoVG9rZW5zKHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbilcbiAgICAgICAgLnRoZW4oZmluYWxNZXRhZGF0YSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXRhZGF0YTogZmluYWxNZXRhZGF0YSxcbiAgICAgICAgICAgIHJlZlxuICAgICAgICB9O1xuICAgIH0pO1xufVxuLyoqXG4gKiBVcGxvYWRzIGRhdGEgdG8gdGhpcyBvYmplY3QncyBsb2NhdGlvbi5cbiAqIFRoZSB1cGxvYWQgY2FuIGJlIHBhdXNlZCBhbmQgcmVzdW1lZCwgYW5kIGV4cG9zZXMgcHJvZ3Jlc3MgdXBkYXRlcy5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHdoZXJlIGRhdGEgc2hvdWxkIGJlIHVwbG9hZGVkLlxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byB1cGxvYWQuXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBNZXRhZGF0YSBmb3IgdGhlIG5ld2x5IHVwbG9hZGVkIGRhdGEuXG4gKiBAcmV0dXJucyBBbiBVcGxvYWRUYXNrXG4gKi9cbmZ1bmN0aW9uIHVwbG9hZEJ5dGVzUmVzdW1hYmxlJDEocmVmLCBkYXRhLCBtZXRhZGF0YSkge1xuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ3VwbG9hZEJ5dGVzUmVzdW1hYmxlJyk7XG4gICAgcmV0dXJuIG5ldyBVcGxvYWRUYXNrKHJlZiwgbmV3IEZic0Jsb2IoZGF0YSksIG1ldGFkYXRhKTtcbn1cbi8qKlxuICogVXBsb2FkcyBhIHN0cmluZyB0byB0aGlzIG9iamVjdCdzIGxvY2F0aW9uLlxuICogVGhlIHVwbG9hZCBpcyBub3QgcmVzdW1hYmxlLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2Ugd2hlcmUgc3RyaW5nIHNob3VsZCBiZSB1cGxvYWRlZC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gdXBsb2FkLlxuICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgb2YgdGhlIHN0cmluZyB0byB1cGxvYWQuXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBNZXRhZGF0YSBmb3IgdGhlIG5ld2x5IHVwbG9hZGVkIHN0cmluZy5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSBjb250YWluaW5nIGFuIFVwbG9hZFJlc3VsdFxuICovXG5mdW5jdGlvbiB1cGxvYWRTdHJpbmckMShyZWYsIHZhbHVlLCBmb3JtYXQgPSBTdHJpbmdGb3JtYXQuUkFXLCBtZXRhZGF0YSkge1xuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ3VwbG9hZFN0cmluZycpO1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhRnJvbVN0cmluZyhmb3JtYXQsIHZhbHVlKTtcbiAgICBjb25zdCBtZXRhZGF0YUNsb25lID0gT2JqZWN0LmFzc2lnbih7fSwgbWV0YWRhdGEpO1xuICAgIGlmIChtZXRhZGF0YUNsb25lWydjb250ZW50VHlwZSddID09IG51bGwgJiYgZGF0YS5jb250ZW50VHlwZSAhPSBudWxsKSB7XG4gICAgICAgIG1ldGFkYXRhQ2xvbmVbJ2NvbnRlbnRUeXBlJ10gPSBkYXRhLmNvbnRlbnRUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gdXBsb2FkQnl0ZXMkMShyZWYsIGRhdGEuZGF0YSwgbWV0YWRhdGFDbG9uZSk7XG59XG4vKipcbiAqIExpc3QgYWxsIGl0ZW1zIChmaWxlcykgYW5kIHByZWZpeGVzIChmb2xkZXJzKSB1bmRlciB0aGlzIHN0b3JhZ2UgcmVmZXJlbmNlLlxuICpcbiAqIFRoaXMgaXMgYSBoZWxwZXIgbWV0aG9kIGZvciBjYWxsaW5nIGxpc3QoKSByZXBlYXRlZGx5IHVudGlsIHRoZXJlIGFyZVxuICogbm8gbW9yZSByZXN1bHRzLiBUaGUgZGVmYXVsdCBwYWdpbmF0aW9uIHNpemUgaXMgMTAwMC5cbiAqXG4gKiBOb3RlOiBUaGUgcmVzdWx0cyBtYXkgbm90IGJlIGNvbnNpc3RlbnQgaWYgb2JqZWN0cyBhcmUgY2hhbmdlZCB3aGlsZSB0aGlzXG4gKiBvcGVyYXRpb24gaXMgcnVubmluZy5cbiAqXG4gKiBXYXJuaW5nOiBsaXN0QWxsIG1heSBwb3RlbnRpYWxseSBjb25zdW1lIHRvbyBtYW55IHJlc291cmNlcyBpZiB0aGVyZSBhcmVcbiAqIHRvbyBtYW55IHJlc3VsdHMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSB0byBnZXQgbGlzdCBmcm9tLlxuICpcbiAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYWxsIHRoZSBpdGVtcyBhbmQgcHJlZml4ZXMgdW5kZXJcbiAqICAgICAgdGhlIGN1cnJlbnQgc3RvcmFnZSByZWZlcmVuY2UuIGBwcmVmaXhlc2AgY29udGFpbnMgcmVmZXJlbmNlcyB0b1xuICogICAgICBzdWItZGlyZWN0b3JpZXMgYW5kIGBpdGVtc2AgY29udGFpbnMgcmVmZXJlbmNlcyB0byBvYmplY3RzIGluIHRoaXNcbiAqICAgICAgZm9sZGVyLiBgbmV4dFBhZ2VUb2tlbmAgaXMgbmV2ZXIgcmV0dXJuZWQuXG4gKi9cbmZ1bmN0aW9uIGxpc3RBbGwkMShyZWYpIHtcbiAgICBjb25zdCBhY2N1bXVsYXRvciA9IHtcbiAgICAgICAgcHJlZml4ZXM6IFtdLFxuICAgICAgICBpdGVtczogW11cbiAgICB9O1xuICAgIHJldHVybiBsaXN0QWxsSGVscGVyKHJlZiwgYWNjdW11bGF0b3IpLnRoZW4oKCkgPT4gYWNjdW11bGF0b3IpO1xufVxuLyoqXG4gKiBTZXBhcmF0ZWQgZnJvbSBsaXN0QWxsIGJlY2F1c2UgYXN5bmMgZnVuY3Rpb25zIGNhbid0IHVzZSBcImFyZ3VtZW50c1wiLlxuICogQHBhcmFtIHJlZlxuICogQHBhcmFtIGFjY3VtdWxhdG9yXG4gKiBAcGFyYW0gcGFnZVRva2VuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxpc3RBbGxIZWxwZXIocmVmLCBhY2N1bXVsYXRvciwgcGFnZVRva2VuKSB7XG4gICAgY29uc3Qgb3B0ID0ge1xuICAgICAgICAvLyBtYXhSZXN1bHRzIGlzIDEwMDAgYnkgZGVmYXVsdC5cbiAgICAgICAgcGFnZVRva2VuXG4gICAgfTtcbiAgICBjb25zdCBuZXh0UGFnZSA9IGF3YWl0IGxpc3QkMShyZWYsIG9wdCk7XG4gICAgYWNjdW11bGF0b3IucHJlZml4ZXMucHVzaCguLi5uZXh0UGFnZS5wcmVmaXhlcyk7XG4gICAgYWNjdW11bGF0b3IuaXRlbXMucHVzaCguLi5uZXh0UGFnZS5pdGVtcyk7XG4gICAgaWYgKG5leHRQYWdlLm5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBhd2FpdCBsaXN0QWxsSGVscGVyKHJlZiwgYWNjdW11bGF0b3IsIG5leHRQYWdlLm5leHRQYWdlVG9rZW4pO1xuICAgIH1cbn1cbi8qKlxuICogTGlzdCBpdGVtcyAoZmlsZXMpIGFuZCBwcmVmaXhlcyAoZm9sZGVycykgdW5kZXIgdGhpcyBzdG9yYWdlIHJlZmVyZW5jZS5cbiAqXG4gKiBMaXN0IEFQSSBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgRmlyZWJhc2UgUnVsZXMgVmVyc2lvbiAyLlxuICpcbiAqIEdDUyBpcyBhIGtleS1ibG9iIHN0b3JlLiBGaXJlYmFzZSBTdG9yYWdlIGltcG9zZXMgdGhlIHNlbWFudGljIG9mICcvJ1xuICogZGVsaW1pdGVkIGZvbGRlciBzdHJ1Y3R1cmUuXG4gKiBSZWZlciB0byBHQ1MncyBMaXN0IEFQSSBpZiB5b3Ugd2FudCB0byBsZWFybiBtb3JlLlxuICpcbiAqIFRvIGFkaGVyZSB0byBGaXJlYmFzZSBSdWxlcydzIFNlbWFudGljcywgRmlyZWJhc2UgU3RvcmFnZSBkb2VzIG5vdFxuICogc3VwcG9ydCBvYmplY3RzIHdob3NlIHBhdGhzIGVuZCB3aXRoIFwiL1wiIG9yIGNvbnRhaW4gdHdvIGNvbnNlY3V0aXZlXG4gKiBcIi9cInMuIEZpcmViYXNlIFN0b3JhZ2UgTGlzdCBBUEkgd2lsbCBmaWx0ZXIgdGhlc2UgdW5zdXBwb3J0ZWQgb2JqZWN0cy5cbiAqIGxpc3QoKSBtYXkgZmFpbCBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgdW5zdXBwb3J0ZWQgb2JqZWN0cyBpbiB0aGUgYnVja2V0LlxuICogQHB1YmxpY1xuICpcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHRvIGdldCBsaXN0IGZyb20uXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFNlZSBMaXN0T3B0aW9ucyBmb3IgZGV0YWlscy5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGl0ZW1zIGFuZCBwcmVmaXhlcy5cbiAqICAgICAgYHByZWZpeGVzYCBjb250YWlucyByZWZlcmVuY2VzIHRvIHN1Yi1mb2xkZXJzIGFuZCBgaXRlbXNgXG4gKiAgICAgIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gb2JqZWN0cyBpbiB0aGlzIGZvbGRlci4gYG5leHRQYWdlVG9rZW5gXG4gKiAgICAgIGNhbiBiZSB1c2VkIHRvIGdldCB0aGUgcmVzdCBvZiB0aGUgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbGlzdCQxKHJlZiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1heFJlc3VsdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZU51bWJlcignb3B0aW9ucy5tYXhSZXN1bHRzJywgXG4gICAgICAgICAgICAvKiBtaW5WYWx1ZT0gKi8gMSwgXG4gICAgICAgICAgICAvKiBtYXhWYWx1ZT0gKi8gMTAwMCwgb3B0aW9ucy5tYXhSZXN1bHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvcCA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBsaXN0JDIocmVmLnN0b3JhZ2UsIHJlZi5fbG9jYXRpb24sIFxuICAgIC8qZGVsaW1pdGVyPSAqLyAnLycsIG9wLnBhZ2VUb2tlbiwgb3AubWF4UmVzdWx0cyk7XG4gICAgcmV0dXJuIHJlZi5zdG9yYWdlLm1ha2VSZXF1ZXN0V2l0aFRva2VucyhyZXF1ZXN0SW5mbywgbmV3VGV4dENvbm5lY3Rpb24pO1xufVxuLyoqXG4gKiBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG1ldGFkYXRhIGZvciB0aGlzIG9iamVjdC4gSWYgdGhpc1xuICogb2JqZWN0IGRvZXNuJ3QgZXhpc3Qgb3IgbWV0YWRhdGEgY2Fubm90IGJlIHJldHJpZXZlZCwgdGhlIHByb21pc2UgaXNcbiAqIHJlamVjdGVkLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2UgdG8gZ2V0IG1ldGFkYXRhIGZyb20uXG4gKi9cbmZ1bmN0aW9uIGdldE1ldGFkYXRhJDEocmVmKSB7XG4gICAgcmVmLl90aHJvd0lmUm9vdCgnZ2V0TWV0YWRhdGEnKTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IGdldE1ldGFkYXRhJDIocmVmLnN0b3JhZ2UsIHJlZi5fbG9jYXRpb24sIGdldE1hcHBpbmdzKCkpO1xuICAgIHJldHVybiByZWYuc3RvcmFnZS5tYWtlUmVxdWVzdFdpdGhUb2tlbnMocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uKTtcbn1cbi8qKlxuICogVXBkYXRlcyB0aGUgbWV0YWRhdGEgZm9yIHRoaXMgb2JqZWN0LlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2UgdG8gdXBkYXRlIG1ldGFkYXRhIGZvci5cbiAqIEBwYXJhbSBtZXRhZGF0YSAtIFRoZSBuZXcgbWV0YWRhdGEgZm9yIHRoZSBvYmplY3QuXG4gKiAgICAgT25seSB2YWx1ZXMgdGhhdCBoYXZlIGJlZW4gZXhwbGljaXRseSBzZXQgd2lsbCBiZSBjaGFuZ2VkLiBFeHBsaWNpdGx5XG4gKiAgICAgc2V0dGluZyBhIHZhbHVlIHRvIG51bGwgd2lsbCByZW1vdmUgdGhlIG1ldGFkYXRhLlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlc1xuICogICAgIHdpdGggdGhlIG5ldyBtZXRhZGF0YSBmb3IgdGhpcyBvYmplY3QuXG4gKiAgICAgU2VlIGBmaXJlYmFzZVN0b3JhZ2UuUmVmZXJlbmNlLnByb3RvdHlwZS5nZXRNZXRhZGF0YWBcbiAqL1xuZnVuY3Rpb24gdXBkYXRlTWV0YWRhdGEkMShyZWYsIG1ldGFkYXRhKSB7XG4gICAgcmVmLl90aHJvd0lmUm9vdCgndXBkYXRlTWV0YWRhdGEnKTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IHVwZGF0ZU1ldGFkYXRhJDIocmVmLnN0b3JhZ2UsIHJlZi5fbG9jYXRpb24sIG1ldGFkYXRhLCBnZXRNYXBwaW5ncygpKTtcbiAgICByZXR1cm4gcmVmLnN0b3JhZ2UubWFrZVJlcXVlc3RXaXRoVG9rZW5zKHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbik7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGRvd25sb2FkIFVSTCBmb3IgdGhlIGdpdmVuIFJlZmVyZW5jZS5cbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZG93bmxvYWRcbiAqICAgICBVUkwgZm9yIHRoaXMgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXREb3dubG9hZFVSTCQxKHJlZikge1xuICAgIHJlZi5fdGhyb3dJZlJvb3QoJ2dldERvd25sb2FkVVJMJyk7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSBnZXREb3dubG9hZFVybChyZWYuc3RvcmFnZSwgcmVmLl9sb2NhdGlvbiwgZ2V0TWFwcGluZ3MoKSk7XG4gICAgcmV0dXJuIHJlZi5zdG9yYWdlXG4gICAgICAgIC5tYWtlUmVxdWVzdFdpdGhUb2tlbnMocmVxdWVzdEluZm8sIG5ld1RleHRDb25uZWN0aW9uKVxuICAgICAgICAudGhlbih1cmwgPT4ge1xuICAgICAgICBpZiAodXJsID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBub0Rvd25sb2FkVVJMKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9KTtcbn1cbi8qKlxuICogRGVsZXRlcyB0aGUgb2JqZWN0IGF0IHRoaXMgbG9jYXRpb24uXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0gU3RvcmFnZVJlZmVyZW5jZSBmb3Igb2JqZWN0IHRvIGRlbGV0ZS5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgaWYgdGhlIGRlbGV0aW9uIHN1Y2NlZWRzLlxuICovXG5mdW5jdGlvbiBkZWxldGVPYmplY3QkMShyZWYpIHtcbiAgICByZWYuX3Rocm93SWZSb290KCdkZWxldGVPYmplY3QnKTtcbiAgICBjb25zdCByZXF1ZXN0SW5mbyA9IGRlbGV0ZU9iamVjdCQyKHJlZi5zdG9yYWdlLCByZWYuX2xvY2F0aW9uKTtcbiAgICByZXR1cm4gcmVmLnN0b3JhZ2UubWFrZVJlcXVlc3RXaXRoVG9rZW5zKHJlcXVlc3RJbmZvLCBuZXdUZXh0Q29ubmVjdGlvbik7XG59XG4vKipcbiAqIFJldHVybnMgcmVmZXJlbmNlIGZvciBvYmplY3Qgb2J0YWluZWQgYnkgYXBwZW5kaW5nIGBjaGlsZFBhdGhgIHRvIGByZWZgLlxuICpcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHRvIGdldCBjaGlsZCBvZi5cbiAqIEBwYXJhbSBjaGlsZFBhdGggLSBDaGlsZCBwYXRoIGZyb20gcHJvdmlkZWQgcmVmLlxuICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhlIG9iamVjdCBvYnRhaW5lZCBieVxuICogYXBwZW5kaW5nIGNoaWxkUGF0aCwgcmVtb3ZpbmcgYW55IGR1cGxpY2F0ZSwgYmVnaW5uaW5nLCBvciB0cmFpbGluZ1xuICogc2xhc2hlcy5cbiAqXG4gKi9cbmZ1bmN0aW9uIF9nZXRDaGlsZCQxKHJlZiwgY2hpbGRQYXRoKSB7XG4gICAgY29uc3QgbmV3UGF0aCA9IGNoaWxkKHJlZi5fbG9jYXRpb24ucGF0aCwgY2hpbGRQYXRoKTtcbiAgICBjb25zdCBsb2NhdGlvbiA9IG5ldyBMb2NhdGlvbihyZWYuX2xvY2F0aW9uLmJ1Y2tldCwgbmV3UGF0aCk7XG4gICAgcmV0dXJuIG5ldyBSZWZlcmVuY2UocmVmLnN0b3JhZ2UsIGxvY2F0aW9uKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVXJsKHBhdGgpIHtcbiAgICByZXR1cm4gL15bQS1aYS16XSs6XFwvXFwvLy50ZXN0KHBhdGgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgZmlyZWJhc2VTdG9yYWdlLlJlZmVyZW5jZSBmb3IgdGhlIGdpdmVuIHVybC5cbiAqL1xuZnVuY3Rpb24gcmVmRnJvbVVSTChzZXJ2aWNlLCB1cmwpIHtcbiAgICByZXR1cm4gbmV3IFJlZmVyZW5jZShzZXJ2aWNlLCB1cmwpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgZmlyZWJhc2VTdG9yYWdlLlJlZmVyZW5jZSBmb3IgdGhlIGdpdmVuIHBhdGggaW4gdGhlIGRlZmF1bHRcbiAqIGJ1Y2tldC5cbiAqL1xuZnVuY3Rpb24gcmVmRnJvbVBhdGgocmVmLCBwYXRoKSB7XG4gICAgaWYgKHJlZiBpbnN0YW5jZW9mIEZpcmViYXNlU3RvcmFnZUltcGwpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZSA9IHJlZjtcbiAgICAgICAgaWYgKHNlcnZpY2UuX2J1Y2tldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBub0RlZmF1bHRCdWNrZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWZlcmVuY2UgPSBuZXcgUmVmZXJlbmNlKHNlcnZpY2UsIHNlcnZpY2UuX2J1Y2tldCk7XG4gICAgICAgIGlmIChwYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZWZGcm9tUGF0aChyZWZlcmVuY2UsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlZmVyZW5jZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gcmVmIGlzIGEgUmVmZXJlbmNlXG4gICAgICAgIGlmIChwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0Q2hpbGQkMShyZWYsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHJlZiQxKHNlcnZpY2VPclJlZiwgcGF0aE9yVXJsKSB7XG4gICAgaWYgKHBhdGhPclVybCAmJiBpc1VybChwYXRoT3JVcmwpKSB7XG4gICAgICAgIGlmIChzZXJ2aWNlT3JSZWYgaW5zdGFuY2VvZiBGaXJlYmFzZVN0b3JhZ2VJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmRnJvbVVSTChzZXJ2aWNlT3JSZWYsIHBhdGhPclVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkQXJndW1lbnQoJ1RvIHVzZSByZWYoc2VydmljZSwgdXJsKSwgdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBTdG9yYWdlIGluc3RhbmNlLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVmRnJvbVBhdGgoc2VydmljZU9yUmVmLCBwYXRoT3JVcmwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV4dHJhY3RCdWNrZXQoaG9zdCwgY29uZmlnKSB7XG4gICAgY29uc3QgYnVja2V0U3RyaW5nID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnW0NPTkZJR19TVE9SQUdFX0JVQ0tFVF9LRVldO1xuICAgIGlmIChidWNrZXRTdHJpbmcgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIExvY2F0aW9uLm1ha2VGcm9tQnVja2V0U3BlYyhidWNrZXRTdHJpbmcsIGhvc3QpO1xufVxuZnVuY3Rpb24gY29ubmVjdFN0b3JhZ2VFbXVsYXRvciQxKHN0b3JhZ2UsIGhvc3QsIHBvcnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN0b3JhZ2UuaG9zdCA9IGAke2hvc3R9OiR7cG9ydH1gO1xuICAgIHN0b3JhZ2UuX3Byb3RvY29sID0gJ2h0dHAnO1xuICAgIGNvbnN0IHsgbW9ja1VzZXJUb2tlbiB9ID0gb3B0aW9ucztcbiAgICBpZiAobW9ja1VzZXJUb2tlbikge1xuICAgICAgICBzdG9yYWdlLl9vdmVycmlkZUF1dGhUb2tlbiA9XG4gICAgICAgICAgICB0eXBlb2YgbW9ja1VzZXJUb2tlbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IG1vY2tVc2VyVG9rZW5cbiAgICAgICAgICAgICAgICA6IGNyZWF0ZU1vY2tVc2VyVG9rZW4obW9ja1VzZXJUb2tlbiwgc3RvcmFnZS5hcHAub3B0aW9ucy5wcm9qZWN0SWQpO1xuICAgIH1cbn1cbi8qKlxuICogQSBzZXJ2aWNlIHRoYXQgcHJvdmlkZXMgRmlyZWJhc2UgU3RvcmFnZSBSZWZlcmVuY2UgaW5zdGFuY2VzLlxuICogQHBhcmFtIG9wdF91cmwgLSBnczovLyB1cmwgdG8gYSBjdXN0b20gU3RvcmFnZSBCdWNrZXRcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgRmlyZWJhc2VTdG9yYWdlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogRmlyZWJhc2VBcHAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgU3RvcmFnZVNlcnZpY2UgaW5zdGFuY2UuXG4gICAgICovXG4gICAgYXBwLCBfYXV0aFByb3ZpZGVyLCBcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfYXBwQ2hlY2tQcm92aWRlciwgXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3VybCwgX2ZpcmViYXNlVmVyc2lvbikge1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5fYXV0aFByb3ZpZGVyID0gX2F1dGhQcm92aWRlcjtcbiAgICAgICAgdGhpcy5fYXBwQ2hlY2tQcm92aWRlciA9IF9hcHBDaGVja1Byb3ZpZGVyO1xuICAgICAgICB0aGlzLl91cmwgPSBfdXJsO1xuICAgICAgICB0aGlzLl9maXJlYmFzZVZlcnNpb24gPSBfZmlyZWJhc2VWZXJzaW9uO1xuICAgICAgICB0aGlzLl9idWNrZXQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBzdHJpbmcgY2FuIGJlIGluIHRoZSBmb3JtYXRzOlxuICAgICAgICAgKiAtIGhvc3RcbiAgICAgICAgICogLSBob3N0OnBvcnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hvc3QgPSBERUZBVUxUX0hPU1Q7XG4gICAgICAgIHRoaXMuX3Byb3RvY29sID0gJ2h0dHBzJztcbiAgICAgICAgdGhpcy5fYXBwSWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9kZWxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21heE9wZXJhdGlvblJldHJ5VGltZSA9IERFRkFVTFRfTUFYX09QRVJBVElPTl9SRVRSWV9USU1FO1xuICAgICAgICB0aGlzLl9tYXhVcGxvYWRSZXRyeVRpbWUgPSBERUZBVUxUX01BWF9VUExPQURfUkVUUllfVElNRTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmIChfdXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1Y2tldCA9IExvY2F0aW9uLm1ha2VGcm9tQnVja2V0U3BlYyhfdXJsLCB0aGlzLl9ob3N0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2J1Y2tldCA9IGV4dHJhY3RCdWNrZXQodGhpcy5faG9zdCwgdGhpcy5hcHAub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGhvc3Qgc3RyaW5nIGZvciB0aGlzIHNlcnZpY2UsIGluIHRoZSBmb3JtIG9mIGBob3N0YCBvclxuICAgICAqIGBob3N0OnBvcnRgLlxuICAgICAqL1xuICAgIGdldCBob3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faG9zdDtcbiAgICB9XG4gICAgc2V0IGhvc3QoaG9zdCkge1xuICAgICAgICB0aGlzLl9ob3N0ID0gaG9zdDtcbiAgICAgICAgaWYgKHRoaXMuX3VybCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9idWNrZXQgPSBMb2NhdGlvbi5tYWtlRnJvbUJ1Y2tldFNwZWModGhpcy5fdXJsLCBob3N0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2J1Y2tldCA9IGV4dHJhY3RCdWNrZXQoaG9zdCwgdGhpcy5hcHAub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gdGltZSB0byByZXRyeSB1cGxvYWRzIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBnZXQgbWF4VXBsb2FkUmV0cnlUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4VXBsb2FkUmV0cnlUaW1lO1xuICAgIH1cbiAgICBzZXQgbWF4VXBsb2FkUmV0cnlUaW1lKHRpbWUpIHtcbiAgICAgICAgdmFsaWRhdGVOdW1iZXIoJ3RpbWUnLCBcbiAgICAgICAgLyogbWluVmFsdWU9Ki8gMCwgXG4gICAgICAgIC8qIG1heFZhbHVlPSAqLyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHRpbWUpO1xuICAgICAgICB0aGlzLl9tYXhVcGxvYWRSZXRyeVRpbWUgPSB0aW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSB0aW1lIHRvIHJldHJ5IG9wZXJhdGlvbnMgb3RoZXIgdGhhbiB1cGxvYWRzIG9yIGRvd25sb2FkcyBpblxuICAgICAqIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBnZXQgbWF4T3BlcmF0aW9uUmV0cnlUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4T3BlcmF0aW9uUmV0cnlUaW1lO1xuICAgIH1cbiAgICBzZXQgbWF4T3BlcmF0aW9uUmV0cnlUaW1lKHRpbWUpIHtcbiAgICAgICAgdmFsaWRhdGVOdW1iZXIoJ3RpbWUnLCBcbiAgICAgICAgLyogbWluVmFsdWU9Ki8gMCwgXG4gICAgICAgIC8qIG1heFZhbHVlPSAqLyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHRpbWUpO1xuICAgICAgICB0aGlzLl9tYXhPcGVyYXRpb25SZXRyeVRpbWUgPSB0aW1lO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0QXV0aFRva2VuKCkge1xuICAgICAgICBpZiAodGhpcy5fb3ZlcnJpZGVBdXRoVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vdmVycmlkZUF1dGhUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdXRoID0gdGhpcy5fYXV0aFByb3ZpZGVyLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xuICAgICAgICBpZiAoYXV0aCkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5EYXRhID0gYXdhaXQgYXV0aC5nZXRUb2tlbigpO1xuICAgICAgICAgICAgaWYgKHRva2VuRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkRhdGEuYWNjZXNzVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRBcHBDaGVja1Rva2VuKCkge1xuICAgICAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAodGhpcy5hcHApICYmIHRoaXMuYXBwLnNldHRpbmdzLmFwcENoZWNrVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcC5zZXR0aW5ncy5hcHBDaGVja1Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcENoZWNrID0gdGhpcy5fYXBwQ2hlY2tQcm92aWRlci5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKGFwcENoZWNrKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhcHBDaGVjay5nZXRUb2tlbigpO1xuICAgICAgICAgICAgLy8gVE9ETzogV2hhdCBkbyB3ZSB3YW50IHRvIGRvIGlmIHRoZXJlIGlzIGFuIGVycm9yIGdldHRpbmcgdGhlIHRva2VuP1xuICAgICAgICAgICAgLy8gQ29udGV4dDogYXBwQ2hlY2suZ2V0VG9rZW4oKSB3aWxsIG5ldmVyIHRocm93IGV2ZW4gaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEluIHRoZSBlcnJvciBjYXNlLCBhIGR1bW15IHRva2VuIHdpbGwgYmVcbiAgICAgICAgICAgIC8vIHJldHVybmVkIGFsb25nIHdpdGggYW4gZXJyb3IgZmllbGQgZGVzY3JpYmluZyB0aGUgZXJyb3IuIEluIGdlbmVyYWwsIHdlIHNob3VsZG4ndCBjYXJlIGFib3V0IHRoZSBlcnJvciBjb25kaXRpb24gYW5kIGp1c3QgdXNlXG4gICAgICAgICAgICAvLyB0aGUgdG9rZW4gKGFjdHVhbCBvciBkdW1teSkgdG8gc2VuZCByZXF1ZXN0cy5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgcnVubmluZyByZXF1ZXN0cyBhbmQgcHJldmVudCBtb3JlIGZyb20gYmVpbmcgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBfZGVsZXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHMuZm9yRWFjaChyZXF1ZXN0ID0+IHJlcXVlc3QuY2FuY2VsKCkpO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgZmlyZWJhc2VTdG9yYWdlLlJlZmVyZW5jZSBvYmplY3QgcmVmZXJlbmNpbmcgdGhpcyBTdG9yYWdlU2VydmljZVxuICAgICAqIGF0IHRoZSBnaXZlbiBMb2NhdGlvbi5cbiAgICAgKi9cbiAgICBfbWFrZVN0b3JhZ2VSZWZlcmVuY2UobG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVmZXJlbmNlKHRoaXMsIGxvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSByZXF1ZXN0SW5mbyAtIEhUVFAgUmVxdWVzdEluZm8gb2JqZWN0XG4gICAgICogQHBhcmFtIGF1dGhUb2tlbiAtIEZpcmViYXNlIGF1dGggdG9rZW5cbiAgICAgKi9cbiAgICBfbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIHJlcXVlc3RGYWN0b3J5LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4sIHJldHJ5ID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBtYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgdGhpcy5fYXBwSWQsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgcmVxdWVzdEZhY3RvcnksIHRoaXMuX2ZpcmViYXNlVmVyc2lvbiwgcmV0cnkpO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHMuYWRkKHJlcXVlc3QpO1xuICAgICAgICAgICAgLy8gUmVxdWVzdCByZW1vdmVzIGl0c2VsZiBmcm9tIHNldCB3aGVuIGNvbXBsZXRlLlxuICAgICAgICAgICAgcmVxdWVzdC5nZXRQcm9taXNlKCkudGhlbigoKSA9PiB0aGlzLl9yZXF1ZXN0cy5kZWxldGUocmVxdWVzdCksICgpID0+IHRoaXMuX3JlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0KSk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFpbFJlcXVlc3QoYXBwRGVsZXRlZCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBtYWtlUmVxdWVzdFdpdGhUb2tlbnMocmVxdWVzdEluZm8sIHJlcXVlc3RGYWN0b3J5KSB7XG4gICAgICAgIGNvbnN0IFthdXRoVG9rZW4sIGFwcENoZWNrVG9rZW5dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5fZ2V0QXV0aFRva2VuKCksXG4gICAgICAgICAgICB0aGlzLl9nZXRBcHBDaGVja1Rva2VuKClcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgcmVxdWVzdEZhY3RvcnksIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbikuZ2V0UHJvbWlzZSgpO1xuICAgIH1cbn1cblxuY29uc3QgbmFtZSA9IFwiQGZpcmViYXNlL3N0b3JhZ2VcIjtcbmNvbnN0IHZlcnNpb24gPSBcIjAuMTMuN1wiO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUeXBlIGNvbnN0YW50IGZvciBGaXJlYmFzZSBTdG9yYWdlLlxuICovXG5jb25zdCBTVE9SQUdFX1RZUEUgPSAnc3RvcmFnZSc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIERvd25sb2FkcyB0aGUgZGF0YSBhdCB0aGUgb2JqZWN0J3MgbG9jYXRpb24uIFJldHVybnMgYW4gZXJyb3IgaWYgdGhlIG9iamVjdFxuICogaXMgbm90IGZvdW5kLlxuICpcbiAqIFRvIHVzZSB0aGlzIGZ1bmN0aW9uYWxpdHksIHlvdSBoYXZlIHRvIHdoaXRlbGlzdCB5b3VyIGFwcCdzIG9yaWdpbiBpbiB5b3VyXG4gKiBDbG91ZCBTdG9yYWdlIGJ1Y2tldC4gU2VlIGFsc29cbiAqIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9zdG9yYWdlL2RvY3MvY29uZmlndXJpbmctY29yc1xuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHdoZXJlIGRhdGEgc2hvdWxkIGJlIGRvd25sb2FkZWQuXG4gKiBAcGFyYW0gbWF4RG93bmxvYWRTaXplQnl0ZXMgLSBJZiBzZXQsIHRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBpbiBieXRlcyB0b1xuICogcmV0cmlldmUuXG4gKiBAcmV0dXJucyBBIFByb21pc2UgY29udGFpbmluZyB0aGUgb2JqZWN0J3MgYnl0ZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Qnl0ZXMocmVmLCBtYXhEb3dubG9hZFNpemVCeXRlcykge1xuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xuICAgIHJldHVybiBnZXRCeXRlc0ludGVybmFsKHJlZiwgbWF4RG93bmxvYWRTaXplQnl0ZXMpO1xufVxuLyoqXG4gKiBVcGxvYWRzIGRhdGEgdG8gdGhpcyBvYmplY3QncyBsb2NhdGlvbi5cbiAqIFRoZSB1cGxvYWQgaXMgbm90IHJlc3VtYWJsZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gd2hlcmUgZGF0YSBzaG91bGQgYmUgdXBsb2FkZWQuXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVwbG9hZC5cbiAqIEBwYXJhbSBtZXRhZGF0YSAtIE1ldGFkYXRhIGZvciB0aGUgZGF0YSB0byB1cGxvYWQuXG4gKiBAcmV0dXJucyBBIFByb21pc2UgY29udGFpbmluZyBhbiBVcGxvYWRSZXN1bHRcbiAqL1xuZnVuY3Rpb24gdXBsb2FkQnl0ZXMocmVmLCBkYXRhLCBtZXRhZGF0YSkge1xuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xuICAgIHJldHVybiB1cGxvYWRCeXRlcyQxKHJlZiwgZGF0YSwgbWV0YWRhdGEpO1xufVxuLyoqXG4gKiBVcGxvYWRzIGEgc3RyaW5nIHRvIHRoaXMgb2JqZWN0J3MgbG9jYXRpb24uXG4gKiBUaGUgdXBsb2FkIGlzIG5vdCByZXN1bWFibGUuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9IHdoZXJlIHN0cmluZyBzaG91bGQgYmUgdXBsb2FkZWQuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIHVwbG9hZC5cbiAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IG9mIHRoZSBzdHJpbmcgdG8gdXBsb2FkLlxuICogQHBhcmFtIG1ldGFkYXRhIC0gTWV0YWRhdGEgZm9yIHRoZSBzdHJpbmcgdG8gdXBsb2FkLlxuICogQHJldHVybnMgQSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gVXBsb2FkUmVzdWx0XG4gKi9cbmZ1bmN0aW9uIHVwbG9hZFN0cmluZyhyZWYsIHZhbHVlLCBmb3JtYXQsIG1ldGFkYXRhKSB7XG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XG4gICAgcmV0dXJuIHVwbG9hZFN0cmluZyQxKHJlZiwgdmFsdWUsIGZvcm1hdCwgbWV0YWRhdGEpO1xufVxuLyoqXG4gKiBVcGxvYWRzIGRhdGEgdG8gdGhpcyBvYmplY3QncyBsb2NhdGlvbi5cbiAqIFRoZSB1cGxvYWQgY2FuIGJlIHBhdXNlZCBhbmQgcmVzdW1lZCwgYW5kIGV4cG9zZXMgcHJvZ3Jlc3MgdXBkYXRlcy5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gd2hlcmUgZGF0YSBzaG91bGQgYmUgdXBsb2FkZWQuXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHVwbG9hZC5cbiAqIEBwYXJhbSBtZXRhZGF0YSAtIE1ldGFkYXRhIGZvciB0aGUgZGF0YSB0byB1cGxvYWQuXG4gKiBAcmV0dXJucyBBbiBVcGxvYWRUYXNrXG4gKi9cbmZ1bmN0aW9uIHVwbG9hZEJ5dGVzUmVzdW1hYmxlKHJlZiwgZGF0YSwgbWV0YWRhdGEpIHtcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcbiAgICByZXR1cm4gdXBsb2FkQnl0ZXNSZXN1bWFibGUkMShyZWYsIGRhdGEsIG1ldGFkYXRhKTtcbn1cbi8qKlxuICogQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBtZXRhZGF0YSBmb3IgdGhpcyBvYmplY3QuIElmIHRoaXNcbiAqIG9iamVjdCBkb2Vzbid0IGV4aXN0IG9yIG1ldGFkYXRhIGNhbm5vdCBiZSByZXRyaWV2ZWQsIHRoZSBwcm9taXNlIGlzXG4gKiByZWplY3RlZC5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gdG8gZ2V0IG1ldGFkYXRhIGZyb20uXG4gKi9cbmZ1bmN0aW9uIGdldE1ldGFkYXRhKHJlZikge1xuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xuICAgIHJldHVybiBnZXRNZXRhZGF0YSQxKHJlZik7XG59XG4vKipcbiAqIFVwZGF0ZXMgdGhlIG1ldGFkYXRhIGZvciB0aGlzIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSB7QGxpbmsgU3RvcmFnZVJlZmVyZW5jZX0gdG8gdXBkYXRlIG1ldGFkYXRhIGZvci5cbiAqIEBwYXJhbSBtZXRhZGF0YSAtIFRoZSBuZXcgbWV0YWRhdGEgZm9yIHRoZSBvYmplY3QuXG4gKiAgICAgT25seSB2YWx1ZXMgdGhhdCBoYXZlIGJlZW4gZXhwbGljaXRseSBzZXQgd2lsbCBiZSBjaGFuZ2VkLiBFeHBsaWNpdGx5XG4gKiAgICAgc2V0dGluZyBhIHZhbHVlIHRvIG51bGwgd2lsbCByZW1vdmUgdGhlIG1ldGFkYXRhLlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBuZXcgbWV0YWRhdGEgZm9yIHRoaXMgb2JqZWN0LlxuICovXG5mdW5jdGlvbiB1cGRhdGVNZXRhZGF0YShyZWYsIG1ldGFkYXRhKSB7XG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XG4gICAgcmV0dXJuIHVwZGF0ZU1ldGFkYXRhJDEocmVmLCBtZXRhZGF0YSk7XG59XG4vKipcbiAqIExpc3QgaXRlbXMgKGZpbGVzKSBhbmQgcHJlZml4ZXMgKGZvbGRlcnMpIHVuZGVyIHRoaXMgc3RvcmFnZSByZWZlcmVuY2UuXG4gKlxuICogTGlzdCBBUEkgaXMgb25seSBhdmFpbGFibGUgZm9yIEZpcmViYXNlIFJ1bGVzIFZlcnNpb24gMi5cbiAqXG4gKiBHQ1MgaXMgYSBrZXktYmxvYiBzdG9yZS4gRmlyZWJhc2UgU3RvcmFnZSBpbXBvc2VzIHRoZSBzZW1hbnRpYyBvZiAnLydcbiAqIGRlbGltaXRlZCBmb2xkZXIgc3RydWN0dXJlLlxuICogUmVmZXIgdG8gR0NTJ3MgTGlzdCBBUEkgaWYgeW91IHdhbnQgdG8gbGVhcm4gbW9yZS5cbiAqXG4gKiBUbyBhZGhlcmUgdG8gRmlyZWJhc2UgUnVsZXMncyBTZW1hbnRpY3MsIEZpcmViYXNlIFN0b3JhZ2UgZG9lcyBub3RcbiAqIHN1cHBvcnQgb2JqZWN0cyB3aG9zZSBwYXRocyBlbmQgd2l0aCBcIi9cIiBvciBjb250YWluIHR3byBjb25zZWN1dGl2ZVxuICogXCIvXCJzLiBGaXJlYmFzZSBTdG9yYWdlIExpc3QgQVBJIHdpbGwgZmlsdGVyIHRoZXNlIHVuc3VwcG9ydGVkIG9iamVjdHMuXG4gKiBsaXN0KCkgbWF5IGZhaWwgaWYgdGhlcmUgYXJlIHRvbyBtYW55IHVuc3VwcG9ydGVkIG9iamVjdHMgaW4gdGhlIGJ1Y2tldC5cbiAqIEBwdWJsaWNcbiAqXG4gKiBAcGFyYW0gcmVmIC0ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9IHRvIGdldCBsaXN0IGZyb20uXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFNlZSB7QGxpbmsgTGlzdE9wdGlvbnN9IGZvciBkZXRhaWxzLlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBpdGVtcyBhbmQgcHJlZml4ZXMuXG4gKiAgICAgIGBwcmVmaXhlc2AgY29udGFpbnMgcmVmZXJlbmNlcyB0byBzdWItZm9sZGVycyBhbmQgYGl0ZW1zYFxuICogICAgICBjb250YWlucyByZWZlcmVuY2VzIHRvIG9iamVjdHMgaW4gdGhpcyBmb2xkZXIuIGBuZXh0UGFnZVRva2VuYFxuICogICAgICBjYW4gYmUgdXNlZCB0byBnZXQgdGhlIHJlc3Qgb2YgdGhlIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGxpc3QocmVmLCBvcHRpb25zKSB7XG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XG4gICAgcmV0dXJuIGxpc3QkMShyZWYsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBMaXN0IGFsbCBpdGVtcyAoZmlsZXMpIGFuZCBwcmVmaXhlcyAoZm9sZGVycykgdW5kZXIgdGhpcyBzdG9yYWdlIHJlZmVyZW5jZS5cbiAqXG4gKiBUaGlzIGlzIGEgaGVscGVyIG1ldGhvZCBmb3IgY2FsbGluZyBsaXN0KCkgcmVwZWF0ZWRseSB1bnRpbCB0aGVyZSBhcmVcbiAqIG5vIG1vcmUgcmVzdWx0cy4gVGhlIGRlZmF1bHQgcGFnaW5hdGlvbiBzaXplIGlzIDEwMDAuXG4gKlxuICogTm90ZTogVGhlIHJlc3VsdHMgbWF5IG5vdCBiZSBjb25zaXN0ZW50IGlmIG9iamVjdHMgYXJlIGNoYW5nZWQgd2hpbGUgdGhpc1xuICogb3BlcmF0aW9uIGlzIHJ1bm5pbmcuXG4gKlxuICogV2FybmluZzogYGxpc3RBbGxgIG1heSBwb3RlbnRpYWxseSBjb25zdW1lIHRvbyBtYW55IHJlc291cmNlcyBpZiB0aGVyZSBhcmVcbiAqIHRvbyBtYW55IHJlc3VsdHMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9IHRvIGdldCBsaXN0IGZyb20uXG4gKlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIGFsbCB0aGUgaXRlbXMgYW5kIHByZWZpeGVzIHVuZGVyXG4gKiAgICAgIHRoZSBjdXJyZW50IHN0b3JhZ2UgcmVmZXJlbmNlLiBgcHJlZml4ZXNgIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG9cbiAqICAgICAgc3ViLWRpcmVjdG9yaWVzIGFuZCBgaXRlbXNgIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gb2JqZWN0cyBpbiB0aGlzXG4gKiAgICAgIGZvbGRlci4gYG5leHRQYWdlVG9rZW5gIGlzIG5ldmVyIHJldHVybmVkLlxuICovXG5mdW5jdGlvbiBsaXN0QWxsKHJlZikge1xuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xuICAgIHJldHVybiBsaXN0QWxsJDEocmVmKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZG93bmxvYWQgVVJMIGZvciB0aGUgZ2l2ZW4ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9LlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlZiAtIHtAbGluayBTdG9yYWdlUmVmZXJlbmNlfSB0byBnZXQgdGhlIGRvd25sb2FkIFVSTCBmb3IuXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGRvd25sb2FkXG4gKiAgICAgVVJMIGZvciB0aGlzIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0RG93bmxvYWRVUkwocmVmKSB7XG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XG4gICAgcmV0dXJuIGdldERvd25sb2FkVVJMJDEocmVmKTtcbn1cbi8qKlxuICogRGVsZXRlcyB0aGUgb2JqZWN0IGF0IHRoaXMgbG9jYXRpb24uXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcmVmIC0ge0BsaW5rIFN0b3JhZ2VSZWZlcmVuY2V9IGZvciBvYmplY3QgdG8gZGVsZXRlLlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyBpZiB0aGUgZGVsZXRpb24gc3VjY2VlZHMuXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZU9iamVjdChyZWYpIHtcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcbiAgICByZXR1cm4gZGVsZXRlT2JqZWN0JDEocmVmKTtcbn1cbmZ1bmN0aW9uIHJlZihzZXJ2aWNlT3JSZWYsIHBhdGhPclVybCkge1xuICAgIHNlcnZpY2VPclJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShzZXJ2aWNlT3JSZWYpO1xuICAgIHJldHVybiByZWYkMShzZXJ2aWNlT3JSZWYsIHBhdGhPclVybCk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfZ2V0Q2hpbGQocmVmLCBjaGlsZFBhdGgpIHtcbiAgICByZXR1cm4gX2dldENoaWxkJDEocmVmLCBjaGlsZFBhdGgpO1xufVxuLyoqXG4gKiBHZXRzIGEge0BsaW5rIEZpcmViYXNlU3RvcmFnZX0gaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBGaXJlYmFzZSBhcHAuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gYXBwIC0gRmlyZWJhc2UgYXBwIHRvIGdldCB7QGxpbmsgRmlyZWJhc2VTdG9yYWdlfSBpbnN0YW5jZSBmb3IuXG4gKiBAcGFyYW0gYnVja2V0VXJsIC0gVGhlIGdzOi8vIHVybCB0byB5b3VyIEZpcmViYXNlIFN0b3JhZ2UgQnVja2V0LlxuICogSWYgbm90IHBhc3NlZCwgdXNlcyB0aGUgYXBwJ3MgZGVmYXVsdCBTdG9yYWdlIEJ1Y2tldC5cbiAqIEByZXR1cm5zIEEge0BsaW5rIEZpcmViYXNlU3RvcmFnZX0gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFN0b3JhZ2UoYXBwID0gZ2V0QXBwKCksIGJ1Y2tldFVybCkge1xuICAgIGFwcCA9IGdldE1vZHVsYXJJbnN0YW5jZShhcHApO1xuICAgIGNvbnN0IHN0b3JhZ2VQcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsIFNUT1JBR0VfVFlQRSk7XG4gICAgY29uc3Qgc3RvcmFnZUluc3RhbmNlID0gc3RvcmFnZVByb3ZpZGVyLmdldEltbWVkaWF0ZSh7XG4gICAgICAgIGlkZW50aWZpZXI6IGJ1Y2tldFVybFxuICAgIH0pO1xuICAgIGNvbnN0IGVtdWxhdG9yID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0KCdzdG9yYWdlJyk7XG4gICAgaWYgKGVtdWxhdG9yKSB7XG4gICAgICAgIGNvbm5lY3RTdG9yYWdlRW11bGF0b3Ioc3RvcmFnZUluc3RhbmNlLCAuLi5lbXVsYXRvcik7XG4gICAgfVxuICAgIHJldHVybiBzdG9yYWdlSW5zdGFuY2U7XG59XG4vKipcbiAqIE1vZGlmeSB0aGlzIHtAbGluayBGaXJlYmFzZVN0b3JhZ2V9IGluc3RhbmNlIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIENsb3VkIFN0b3JhZ2UgZW11bGF0b3IuXG4gKlxuICogQHBhcmFtIHN0b3JhZ2UgLSBUaGUge0BsaW5rIEZpcmViYXNlU3RvcmFnZX0gaW5zdGFuY2VcbiAqIEBwYXJhbSBob3N0IC0gVGhlIGVtdWxhdG9yIGhvc3QgKGV4OiBsb2NhbGhvc3QpXG4gKiBAcGFyYW0gcG9ydCAtIFRoZSBlbXVsYXRvciBwb3J0IChleDogNTAwMSlcbiAqIEBwYXJhbSBvcHRpb25zIC0gRW11bGF0b3Igb3B0aW9ucy4gYG9wdGlvbnMubW9ja1VzZXJUb2tlbmAgaXMgdGhlIG1vY2sgYXV0aFxuICogdG9rZW4gdG8gdXNlIGZvciB1bml0IHRlc3RpbmcgU2VjdXJpdHkgUnVsZXMuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNvbm5lY3RTdG9yYWdlRW11bGF0b3Ioc3RvcmFnZSwgaG9zdCwgcG9ydCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29ubmVjdFN0b3JhZ2VFbXVsYXRvciQxKHN0b3JhZ2UsIGhvc3QsIHBvcnQsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEb3dubG9hZHMgdGhlIGRhdGEgYXQgdGhlIG9iamVjdCdzIGxvY2F0aW9uLiBSZXR1cm5zIGFuIGVycm9yIGlmIHRoZSBvYmplY3RcbiAqIGlzIG5vdCBmb3VuZC5cbiAqXG4gKiBUbyB1c2UgdGhpcyBmdW5jdGlvbmFsaXR5LCB5b3UgaGF2ZSB0byB3aGl0ZWxpc3QgeW91ciBhcHAncyBvcmlnaW4gaW4geW91clxuICogQ2xvdWQgU3RvcmFnZSBidWNrZXQuIFNlZSBhbHNvXG4gKiBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vc3RvcmFnZS9kb2NzL2NvbmZpZ3VyaW5nLWNvcnNcbiAqXG4gKiBUaGlzIEFQSSBpcyBub3QgYXZhaWxhYmxlIGluIE5vZGUuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlZiAtIFN0b3JhZ2VSZWZlcmVuY2Ugd2hlcmUgZGF0YSBzaG91bGQgYmUgZG93bmxvYWRlZC5cbiAqIEBwYXJhbSBtYXhEb3dubG9hZFNpemVCeXRlcyAtIElmIHNldCwgdGhlIG1heGltdW0gYWxsb3dlZCBzaXplIGluIGJ5dGVzIHRvXG4gKiByZXRyaWV2ZS5cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBCbG9iIGNvbnRhaW5pbmcgdGhlIG9iamVjdCdzIGJ5dGVzXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbmZ1bmN0aW9uIGdldEJsb2IocmVmLCBtYXhEb3dubG9hZFNpemVCeXRlcykge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2V0QmxvYigpIGlzIG9ubHkgYXZhaWxhYmxlIGluIEJyb3dzZXItbGlrZSBlbnZpcm9ubWVudHMnKTtcbn1cbi8qKlxuICogRG93bmxvYWRzIHRoZSBkYXRhIGF0IHRoZSBvYmplY3QncyBsb2NhdGlvbi4gUmFpc2VzIGFuIGVycm9yIGV2ZW50IGlmIHRoZVxuICogb2JqZWN0IGlzIG5vdCBmb3VuZC5cbiAqXG4gKiBUaGlzIEFQSSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBOb2RlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSByZWYgLSBTdG9yYWdlUmVmZXJlbmNlIHdoZXJlIGRhdGEgc2hvdWxkIGJlIGRvd25sb2FkZWQuXG4gKiBAcGFyYW0gbWF4RG93bmxvYWRTaXplQnl0ZXMgLSBJZiBzZXQsIHRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBpbiBieXRlcyB0b1xuICogcmV0cmlldmUuXG4gKiBAcmV0dXJucyBBIHN0cmVhbSB3aXRoIHRoZSBvYmplY3QncyBkYXRhIGFzIGJ5dGVzXG4gKi9cbmZ1bmN0aW9uIGdldFN0cmVhbShyZWYsIG1heERvd25sb2FkU2l6ZUJ5dGVzKSB7XG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XG4gICAgcmV0dXJuIGdldFN0cmVhbUludGVybmFsKHJlZiwgbWF4RG93bmxvYWRTaXplQnl0ZXMpO1xufVxuXG4vKipcbiAqIENsb3VkIFN0b3JhZ2UgZm9yIEZpcmViYXNlXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGZhY3RvcnkoY29udGFpbmVyLCB7IGluc3RhbmNlSWRlbnRpZmllcjogdXJsIH0pIHtcbiAgICBjb25zdCBhcHAgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcCcpLmdldEltbWVkaWF0ZSgpO1xuICAgIGNvbnN0IGF1dGhQcm92aWRlciA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXV0aC1pbnRlcm5hbCcpO1xuICAgIGNvbnN0IGFwcENoZWNrUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcC1jaGVjay1pbnRlcm5hbCcpO1xuICAgIHJldHVybiBuZXcgRmlyZWJhc2VTdG9yYWdlSW1wbChhcHAsIGF1dGhQcm92aWRlciwgYXBwQ2hlY2tQcm92aWRlciwgdXJsLCBTREtfVkVSU0lPTik7XG59XG5mdW5jdGlvbiByZWdpc3RlclN0b3JhZ2UoKSB7XG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoU1RPUkFHRV9UWVBFLCBmYWN0b3J5LCBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKS5zZXRNdWx0aXBsZUluc3RhbmNlcyh0cnVlKSk7XG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24pO1xufVxucmVnaXN0ZXJTdG9yYWdlKCk7XG5cbmV4cG9ydCB7IFN0b3JhZ2VFcnJvciwgU3RvcmFnZUVycm9yQ29kZSwgU3RyaW5nRm9ybWF0LCBGYnNCbG9iIGFzIF9GYnNCbG9iLCBMb2NhdGlvbiBhcyBfTG9jYXRpb24sIFRhc2tFdmVudCBhcyBfVGFza0V2ZW50LCBUYXNrU3RhdGUgYXMgX1Rhc2tTdGF0ZSwgVXBsb2FkVGFzayBhcyBfVXBsb2FkVGFzaywgZGF0YUZyb21TdHJpbmcgYXMgX2RhdGFGcm9tU3RyaW5nLCBfZ2V0Q2hpbGQsIGludmFsaWRBcmd1bWVudCBhcyBfaW52YWxpZEFyZ3VtZW50LCBpbnZhbGlkUm9vdE9wZXJhdGlvbiBhcyBfaW52YWxpZFJvb3RPcGVyYXRpb24sIGNvbm5lY3RTdG9yYWdlRW11bGF0b3IsIGRlbGV0ZU9iamVjdCwgZ2V0QmxvYiwgZ2V0Qnl0ZXMsIGdldERvd25sb2FkVVJMLCBnZXRNZXRhZGF0YSwgZ2V0U3RvcmFnZSwgZ2V0U3RyZWFtLCBsaXN0LCBsaXN0QWxsLCByZWYsIHVwZGF0ZU1ldGFkYXRhLCB1cGxvYWRCeXRlcywgdXBsb2FkQnl0ZXNSZXN1bWFibGUsIHVwbG9hZFN0cmluZyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@firebase/storage/dist/node-esm/index.node.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@firebase/util/dist/node-esm/index.node.esm.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@firebase/util/dist/node-esm/index.node.esm.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANTS: () => (/* binding */ CONSTANTS),\n/* harmony export */   DecodeBase64StringError: () => (/* binding */ DecodeBase64StringError),\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   ErrorFactory: () => (/* binding */ ErrorFactory),\n/* harmony export */   FirebaseError: () => (/* binding */ FirebaseError),\n/* harmony export */   MAX_VALUE_MILLIS: () => (/* binding */ MAX_VALUE_MILLIS),\n/* harmony export */   RANDOM_FACTOR: () => (/* binding */ RANDOM_FACTOR),\n/* harmony export */   Sha1: () => (/* binding */ Sha1),\n/* harmony export */   areCookiesEnabled: () => (/* binding */ areCookiesEnabled),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertionError: () => (/* binding */ assertionError),\n/* harmony export */   async: () => (/* binding */ async),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64Decode: () => (/* binding */ base64Decode),\n/* harmony export */   base64Encode: () => (/* binding */ base64Encode),\n/* harmony export */   base64urlEncodeWithoutPadding: () => (/* binding */ base64urlEncodeWithoutPadding),\n/* harmony export */   calculateBackoffMillis: () => (/* binding */ calculateBackoffMillis),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createMockUserToken: () => (/* binding */ createMockUserToken),\n/* harmony export */   createSubscribe: () => (/* binding */ createSubscribe),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   deepExtend: () => (/* binding */ deepExtend),\n/* harmony export */   errorPrefix: () => (/* binding */ errorPrefix),\n/* harmony export */   extractQuerystring: () => (/* binding */ extractQuerystring),\n/* harmony export */   getDefaultAppConfig: () => (/* binding */ getDefaultAppConfig),\n/* harmony export */   getDefaultEmulatorHost: () => (/* binding */ getDefaultEmulatorHost),\n/* harmony export */   getDefaultEmulatorHostnameAndPort: () => (/* binding */ getDefaultEmulatorHostnameAndPort),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getExperimentalSetting: () => (/* binding */ getExperimentalSetting),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   getModularInstance: () => (/* binding */ getModularInstance),\n/* harmony export */   getUA: () => (/* binding */ getUA),\n/* harmony export */   isAdmin: () => (/* binding */ isAdmin),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isBrowserExtension: () => (/* binding */ isBrowserExtension),\n/* harmony export */   isCloudflareWorker: () => (/* binding */ isCloudflareWorker),\n/* harmony export */   isElectron: () => (/* binding */ isElectron),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isIE: () => (/* binding */ isIE),\n/* harmony export */   isIndexedDBAvailable: () => (/* binding */ isIndexedDBAvailable),\n/* harmony export */   isMobileCordova: () => (/* binding */ isMobileCordova),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isNodeSdk: () => (/* binding */ isNodeSdk),\n/* harmony export */   isReactNative: () => (/* binding */ isReactNative),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isUWP: () => (/* binding */ isUWP),\n/* harmony export */   isValidFormat: () => (/* binding */ isValidFormat),\n/* harmony export */   isValidTimestamp: () => (/* binding */ isValidTimestamp),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   issuedAtTime: () => (/* binding */ issuedAtTime),\n/* harmony export */   jsonEval: () => (/* binding */ jsonEval),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   ordinal: () => (/* binding */ ordinal),\n/* harmony export */   promiseWithTimeout: () => (/* binding */ promiseWithTimeout),\n/* harmony export */   querystring: () => (/* binding */ querystring),\n/* harmony export */   querystringDecode: () => (/* binding */ querystringDecode),\n/* harmony export */   safeGet: () => (/* binding */ safeGet),\n/* harmony export */   stringLength: () => (/* binding */ stringLength),\n/* harmony export */   stringToByteArray: () => (/* binding */ stringToByteArray),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   validateArgCount: () => (/* binding */ validateArgCount),\n/* harmony export */   validateCallback: () => (/* binding */ validateCallback),\n/* harmony export */   validateContextObject: () => (/* binding */ validateContextObject),\n/* harmony export */   validateIndexedDBOpenable: () => (/* binding */ validateIndexedDBOpenable),\n/* harmony export */   validateNamespace: () => (/* binding */ validateNamespace)\n/* harmony export */ });\n/* harmony import */ var _postinstall_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../postinstall.mjs */ \"(ssr)/../node_modules/@firebase/util/dist/postinstall.mjs\");\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\n */\nconst CONSTANTS = {\n    /**\n     * @define {boolean} Whether this is the client Node.js SDK.\n     */\n    NODE_CLIENT: false,\n    /**\n     * @define {boolean} Whether this is the Admin Node.js SDK.\n     */\n    NODE_ADMIN: false,\n    /**\n     * Firebase SDK Version\n     */\n    SDK_VERSION: '${JSCORE_VERSION}'\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Throws an error if the provided assertion is falsy\n */\nconst assert = function (assertion, message) {\n    if (!assertion) {\n        throw assertionError(message);\n    }\n};\n/**\n * Returns an Error object suitable for throwing.\n */\nconst assertionError = function (message) {\n    return new Error('Firebase Database (' +\n        CONSTANTS.SDK_VERSION +\n        ') INTERNAL ASSERT FAILED: ' +\n        message);\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst stringToByteArray$1 = function (str) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        let c = str.charCodeAt(i);\n        if (c < 128) {\n            out[p++] = c;\n        }\n        else if (c < 2048) {\n            out[p++] = (c >> 6) | 192;\n            out[p++] = (c & 63) | 128;\n        }\n        else if ((c & 0xfc00) === 0xd800 &&\n            i + 1 < str.length &&\n            (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\n            // Surrogate Pair\n            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\n            out[p++] = (c >> 18) | 240;\n            out[p++] = ((c >> 12) & 63) | 128;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n        else {\n            out[p++] = (c >> 12) | 224;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n    }\n    return out;\n};\n/**\n * Turns an array of numbers into the string given by the concatenation of the\n * characters to which the numbers correspond.\n * @param bytes Array of numbers representing characters.\n * @return Stringification of the array.\n */\nconst byteArrayToString = function (bytes) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let pos = 0, c = 0;\n    while (pos < bytes.length) {\n        const c1 = bytes[pos++];\n        if (c1 < 128) {\n            out[c++] = String.fromCharCode(c1);\n        }\n        else if (c1 > 191 && c1 < 224) {\n            const c2 = bytes[pos++];\n            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));\n        }\n        else if (c1 > 239 && c1 < 365) {\n            // Surrogate Pair\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            const c4 = bytes[pos++];\n            const u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -\n                0x10000;\n            out[c++] = String.fromCharCode(0xd800 + (u >> 10));\n            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\n        }\n        else {\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n        }\n    }\n    return out.join('');\n};\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\n// Static lookup maps, lazily populated by init_()\n// TODO(dlarocque): Define this as a class, since we no longer target ES5.\nconst base64 = {\n    /**\n     * Maps bytes to characters.\n     */\n    byteToCharMap_: null,\n    /**\n     * Maps characters to bytes.\n     */\n    charToByteMap_: null,\n    /**\n     * Maps bytes to websafe characters.\n     * @private\n     */\n    byteToCharMapWebSafe_: null,\n    /**\n     * Maps websafe characters to bytes.\n     * @private\n     */\n    charToByteMapWebSafe_: null,\n    /**\n     * Our default alphabet, shared between\n     * ENCODED_VALS and ENCODED_VALS_WEBSAFE\n     */\n    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\n    /**\n     * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\n     */\n    get ENCODED_VALS() {\n        return this.ENCODED_VALS_BASE + '+/=';\n    },\n    /**\n     * Our websafe alphabet.\n     */\n    get ENCODED_VALS_WEBSAFE() {\n        return this.ENCODED_VALS_BASE + '-_.';\n    },\n    /**\n     * Whether this browser supports the atob and btoa functions. This extension\n     * started at Mozilla but is now implemented by many browsers. We use the\n     * ASSUME_* variables to avoid pulling in the full useragent detection library\n     * but still allowing the standard per-browser compilations.\n     *\n     */\n    HAS_NATIVE_SUPPORT: typeof atob === 'function',\n    /**\n     * Base64-encode an array of bytes.\n     *\n     * @param input An array of bytes (numbers with\n     *     value in [0, 255]) to encode.\n     * @param webSafe Boolean indicating we should use the\n     *     alternative alphabet.\n     * @return The base64 encoded string.\n     */\n    encodeByteArray(input, webSafe) {\n        if (!Array.isArray(input)) {\n            throw Error('encodeByteArray takes an array as a parameter');\n        }\n        this.init_();\n        const byteToCharMap = webSafe\n            ? this.byteToCharMapWebSafe_\n            : this.byteToCharMap_;\n        const output = [];\n        for (let i = 0; i < input.length; i += 3) {\n            const byte1 = input[i];\n            const haveByte2 = i + 1 < input.length;\n            const byte2 = haveByte2 ? input[i + 1] : 0;\n            const haveByte3 = i + 2 < input.length;\n            const byte3 = haveByte3 ? input[i + 2] : 0;\n            const outByte1 = byte1 >> 2;\n            const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n            let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\n            let outByte4 = byte3 & 0x3f;\n            if (!haveByte3) {\n                outByte4 = 64;\n                if (!haveByte2) {\n                    outByte3 = 64;\n                }\n            }\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n        }\n        return output.join('');\n    },\n    /**\n     * Base64-encode a string.\n     *\n     * @param input A string to encode.\n     * @param webSafe If true, we should use the\n     *     alternative alphabet.\n     * @return The base64 encoded string.\n     */\n    encodeString(input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return btoa(input);\n        }\n        return this.encodeByteArray(stringToByteArray$1(input), webSafe);\n    },\n    /**\n     * Base64-decode a string.\n     *\n     * @param input to decode.\n     * @param webSafe True if we should use the\n     *     alternative alphabet.\n     * @return string representing the decoded value.\n     */\n    decodeString(input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return atob(input);\n        }\n        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\n    },\n    /**\n     * Base64-decode a string.\n     *\n     * In base-64 decoding, groups of four characters are converted into three\n     * bytes.  If the encoder did not apply padding, the input length may not\n     * be a multiple of 4.\n     *\n     * In this case, the last group will have fewer than 4 characters, and\n     * padding will be inferred.  If the group has one or two characters, it decodes\n     * to one byte.  If the group has three characters, it decodes to two bytes.\n     *\n     * @param input Input to decode.\n     * @param webSafe True if we should use the web-safe alphabet.\n     * @return bytes representing the decoded value.\n     */\n    decodeStringToByteArray(input, webSafe) {\n        this.init_();\n        const charToByteMap = webSafe\n            ? this.charToByteMapWebSafe_\n            : this.charToByteMap_;\n        const output = [];\n        for (let i = 0; i < input.length;) {\n            const byte1 = charToByteMap[input.charAt(i++)];\n            const haveByte2 = i < input.length;\n            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n            ++i;\n            const haveByte3 = i < input.length;\n            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            const haveByte4 = i < input.length;\n            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n                throw new DecodeBase64StringError();\n            }\n            const outByte1 = (byte1 << 2) | (byte2 >> 4);\n            output.push(outByte1);\n            if (byte3 !== 64) {\n                const outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);\n                output.push(outByte2);\n                if (byte4 !== 64) {\n                    const outByte3 = ((byte3 << 6) & 0xc0) | byte4;\n                    output.push(outByte3);\n                }\n            }\n        }\n        return output;\n    },\n    /**\n     * Lazy static initialization function. Called before\n     * accessing any of the static map variables.\n     * @private\n     */\n    init_() {\n        if (!this.byteToCharMap_) {\n            this.byteToCharMap_ = {};\n            this.charToByteMap_ = {};\n            this.byteToCharMapWebSafe_ = {};\n            this.charToByteMapWebSafe_ = {};\n            // We want quick mappings back and forth, so we precompute two maps.\n            for (let i = 0; i < this.ENCODED_VALS.length; i++) {\n                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n                this.charToByteMap_[this.byteToCharMap_[i]] = i;\n                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n                // Be forgiving when decoding and correctly decode both encodings.\n                if (i >= this.ENCODED_VALS_BASE.length) {\n                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n                }\n            }\n        }\n    }\n};\n/**\n * An error encountered while decoding base64 string.\n */\nclass DecodeBase64StringError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'DecodeBase64StringError';\n    }\n}\n/**\n * URL-safe base64 encoding\n */\nconst base64Encode = function (str) {\n    const utf8Bytes = stringToByteArray$1(str);\n    return base64.encodeByteArray(utf8Bytes, true);\n};\n/**\n * URL-safe base64 encoding (without \".\" padding in the end).\n * e.g. Used in JSON Web Token (JWT) parts.\n */\nconst base64urlEncodeWithoutPadding = function (str) {\n    // Use base64url encoding and remove padding in the end (dot characters).\n    return base64Encode(str).replace(/\\./g, '');\n};\n/**\n * URL-safe base64 decoding\n *\n * NOTE: DO NOT use the global atob() function - it does NOT support the\n * base64Url variant encoding.\n *\n * @param str To be decoded\n * @return Decoded result, if possible\n */\nconst base64Decode = function (str) {\n    try {\n        return base64.decodeString(str, true);\n    }\n    catch (e) {\n        console.error('base64Decode failed: ', e);\n    }\n    return null;\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Do a deep-copy of basic JavaScript Objects or Arrays.\n */\nfunction deepCopy(value) {\n    return deepExtend(undefined, value);\n}\n/**\n * Copy properties from source to target (recursively allows extension\n * of Objects and Arrays).  Scalar values in the target are over-written.\n * If target is undefined, an object of the appropriate type will be created\n * (and returned).\n *\n * We recursively copy all child properties of plain Objects in the source- so\n * that namespace- like dictionaries are merged.\n *\n * Note that the target can be a function, in which case the properties in\n * the source Object are copied onto it as static properties of the Function.\n *\n * Note: we don't merge __proto__ to prevent prototype pollution\n */\nfunction deepExtend(target, source) {\n    if (!(source instanceof Object)) {\n        return source;\n    }\n    switch (source.constructor) {\n        case Date:\n            // Treat Dates like scalars; if the target date object had any child\n            // properties - they will be lost!\n            const dateValue = source;\n            return new Date(dateValue.getTime());\n        case Object:\n            if (target === undefined) {\n                target = {};\n            }\n            break;\n        case Array:\n            // Always copy the array source and overwrite the target.\n            target = [];\n            break;\n        default:\n            // Not a plain Object - treat it as a scalar.\n            return source;\n    }\n    for (const prop in source) {\n        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\n        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\n            continue;\n        }\n        target[prop] = deepExtend(target[prop], source[prop]);\n    }\n    return target;\n}\nfunction isValidKey(key) {\n    return key !== '__proto__';\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Polyfill for `globalThis` object.\n * @returns the `globalThis` object for the given environment.\n * @public\n */\nfunction getGlobal() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('Unable to locate global object.');\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;\n/**\n * Attempt to read defaults from a JSON string provided to\n * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in\n * process(.)env(.)__FIREBASE_DEFAULTS_PATH__\n * The dots are in parens because certain compilers (Vite?) cannot\n * handle seeing that variable in comments.\n * See https://github.com/firebase/firebase-js-sdk/issues/6838\n */\nconst getDefaultsFromEnvVariable = () => {\n    if (typeof process === 'undefined' || typeof process.env === 'undefined') {\n        return;\n    }\n    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\n    if (defaultsJsonString) {\n        return JSON.parse(defaultsJsonString);\n    }\n};\nconst getDefaultsFromCookie = () => {\n    if (typeof document === 'undefined') {\n        return;\n    }\n    let match;\n    try {\n        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\n    }\n    catch (e) {\n        // Some environments such as Angular Universal SSR have a\n        // `document` object but error on accessing `document.cookie`.\n        return;\n    }\n    const decoded = match && base64Decode(match[1]);\n    return decoded && JSON.parse(decoded);\n};\n/**\n * Get the __FIREBASE_DEFAULTS__ object. It checks in order:\n * (1) if such an object exists as a property of `globalThis`\n * (2) if such an object was provided on a shell environment variable\n * (3) if such an object exists in a cookie\n * @public\n */\nconst getDefaults = () => {\n    try {\n        return ((0,_postinstall_mjs__WEBPACK_IMPORTED_MODULE_0__.getDefaultsFromPostinstall)() ||\n            getDefaultsFromGlobal() ||\n            getDefaultsFromEnvVariable() ||\n            getDefaultsFromCookie());\n    }\n    catch (e) {\n        /**\n         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due\n         * to any environment case we have not accounted for. Log to\n         * info instead of swallowing so we can find these unknown cases\n         * and add paths for them if needed.\n         */\n        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\n        return;\n    }\n};\n/**\n * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object\n * for the given product.\n * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available\n * @public\n */\nconst getDefaultEmulatorHost = (productName) => { var _a, _b; return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName]; };\n/**\n * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object\n * for the given product.\n * @returns a pair of hostname and port like `[\"::1\", 4000]` if available\n * @public\n */\nconst getDefaultEmulatorHostnameAndPort = (productName) => {\n    const host = getDefaultEmulatorHost(productName);\n    if (!host) {\n        return undefined;\n    }\n    const separatorIndex = host.lastIndexOf(':'); // Finding the last since IPv6 addr also has colons.\n    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {\n        throw new Error(`Invalid host ${host} with no separate hostname and port!`);\n    }\n    // eslint-disable-next-line no-restricted-globals\n    const port = parseInt(host.substring(separatorIndex + 1), 10);\n    if (host[0] === '[') {\n        // Bracket-quoted `[ipv6addr]:port` => return \"ipv6addr\" (without brackets).\n        return [host.substring(1, separatorIndex - 1), port];\n    }\n    else {\n        return [host.substring(0, separatorIndex), port];\n    }\n};\n/**\n * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.\n * @public\n */\nconst getDefaultAppConfig = () => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config; };\n/**\n * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties\n * prefixed by \"_\")\n * @public\n */\nconst getExperimentalSetting = (name) => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`]; };\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Deferred {\n    constructor() {\n        this.reject = () => { };\n        this.resolve = () => { };\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n    /**\n     * Our API internals are not promisified and cannot because our callback APIs have subtle expectations around\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\n     */\n    wrapCallback(callback) {\n        return (error, value) => {\n            if (error) {\n                this.reject(error);\n            }\n            else {\n                this.resolve(value);\n            }\n            if (typeof callback === 'function') {\n                // Attaching noop handler just in case developer wasn't expecting\n                // promises\n                this.promise.catch(() => { });\n                // Some of our callbacks don't expect a value and our own tests\n                // assert that the parameter length is 1\n                if (callback.length === 1) {\n                    callback(error);\n                }\n                else {\n                    callback(error, value);\n                }\n            }\n        };\n    }\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction createMockUserToken(token, projectId) {\n    if (token.uid) {\n        throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\n    }\n    // Unsecured JWTs use \"none\" as the algorithm.\n    const header = {\n        alg: 'none',\n        type: 'JWT'\n    };\n    const project = projectId || 'demo-project';\n    const iat = token.iat || 0;\n    const sub = token.sub || token.user_id;\n    if (!sub) {\n        throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\n    }\n    const payload = Object.assign({ \n        // Set all required fields to decent defaults\n        iss: `https://securetoken.google.com/${project}`, aud: project, iat, exp: iat + 3600, auth_time: iat, sub, user_id: sub, firebase: {\n            sign_in_provider: 'custom',\n            identities: {}\n        } }, token);\n    // Unsecured JWTs use the empty string as a signature.\n    const signature = '';\n    return [\n        base64urlEncodeWithoutPadding(JSON.stringify(header)),\n        base64urlEncodeWithoutPadding(JSON.stringify(payload)),\n        signature\n    ].join('.');\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns navigator.userAgent string or '' if it's not defined.\n * @return user agent string\n */\nfunction getUA() {\n    if (typeof navigator !== 'undefined' &&\n        typeof navigator['userAgent'] === 'string') {\n        return navigator['userAgent'];\n    }\n    else {\n        return '';\n    }\n}\n/**\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\n *\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\n * wait for a callback.\n */\nfunction isMobileCordova() {\n    return (typeof window !== 'undefined' &&\n        // @ts-ignore Setting up an broadly applicable index signature for Window\n        // just to deal with this case would probably be a bad idea.\n        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&\n        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA()));\n}\n/**\n * Detect Node.js.\n *\n * @return true if Node.js environment is detected or specified.\n */\n// Node detection logic from: https://github.com/iliakan/detect-node/\nfunction isNode() {\n    var _a;\n    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;\n    if (forceEnvironment === 'node') {\n        return true;\n    }\n    else if (forceEnvironment === 'browser') {\n        return false;\n    }\n    try {\n        return (Object.prototype.toString.call(global.process) === '[object process]');\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * Detect Browser Environment.\n * Note: This will return true for certain test frameworks that are incompletely\n * mimicking a browser, and should not lead to assuming all browser APIs are\n * available.\n */\nfunction isBrowser() {\n    return typeof window !== 'undefined' || isWebWorker();\n}\n/**\n * Detect Web Worker context.\n */\nfunction isWebWorker() {\n    return (typeof WorkerGlobalScope !== 'undefined' &&\n        typeof self !== 'undefined' &&\n        self instanceof WorkerGlobalScope);\n}\n/**\n * Detect Cloudflare Worker context.\n */\nfunction isCloudflareWorker() {\n    return (typeof navigator !== 'undefined' &&\n        navigator.userAgent === 'Cloudflare-Workers');\n}\nfunction isBrowserExtension() {\n    const runtime = typeof chrome === 'object'\n        ? chrome.runtime\n        : typeof browser === 'object'\n            ? browser.runtime\n            : undefined;\n    return typeof runtime === 'object' && runtime.id !== undefined;\n}\n/**\n * Detect React Native.\n *\n * @return true if ReactNative environment is detected.\n */\nfunction isReactNative() {\n    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');\n}\n/** Detects Electron apps. */\nfunction isElectron() {\n    return getUA().indexOf('Electron/') >= 0;\n}\n/** Detects Internet Explorer. */\nfunction isIE() {\n    const ua = getUA();\n    return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;\n}\n/** Detects Universal Windows Platform apps. */\nfunction isUWP() {\n    return getUA().indexOf('MSAppHost/') >= 0;\n}\n/**\n * Detect whether the current SDK build is the Node version.\n *\n * @return true if it's the Node SDK build.\n */\nfunction isNodeSdk() {\n    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\n}\n/** Returns true if we are running in Safari. */\nfunction isSafari() {\n    return (!isNode() &&\n        !!navigator.userAgent &&\n        navigator.userAgent.includes('Safari') &&\n        !navigator.userAgent.includes('Chrome'));\n}\n/**\n * This method checks if indexedDB is supported by current browser/service worker context\n * @return true if indexedDB is supported by current browser/service worker context\n */\nfunction isIndexedDBAvailable() {\n    try {\n        return typeof indexedDB === 'object';\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\n * if errors occur during the database open operation.\n *\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\n * private browsing)\n */\nfunction validateIndexedDBOpenable() {\n    return new Promise((resolve, reject) => {\n        try {\n            let preExist = true;\n            const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';\n            const request = self.indexedDB.open(DB_CHECK_NAME);\n            request.onsuccess = () => {\n                request.result.close();\n                // delete database only when it doesn't pre-exist\n                if (!preExist) {\n                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);\n                }\n                resolve(true);\n            };\n            request.onupgradeneeded = () => {\n                preExist = false;\n            };\n            request.onerror = () => {\n                var _a;\n                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');\n            };\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\n *\n * This method checks whether cookie is enabled within current browser\n * @return true if cookie is enabled within current browser\n */\nfunction areCookiesEnabled() {\n    if (typeof navigator === 'undefined' || !navigator.cookieEnabled) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Standardized Firebase Error.\n *\n * Usage:\n *\n *   // TypeScript string literals for type-safe codes\n *   type Err =\n *     'unknown' |\n *     'object-not-found'\n *     ;\n *\n *   // Closure enum for type-safe error codes\n *   // at-enum {string}\n *   var Err = {\n *     UNKNOWN: 'unknown',\n *     OBJECT_NOT_FOUND: 'object-not-found',\n *   }\n *\n *   let errors: Map<Err, string> = {\n *     'generic-error': \"Unknown error\",\n *     'file-not-found': \"Could not find file: {$file}\",\n *   };\n *\n *   // Type-safe function - must pass a valid error code as param.\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\n *\n *   ...\n *   throw error.create(Err.GENERIC);\n *   ...\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\n *   ...\n *   // Service: Could not file file: foo.txt (service/file-not-found).\n *\n *   catch (e) {\n *     assert(e.message === \"Could not find file: foo.txt.\");\n *     if ((e as FirebaseError)?.code === 'service/file-not-found') {\n *       console.log(\"Could not read file: \" + e['file']);\n *     }\n *   }\n */\nconst ERROR_NAME = 'FirebaseError';\n// Based on code from:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\nclass FirebaseError extends Error {\n    constructor(\n    /** The error code for this error. */\n    code, message, \n    /** Custom data for this error. */\n    customData) {\n        super(message);\n        this.code = code;\n        this.customData = customData;\n        /** The custom name for all FirebaseErrors. */\n        this.name = ERROR_NAME;\n        // Fix For ES5\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        // TODO(dlarocque): Replace this with `new.target`: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#support-for-newtarget\n        //                   which we can now use since we no longer target ES5.\n        Object.setPrototypeOf(this, FirebaseError.prototype);\n        // Maintains proper stack trace for where our error was thrown.\n        // Only available on V8.\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ErrorFactory.prototype.create);\n        }\n    }\n}\nclass ErrorFactory {\n    constructor(service, serviceName, errors) {\n        this.service = service;\n        this.serviceName = serviceName;\n        this.errors = errors;\n    }\n    create(code, ...data) {\n        const customData = data[0] || {};\n        const fullCode = `${this.service}/${code}`;\n        const template = this.errors[code];\n        const message = template ? replaceTemplate(template, customData) : 'Error';\n        // Service Name: Error message (service/code).\n        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n        const error = new FirebaseError(fullCode, fullMessage, customData);\n        return error;\n    }\n}\nfunction replaceTemplate(template, data) {\n    return template.replace(PATTERN, (_, key) => {\n        const value = data[key];\n        return value != null ? String(value) : `<${key}?>`;\n    });\n}\nconst PATTERN = /\\{\\$([^}]+)}/g;\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Evaluates a JSON string into a javascript object.\n *\n * @param {string} str A string containing JSON.\n * @return {*} The javascript object representing the specified JSON.\n */\nfunction jsonEval(str) {\n    return JSON.parse(str);\n}\n/**\n * Returns JSON representing a javascript object.\n * @param {*} data JavaScript object to be stringified.\n * @return {string} The JSON contents of the object.\n */\nfunction stringify(data) {\n    return JSON.stringify(data);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Decodes a Firebase auth. token into constituent parts.\n *\n * Notes:\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst decode = function (token) {\n    let header = {}, claims = {}, data = {}, signature = '';\n    try {\n        const parts = token.split('.');\n        header = jsonEval(base64Decode(parts[0]) || '');\n        claims = jsonEval(base64Decode(parts[1]) || '');\n        signature = parts[2];\n        data = claims['d'] || {};\n        delete claims['d'];\n    }\n    catch (e) { }\n    return {\n        header,\n        claims,\n        data,\n        signature\n    };\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isValidTimestamp = function (token) {\n    const claims = decode(token).claims;\n    const now = Math.floor(new Date().getTime() / 1000);\n    let validSince = 0, validUntil = 0;\n    if (typeof claims === 'object') {\n        if (claims.hasOwnProperty('nbf')) {\n            validSince = claims['nbf'];\n        }\n        else if (claims.hasOwnProperty('iat')) {\n            validSince = claims['iat'];\n        }\n        if (claims.hasOwnProperty('exp')) {\n            validUntil = claims['exp'];\n        }\n        else {\n            // token will expire after 24h by default\n            validUntil = validSince + 86400;\n        }\n    }\n    return (!!now &&\n        !!validSince &&\n        !!validUntil &&\n        now >= validSince &&\n        now <= validUntil);\n};\n/**\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\n *\n * Notes:\n * - May return null if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst issuedAtTime = function (token) {\n    const claims = decode(token).claims;\n    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\n        return claims['iat'];\n    }\n    return null;\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isValidFormat = function (token) {\n    const decoded = decode(token), claims = decoded.claims;\n    return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');\n};\n/**\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isAdmin = function (token) {\n    const claims = decode(token).claims;\n    return typeof claims === 'object' && claims['admin'] === true;\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction safeGet(obj, key) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return obj[key];\n    }\n    else {\n        return undefined;\n    }\n}\nfunction isEmpty(obj) {\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction map(obj, fn, contextObj) {\n    const res = {};\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            res[key] = fn.call(contextObj, obj[key], key, obj);\n        }\n    }\n    return res;\n}\n/**\n * Deep equal two objects. Support Arrays and Objects.\n */\nfunction deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    for (const k of aKeys) {\n        if (!bKeys.includes(k)) {\n            return false;\n        }\n        const aProp = a[k];\n        const bProp = b[k];\n        if (isObject(aProp) && isObject(bProp)) {\n            if (!deepEqual(aProp, bProp)) {\n                return false;\n            }\n        }\n        else if (aProp !== bProp) {\n            return false;\n        }\n    }\n    for (const k of bKeys) {\n        if (!aKeys.includes(k)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isObject(thing) {\n    return thing !== null && typeof thing === 'object';\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Rejects if the given promise doesn't resolve in timeInMS milliseconds.\n * @internal\n */\nfunction promiseWithTimeout(promise, timeInMS = 2000) {\n    const deferredPromise = new Deferred();\n    setTimeout(() => deferredPromise.reject('timeout!'), timeInMS);\n    promise.then(deferredPromise.resolve, deferredPromise.reject);\n    return deferredPromise.promise;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\n * params object (e.g. {arg: 'val', arg2: 'val2'})\n * Note: You must prepend it with ? when adding it to a URL.\n */\nfunction querystring(querystringParams) {\n    const params = [];\n    for (const [key, value] of Object.entries(querystringParams)) {\n        if (Array.isArray(value)) {\n            value.forEach(arrayVal => {\n                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));\n            });\n        }\n        else {\n            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n        }\n    }\n    return params.length ? '&' + params.join('&') : '';\n}\n/**\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\n * (e.g. {arg: 'val', arg2: 'val2'})\n */\nfunction querystringDecode(querystring) {\n    const obj = {};\n    const tokens = querystring.replace(/^\\?/, '').split('&');\n    tokens.forEach(token => {\n        if (token) {\n            const [key, value] = token.split('=');\n            obj[decodeURIComponent(key)] = decodeURIComponent(value);\n        }\n    });\n    return obj;\n}\n/**\n * Extract the query string part of a URL, including the leading question mark (if present).\n */\nfunction extractQuerystring(url) {\n    const queryStart = url.indexOf('?');\n    if (!queryStart) {\n        return '';\n    }\n    const fragmentStart = url.indexOf('#', queryStart);\n    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview SHA-1 cryptographic hash.\n * Variable names follow the notation in FIPS PUB 180-3:\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\n *\n * Usage:\n *   var sha1 = new sha1();\n *   sha1.update(bytes);\n *   var hash = sha1.digest();\n *\n * Performance:\n *   Chrome 23:   ~400 Mbit/s\n *   Firefox 16:  ~250 Mbit/s\n *\n */\n/**\n * SHA-1 cryptographic hash constructor.\n *\n * The properties declared here are discussed in the above algorithm document.\n * @constructor\n * @final\n * @struct\n */\nclass Sha1 {\n    constructor() {\n        /**\n         * Holds the previous values of accumulated variables a-e in the compress_\n         * function.\n         * @private\n         */\n        this.chain_ = [];\n        /**\n         * A buffer holding the partially computed hash result.\n         * @private\n         */\n        this.buf_ = [];\n        /**\n         * An array of 80 bytes, each a part of the message to be hashed.  Referred to\n         * as the message schedule in the docs.\n         * @private\n         */\n        this.W_ = [];\n        /**\n         * Contains data needed to pad messages less than 64 bytes.\n         * @private\n         */\n        this.pad_ = [];\n        /**\n         * @private {number}\n         */\n        this.inbuf_ = 0;\n        /**\n         * @private {number}\n         */\n        this.total_ = 0;\n        this.blockSize = 512 / 8;\n        this.pad_[0] = 128;\n        for (let i = 1; i < this.blockSize; ++i) {\n            this.pad_[i] = 0;\n        }\n        this.reset();\n    }\n    reset() {\n        this.chain_[0] = 0x67452301;\n        this.chain_[1] = 0xefcdab89;\n        this.chain_[2] = 0x98badcfe;\n        this.chain_[3] = 0x10325476;\n        this.chain_[4] = 0xc3d2e1f0;\n        this.inbuf_ = 0;\n        this.total_ = 0;\n    }\n    /**\n     * Internal compress helper function.\n     * @param buf Block to compress.\n     * @param offset Offset of the block in the buffer.\n     * @private\n     */\n    compress_(buf, offset) {\n        if (!offset) {\n            offset = 0;\n        }\n        const W = this.W_;\n        // get 16 big endian words\n        if (typeof buf === 'string') {\n            for (let i = 0; i < 16; i++) {\n                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\n                // have a bug that turns the post-increment ++ operator into pre-increment\n                // during JIT compilation.  We have code that depends heavily on SHA-1 for\n                // correctness and which is affected by this bug, so I've removed all uses\n                // of post-increment ++ in which the result value is used.  We can revert\n                // this change once the Safari bug\n                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\n                // most clients have been updated.\n                W[i] =\n                    (buf.charCodeAt(offset) << 24) |\n                        (buf.charCodeAt(offset + 1) << 16) |\n                        (buf.charCodeAt(offset + 2) << 8) |\n                        buf.charCodeAt(offset + 3);\n                offset += 4;\n            }\n        }\n        else {\n            for (let i = 0; i < 16; i++) {\n                W[i] =\n                    (buf[offset] << 24) |\n                        (buf[offset + 1] << 16) |\n                        (buf[offset + 2] << 8) |\n                        buf[offset + 3];\n                offset += 4;\n            }\n        }\n        // expand to 80 words\n        for (let i = 16; i < 80; i++) {\n            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;\n        }\n        let a = this.chain_[0];\n        let b = this.chain_[1];\n        let c = this.chain_[2];\n        let d = this.chain_[3];\n        let e = this.chain_[4];\n        let f, k;\n        // TODO(user): Try to unroll this loop to speed up the computation.\n        for (let i = 0; i < 80; i++) {\n            if (i < 40) {\n                if (i < 20) {\n                    f = d ^ (b & (c ^ d));\n                    k = 0x5a827999;\n                }\n                else {\n                    f = b ^ c ^ d;\n                    k = 0x6ed9eba1;\n                }\n            }\n            else {\n                if (i < 60) {\n                    f = (b & c) | (d & (b | c));\n                    k = 0x8f1bbcdc;\n                }\n                else {\n                    f = b ^ c ^ d;\n                    k = 0xca62c1d6;\n                }\n            }\n            const t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;\n            e = d;\n            d = c;\n            c = ((b << 30) | (b >>> 2)) & 0xffffffff;\n            b = a;\n            a = t;\n        }\n        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;\n        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;\n        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;\n        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;\n        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;\n    }\n    update(bytes, length) {\n        // TODO(johnlenz): tighten the function signature and remove this check\n        if (bytes == null) {\n            return;\n        }\n        if (length === undefined) {\n            length = bytes.length;\n        }\n        const lengthMinusBlock = length - this.blockSize;\n        let n = 0;\n        // Using local instead of member variables gives ~5% speedup on Firefox 16.\n        const buf = this.buf_;\n        let inbuf = this.inbuf_;\n        // The outer while loop should execute at most twice.\n        while (n < length) {\n            // When we have no data in the block to top up, we can directly process the\n            // input buffer (assuming it contains sufficient data). This gives ~25%\n            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\n            // the data is provided in large chunks (or in multiples of 64 bytes).\n            if (inbuf === 0) {\n                while (n <= lengthMinusBlock) {\n                    this.compress_(bytes, n);\n                    n += this.blockSize;\n                }\n            }\n            if (typeof bytes === 'string') {\n                while (n < length) {\n                    buf[inbuf] = bytes.charCodeAt(n);\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        // Jump to the outer loop so we use the full-block optimization.\n                        break;\n                    }\n                }\n            }\n            else {\n                while (n < length) {\n                    buf[inbuf] = bytes[n];\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        // Jump to the outer loop so we use the full-block optimization.\n                        break;\n                    }\n                }\n            }\n        }\n        this.inbuf_ = inbuf;\n        this.total_ += length;\n    }\n    /** @override */\n    digest() {\n        const digest = [];\n        let totalBits = this.total_ * 8;\n        // Add pad 0x80 0x00*.\n        if (this.inbuf_ < 56) {\n            this.update(this.pad_, 56 - this.inbuf_);\n        }\n        else {\n            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\n        }\n        // Add # bits.\n        for (let i = this.blockSize - 1; i >= 56; i--) {\n            this.buf_[i] = totalBits & 255;\n            totalBits /= 256; // Don't use bit-shifting here!\n        }\n        this.compress_(this.buf_);\n        let n = 0;\n        for (let i = 0; i < 5; i++) {\n            for (let j = 24; j >= 0; j -= 8) {\n                digest[n] = (this.chain_[i] >> j) & 255;\n                ++n;\n            }\n        }\n        return digest;\n    }\n}\n\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nfunction createSubscribe(executor, onNoObservers) {\n    const proxy = new ObserverProxy(executor, onNoObservers);\n    return proxy.subscribe.bind(proxy);\n}\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nclass ObserverProxy {\n    /**\n     * @param executor Function which can make calls to a single Observer\n     *     as a proxy.\n     * @param onNoObservers Callback when count of Observers goes to zero.\n     */\n    constructor(executor, onNoObservers) {\n        this.observers = [];\n        this.unsubscribes = [];\n        this.observerCount = 0;\n        // Micro-task scheduling by calling task.then().\n        this.task = Promise.resolve();\n        this.finalized = false;\n        this.onNoObservers = onNoObservers;\n        // Call the executor asynchronously so subscribers that are called\n        // synchronously after the creation of the subscribe function\n        // can still receive the very first value generated in the executor.\n        this.task\n            .then(() => {\n            executor(this);\n        })\n            .catch(e => {\n            this.error(e);\n        });\n    }\n    next(value) {\n        this.forEachObserver((observer) => {\n            observer.next(value);\n        });\n    }\n    error(error) {\n        this.forEachObserver((observer) => {\n            observer.error(error);\n        });\n        this.close(error);\n    }\n    complete() {\n        this.forEachObserver((observer) => {\n            observer.complete();\n        });\n        this.close();\n    }\n    /**\n     * Subscribe function that can be used to add an Observer to the fan-out list.\n     *\n     * - We require that no event is sent to a subscriber synchronously to their\n     *   call to subscribe().\n     */\n    subscribe(nextOrObserver, error, complete) {\n        let observer;\n        if (nextOrObserver === undefined &&\n            error === undefined &&\n            complete === undefined) {\n            throw new Error('Missing Observer.');\n        }\n        // Assemble an Observer object when passed as callback functions.\n        if (implementsAnyMethods(nextOrObserver, [\n            'next',\n            'error',\n            'complete'\n        ])) {\n            observer = nextOrObserver;\n        }\n        else {\n            observer = {\n                next: nextOrObserver,\n                error,\n                complete\n            };\n        }\n        if (observer.next === undefined) {\n            observer.next = noop;\n        }\n        if (observer.error === undefined) {\n            observer.error = noop;\n        }\n        if (observer.complete === undefined) {\n            observer.complete = noop;\n        }\n        const unsub = this.unsubscribeOne.bind(this, this.observers.length);\n        // Attempt to subscribe to a terminated Observable - we\n        // just respond to the Observer with the final error or complete\n        // event.\n        if (this.finalized) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.task.then(() => {\n                try {\n                    if (this.finalError) {\n                        observer.error(this.finalError);\n                    }\n                    else {\n                        observer.complete();\n                    }\n                }\n                catch (e) {\n                    // nothing\n                }\n                return;\n            });\n        }\n        this.observers.push(observer);\n        return unsub;\n    }\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\n    // any unsubscribed Observer.\n    unsubscribeOne(i) {\n        if (this.observers === undefined || this.observers[i] === undefined) {\n            return;\n        }\n        delete this.observers[i];\n        this.observerCount -= 1;\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n            this.onNoObservers(this);\n        }\n    }\n    forEachObserver(fn) {\n        if (this.finalized) {\n            // Already closed by previous event....just eat the additional values.\n            return;\n        }\n        // Since sendOne calls asynchronously - there is no chance that\n        // this.observers will become undefined.\n        for (let i = 0; i < this.observers.length; i++) {\n            this.sendOne(i, fn);\n        }\n    }\n    // Call the Observer via one of it's callback function. We are careful to\n    // confirm that the observe has not been unsubscribed since this asynchronous\n    // function had been queued.\n    sendOne(i, fn) {\n        // Execute the callback asynchronously\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(() => {\n            if (this.observers !== undefined && this.observers[i] !== undefined) {\n                try {\n                    fn(this.observers[i]);\n                }\n                catch (e) {\n                    // Ignore exceptions raised in Observers or missing methods of an\n                    // Observer.\n                    // Log error to console. b/31404806\n                    if (typeof console !== 'undefined' && console.error) {\n                        console.error(e);\n                    }\n                }\n            }\n        });\n    }\n    close(err) {\n        if (this.finalized) {\n            return;\n        }\n        this.finalized = true;\n        if (err !== undefined) {\n            this.finalError = err;\n        }\n        // Proxy is no longer needed - garbage collect references\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(() => {\n            this.observers = undefined;\n            this.onNoObservers = undefined;\n        });\n    }\n}\n/** Turn synchronous function into one called asynchronously. */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction async(fn, onError) {\n    return (...args) => {\n        Promise.resolve(true)\n            .then(() => {\n            fn(...args);\n        })\n            .catch((error) => {\n            if (onError) {\n                onError(error);\n            }\n        });\n    };\n}\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n    if (typeof obj !== 'object' || obj === null) {\n        return false;\n    }\n    for (const method of methods) {\n        if (method in obj && typeof obj[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction noop() {\n    // do nothing\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Check to make sure the appropriate number of arguments are provided for a public function.\n * Throws an error if it fails.\n *\n * @param fnName The function name\n * @param minCount The minimum number of arguments to allow for the function call\n * @param maxCount The maximum number of argument to allow for the function call\n * @param argCount The actual number of arguments provided.\n */\nconst validateArgCount = function (fnName, minCount, maxCount, argCount) {\n    let argError;\n    if (argCount < minCount) {\n        argError = 'at least ' + minCount;\n    }\n    else if (argCount > maxCount) {\n        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;\n    }\n    if (argError) {\n        const error = fnName +\n            ' failed: Was called with ' +\n            argCount +\n            (argCount === 1 ? ' argument.' : ' arguments.') +\n            ' Expects ' +\n            argError +\n            '.';\n        throw new Error(error);\n    }\n};\n/**\n * Generates a string to prefix an error message about failed argument validation\n *\n * @param fnName The function name\n * @param argName The name of the argument\n * @return The prefix to add to the error thrown for validation.\n */\nfunction errorPrefix(fnName, argName) {\n    return `${fnName} failed: ${argName} argument `;\n}\n/**\n * @param fnName\n * @param argumentNumber\n * @param namespace\n * @param optional\n */\nfunction validateNamespace(fnName, namespace, optional) {\n    if (optional && !namespace) {\n        return;\n    }\n    if (typeof namespace !== 'string') {\n        //TODO: I should do more validation here. We only allow certain chars in namespaces.\n        throw new Error(errorPrefix(fnName, 'namespace') + 'must be a valid firebase namespace.');\n    }\n}\nfunction validateCallback(fnName, argumentName, \n// eslint-disable-next-line @typescript-eslint/ban-types\ncallback, optional) {\n    if (optional && !callback) {\n        return;\n    }\n    if (typeof callback !== 'function') {\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid function.');\n    }\n}\nfunction validateContextObject(fnName, argumentName, context, optional) {\n    if (optional && !context) {\n        return;\n    }\n    if (typeof context !== 'object' || context === null) {\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid context object.');\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\n// so it's been modified.\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\n// use 2 characters in JavaScript.  All 4-byte UTF-8 characters begin with a first\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\n// pair).\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\n/**\n * @param {string} str\n * @return {Array}\n */\nconst stringToByteArray = function (str) {\n    const out = [];\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        let c = str.charCodeAt(i);\n        // Is this the lead surrogate in a surrogate pair?\n        if (c >= 0xd800 && c <= 0xdbff) {\n            const high = c - 0xd800; // the high 10 bits.\n            i++;\n            assert(i < str.length, 'Surrogate pair missing trail surrogate.');\n            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\n            c = 0x10000 + (high << 10) + low;\n        }\n        if (c < 128) {\n            out[p++] = c;\n        }\n        else if (c < 2048) {\n            out[p++] = (c >> 6) | 192;\n            out[p++] = (c & 63) | 128;\n        }\n        else if (c < 65536) {\n            out[p++] = (c >> 12) | 224;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n        else {\n            out[p++] = (c >> 18) | 240;\n            out[p++] = ((c >> 12) & 63) | 128;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n    }\n    return out;\n};\n/**\n * Calculate length without actually converting; useful for doing cheaper validation.\n * @param {string} str\n * @return {number}\n */\nconst stringLength = function (str) {\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        if (c < 128) {\n            p++;\n        }\n        else if (c < 2048) {\n            p += 2;\n        }\n        else if (c >= 0xd800 && c <= 0xdbff) {\n            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\n            p += 4;\n            i++; // skip trail surrogate.\n        }\n        else {\n            p += 3;\n        }\n    }\n    return p;\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The amount of milliseconds to exponentially increase.\n */\nconst DEFAULT_INTERVAL_MILLIS = 1000;\n/**\n * The factor to backoff by.\n * Should be a number greater than 1.\n */\nconst DEFAULT_BACKOFF_FACTOR = 2;\n/**\n * The maximum milliseconds to increase to.\n *\n * <p>Visible for testing\n */\nconst MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\n/**\n * The percentage of backoff time to randomize by.\n * See\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\n * for context.\n *\n * <p>Visible for testing\n */\nconst RANDOM_FACTOR = 0.5;\n/**\n * Based on the backoff method from\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\n */\nfunction calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {\n    // Calculates an exponentially increasing value.\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\n    // and count to restore state.\n    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\n    // A random \"fuzz\" to avoid waves of retries.\n    // Deviation: randomFactor is required.\n    const randomWait = Math.round(\n    // A fraction of the backoff value to add/subtract.\n    // Deviation: changes multiplication order to improve readability.\n    RANDOM_FACTOR *\n        currBaseValue *\n        // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\n        // if we add or subtract.\n        (Math.random() - 0.5) *\n        2);\n    // Limits backoff to max to avoid effectively permanent backoff.\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provide English ordinal letters after a number\n */\nfunction ordinal(i) {\n    if (!Number.isFinite(i)) {\n        return `${i}`;\n    }\n    return i + indicator(i);\n}\nfunction indicator(i) {\n    i = Math.abs(i);\n    const cent = i % 100;\n    if (cent >= 10 && cent <= 20) {\n        return 'th';\n    }\n    const dec = i % 10;\n    if (dec === 1) {\n        return 'st';\n    }\n    if (dec === 2) {\n        return 'nd';\n    }\n    if (dec === 3) {\n        return 'rd';\n    }\n    return 'th';\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getModularInstance(service) {\n    if (service && service._delegate) {\n        return service._delegate;\n    }\n    else {\n        return service;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Overriding the constant (we should be the only ones doing this)\nCONSTANTS.NODE_CLIENT = true;\n\n\n//# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3Qvbm9kZS1lc20vaW5kZXgubm9kZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEVBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsRUFBRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRLHdFQUF3RSxLQUFLOztBQUVoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhLEdBQUcsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCLElBQUksU0FBUyxHQUFHLFNBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSTtBQUN2RCxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsTUFBTSxJQUFJOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWEsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0IsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRLFVBQVUsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxL0I7QUFDci9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGFsa190b190ZXh0Ly4uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L25vZGUtZXNtL2luZGV4Lm5vZGUuZXNtLmpzP2IyMTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0RGVmYXVsdHNGcm9tUG9zdGluc3RhbGwgfSBmcm9tICcuLi9wb3N0aW5zdGFsbC5tanMnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZpcmViYXNlIGNvbnN0YW50cy4gIFNvbWUgb2YgdGhlc2UgKEBkZWZpbmVzKSBjYW4gYmUgb3ZlcnJpZGRlbiBhdCBjb21waWxlLXRpbWUuXG4gKi9cbmNvbnN0IENPTlNUQU5UUyA9IHtcbiAgICAvKipcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIGNsaWVudCBOb2RlLmpzIFNESy5cbiAgICAgKi9cbiAgICBOT0RFX0NMSUVOVDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGlzIHRoZSBBZG1pbiBOb2RlLmpzIFNESy5cbiAgICAgKi9cbiAgICBOT0RFX0FETUlOOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBGaXJlYmFzZSBTREsgVmVyc2lvblxuICAgICAqL1xuICAgIFNES19WRVJTSU9OOiAnJHtKU0NPUkVfVkVSU0lPTn0nXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHByb3ZpZGVkIGFzc2VydGlvbiBpcyBmYWxzeVxuICovXG5jb25zdCBhc3NlcnQgPSBmdW5jdGlvbiAoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IobWVzc2FnZSk7XG4gICAgfVxufTtcbi8qKlxuICogUmV0dXJucyBhbiBFcnJvciBvYmplY3Qgc3VpdGFibGUgZm9yIHRocm93aW5nLlxuICovXG5jb25zdCBhc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignRmlyZWJhc2UgRGF0YWJhc2UgKCcgK1xuICAgICAgICBDT05TVEFOVFMuU0RLX1ZFUlNJT04gK1xuICAgICAgICAnKSBJTlRFUk5BTCBBU1NFUlQgRkFJTEVEOiAnICtcbiAgICAgICAgbWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3Qgc3RyaW5nVG9CeXRlQXJyYXkkMSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGxldCBwID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgICAgb3V0W3ArK10gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxuICAgICAgICAgICAgaSArIDEgPCBzdHIubGVuZ3RoICYmXG4gICAgICAgICAgICAoc3RyLmNoYXJDb2RlQXQoaSArIDEpICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgwM2ZmKTtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTgpIHwgMjQwO1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIG51bWJlcnMgaW50byB0aGUgc3RyaW5nIGdpdmVuIGJ5IHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZVxuICogY2hhcmFjdGVycyB0byB3aGljaCB0aGUgbnVtYmVycyBjb3JyZXNwb25kLlxuICogQHBhcmFtIGJ5dGVzIEFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGNoYXJhY3RlcnMuXG4gKiBAcmV0dXJuIFN0cmluZ2lmaWNhdGlvbiBvZiB0aGUgYXJyYXkuXG4gKi9cbmNvbnN0IGJ5dGVBcnJheVRvU3RyaW5nID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgLy8gVE9ETyh1c2VyKTogVXNlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMgaWYvd2hlbiBhdmFpbGFibGVcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgcG9zID0gMCwgYyA9IDA7XG4gICAgd2hpbGUgKHBvcyA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjMSA9IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYzEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMxID4gMTkxICYmIGMxIDwgMjI0KSB7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMxICYgMzEpIDw8IDYpIHwgKGMyICYgNjMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjMSA+IDIzOSAmJiBjMSA8IDM2NSkge1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xuICAgICAgICAgICAgY29uc3QgYzMgPSBieXRlc1twb3MrK107XG4gICAgICAgICAgICBjb25zdCBjNCA9IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IHUgPSAoKChjMSAmIDcpIDw8IDE4KSB8ICgoYzIgJiA2MykgPDwgMTIpIHwgKChjMyAmIDYzKSA8PCA2KSB8IChjNCAmIDYzKSkgLVxuICAgICAgICAgICAgICAgIDB4MTAwMDA7XG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODAwICsgKHUgPj4gMTApKTtcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGRjMDAgKyAodSAmIDEwMjMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xuICAgICAgICAgICAgY29uc3QgYzMgPSBieXRlc1twb3MrK107XG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjMSAmIDE1KSA8PCAxMikgfCAoKGMyICYgNjMpIDw8IDYpIHwgKGMzICYgNjMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xufTtcbi8vIFdlIGRlZmluZSBpdCBhcyBhbiBvYmplY3QgbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY2xhc3MgYmVjYXVzZSBhIGNsYXNzIGNvbXBpbGVkIGRvd24gdG8gZXM1IGNhbid0XG4vLyBiZSB0cmVlc2hha2VkLiBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvMTY5MVxuLy8gU3RhdGljIGxvb2t1cCBtYXBzLCBsYXppbHkgcG9wdWxhdGVkIGJ5IGluaXRfKClcbi8vIFRPRE8oZGxhcm9jcXVlKTogRGVmaW5lIHRoaXMgYXMgYSBjbGFzcywgc2luY2Ugd2Ugbm8gbG9uZ2VyIHRhcmdldCBFUzUuXG5jb25zdCBiYXNlNjQgPSB7XG4gICAgLyoqXG4gICAgICogTWFwcyBieXRlcyB0byBjaGFyYWN0ZXJzLlxuICAgICAqL1xuICAgIGJ5dGVUb0NoYXJNYXBfOiBudWxsLFxuICAgIC8qKlxuICAgICAqIE1hcHMgY2hhcmFjdGVycyB0byBieXRlcy5cbiAgICAgKi9cbiAgICBjaGFyVG9CeXRlTWFwXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIHdlYnNhZmUgY2hhcmFjdGVycy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ5dGVUb0NoYXJNYXBXZWJTYWZlXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBNYXBzIHdlYnNhZmUgY2hhcmFjdGVycyB0byBieXRlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNoYXJUb0J5dGVNYXBXZWJTYWZlXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBPdXIgZGVmYXVsdCBhbHBoYWJldCwgc2hhcmVkIGJldHdlZW5cbiAgICAgKiBFTkNPREVEX1ZBTFMgYW5kIEVOQ09ERURfVkFMU19XRUJTQUZFXG4gICAgICovXG4gICAgRU5DT0RFRF9WQUxTX0JBU0U6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicgKyAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonICsgJzAxMjM0NTY3ODknLFxuICAgIC8qKlxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LiBWYWx1ZSA2NCAoPSkgaXMgc3BlY2lhbDsgaXQgbWVhbnMgXCJub3RoaW5nLlwiXG4gICAgICovXG4gICAgZ2V0IEVOQ09ERURfVkFMUygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnKy89JztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE91ciB3ZWJzYWZlIGFscGhhYmV0LlxuICAgICAqL1xuICAgIGdldCBFTkNPREVEX1ZBTFNfV0VCU0FGRSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnLV8uJztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHRoZSBhdG9iIGFuZCBidG9hIGZ1bmN0aW9ucy4gVGhpcyBleHRlbnNpb25cbiAgICAgKiBzdGFydGVkIGF0IE1vemlsbGEgYnV0IGlzIG5vdyBpbXBsZW1lbnRlZCBieSBtYW55IGJyb3dzZXJzLiBXZSB1c2UgdGhlXG4gICAgICogQVNTVU1FXyogdmFyaWFibGVzIHRvIGF2b2lkIHB1bGxpbmcgaW4gdGhlIGZ1bGwgdXNlcmFnZW50IGRldGVjdGlvbiBsaWJyYXJ5XG4gICAgICogYnV0IHN0aWxsIGFsbG93aW5nIHRoZSBzdGFuZGFyZCBwZXItYnJvd3NlciBjb21waWxhdGlvbnMuXG4gICAgICpcbiAgICAgKi9cbiAgICBIQVNfTkFUSVZFX1NVUFBPUlQ6IHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nLFxuICAgIC8qKlxuICAgICAqIEJhc2U2NC1lbmNvZGUgYW4gYXJyYXkgb2YgYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgQW4gYXJyYXkgb2YgYnl0ZXMgKG51bWJlcnMgd2l0aFxuICAgICAqICAgICB2YWx1ZSBpbiBbMCwgMjU1XSkgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIEJvb2xlYW4gaW5kaWNhdGluZyB3ZSBzaG91bGQgdXNlIHRoZVxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZW5jb2RlQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdlbmNvZGVCeXRlQXJyYXkgdGFrZXMgYW4gYXJyYXkgYXMgYSBwYXJhbWV0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRfKCk7XG4gICAgICAgIGNvbnN0IGJ5dGVUb0NoYXJNYXAgPSB3ZWJTYWZlXG4gICAgICAgICAgICA/IHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfXG4gICAgICAgICAgICA6IHRoaXMuYnl0ZVRvQ2hhck1hcF87XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlMSA9IGlucHV0W2ldO1xuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSArIDEgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBieXRlMiA9IGhhdmVCeXRlMiA/IGlucHV0W2kgKyAxXSA6IDA7XG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTMgPSBpICsgMiA8IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gaW5wdXRbaSArIDJdIDogMDtcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUxID0gYnl0ZTEgPj4gMjtcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMSAmIDB4MDMpIDw8IDQpIHwgKGJ5dGUyID4+IDQpO1xuICAgICAgICAgICAgbGV0IG91dEJ5dGUzID0gKChieXRlMiAmIDB4MGYpIDw8IDIpIHwgKGJ5dGUzID4+IDYpO1xuICAgICAgICAgICAgbGV0IG91dEJ5dGU0ID0gYnl0ZTMgJiAweDNmO1xuICAgICAgICAgICAgaWYgKCFoYXZlQnl0ZTMpIHtcbiAgICAgICAgICAgICAgICBvdXRCeXRlNCA9IDY0O1xuICAgICAgICAgICAgICAgIGlmICghaGF2ZUJ5dGUyKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dEJ5dGUzID0gNjQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0LnB1c2goYnl0ZVRvQ2hhck1hcFtvdXRCeXRlMV0sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTJdLCBieXRlVG9DaGFyTWFwW291dEJ5dGUzXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlNF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBCYXNlNjQtZW5jb2RlIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IEEgc3RyaW5nIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBJZiB0cnVlLCB3ZSBzaG91bGQgdXNlIHRoZVxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZW5jb2RlU3RyaW5nKGlucHV0LCB3ZWJTYWZlKSB7XG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XG4gICAgICAgIC8vIGEgbmF0aXZlIGJhc2U2NCBlbmNvZGVyIGluIHRoZSBmb3JtIG9mIFwiYnRvYS9hdG9iXCJcbiAgICAgICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICF3ZWJTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gYnRvYShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlQnl0ZUFycmF5KHN0cmluZ1RvQnl0ZUFycmF5JDEoaW5wdXQpLCB3ZWJTYWZlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgdG8gZGVjb2RlLlxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIFRydWUgaWYgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXG4gICAgICogQHJldHVybiBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZVN0cmluZyhpbnB1dCwgd2ViU2FmZSkge1xuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgTW96aWxsYSBicm93c2VycyB0aGF0IGltcGxlbWVudFxuICAgICAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF0b2IoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlQXJyYXlUb1N0cmluZyh0aGlzLmRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogSW4gYmFzZS02NCBkZWNvZGluZywgZ3JvdXBzIG9mIGZvdXIgY2hhcmFjdGVycyBhcmUgY29udmVydGVkIGludG8gdGhyZWVcbiAgICAgKiBieXRlcy4gIElmIHRoZSBlbmNvZGVyIGRpZCBub3QgYXBwbHkgcGFkZGluZywgdGhlIGlucHV0IGxlbmd0aCBtYXkgbm90XG4gICAgICogYmUgYSBtdWx0aXBsZSBvZiA0LlxuICAgICAqXG4gICAgICogSW4gdGhpcyBjYXNlLCB0aGUgbGFzdCBncm91cCB3aWxsIGhhdmUgZmV3ZXIgdGhhbiA0IGNoYXJhY3RlcnMsIGFuZFxuICAgICAqIHBhZGRpbmcgd2lsbCBiZSBpbmZlcnJlZC4gIElmIHRoZSBncm91cCBoYXMgb25lIG9yIHR3byBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzXG4gICAgICogdG8gb25lIGJ5dGUuICBJZiB0aGUgZ3JvdXAgaGFzIHRocmVlIGNoYXJhY3RlcnMsIGl0IGRlY29kZXMgdG8gdHdvIGJ5dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IElucHV0IHRvIGRlY29kZS5cbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlIHdlYi1zYWZlIGFscGhhYmV0LlxuICAgICAqIEByZXR1cm4gYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSB7XG4gICAgICAgIHRoaXMuaW5pdF8oKTtcbiAgICAgICAgY29uc3QgY2hhclRvQnl0ZU1hcCA9IHdlYlNhZmVcbiAgICAgICAgICAgID8gdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9cbiAgICAgICAgICAgIDogdGhpcy5jaGFyVG9CeXRlTWFwXztcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMiA9IGkgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBieXRlMiA9IGhhdmVCeXRlMiA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDA7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTMgPSBpIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlNCA9IGkgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBieXRlNCA9IGhhdmVCeXRlNCA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgaWYgKGJ5dGUxID09IG51bGwgfHwgYnl0ZTIgPT0gbnVsbCB8fCBieXRlMyA9PSBudWxsIHx8IGJ5dGU0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUxID0gKGJ5dGUxIDw8IDIpIHwgKGJ5dGUyID4+IDQpO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTEpO1xuICAgICAgICAgICAgaWYgKGJ5dGUzICE9PSA2NCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMiA8PCA0KSAmIDB4ZjApIHwgKGJ5dGUzID4+IDIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUyKTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZTQgIT09IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUzID0gKChieXRlMyA8PCA2KSAmIDB4YzApIHwgYnl0ZTQ7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIExhenkgc3RhdGljIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uLiBDYWxsZWQgYmVmb3JlXG4gICAgICogYWNjZXNzaW5nIGFueSBvZiB0aGUgc3RhdGljIG1hcCB2YXJpYWJsZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0XygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ5dGVUb0NoYXJNYXBfKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfID0ge307XG4gICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfID0ge307XG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlXyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV8gPSB7fTtcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgcXVpY2sgbWFwcGluZ3MgYmFjayBhbmQgZm9ydGgsIHNvIHdlIHByZWNvbXB1dGUgdHdvIG1hcHMuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRU5DT0RFRF9WQUxTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuYnl0ZVRvQ2hhck1hcF9baV1dID0gaTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldXSA9IGk7XG4gICAgICAgICAgICAgICAgLy8gQmUgZm9yZ2l2aW5nIHdoZW4gZGVjb2RpbmcgYW5kIGNvcnJlY3RseSBkZWNvZGUgYm90aCBlbmNvZGluZ3MuXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKV0gPSBpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1t0aGlzLkVOQ09ERURfVkFMUy5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBBbiBlcnJvciBlbmNvdW50ZXJlZCB3aGlsZSBkZWNvZGluZyBiYXNlNjQgc3RyaW5nLlxuICovXG5jbGFzcyBEZWNvZGVCYXNlNjRTdHJpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0RlY29kZUJhc2U2NFN0cmluZ0Vycm9yJztcbiAgICB9XG59XG4vKipcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZ1xuICovXG5jb25zdCBiYXNlNjRFbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgY29uc3QgdXRmOEJ5dGVzID0gc3RyaW5nVG9CeXRlQXJyYXkkMShzdHIpO1xuICAgIHJldHVybiBiYXNlNjQuZW5jb2RlQnl0ZUFycmF5KHV0ZjhCeXRlcywgdHJ1ZSk7XG59O1xuLyoqXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmcgKHdpdGhvdXQgXCIuXCIgcGFkZGluZyBpbiB0aGUgZW5kKS5cbiAqIGUuZy4gVXNlZCBpbiBKU09OIFdlYiBUb2tlbiAoSldUKSBwYXJ0cy5cbiAqL1xuY29uc3QgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgLy8gVXNlIGJhc2U2NHVybCBlbmNvZGluZyBhbmQgcmVtb3ZlIHBhZGRpbmcgaW4gdGhlIGVuZCAoZG90IGNoYXJhY3RlcnMpLlxuICAgIHJldHVybiBiYXNlNjRFbmNvZGUoc3RyKS5yZXBsYWNlKC9cXC4vZywgJycpO1xufTtcbi8qKlxuICogVVJMLXNhZmUgYmFzZTY0IGRlY29kaW5nXG4gKlxuICogTk9URTogRE8gTk9UIHVzZSB0aGUgZ2xvYmFsIGF0b2IoKSBmdW5jdGlvbiAtIGl0IGRvZXMgTk9UIHN1cHBvcnQgdGhlXG4gKiBiYXNlNjRVcmwgdmFyaWFudCBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0gc3RyIFRvIGJlIGRlY29kZWRcbiAqIEByZXR1cm4gRGVjb2RlZCByZXN1bHQsIGlmIHBvc3NpYmxlXG4gKi9cbmNvbnN0IGJhc2U2NERlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYmFzZTY0LmRlY29kZVN0cmluZyhzdHIsIHRydWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdiYXNlNjREZWNvZGUgZmFpbGVkOiAnLCBlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEbyBhIGRlZXAtY29weSBvZiBiYXNpYyBKYXZhU2NyaXB0IE9iamVjdHMgb3IgQXJyYXlzLlxuICovXG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xuICAgIHJldHVybiBkZWVwRXh0ZW5kKHVuZGVmaW5lZCwgdmFsdWUpO1xufVxuLyoqXG4gKiBDb3B5IHByb3BlcnRpZXMgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IChyZWN1cnNpdmVseSBhbGxvd3MgZXh0ZW5zaW9uXG4gKiBvZiBPYmplY3RzIGFuZCBBcnJheXMpLiAgU2NhbGFyIHZhbHVlcyBpbiB0aGUgdGFyZ2V0IGFyZSBvdmVyLXdyaXR0ZW4uXG4gKiBJZiB0YXJnZXQgaXMgdW5kZWZpbmVkLCBhbiBvYmplY3Qgb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGUgd2lsbCBiZSBjcmVhdGVkXG4gKiAoYW5kIHJldHVybmVkKS5cbiAqXG4gKiBXZSByZWN1cnNpdmVseSBjb3B5IGFsbCBjaGlsZCBwcm9wZXJ0aWVzIG9mIHBsYWluIE9iamVjdHMgaW4gdGhlIHNvdXJjZS0gc29cbiAqIHRoYXQgbmFtZXNwYWNlLSBsaWtlIGRpY3Rpb25hcmllcyBhcmUgbWVyZ2VkLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgdGFyZ2V0IGNhbiBiZSBhIGZ1bmN0aW9uLCBpbiB3aGljaCBjYXNlIHRoZSBwcm9wZXJ0aWVzIGluXG4gKiB0aGUgc291cmNlIE9iamVjdCBhcmUgY29waWVkIG9udG8gaXQgYXMgc3RhdGljIHByb3BlcnRpZXMgb2YgdGhlIEZ1bmN0aW9uLlxuICpcbiAqIE5vdGU6IHdlIGRvbid0IG1lcmdlIF9fcHJvdG9fXyB0byBwcmV2ZW50IHByb3RvdHlwZSBwb2xsdXRpb25cbiAqL1xuZnVuY3Rpb24gZGVlcEV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG4gICAgc3dpdGNoIChzb3VyY2UuY29uc3RydWN0b3IpIHtcbiAgICAgICAgY2FzZSBEYXRlOlxuICAgICAgICAgICAgLy8gVHJlYXQgRGF0ZXMgbGlrZSBzY2FsYXJzOyBpZiB0aGUgdGFyZ2V0IGRhdGUgb2JqZWN0IGhhZCBhbnkgY2hpbGRcbiAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgLSB0aGV5IHdpbGwgYmUgbG9zdCFcbiAgICAgICAgICAgIGNvbnN0IGRhdGVWYWx1ZSA9IHNvdXJjZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlVmFsdWUuZ2V0VGltZSgpKTtcbiAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgICAgLy8gQWx3YXlzIGNvcHkgdGhlIGFycmF5IHNvdXJjZSBhbmQgb3ZlcndyaXRlIHRoZSB0YXJnZXQuXG4gICAgICAgICAgICB0YXJnZXQgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gTm90IGEgcGxhaW4gT2JqZWN0IC0gdHJlYXQgaXQgYXMgYSBzY2FsYXIuXG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIC8vIHVzZSBpc1ZhbGlkS2V5IHRvIGd1YXJkIGFnYWluc3QgcHJvdG90eXBlIHBvbGx1dGlvbi4gU2VlIGh0dHBzOi8vc255ay5pby92dWxuL1NOWUstSlMtTE9EQVNILTQ1MDIwMlxuICAgICAgICBpZiAoIXNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCAhaXNWYWxpZEtleShwcm9wKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gZGVlcEV4dGVuZCh0YXJnZXRbcHJvcF0sIHNvdXJjZVtwcm9wXSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkgIT09ICdfX3Byb3RvX18nO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgYGdsb2JhbFRoaXNgIG9iamVjdC5cbiAqIEByZXR1cm5zIHRoZSBgZ2xvYmFsVGhpc2Agb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0LicpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgZ2V0RGVmYXVsdHNGcm9tR2xvYmFsID0gKCkgPT4gZ2V0R2xvYmFsKCkuX19GSVJFQkFTRV9ERUZBVUxUU19fO1xuLyoqXG4gKiBBdHRlbXB0IHRvIHJlYWQgZGVmYXVsdHMgZnJvbSBhIEpTT04gc3RyaW5nIHByb3ZpZGVkIHRvXG4gKiBwcm9jZXNzKC4pZW52KC4pX19GSVJFQkFTRV9ERUZBVUxUU19fIG9yIGEgSlNPTiBmaWxlIHdob3NlIHBhdGggaXMgaW5cbiAqIHByb2Nlc3MoLillbnYoLilfX0ZJUkVCQVNFX0RFRkFVTFRTX1BBVEhfX1xuICogVGhlIGRvdHMgYXJlIGluIHBhcmVucyBiZWNhdXNlIGNlcnRhaW4gY29tcGlsZXJzIChWaXRlPykgY2Fubm90XG4gKiBoYW5kbGUgc2VlaW5nIHRoYXQgdmFyaWFibGUgaW4gY29tbWVudHMuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9pc3N1ZXMvNjgzOFxuICovXG5jb25zdCBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBwcm9jZXNzLmVudiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0c0pzb25TdHJpbmcgPSBwcm9jZXNzLmVudi5fX0ZJUkVCQVNFX0RFRkFVTFRTX187XG4gICAgaWYgKGRlZmF1bHRzSnNvblN0cmluZykge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkZWZhdWx0c0pzb25TdHJpbmcpO1xuICAgIH1cbn07XG5jb25zdCBnZXREZWZhdWx0c0Zyb21Db29raWUgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbWF0Y2g7XG4gICAgdHJ5IHtcbiAgICAgICAgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2goL19fRklSRUJBU0VfREVGQVVMVFNfXz0oW147XSspLyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFNvbWUgZW52aXJvbm1lbnRzIHN1Y2ggYXMgQW5ndWxhciBVbml2ZXJzYWwgU1NSIGhhdmUgYVxuICAgICAgICAvLyBgZG9jdW1lbnRgIG9iamVjdCBidXQgZXJyb3Igb24gYWNjZXNzaW5nIGBkb2N1bWVudC5jb29raWVgLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZWQgPSBtYXRjaCAmJiBiYXNlNjREZWNvZGUobWF0Y2hbMV0pO1xuICAgIHJldHVybiBkZWNvZGVkICYmIEpTT04ucGFyc2UoZGVjb2RlZCk7XG59O1xuLyoqXG4gKiBHZXQgdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuIEl0IGNoZWNrcyBpbiBvcmRlcjpcbiAqICgxKSBpZiBzdWNoIGFuIG9iamVjdCBleGlzdHMgYXMgYSBwcm9wZXJ0eSBvZiBgZ2xvYmFsVGhpc2BcbiAqICgyKSBpZiBzdWNoIGFuIG9iamVjdCB3YXMgcHJvdmlkZWQgb24gYSBzaGVsbCBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICogKDMpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBpbiBhIGNvb2tpZVxuICogQHB1YmxpY1xuICovXG5jb25zdCBnZXREZWZhdWx0cyA9ICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKGdldERlZmF1bHRzRnJvbVBvc3RpbnN0YWxsKCkgfHxcbiAgICAgICAgICAgIGdldERlZmF1bHRzRnJvbUdsb2JhbCgpIHx8XG4gICAgICAgICAgICBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSgpIHx8XG4gICAgICAgICAgICBnZXREZWZhdWx0c0Zyb21Db29raWUoKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXRjaC1hbGwgZm9yIGJlaW5nIHVuYWJsZSB0byBnZXQgX19GSVJFQkFTRV9ERUZBVUxUU19fIGR1ZVxuICAgICAgICAgKiB0byBhbnkgZW52aXJvbm1lbnQgY2FzZSB3ZSBoYXZlIG5vdCBhY2NvdW50ZWQgZm9yLiBMb2cgdG9cbiAgICAgICAgICogaW5mbyBpbnN0ZWFkIG9mIHN3YWxsb3dpbmcgc28gd2UgY2FuIGZpbmQgdGhlc2UgdW5rbm93biBjYXNlc1xuICAgICAgICAgKiBhbmQgYWRkIHBhdGhzIGZvciB0aGVtIGlmIG5lZWRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgVW5hYmxlIHRvIGdldCBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gZHVlIHRvOiAke2V9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIGVtdWxhdG9yIGhvc3Qgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0XG4gKiBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXG4gKiBAcmV0dXJucyBhIFVSTCBob3N0IGZvcm1hdHRlZCBsaWtlIGAxMjcuMC4wLjE6OTk5OWAgb3IgYFs6OjFdOjQwMDBgIGlmIGF2YWlsYWJsZVxuICogQHB1YmxpY1xuICovXG5jb25zdCBnZXREZWZhdWx0RW11bGF0b3JIb3N0ID0gKHByb2R1Y3ROYW1lKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW11bGF0b3JIb3N0cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW3Byb2R1Y3ROYW1lXTsgfTtcbi8qKlxuICogUmV0dXJucyBlbXVsYXRvciBob3N0bmFtZSBhbmQgcG9ydCBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3RcbiAqIGZvciB0aGUgZ2l2ZW4gcHJvZHVjdC5cbiAqIEByZXR1cm5zIGEgcGFpciBvZiBob3N0bmFtZSBhbmQgcG9ydCBsaWtlIGBbXCI6OjFcIiwgNDAwMF1gIGlmIGF2YWlsYWJsZVxuICogQHB1YmxpY1xuICovXG5jb25zdCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQgPSAocHJvZHVjdE5hbWUpID0+IHtcbiAgICBjb25zdCBob3N0ID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdChwcm9kdWN0TmFtZSk7XG4gICAgaWYgKCFob3N0KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHNlcGFyYXRvckluZGV4ID0gaG9zdC5sYXN0SW5kZXhPZignOicpOyAvLyBGaW5kaW5nIHRoZSBsYXN0IHNpbmNlIElQdjYgYWRkciBhbHNvIGhhcyBjb2xvbnMuXG4gICAgaWYgKHNlcGFyYXRvckluZGV4IDw9IDAgfHwgc2VwYXJhdG9ySW5kZXggKyAxID09PSBob3N0Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaG9zdCAke2hvc3R9IHdpdGggbm8gc2VwYXJhdGUgaG9zdG5hbWUgYW5kIHBvcnQhYCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICBjb25zdCBwb3J0ID0gcGFyc2VJbnQoaG9zdC5zdWJzdHJpbmcoc2VwYXJhdG9ySW5kZXggKyAxKSwgMTApO1xuICAgIGlmIChob3N0WzBdID09PSAnWycpIHtcbiAgICAgICAgLy8gQnJhY2tldC1xdW90ZWQgYFtpcHY2YWRkcl06cG9ydGAgPT4gcmV0dXJuIFwiaXB2NmFkZHJcIiAod2l0aG91dCBicmFja2V0cykuXG4gICAgICAgIHJldHVybiBbaG9zdC5zdWJzdHJpbmcoMSwgc2VwYXJhdG9ySW5kZXggLSAxKSwgcG9ydF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW2hvc3Quc3Vic3RyaW5nKDAsIHNlcGFyYXRvckluZGV4KSwgcG9ydF07XG4gICAgfVxufTtcbi8qKlxuICogUmV0dXJucyBGaXJlYmFzZSBhcHAgY29uZmlnIHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZ2V0RGVmYXVsdEFwcENvbmZpZyA9ICgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZzsgfTtcbi8qKlxuICogUmV0dXJucyBhbiBleHBlcmltZW50YWwgc2V0dGluZyBvbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdCAocHJvcGVydGllc1xuICogcHJlZml4ZWQgYnkgXCJfXCIpXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGdldEV4cGVyaW1lbnRhbFNldHRpbmcgPSAobmFtZSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYF8ke25hbWV9YF07IH07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBEZWZlcnJlZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVqZWN0ID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLnJlc29sdmUgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE91ciBBUEkgaW50ZXJuYWxzIGFyZSBub3QgcHJvbWlzaWZpZWQgYW5kIGNhbm5vdCBiZWNhdXNlIG91ciBjYWxsYmFjayBBUElzIGhhdmUgc3VidGxlIGV4cGVjdGF0aW9ucyBhcm91bmRcbiAgICAgKiBpbnZva2luZyBwcm9taXNlcyBpbmxpbmUsIHdoaWNoIFByb21pc2VzIGFyZSBmb3JiaWRkZW4gdG8gZG8uIFRoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9uYWwgbm9kZS1zdHlsZSBjYWxsYmFja1xuICAgICAqIGFuZCByZXR1cm5zIGEgbm9kZS1zdHlsZSBjYWxsYmFjayB3aGljaCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBEZWZlcnJlZCdzIHByb21pc2UuXG4gICAgICovXG4gICAgd3JhcENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiAoZXJyb3IsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIEF0dGFjaGluZyBub29wIGhhbmRsZXIganVzdCBpbiBjYXNlIGRldmVsb3BlciB3YXNuJ3QgZXhwZWN0aW5nXG4gICAgICAgICAgICAgICAgLy8gcHJvbWlzZXNcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2UuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgICAgICAgICAvLyBTb21lIG9mIG91ciBjYWxsYmFja3MgZG9uJ3QgZXhwZWN0IGEgdmFsdWUgYW5kIG91ciBvd24gdGVzdHNcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQgdGhhdCB0aGUgcGFyYW1ldGVyIGxlbmd0aCBpcyAxXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNb2NrVXNlclRva2VuKHRva2VuLCBwcm9qZWN0SWQpIHtcbiAgICBpZiAodG9rZW4udWlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFwidWlkXCIgZmllbGQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBieSBtb2NrVXNlclRva2VuLiBQbGVhc2UgdXNlIFwic3ViXCIgaW5zdGVhZCBmb3IgRmlyZWJhc2UgQXV0aCBVc2VyIElELicpO1xuICAgIH1cbiAgICAvLyBVbnNlY3VyZWQgSldUcyB1c2UgXCJub25lXCIgYXMgdGhlIGFsZ29yaXRobS5cbiAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICAgIGFsZzogJ25vbmUnLFxuICAgICAgICB0eXBlOiAnSldUJ1xuICAgIH07XG4gICAgY29uc3QgcHJvamVjdCA9IHByb2plY3RJZCB8fCAnZGVtby1wcm9qZWN0JztcbiAgICBjb25zdCBpYXQgPSB0b2tlbi5pYXQgfHwgMDtcbiAgICBjb25zdCBzdWIgPSB0b2tlbi5zdWIgfHwgdG9rZW4udXNlcl9pZDtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2NrVXNlclRva2VuIG11c3QgY29udGFpbiAnc3ViJyBvciAndXNlcl9pZCcgZmllbGQhXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7IFxuICAgICAgICAvLyBTZXQgYWxsIHJlcXVpcmVkIGZpZWxkcyB0byBkZWNlbnQgZGVmYXVsdHNcbiAgICAgICAgaXNzOiBgaHR0cHM6Ly9zZWN1cmV0b2tlbi5nb29nbGUuY29tLyR7cHJvamVjdH1gLCBhdWQ6IHByb2plY3QsIGlhdCwgZXhwOiBpYXQgKyAzNjAwLCBhdXRoX3RpbWU6IGlhdCwgc3ViLCB1c2VyX2lkOiBzdWIsIGZpcmViYXNlOiB7XG4gICAgICAgICAgICBzaWduX2luX3Byb3ZpZGVyOiAnY3VzdG9tJyxcbiAgICAgICAgICAgIGlkZW50aXRpZXM6IHt9XG4gICAgICAgIH0gfSwgdG9rZW4pO1xuICAgIC8vIFVuc2VjdXJlZCBKV1RzIHVzZSB0aGUgZW1wdHkgc3RyaW5nIGFzIGEgc2lnbmF0dXJlLlxuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICcnO1xuICAgIHJldHVybiBbXG4gICAgICAgIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KGhlYWRlcikpLFxuICAgICAgICBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSksXG4gICAgICAgIHNpZ25hdHVyZVxuICAgIF0uam9pbignLicpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIG5hdmlnYXRvci51c2VyQWdlbnQgc3RyaW5nIG9yICcnIGlmIGl0J3Mgbm90IGRlZmluZWQuXG4gKiBAcmV0dXJuIHVzZXIgYWdlbnQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdldFVBKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yWyd1c2VyQWdlbnQnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvclsndXNlckFnZW50J107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlY3QgQ29yZG92YSAvIFBob25lR2FwIC8gSW9uaWMgZnJhbWV3b3JrcyBvbiBhIG1vYmlsZSBkZXZpY2UuXG4gKlxuICogRGVsaWJlcmF0ZWx5IGRvZXMgbm90IHJlbHkgb24gY2hlY2tpbmcgYGZpbGU6Ly9gIFVSTHMgKGFzIHRoaXMgZmFpbHMgUGhvbmVHYXBcbiAqIGluIHRoZSBSaXBwbGUgZW11bGF0b3IpIG5vciBDb3Jkb3ZhIGBvbkRldmljZVJlYWR5YCwgd2hpY2ggd291bGQgbm9ybWFsbHlcbiAqIHdhaXQgZm9yIGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGlzTW9iaWxlQ29yZG92YSgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgU2V0dGluZyB1cCBhbiBicm9hZGx5IGFwcGxpY2FibGUgaW5kZXggc2lnbmF0dXJlIGZvciBXaW5kb3dcbiAgICAgICAgLy8ganVzdCB0byBkZWFsIHdpdGggdGhpcyBjYXNlIHdvdWxkIHByb2JhYmx5IGJlIGEgYmFkIGlkZWEuXG4gICAgICAgICEhKHdpbmRvd1snY29yZG92YSddIHx8IHdpbmRvd1sncGhvbmVnYXAnXSB8fCB3aW5kb3dbJ1Bob25lR2FwJ10pICYmXG4gICAgICAgIC9pb3N8aXBob25lfGlwb2R8aXBhZHxhbmRyb2lkfGJsYWNrYmVycnl8aWVtb2JpbGUvaS50ZXN0KGdldFVBKCkpKTtcbn1cbi8qKlxuICogRGV0ZWN0IE5vZGUuanMuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIE5vZGUuanMgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQgb3Igc3BlY2lmaWVkLlxuICovXG4vLyBOb2RlIGRldGVjdGlvbiBsb2dpYyBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vaWxpYWthbi9kZXRlY3Qtbm9kZS9cbmZ1bmN0aW9uIGlzTm9kZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZm9yY2VFbnZpcm9ubWVudCA9IChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JjZUVudmlyb25tZW50O1xuICAgIGlmIChmb3JjZUVudmlyb25tZW50ID09PSAnbm9kZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZvcmNlRW52aXJvbm1lbnQgPT09ICdicm93c2VyJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogRGV0ZWN0IEJyb3dzZXIgRW52aXJvbm1lbnQuXG4gKiBOb3RlOiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgZm9yIGNlcnRhaW4gdGVzdCBmcmFtZXdvcmtzIHRoYXQgYXJlIGluY29tcGxldGVseVxuICogbWltaWNraW5nIGEgYnJvd3NlciwgYW5kIHNob3VsZCBub3QgbGVhZCB0byBhc3N1bWluZyBhbGwgYnJvd3NlciBBUElzIGFyZVxuICogYXZhaWxhYmxlLlxuICovXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnIHx8IGlzV2ViV29ya2VyKCk7XG59XG4vKipcbiAqIERldGVjdCBXZWIgV29ya2VyIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGlzV2ViV29ya2VyKCkge1xuICAgIHJldHVybiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKTtcbn1cbi8qKlxuICogRGV0ZWN0IENsb3VkZmxhcmUgV29ya2VyIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGlzQ2xvdWRmbGFyZVdvcmtlcigpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQgPT09ICdDbG91ZGZsYXJlLVdvcmtlcnMnKTtcbn1cbmZ1bmN0aW9uIGlzQnJvd3NlckV4dGVuc2lvbigpIHtcbiAgICBjb25zdCBydW50aW1lID0gdHlwZW9mIGNocm9tZSA9PT0gJ29iamVjdCdcbiAgICAgICAgPyBjaHJvbWUucnVudGltZVxuICAgICAgICA6IHR5cGVvZiBicm93c2VyID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyBicm93c2VyLnJ1bnRpbWVcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB0eXBlb2YgcnVudGltZSA9PT0gJ29iamVjdCcgJiYgcnVudGltZS5pZCAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBEZXRlY3QgUmVhY3QgTmF0aXZlLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudCBpcyBkZXRlY3RlZC5cbiAqL1xuZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvclsncHJvZHVjdCddID09PSAnUmVhY3ROYXRpdmUnKTtcbn1cbi8qKiBEZXRlY3RzIEVsZWN0cm9uIGFwcHMuICovXG5mdW5jdGlvbiBpc0VsZWN0cm9uKCkge1xuICAgIHJldHVybiBnZXRVQSgpLmluZGV4T2YoJ0VsZWN0cm9uLycpID49IDA7XG59XG4vKiogRGV0ZWN0cyBJbnRlcm5ldCBFeHBsb3Jlci4gKi9cbmZ1bmN0aW9uIGlzSUUoKSB7XG4gICAgY29uc3QgdWEgPSBnZXRVQSgpO1xuICAgIHJldHVybiB1YS5pbmRleE9mKCdNU0lFICcpID49IDAgfHwgdWEuaW5kZXhPZignVHJpZGVudC8nKSA+PSAwO1xufVxuLyoqIERldGVjdHMgVW5pdmVyc2FsIFdpbmRvd3MgUGxhdGZvcm0gYXBwcy4gKi9cbmZ1bmN0aW9uIGlzVVdQKCkge1xuICAgIHJldHVybiBnZXRVQSgpLmluZGV4T2YoJ01TQXBwSG9zdC8nKSA+PSAwO1xufVxuLyoqXG4gKiBEZXRlY3Qgd2hldGhlciB0aGUgY3VycmVudCBTREsgYnVpbGQgaXMgdGhlIE5vZGUgdmVyc2lvbi5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgaXQncyB0aGUgTm9kZSBTREsgYnVpbGQuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZVNkaygpIHtcbiAgICByZXR1cm4gQ09OU1RBTlRTLk5PREVfQ0xJRU5UID09PSB0cnVlIHx8IENPTlNUQU5UUy5OT0RFX0FETUlOID09PSB0cnVlO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgcnVubmluZyBpbiBTYWZhcmkuICovXG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgICByZXR1cm4gKCFpc05vZGUoKSAmJlxuICAgICAgICAhIW5hdmlnYXRvci51c2VyQWdlbnQgJiZcbiAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnU2FmYXJpJykgJiZcbiAgICAgICAgIW5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ0Nocm9tZScpKTtcbn1cbi8qKlxuICogVGhpcyBtZXRob2QgY2hlY2tzIGlmIGluZGV4ZWREQiBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBicm93c2VyL3NlcnZpY2Ugd29ya2VyIGNvbnRleHRcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXhlZERCQXZhaWxhYmxlKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5kZXhlZERCID09PSAnb2JqZWN0JztcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBtZXRob2QgdmFsaWRhdGVzIGJyb3dzZXIvc3cgY29udGV4dCBmb3IgaW5kZXhlZERCIGJ5IG9wZW5pbmcgYSBkdW1teSBpbmRleGVkREIgZGF0YWJhc2UgYW5kIHJlamVjdFxuICogaWYgZXJyb3JzIG9jY3VyIGR1cmluZyB0aGUgZGF0YWJhc2Ugb3BlbiBvcGVyYXRpb24uXG4gKlxuICogQHRocm93cyBleGNlcHRpb24gaWYgY3VycmVudCBicm93c2VyL3N3IGNvbnRleHQgY2FuJ3QgcnVuIGlkYi5vcGVuIChleDogU2FmYXJpIGlmcmFtZSwgRmlyZWZveFxuICogcHJpdmF0ZSBicm93c2luZylcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHByZUV4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IERCX0NIRUNLX05BTUUgPSAndmFsaWRhdGUtYnJvd3Nlci1jb250ZXh0LWZvci1pbmRleGVkZGItYW5hbHl0aWNzLW1vZHVsZSc7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gc2VsZi5pbmRleGVkREIub3BlbihEQl9DSEVDS19OQU1FKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzdWx0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIGRhdGFiYXNlIG9ubHkgd2hlbiBpdCBkb2Vzbid0IHByZS1leGlzdFxuICAgICAgICAgICAgICAgIGlmICghcHJlRXhpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoREJfQ0hFQ0tfTkFNRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJlRXhpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJlamVjdCgoKF9hID0gcmVxdWVzdC5lcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lc3NhZ2UpIHx8ICcnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqXG4gKiBUaGlzIG1ldGhvZCBjaGVja3Mgd2hldGhlciBjb29raWUgaXMgZW5hYmxlZCB3aXRoaW4gY3VycmVudCBicm93c2VyXG4gKiBAcmV0dXJuIHRydWUgaWYgY29va2llIGlzIGVuYWJsZWQgd2l0aGluIGN1cnJlbnQgYnJvd3NlclxuICovXG5mdW5jdGlvbiBhcmVDb29raWVzRW5hYmxlZCgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci5jb29raWVFbmFibGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU3RhbmRhcmRpemVkIEZpcmViYXNlIEVycm9yLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgLy8gVHlwZVNjcmlwdCBzdHJpbmcgbGl0ZXJhbHMgZm9yIHR5cGUtc2FmZSBjb2Rlc1xuICogICB0eXBlIEVyciA9XG4gKiAgICAgJ3Vua25vd24nIHxcbiAqICAgICAnb2JqZWN0LW5vdC1mb3VuZCdcbiAqICAgICA7XG4gKlxuICogICAvLyBDbG9zdXJlIGVudW0gZm9yIHR5cGUtc2FmZSBlcnJvciBjb2Rlc1xuICogICAvLyBhdC1lbnVtIHtzdHJpbmd9XG4gKiAgIHZhciBFcnIgPSB7XG4gKiAgICAgVU5LTk9XTjogJ3Vua25vd24nLFxuICogICAgIE9CSkVDVF9OT1RfRk9VTkQ6ICdvYmplY3Qtbm90LWZvdW5kJyxcbiAqICAgfVxuICpcbiAqICAgbGV0IGVycm9yczogTWFwPEVyciwgc3RyaW5nPiA9IHtcbiAqICAgICAnZ2VuZXJpYy1lcnJvcic6IFwiVW5rbm93biBlcnJvclwiLFxuICogICAgICdmaWxlLW5vdC1mb3VuZCc6IFwiQ291bGQgbm90IGZpbmQgZmlsZTogeyRmaWxlfVwiLFxuICogICB9O1xuICpcbiAqICAgLy8gVHlwZS1zYWZlIGZ1bmN0aW9uIC0gbXVzdCBwYXNzIGEgdmFsaWQgZXJyb3IgY29kZSBhcyBwYXJhbS5cbiAqICAgbGV0IGVycm9yID0gbmV3IEVycm9yRmFjdG9yeTxFcnI+KCdzZXJ2aWNlJywgJ1NlcnZpY2UnLCBlcnJvcnMpO1xuICpcbiAqICAgLi4uXG4gKiAgIHRocm93IGVycm9yLmNyZWF0ZShFcnIuR0VORVJJQyk7XG4gKiAgIC4uLlxuICogICB0aHJvdyBlcnJvci5jcmVhdGUoRXJyLkZJTEVfTk9UX0ZPVU5ELCB7J2ZpbGUnOiBmaWxlTmFtZX0pO1xuICogICAuLi5cbiAqICAgLy8gU2VydmljZTogQ291bGQgbm90IGZpbGUgZmlsZTogZm9vLnR4dCAoc2VydmljZS9maWxlLW5vdC1mb3VuZCkuXG4gKlxuICogICBjYXRjaCAoZSkge1xuICogICAgIGFzc2VydChlLm1lc3NhZ2UgPT09IFwiQ291bGQgbm90IGZpbmQgZmlsZTogZm9vLnR4dC5cIik7XG4gKiAgICAgaWYgKChlIGFzIEZpcmViYXNlRXJyb3IpPy5jb2RlID09PSAnc2VydmljZS9maWxlLW5vdC1mb3VuZCcpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGQgbm90IHJlYWQgZmlsZTogXCIgKyBlWydmaWxlJ10pO1xuICogICAgIH1cbiAqICAgfVxuICovXG5jb25zdCBFUlJPUl9OQU1FID0gJ0ZpcmViYXNlRXJyb3InO1xuLy8gQmFzZWQgb24gY29kZSBmcm9tOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjQ3VzdG9tX0Vycm9yX1R5cGVzXG5jbGFzcyBGaXJlYmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgZXJyb3IgY29kZSBmb3IgdGhpcyBlcnJvci4gKi9cbiAgICBjb2RlLCBtZXNzYWdlLCBcbiAgICAvKiogQ3VzdG9tIGRhdGEgZm9yIHRoaXMgZXJyb3IuICovXG4gICAgY3VzdG9tRGF0YSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5jdXN0b21EYXRhID0gY3VzdG9tRGF0YTtcbiAgICAgICAgLyoqIFRoZSBjdXN0b20gbmFtZSBmb3IgYWxsIEZpcmViYXNlRXJyb3JzLiAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBFUlJPUl9OQU1FO1xuICAgICAgICAvLyBGaXggRm9yIEVTNVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQtd2lraS9ibG9iL21hc3Rlci9CcmVha2luZy1DaGFuZ2VzLm1kI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29ya1xuICAgICAgICAvLyBUT0RPKGRsYXJvY3F1ZSk6IFJlcGxhY2UgdGhpcyB3aXRoIGBuZXcudGFyZ2V0YDogaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svcmVsZWFzZS1ub3Rlcy90eXBlc2NyaXB0LTItMi5odG1sI3N1cHBvcnQtZm9yLW5ld3RhcmdldFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICB3aGljaCB3ZSBjYW4gbm93IHVzZSBzaW5jZSB3ZSBubyBsb25nZXIgdGFyZ2V0IEVTNS5cbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEZpcmViYXNlRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24uXG4gICAgICAgIC8vIE9ubHkgYXZhaWxhYmxlIG9uIFY4LlxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEVycm9yRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEVycm9yRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSwgc2VydmljZU5hbWUsIGVycm9ycykge1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICBjcmVhdGUoY29kZSwgLi4uZGF0YSkge1xuICAgICAgICBjb25zdCBjdXN0b21EYXRhID0gZGF0YVswXSB8fCB7fTtcbiAgICAgICAgY29uc3QgZnVsbENvZGUgPSBgJHt0aGlzLnNlcnZpY2V9LyR7Y29kZX1gO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuZXJyb3JzW2NvZGVdO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGVtcGxhdGUgPyByZXBsYWNlVGVtcGxhdGUodGVtcGxhdGUsIGN1c3RvbURhdGEpIDogJ0Vycm9yJztcbiAgICAgICAgLy8gU2VydmljZSBOYW1lOiBFcnJvciBtZXNzYWdlIChzZXJ2aWNlL2NvZGUpLlxuICAgICAgICBjb25zdCBmdWxsTWVzc2FnZSA9IGAke3RoaXMuc2VydmljZU5hbWV9OiAke21lc3NhZ2V9ICgke2Z1bGxDb2RlfSkuYDtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRmlyZWJhc2VFcnJvcihmdWxsQ29kZSwgZnVsbE1lc3NhZ2UsIGN1c3RvbURhdGEpO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZVRlbXBsYXRlKHRlbXBsYXRlLCBkYXRhKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoUEFUVEVSTiwgKF8sIGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFba2V5XTtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyBTdHJpbmcodmFsdWUpIDogYDwke2tleX0/PmA7XG4gICAgfSk7XG59XG5jb25zdCBQQVRURVJOID0gL1xce1xcJChbXn1dKyl9L2c7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEV2YWx1YXRlcyBhIEpTT04gc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGNvbnRhaW5pbmcgSlNPTi5cbiAqIEByZXR1cm4geyp9IFRoZSBqYXZhc2NyaXB0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBKU09OLlxuICovXG5mdW5jdGlvbiBqc29uRXZhbChzdHIpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xufVxuLyoqXG4gKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50aW5nIGEgamF2YXNjcmlwdCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IGRhdGEgSmF2YVNjcmlwdCBvYmplY3QgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBKU09OIGNvbnRlbnRzIG9mIHRoZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeShkYXRhKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gaW50byBjb25zdGl0dWVudCBwYXJ0cy5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiB3aXRoIGludmFsaWQgLyBpbmNvbXBsZXRlIGNsYWltcyBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmNvbnN0IGRlY29kZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGxldCBoZWFkZXIgPSB7fSwgY2xhaW1zID0ge30sIGRhdGEgPSB7fSwgc2lnbmF0dXJlID0gJyc7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdCgnLicpO1xuICAgICAgICBoZWFkZXIgPSBqc29uRXZhbChiYXNlNjREZWNvZGUocGFydHNbMF0pIHx8ICcnKTtcbiAgICAgICAgY2xhaW1zID0ganNvbkV2YWwoYmFzZTY0RGVjb2RlKHBhcnRzWzFdKSB8fCAnJyk7XG4gICAgICAgIHNpZ25hdHVyZSA9IHBhcnRzWzJdO1xuICAgICAgICBkYXRhID0gY2xhaW1zWydkJ10gfHwge307XG4gICAgICAgIGRlbGV0ZSBjbGFpbXNbJ2QnXTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlcixcbiAgICAgICAgY2xhaW1zLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzaWduYXR1cmVcbiAgICB9O1xufTtcbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyB0aW1lLWJhc2VkIGNsYWltcy4gV2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGVcbiAqIHRva2VuIGlzIHdpdGhpbiB0aGUgdGltZSB3aW5kb3cgYXV0aG9yaXplZCBieSB0aGUgJ25iZicgKG5vdC1iZWZvcmUpIGFuZCAnaWF0JyAoaXNzdWVkLWF0KSBjbGFpbXMuXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmNvbnN0IGlzVmFsaWRUaW1lc3RhbXAgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcbiAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgbGV0IHZhbGlkU2luY2UgPSAwLCB2YWxpZFVudGlsID0gMDtcbiAgICBpZiAodHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnbmJmJykpIHtcbiAgICAgICAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ25iZiddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcbiAgICAgICAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ2lhdCddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2V4cCcpKSB7XG4gICAgICAgICAgICB2YWxpZFVudGlsID0gY2xhaW1zWydleHAnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRva2VuIHdpbGwgZXhwaXJlIGFmdGVyIDI0aCBieSBkZWZhdWx0XG4gICAgICAgICAgICB2YWxpZFVudGlsID0gdmFsaWRTaW5jZSArIDg2NDAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoISFub3cgJiZcbiAgICAgICAgISF2YWxpZFNpbmNlICYmXG4gICAgICAgICEhdmFsaWRVbnRpbCAmJlxuICAgICAgICBub3cgPj0gdmFsaWRTaW5jZSAmJlxuICAgICAgICBub3cgPD0gdmFsaWRVbnRpbCk7XG59O1xuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIHJldHVybnMgaXRzIGlzc3VlZCBhdCB0aW1lIGlmIHZhbGlkLCBudWxsIG90aGVyd2lzZS5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBudWxsIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuY29uc3QgaXNzdWVkQXRUaW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XG4gICAgaWYgKHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcbiAgICAgICAgcmV0dXJuIGNsYWltc1snaWF0J107XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyBmb3JtYXQuIEV4cGVjdHMgYSB2YWxpZCBpc3N1ZWQtYXQgdGltZS5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuY29uc3QgaXNWYWxpZEZvcm1hdCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGUodG9rZW4pLCBjbGFpbXMgPSBkZWNvZGVkLmNsYWltcztcbiAgICByZXR1cm4gISFjbGFpbXMgJiYgdHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKTtcbn07XG4vKipcbiAqIEF0dGVtcHRzIHRvIHBlZXIgaW50byBhbiBhdXRoIHRva2VuIGFuZCBkZXRlcm1pbmUgaWYgaXQncyBhbiBhZG1pbiBhdXRoIHRva2VuIGJ5IGxvb2tpbmcgYXQgdGhlIGNsYWltcyBwb3J0aW9uLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICovXG5jb25zdCBpc0FkbWluID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XG4gICAgcmV0dXJuIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltc1snYWRtaW4nXSA9PT0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBjb250YWlucyhvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuZnVuY3Rpb24gc2FmZUdldChvYmosIGtleSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hcChvYmosIGZuLCBjb250ZXh0T2JqKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IGZuLmNhbGwoY29udGV4dE9iaiwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBEZWVwIGVxdWFsIHR3byBvYmplY3RzLiBTdXBwb3J0IEFycmF5cyBhbmQgT2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICAgIGZvciAoY29uc3QgayBvZiBhS2V5cykge1xuICAgICAgICBpZiAoIWJLZXlzLmluY2x1ZGVzKGspKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYVByb3AgPSBhW2tdO1xuICAgICAgICBjb25zdCBiUHJvcCA9IGJba107XG4gICAgICAgIGlmIChpc09iamVjdChhUHJvcCkgJiYgaXNPYmplY3QoYlByb3ApKSB7XG4gICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChhUHJvcCwgYlByb3ApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFQcm9wICE9PSBiUHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgayBvZiBiS2V5cykge1xuICAgICAgICBpZiAoIWFLZXlzLmluY2x1ZGVzKGspKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc09iamVjdCh0aGluZykge1xuICAgIHJldHVybiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZWplY3RzIGlmIHRoZSBnaXZlbiBwcm9taXNlIGRvZXNuJ3QgcmVzb2x2ZSBpbiB0aW1lSW5NUyBtaWxsaXNlY29uZHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcHJvbWlzZVdpdGhUaW1lb3V0KHByb21pc2UsIHRpbWVJbk1TID0gMjAwMCkge1xuICAgIGNvbnN0IGRlZmVycmVkUHJvbWlzZSA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gZGVmZXJyZWRQcm9taXNlLnJlamVjdCgndGltZW91dCEnKSwgdGltZUluTVMpO1xuICAgIHByb21pc2UudGhlbihkZWZlcnJlZFByb21pc2UucmVzb2x2ZSwgZGVmZXJyZWRQcm9taXNlLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkUHJvbWlzZS5wcm9taXNlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgcXVlcnlzdHJpbmctZm9ybWF0dGVkIHN0cmluZyAoZS5nLiAmYXJnPXZhbCZhcmcyPXZhbDIpIGZyb20gYVxuICogcGFyYW1zIG9iamVjdCAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcbiAqIE5vdGU6IFlvdSBtdXN0IHByZXBlbmQgaXQgd2l0aCA/IHdoZW4gYWRkaW5nIGl0IHRvIGEgVVJMLlxuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeXN0cmluZ1BhcmFtcykge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5c3RyaW5nUGFyYW1zKSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goYXJyYXlWYWwgPT4ge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFycmF5VmFsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcy5sZW5ndGggPyAnJicgKyBwYXJhbXMuam9pbignJicpIDogJyc7XG59XG4vKipcbiAqIERlY29kZXMgYSBxdWVyeXN0cmluZyAoZS5nLiA/YXJnPXZhbCZhcmcyPXZhbDIpIGludG8gYSBwYXJhbXMgb2JqZWN0XG4gKiAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdEZWNvZGUocXVlcnlzdHJpbmcpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBjb25zdCB0b2tlbnMgPSBxdWVyeXN0cmluZy5yZXBsYWNlKC9eXFw/LywgJycpLnNwbGl0KCcmJyk7XG4gICAgdG9rZW5zLmZvckVhY2godG9rZW4gPT4ge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHRva2VuLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KGtleSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59XG4vKipcbiAqIEV4dHJhY3QgdGhlIHF1ZXJ5IHN0cmluZyBwYXJ0IG9mIGEgVVJMLCBpbmNsdWRpbmcgdGhlIGxlYWRpbmcgcXVlc3Rpb24gbWFyayAoaWYgcHJlc2VudCkuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RRdWVyeXN0cmluZyh1cmwpIHtcbiAgICBjb25zdCBxdWVyeVN0YXJ0ID0gdXJsLmluZGV4T2YoJz8nKTtcbiAgICBpZiAoIXF1ZXJ5U3RhcnQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBmcmFnbWVudFN0YXJ0ID0gdXJsLmluZGV4T2YoJyMnLCBxdWVyeVN0YXJ0KTtcbiAgICByZXR1cm4gdXJsLnN1YnN0cmluZyhxdWVyeVN0YXJ0LCBmcmFnbWVudFN0YXJ0ID4gMCA/IGZyYWdtZW50U3RhcnQgOiB1bmRlZmluZWQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaC5cbiAqIFZhcmlhYmxlIG5hbWVzIGZvbGxvdyB0aGUgbm90YXRpb24gaW4gRklQUyBQVUIgMTgwLTM6XG4gKiBodHRwOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZmlwcy9maXBzMTgwLTMvZmlwczE4MC0zX2ZpbmFsLnBkZi5cbiAqXG4gKiBVc2FnZTpcbiAqICAgdmFyIHNoYTEgPSBuZXcgc2hhMSgpO1xuICogICBzaGExLnVwZGF0ZShieXRlcyk7XG4gKiAgIHZhciBoYXNoID0gc2hhMS5kaWdlc3QoKTtcbiAqXG4gKiBQZXJmb3JtYW5jZTpcbiAqICAgQ2hyb21lIDIzOiAgIH40MDAgTWJpdC9zXG4gKiAgIEZpcmVmb3ggMTY6ICB+MjUwIE1iaXQvc1xuICpcbiAqL1xuLyoqXG4gKiBTSEEtMSBjcnlwdG9ncmFwaGljIGhhc2ggY29uc3RydWN0b3IuXG4gKlxuICogVGhlIHByb3BlcnRpZXMgZGVjbGFyZWQgaGVyZSBhcmUgZGlzY3Vzc2VkIGluIHRoZSBhYm92ZSBhbGdvcml0aG0gZG9jdW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBmaW5hbFxuICogQHN0cnVjdFxuICovXG5jbGFzcyBTaGExIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvbGRzIHRoZSBwcmV2aW91cyB2YWx1ZXMgb2YgYWNjdW11bGF0ZWQgdmFyaWFibGVzIGEtZSBpbiB0aGUgY29tcHJlc3NfXG4gICAgICAgICAqIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFpbl8gPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYnVmZmVyIGhvbGRpbmcgdGhlIHBhcnRpYWxseSBjb21wdXRlZCBoYXNoIHJlc3VsdC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgODAgYnl0ZXMsIGVhY2ggYSBwYXJ0IG9mIHRoZSBtZXNzYWdlIHRvIGJlIGhhc2hlZC4gIFJlZmVycmVkIHRvXG4gICAgICAgICAqIGFzIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGluIHRoZSBkb2NzLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5XXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGFpbnMgZGF0YSBuZWVkZWQgdG8gcGFkIG1lc3NhZ2VzIGxlc3MgdGhhbiA2NCBieXRlcy5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFkXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5idWZfID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvdGFsXyA9IDA7XG4gICAgICAgIHRoaXMuYmxvY2tTaXplID0gNTEyIC8gODtcbiAgICAgICAgdGhpcy5wYWRfWzBdID0gMTI4O1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuYmxvY2tTaXplOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMucGFkX1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAweDY3NDUyMzAxO1xuICAgICAgICB0aGlzLmNoYWluX1sxXSA9IDB4ZWZjZGFiODk7XG4gICAgICAgIHRoaXMuY2hhaW5fWzJdID0gMHg5OGJhZGNmZTtcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAweDEwMzI1NDc2O1xuICAgICAgICB0aGlzLmNoYWluX1s0XSA9IDB4YzNkMmUxZjA7XG4gICAgICAgIHRoaXMuaW5idWZfID0gMDtcbiAgICAgICAgdGhpcy50b3RhbF8gPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjb21wcmVzcyBoZWxwZXIgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIGJ1ZiBCbG9jayB0byBjb21wcmVzcy5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE9mZnNldCBvZiB0aGUgYmxvY2sgaW4gdGhlIGJ1ZmZlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbXByZXNzXyhidWYsIG9mZnNldCkge1xuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBXID0gdGhpcy5XXztcbiAgICAgICAgLy8gZ2V0IDE2IGJpZyBlbmRpYW4gd29yZHNcbiAgICAgICAgaWYgKHR5cGVvZiBidWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHVzZXIpOiBbYnVnIDgxNDAxMjJdIFJlY2VudCB2ZXJzaW9ucyBvZiBTYWZhcmkgZm9yIE1hYyBPUyBhbmQgaU9TXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGJ1ZyB0aGF0IHR1cm5zIHRoZSBwb3N0LWluY3JlbWVudCArKyBvcGVyYXRvciBpbnRvIHByZS1pbmNyZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBkdXJpbmcgSklUIGNvbXBpbGF0aW9uLiAgV2UgaGF2ZSBjb2RlIHRoYXQgZGVwZW5kcyBoZWF2aWx5IG9uIFNIQS0xIGZvclxuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3RuZXNzIGFuZCB3aGljaCBpcyBhZmZlY3RlZCBieSB0aGlzIGJ1Zywgc28gSSd2ZSByZW1vdmVkIGFsbCB1c2VzXG4gICAgICAgICAgICAgICAgLy8gb2YgcG9zdC1pbmNyZW1lbnQgKysgaW4gd2hpY2ggdGhlIHJlc3VsdCB2YWx1ZSBpcyB1c2VkLiAgV2UgY2FuIHJldmVydFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2hhbmdlIG9uY2UgdGhlIFNhZmFyaSBidWdcbiAgICAgICAgICAgICAgICAvLyAoaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEwOTAzNikgaGFzIGJlZW4gZml4ZWQgYW5kXG4gICAgICAgICAgICAgICAgLy8gbW9zdCBjbGllbnRzIGhhdmUgYmVlbiB1cGRhdGVkLlxuICAgICAgICAgICAgICAgIFdbaV0gPVxuICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0KSA8PCAyNCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDEpIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBXW2ldID1cbiAgICAgICAgICAgICAgICAgICAgKGJ1ZltvZmZzZXRdIDw8IDI0KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltvZmZzZXQgKyAzXTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBleHBhbmQgdG8gODAgd29yZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdCA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XG4gICAgICAgICAgICBXW2ldID0gKCh0IDw8IDEpIHwgKHQgPj4+IDMxKSkgJiAweGZmZmZmZmZmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhID0gdGhpcy5jaGFpbl9bMF07XG4gICAgICAgIGxldCBiID0gdGhpcy5jaGFpbl9bMV07XG4gICAgICAgIGxldCBjID0gdGhpcy5jaGFpbl9bMl07XG4gICAgICAgIGxldCBkID0gdGhpcy5jaGFpbl9bM107XG4gICAgICAgIGxldCBlID0gdGhpcy5jaGFpbl9bNF07XG4gICAgICAgIGxldCBmLCBrO1xuICAgICAgICAvLyBUT0RPKHVzZXIpOiBUcnkgdG8gdW5yb2xsIHRoaXMgbG9vcCB0byBzcGVlZCB1cCB0aGUgY29tcHV0YXRpb24uXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCA0MCkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgICAgICAgICAgICAgICBrID0gMHg1YTgyNzk5OTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDZlZDllYmExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgNjApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIHwgYykpO1xuICAgICAgICAgICAgICAgICAgICBrID0gMHg4ZjFiYmNkYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAweGNhNjJjMWQ2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHQgPSAoKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIGsgKyBXW2ldKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICBlID0gZDtcbiAgICAgICAgICAgIGQgPSBjO1xuICAgICAgICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgICAgIGIgPSBhO1xuICAgICAgICAgICAgYSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAodGhpcy5jaGFpbl9bMF0gKyBhKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuY2hhaW5fWzFdID0gKHRoaXMuY2hhaW5fWzFdICsgYikgJiAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLmNoYWluX1syXSA9ICh0aGlzLmNoYWluX1syXSArIGMpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAodGhpcy5jaGFpbl9bM10gKyBkKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuY2hhaW5fWzRdID0gKHRoaXMuY2hhaW5fWzRdICsgZSkgJiAweGZmZmZmZmZmO1xuICAgIH1cbiAgICB1cGRhdGUoYnl0ZXMsIGxlbmd0aCkge1xuICAgICAgICAvLyBUT0RPKGpvaG5sZW56KTogdGlnaHRlbiB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIGFuZCByZW1vdmUgdGhpcyBjaGVja1xuICAgICAgICBpZiAoYnl0ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aE1pbnVzQmxvY2sgPSBsZW5ndGggLSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICAvLyBVc2luZyBsb2NhbCBpbnN0ZWFkIG9mIG1lbWJlciB2YXJpYWJsZXMgZ2l2ZXMgfjUlIHNwZWVkdXAgb24gRmlyZWZveCAxNi5cbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5idWZfO1xuICAgICAgICBsZXQgaW5idWYgPSB0aGlzLmluYnVmXztcbiAgICAgICAgLy8gVGhlIG91dGVyIHdoaWxlIGxvb3Agc2hvdWxkIGV4ZWN1dGUgYXQgbW9zdCB0d2ljZS5cbiAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBubyBkYXRhIGluIHRoZSBibG9jayB0byB0b3AgdXAsIHdlIGNhbiBkaXJlY3RseSBwcm9jZXNzIHRoZVxuICAgICAgICAgICAgLy8gaW5wdXQgYnVmZmVyIChhc3N1bWluZyBpdCBjb250YWlucyBzdWZmaWNpZW50IGRhdGEpLiBUaGlzIGdpdmVzIH4yNSVcbiAgICAgICAgICAgIC8vIHNwZWVkdXAgb24gQ2hyb21lIDIzIGFuZCB+MTUlIHNwZWVkdXAgb24gRmlyZWZveCAxNiwgYnV0IHJlcXVpcmVzIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSBkYXRhIGlzIHByb3ZpZGVkIGluIGxhcmdlIGNodW5rcyAob3IgaW4gbXVsdGlwbGVzIG9mIDY0IGJ5dGVzKS5cbiAgICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuIDw9IGxlbmd0aE1pbnVzQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnl0ZXMsIG4pO1xuICAgICAgICAgICAgICAgICAgICBuICs9IHRoaXMuYmxvY2tTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzLmNoYXJDb2RlQXQobik7XG4gICAgICAgICAgICAgICAgICAgICsraW5idWY7XG4gICAgICAgICAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYnVmID09PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzW25dO1xuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xuICAgICAgICAgICAgICAgICAgICArK247XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmJ1ZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdW1wIHRvIHRoZSBvdXRlciBsb29wIHNvIHdlIHVzZSB0aGUgZnVsbC1ibG9jayBvcHRpbWl6YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluYnVmXyA9IGluYnVmO1xuICAgICAgICB0aGlzLnRvdGFsXyArPSBsZW5ndGg7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IFtdO1xuICAgICAgICBsZXQgdG90YWxCaXRzID0gdGhpcy50b3RhbF8gKiA4O1xuICAgICAgICAvLyBBZGQgcGFkIDB4ODAgMHgwMCouXG4gICAgICAgIGlmICh0aGlzLmluYnVmXyA8IDU2KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnBhZF8sIDU2IC0gdGhpcy5pbmJ1Zl8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy5wYWRfLCB0aGlzLmJsb2NrU2l6ZSAtICh0aGlzLmluYnVmXyAtIDU2KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkICMgYml0cy5cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYmxvY2tTaXplIC0gMTsgaSA+PSA1NjsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLmJ1Zl9baV0gPSB0b3RhbEJpdHMgJiAyNTU7XG4gICAgICAgICAgICB0b3RhbEJpdHMgLz0gMjU2OyAvLyBEb24ndCB1c2UgYml0LXNoaWZ0aW5nIGhlcmUhXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wcmVzc18odGhpcy5idWZfKTtcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xuICAgICAgICAgICAgICAgIGRpZ2VzdFtuXSA9ICh0aGlzLmNoYWluX1tpXSA+PiBqKSAmIDI1NTtcbiAgICAgICAgICAgICAgICArK247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZ2VzdDtcbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIHRvIG1ha2UgYSBTdWJzY3JpYmUgZnVuY3Rpb24gKGp1c3QgbGlrZSBQcm9taXNlIGhlbHBzIG1ha2UgYVxuICogVGhlbmFibGUpLlxuICpcbiAqIEBwYXJhbSBleGVjdXRvciBGdW5jdGlvbiB3aGljaCBjYW4gbWFrZSBjYWxscyB0byBhIHNpbmdsZSBPYnNlcnZlclxuICogICAgIGFzIGEgcHJveHkuXG4gKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmliZShleGVjdXRvciwgb25Ob09ic2VydmVycykge1xuICAgIGNvbnN0IHByb3h5ID0gbmV3IE9ic2VydmVyUHJveHkoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpO1xuICAgIHJldHVybiBwcm94eS5zdWJzY3JpYmUuYmluZChwcm94eSk7XG59XG4vKipcbiAqIEltcGxlbWVudCBmYW4tb3V0IGZvciBhbnkgbnVtYmVyIG9mIE9ic2VydmVycyBhdHRhY2hlZCB2aWEgYSBzdWJzY3JpYmVcbiAqIGZ1bmN0aW9uLlxuICovXG5jbGFzcyBPYnNlcnZlclByb3h5IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcbiAgICAgKiAgICAgYXMgYSBwcm94eS5cbiAgICAgKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZXMgPSBbXTtcbiAgICAgICAgdGhpcy5vYnNlcnZlckNvdW50ID0gMDtcbiAgICAgICAgLy8gTWljcm8tdGFzayBzY2hlZHVsaW5nIGJ5IGNhbGxpbmcgdGFzay50aGVuKCkuXG4gICAgICAgIHRoaXMudGFzayA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnMgPSBvbk5vT2JzZXJ2ZXJzO1xuICAgICAgICAvLyBDYWxsIHRoZSBleGVjdXRvciBhc3luY2hyb25vdXNseSBzbyBzdWJzY3JpYmVycyB0aGF0IGFyZSBjYWxsZWRcbiAgICAgICAgLy8gc3luY2hyb25vdXNseSBhZnRlciB0aGUgY3JlYXRpb24gb2YgdGhlIHN1YnNjcmliZSBmdW5jdGlvblxuICAgICAgICAvLyBjYW4gc3RpbGwgcmVjZWl2ZSB0aGUgdmVyeSBmaXJzdCB2YWx1ZSBnZW5lcmF0ZWQgaW4gdGhlIGV4ZWN1dG9yLlxuICAgICAgICB0aGlzLnRhc2tcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGV4ZWN1dG9yKHRoaXMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5leHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jbG9zZShlcnJvcik7XG4gICAgfVxuICAgIGNvbXBsZXRlKCkge1xuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBhbiBPYnNlcnZlciB0byB0aGUgZmFuLW91dCBsaXN0LlxuICAgICAqXG4gICAgICogLSBXZSByZXF1aXJlIHRoYXQgbm8gZXZlbnQgaXMgc2VudCB0byBhIHN1YnNjcmliZXIgc3luY2hyb25vdXNseSB0byB0aGVpclxuICAgICAqICAgY2FsbCB0byBzdWJzY3JpYmUoKS5cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBsZXQgb2JzZXJ2ZXI7XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBlcnJvciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBjb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgT2JzZXJ2ZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXNzZW1ibGUgYW4gT2JzZXJ2ZXIgb2JqZWN0IHdoZW4gcGFzc2VkIGFzIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICAgICAgaWYgKGltcGxlbWVudHNBbnlNZXRob2RzKG5leHRPck9ic2VydmVyLCBbXG4gICAgICAgICAgICAnbmV4dCcsXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgJ2NvbXBsZXRlJ1xuICAgICAgICBdKSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ic2VydmVyID0ge1xuICAgICAgICAgICAgICAgIG5leHQ6IG5leHRPck9ic2VydmVyLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZlci5uZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZlci5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvciA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9ic2VydmVyLmNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bnN1YiA9IHRoaXMudW5zdWJzY3JpYmVPbmUuYmluZCh0aGlzLCB0aGlzLm9ic2VydmVycy5sZW5ndGgpO1xuICAgICAgICAvLyBBdHRlbXB0IHRvIHN1YnNjcmliZSB0byBhIHRlcm1pbmF0ZWQgT2JzZXJ2YWJsZSAtIHdlXG4gICAgICAgIC8vIGp1c3QgcmVzcG9uZCB0byB0aGUgT2JzZXJ2ZXIgd2l0aCB0aGUgZmluYWwgZXJyb3Igb3IgY29tcGxldGVcbiAgICAgICAgLy8gZXZlbnQuXG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHRoaXMuZmluYWxFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHJldHVybiB1bnN1YjtcbiAgICB9XG4gICAgLy8gVW5zdWJzY3JpYmUgaXMgc3luY2hyb25vdXMgLSB3ZSBndWFyYW50ZWUgdGhhdCBubyBldmVudHMgYXJlIHNlbnQgdG9cbiAgICAvLyBhbnkgdW5zdWJzY3JpYmVkIE9ic2VydmVyLlxuICAgIHVuc3Vic2NyaWJlT25lKGkpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzID09PSB1bmRlZmluZWQgfHwgdGhpcy5vYnNlcnZlcnNbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLm9ic2VydmVyc1tpXTtcbiAgICAgICAgdGhpcy5vYnNlcnZlckNvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyQ291bnQgPT09IDAgJiYgdGhpcy5vbk5vT2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25Ob09ic2VydmVycyh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JFYWNoT2JzZXJ2ZXIoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IGNsb3NlZCBieSBwcmV2aW91cyBldmVudC4uLi5qdXN0IGVhdCB0aGUgYWRkaXRpb25hbCB2YWx1ZXMuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2Ugc2VuZE9uZSBjYWxscyBhc3luY2hyb25vdXNseSAtIHRoZXJlIGlzIG5vIGNoYW5jZSB0aGF0XG4gICAgICAgIC8vIHRoaXMub2JzZXJ2ZXJzIHdpbGwgYmVjb21lIHVuZGVmaW5lZC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9ic2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zZW5kT25lKGksIGZuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYWxsIHRoZSBPYnNlcnZlciB2aWEgb25lIG9mIGl0J3MgY2FsbGJhY2sgZnVuY3Rpb24uIFdlIGFyZSBjYXJlZnVsIHRvXG4gICAgLy8gY29uZmlybSB0aGF0IHRoZSBvYnNlcnZlIGhhcyBub3QgYmVlbiB1bnN1YnNjcmliZWQgc2luY2UgdGhpcyBhc3luY2hyb25vdXNcbiAgICAvLyBmdW5jdGlvbiBoYWQgYmVlbiBxdWV1ZWQuXG4gICAgc2VuZE9uZShpLCBmbikge1xuICAgICAgICAvLyBFeGVjdXRlIHRoZSBjYWxsYmFjayBhc3luY2hyb25vdXNseVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9ic2VydmVycyAhPT0gdW5kZWZpbmVkICYmIHRoaXMub2JzZXJ2ZXJzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmbih0aGlzLm9ic2VydmVyc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBleGNlcHRpb25zIHJhaXNlZCBpbiBPYnNlcnZlcnMgb3IgbWlzc2luZyBtZXRob2RzIG9mIGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ic2VydmVyLlxuICAgICAgICAgICAgICAgICAgICAvLyBMb2cgZXJyb3IgdG8gY29uc29sZS4gYi8zMTQwNDgwNlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZShlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxFcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm94eSBpcyBubyBsb25nZXIgbmVlZGVkIC0gZ2FyYmFnZSBjb2xsZWN0IHJlZmVyZW5jZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMub25Ob09ic2VydmVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFR1cm4gc3luY2hyb25vdXMgZnVuY3Rpb24gaW50byBvbmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5LiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmZ1bmN0aW9uIGFzeW5jKGZuLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh0cnVlKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgb2JqZWN0IHBhc3NlZCBpbiBpbXBsZW1lbnRzIGFueSBvZiB0aGUgbmFtZWQgbWV0aG9kcy5cbiAqL1xuZnVuY3Rpb24gaW1wbGVtZW50c0FueU1ldGhvZHMob2JqLCBtZXRob2RzKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICAgICAgaWYgKG1ldGhvZCBpbiBvYmogJiYgdHlwZW9mIG9ialttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBub29wKCkge1xuICAgIC8vIGRvIG5vdGhpbmdcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgYXJndW1lbnRzIGFyZSBwcm92aWRlZCBmb3IgYSBwdWJsaWMgZnVuY3Rpb24uXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZmFpbHMuXG4gKlxuICogQHBhcmFtIGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxuICogQHBhcmFtIG1pbkNvdW50IFRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXG4gKiBAcGFyYW0gbWF4Q291bnQgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50IHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxuICogQHBhcmFtIGFyZ0NvdW50IFRoZSBhY3R1YWwgbnVtYmVyIG9mIGFyZ3VtZW50cyBwcm92aWRlZC5cbiAqL1xuY29uc3QgdmFsaWRhdGVBcmdDb3VudCA9IGZ1bmN0aW9uIChmbk5hbWUsIG1pbkNvdW50LCBtYXhDb3VudCwgYXJnQ291bnQpIHtcbiAgICBsZXQgYXJnRXJyb3I7XG4gICAgaWYgKGFyZ0NvdW50IDwgbWluQ291bnQpIHtcbiAgICAgICAgYXJnRXJyb3IgPSAnYXQgbGVhc3QgJyArIG1pbkNvdW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmdDb3VudCA+IG1heENvdW50KSB7XG4gICAgICAgIGFyZ0Vycm9yID0gbWF4Q291bnQgPT09IDAgPyAnbm9uZScgOiAnbm8gbW9yZSB0aGFuICcgKyBtYXhDb3VudDtcbiAgICB9XG4gICAgaWYgKGFyZ0Vycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZm5OYW1lICtcbiAgICAgICAgICAgICcgZmFpbGVkOiBXYXMgY2FsbGVkIHdpdGggJyArXG4gICAgICAgICAgICBhcmdDb3VudCArXG4gICAgICAgICAgICAoYXJnQ291bnQgPT09IDEgPyAnIGFyZ3VtZW50LicgOiAnIGFyZ3VtZW50cy4nKSArXG4gICAgICAgICAgICAnIEV4cGVjdHMgJyArXG4gICAgICAgICAgICBhcmdFcnJvciArXG4gICAgICAgICAgICAnLic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgfVxufTtcbi8qKlxuICogR2VuZXJhdGVzIGEgc3RyaW5nIHRvIHByZWZpeCBhbiBlcnJvciBtZXNzYWdlIGFib3V0IGZhaWxlZCBhcmd1bWVudCB2YWxpZGF0aW9uXG4gKlxuICogQHBhcmFtIGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxuICogQHBhcmFtIGFyZ05hbWUgVGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50XG4gKiBAcmV0dXJuIFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciB0aHJvd24gZm9yIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGVycm9yUHJlZml4KGZuTmFtZSwgYXJnTmFtZSkge1xuICAgIHJldHVybiBgJHtmbk5hbWV9IGZhaWxlZDogJHthcmdOYW1lfSBhcmd1bWVudCBgO1xufVxuLyoqXG4gKiBAcGFyYW0gZm5OYW1lXG4gKiBAcGFyYW0gYXJndW1lbnROdW1iZXJcbiAqIEBwYXJhbSBuYW1lc3BhY2VcbiAqIEBwYXJhbSBvcHRpb25hbFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWVzcGFjZShmbk5hbWUsIG5hbWVzcGFjZSwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgIW5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvL1RPRE86IEkgc2hvdWxkIGRvIG1vcmUgdmFsaWRhdGlvbiBoZXJlLiBXZSBvbmx5IGFsbG93IGNlcnRhaW4gY2hhcnMgaW4gbmFtZXNwYWNlcy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgJ25hbWVzcGFjZScpICsgJ211c3QgYmUgYSB2YWxpZCBmaXJlYmFzZSBuYW1lc3BhY2UuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVDYWxsYmFjayhmbk5hbWUsIGFyZ3VtZW50TmFtZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuY2FsbGJhY2ssIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmICFjYWxsYmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArICdtdXN0IGJlIGEgdmFsaWQgZnVuY3Rpb24uJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVDb250ZXh0T2JqZWN0KGZuTmFtZSwgYXJndW1lbnROYW1lLCBjb250ZXh0LCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiAhY29udGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcgfHwgY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBjb250ZXh0IG9iamVjdC4nKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBDb2RlIG9yaWdpbmFsbHkgY2FtZSBmcm9tIGdvb2cuY3J5cHQuc3RyaW5nVG9VdGY4Qnl0ZUFycmF5LCBidXQgZm9yIHNvbWUgcmVhc29uIHRoZXlcbi8vIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgJ1xcclxcbicgd2l0aCAnXFxuJywgYW5kIHRoZXkgZGlkbid0IGhhbmRsZSBzdXJyb2dhdGUgcGFpcnMsXG4vLyBzbyBpdCdzIGJlZW4gbW9kaWZpZWQuXG4vLyBOb3RlIHRoYXQgbm90IGFsbCBVbmljb2RlIGNoYXJhY3RlcnMgYXBwZWFyIGFzIHNpbmdsZSBjaGFyYWN0ZXJzIGluIEphdmFTY3JpcHQgc3RyaW5ncy5cbi8vIGZyb21DaGFyQ29kZSByZXR1cm5zIHRoZSBVVEYtMTYgZW5jb2Rpbmcgb2YgYSBjaGFyYWN0ZXIgLSBzbyBzb21lIFVuaWNvZGUgY2hhcmFjdGVyc1xuLy8gdXNlIDIgY2hhcmFjdGVycyBpbiBKYXZhU2NyaXB0LiAgQWxsIDQtYnl0ZSBVVEYtOCBjaGFyYWN0ZXJzIGJlZ2luIHdpdGggYSBmaXJzdFxuLy8gY2hhcmFjdGVyIGluIHRoZSByYW5nZSAweEQ4MDAgLSAweERCRkYgKHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzby1jYWxsZWQgc3Vycm9nYXRlXG4vLyBwYWlyKS5cbi8vIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtMTUuMS4zXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5jb25zdCBzdHJpbmdUb0J5dGVBcnJheSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgcCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gSXMgdGhpcyB0aGUgbGVhZCBzdXJyb2dhdGUgaW4gYSBzdXJyb2dhdGUgcGFpcj9cbiAgICAgICAgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XG4gICAgICAgICAgICBjb25zdCBoaWdoID0gYyAtIDB4ZDgwMDsgLy8gdGhlIGhpZ2ggMTAgYml0cy5cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGFzc2VydChpIDwgc3RyLmxlbmd0aCwgJ1N1cnJvZ2F0ZSBwYWlyIG1pc3NpbmcgdHJhaWwgc3Vycm9nYXRlLicpO1xuICAgICAgICAgICAgY29uc3QgbG93ID0gc3RyLmNoYXJDb2RlQXQoaSkgLSAweGRjMDA7IC8vIHRoZSBsb3cgMTAgYml0cy5cbiAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKGhpZ2ggPDwgMTApICsgbG93O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCA2NTUzNikge1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDEyKSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcbi8qKlxuICogQ2FsY3VsYXRlIGxlbmd0aCB3aXRob3V0IGFjdHVhbGx5IGNvbnZlcnRpbmc7IHVzZWZ1bCBmb3IgZG9pbmcgY2hlYXBlciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5jb25zdCBzdHJpbmdMZW5ndGggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgbGV0IHAgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICAgIHArKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xuICAgICAgICAgICAgcCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XG4gICAgICAgICAgICAvLyBMZWFkIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLiAgVGhlIHBhaXIgdG9nZXRoZXIgd2lsbCB0YWtlIDQgYnl0ZXMgdG8gcmVwcmVzZW50LlxuICAgICAgICAgICAgcCArPSA0O1xuICAgICAgICAgICAgaSsrOyAvLyBza2lwIHRyYWlsIHN1cnJvZ2F0ZS5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHAgKz0gMztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDtcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGV4cG9uZW50aWFsbHkgaW5jcmVhc2UuXG4gKi9cbmNvbnN0IERFRkFVTFRfSU5URVJWQUxfTUlMTElTID0gMTAwMDtcbi8qKlxuICogVGhlIGZhY3RvciB0byBiYWNrb2ZmIGJ5LlxuICogU2hvdWxkIGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAxLlxuICovXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SID0gMjtcbi8qKlxuICogVGhlIG1heGltdW0gbWlsbGlzZWNvbmRzIHRvIGluY3JlYXNlIHRvLlxuICpcbiAqIDxwPlZpc2libGUgZm9yIHRlc3RpbmdcbiAqL1xuY29uc3QgTUFYX1ZBTFVFX01JTExJUyA9IDQgKiA2MCAqIDYwICogMTAwMDsgLy8gRm91ciBob3VycywgbGlrZSBpT1MgYW5kIEFuZHJvaWQuXG4vKipcbiAqIFRoZSBwZXJjZW50YWdlIG9mIGJhY2tvZmYgdGltZSB0byByYW5kb21pemUgYnkuXG4gKiBTZWVcbiAqIGh0dHA6Ly9nby9zYWZlLWNsaWVudC1iZWhhdmlvciNzdGVwLTEtZGV0ZXJtaW5lLXRoZS1hcHByb3ByaWF0ZS1yZXRyeS1pbnRlcnZhbC10by1oYW5kbGUtc3Bpa2UtdHJhZmZpY1xuICogZm9yIGNvbnRleHQuXG4gKlxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZ1xuICovXG5jb25zdCBSQU5ET01fRkFDVE9SID0gMC41O1xuLyoqXG4gKiBCYXNlZCBvbiB0aGUgYmFja29mZiBtZXRob2QgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvY2xvc3VyZS9nb29nL21hdGgvZXhwb25lbnRpYWxiYWNrb2ZmLmpzLlxuICogRXh0cmFjdGVkIGhlcmUgc28gd2UgZG9uJ3QgbmVlZCB0byBwYXNzIG1ldGFkYXRhIGFuZCBhIHN0YXRlZnVsIEV4cG9uZW50aWFsQmFja29mZiBvYmplY3QgYXJvdW5kLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzKGJhY2tvZmZDb3VudCwgaW50ZXJ2YWxNaWxsaXMgPSBERUZBVUxUX0lOVEVSVkFMX01JTExJUywgYmFja29mZkZhY3RvciA9IERFRkFVTFRfQkFDS09GRl9GQUNUT1IpIHtcbiAgICAvLyBDYWxjdWxhdGVzIGFuIGV4cG9uZW50aWFsbHkgaW5jcmVhc2luZyB2YWx1ZS5cbiAgICAvLyBEZXZpYXRpb246IGNhbGN1bGF0ZXMgdmFsdWUgZnJvbSBjb3VudCBhbmQgYSBjb25zdGFudCBpbnRlcnZhbCwgc28gd2Ugb25seSBuZWVkIHRvIHNhdmUgdmFsdWVcbiAgICAvLyBhbmQgY291bnQgdG8gcmVzdG9yZSBzdGF0ZS5cbiAgICBjb25zdCBjdXJyQmFzZVZhbHVlID0gaW50ZXJ2YWxNaWxsaXMgKiBNYXRoLnBvdyhiYWNrb2ZmRmFjdG9yLCBiYWNrb2ZmQ291bnQpO1xuICAgIC8vIEEgcmFuZG9tIFwiZnV6elwiIHRvIGF2b2lkIHdhdmVzIG9mIHJldHJpZXMuXG4gICAgLy8gRGV2aWF0aW9uOiByYW5kb21GYWN0b3IgaXMgcmVxdWlyZWQuXG4gICAgY29uc3QgcmFuZG9tV2FpdCA9IE1hdGgucm91bmQoXG4gICAgLy8gQSBmcmFjdGlvbiBvZiB0aGUgYmFja29mZiB2YWx1ZSB0byBhZGQvc3VidHJhY3QuXG4gICAgLy8gRGV2aWF0aW9uOiBjaGFuZ2VzIG11bHRpcGxpY2F0aW9uIG9yZGVyIHRvIGltcHJvdmUgcmVhZGFiaWxpdHkuXG4gICAgUkFORE9NX0ZBQ1RPUiAqXG4gICAgICAgIGN1cnJCYXNlVmFsdWUgKlxuICAgICAgICAvLyBBIHJhbmRvbSBmbG9hdCAocm91bmRlZCB0byBpbnQgYnkgTWF0aC5yb3VuZCBhYm92ZSkgaW4gdGhlIHJhbmdlIFstMSwgMV0uIERldGVybWluZXNcbiAgICAgICAgLy8gaWYgd2UgYWRkIG9yIHN1YnRyYWN0LlxuICAgICAgICAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKlxuICAgICAgICAyKTtcbiAgICAvLyBMaW1pdHMgYmFja29mZiB0byBtYXggdG8gYXZvaWQgZWZmZWN0aXZlbHkgcGVybWFuZW50IGJhY2tvZmYuXG4gICAgcmV0dXJuIE1hdGgubWluKE1BWF9WQUxVRV9NSUxMSVMsIGN1cnJCYXNlVmFsdWUgKyByYW5kb21XYWl0KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZSBFbmdsaXNoIG9yZGluYWwgbGV0dGVycyBhZnRlciBhIG51bWJlclxuICovXG5mdW5jdGlvbiBvcmRpbmFsKGkpIHtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpKSkge1xuICAgICAgICByZXR1cm4gYCR7aX1gO1xuICAgIH1cbiAgICByZXR1cm4gaSArIGluZGljYXRvcihpKTtcbn1cbmZ1bmN0aW9uIGluZGljYXRvcihpKSB7XG4gICAgaSA9IE1hdGguYWJzKGkpO1xuICAgIGNvbnN0IGNlbnQgPSBpICUgMTAwO1xuICAgIGlmIChjZW50ID49IDEwICYmIGNlbnQgPD0gMjApIHtcbiAgICAgICAgcmV0dXJuICd0aCc7XG4gICAgfVxuICAgIGNvbnN0IGRlYyA9IGkgJSAxMDtcbiAgICBpZiAoZGVjID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnc3QnO1xuICAgIH1cbiAgICBpZiAoZGVjID09PSAyKSB7XG4gICAgICAgIHJldHVybiAnbmQnO1xuICAgIH1cbiAgICBpZiAoZGVjID09PSAzKSB7XG4gICAgICAgIHJldHVybiAncmQnO1xuICAgIH1cbiAgICByZXR1cm4gJ3RoJztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGdldE1vZHVsYXJJbnN0YW5jZShzZXJ2aWNlKSB7XG4gICAgaWYgKHNlcnZpY2UgJiYgc2VydmljZS5fZGVsZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2UuX2RlbGVnYXRlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2U7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gT3ZlcnJpZGluZyB0aGUgY29uc3RhbnQgKHdlIHNob3VsZCBiZSB0aGUgb25seSBvbmVzIGRvaW5nIHRoaXMpXG5DT05TVEFOVFMuTk9ERV9DTElFTlQgPSB0cnVlO1xuXG5leHBvcnQgeyBDT05TVEFOVFMsIERlY29kZUJhc2U2NFN0cmluZ0Vycm9yLCBEZWZlcnJlZCwgRXJyb3JGYWN0b3J5LCBGaXJlYmFzZUVycm9yLCBNQVhfVkFMVUVfTUlMTElTLCBSQU5ET01fRkFDVE9SLCBTaGExLCBhcmVDb29raWVzRW5hYmxlZCwgYXNzZXJ0LCBhc3NlcnRpb25FcnJvciwgYXN5bmMsIGJhc2U2NCwgYmFzZTY0RGVjb2RlLCBiYXNlNjRFbmNvZGUsIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nLCBjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzLCBjb250YWlucywgY3JlYXRlTW9ja1VzZXJUb2tlbiwgY3JlYXRlU3Vic2NyaWJlLCBkZWNvZGUsIGRlZXBDb3B5LCBkZWVwRXF1YWwsIGRlZXBFeHRlbmQsIGVycm9yUHJlZml4LCBleHRyYWN0UXVlcnlzdHJpbmcsIGdldERlZmF1bHRBcHBDb25maWcsIGdldERlZmF1bHRFbXVsYXRvckhvc3QsIGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCwgZ2V0RGVmYXVsdHMsIGdldEV4cGVyaW1lbnRhbFNldHRpbmcsIGdldEdsb2JhbCwgZ2V0TW9kdWxhckluc3RhbmNlLCBnZXRVQSwgaXNBZG1pbiwgaXNCcm93c2VyLCBpc0Jyb3dzZXJFeHRlbnNpb24sIGlzQ2xvdWRmbGFyZVdvcmtlciwgaXNFbGVjdHJvbiwgaXNFbXB0eSwgaXNJRSwgaXNJbmRleGVkREJBdmFpbGFibGUsIGlzTW9iaWxlQ29yZG92YSwgaXNOb2RlLCBpc05vZGVTZGssIGlzUmVhY3ROYXRpdmUsIGlzU2FmYXJpLCBpc1VXUCwgaXNWYWxpZEZvcm1hdCwgaXNWYWxpZFRpbWVzdGFtcCwgaXNXZWJXb3JrZXIsIGlzc3VlZEF0VGltZSwganNvbkV2YWwsIG1hcCwgb3JkaW5hbCwgcHJvbWlzZVdpdGhUaW1lb3V0LCBxdWVyeXN0cmluZywgcXVlcnlzdHJpbmdEZWNvZGUsIHNhZmVHZXQsIHN0cmluZ0xlbmd0aCwgc3RyaW5nVG9CeXRlQXJyYXksIHN0cmluZ2lmeSwgdmFsaWRhdGVBcmdDb3VudCwgdmFsaWRhdGVDYWxsYmFjaywgdmFsaWRhdGVDb250ZXh0T2JqZWN0LCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlLCB2YWxpZGF0ZU5hbWVzcGFjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@firebase/util/dist/node-esm/index.node.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@firebase/util/dist/postinstall.mjs":
/*!***********************************************************!*\
  !*** ../node_modules/@firebase/util/dist/postinstall.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDefaultsFromPostinstall: () => (/* binding */ getDefaultsFromPostinstall)\n/* harmony export */ });\nconst getDefaultsFromPostinstall = () => (undefined);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvcG9zdGluc3RhbGwubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RhbGtfdG9fdGV4dC8uLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9wb3N0aW5zdGFsbC5tanM/OGU3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBnZXREZWZhdWx0c0Zyb21Qb3N0aW5zdGFsbCA9ICgpID0+ICh1bmRlZmluZWQpO1xuZXhwb3J0IHsgZ2V0RGVmYXVsdHNGcm9tUG9zdGluc3RhbGwgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@firebase/util/dist/postinstall.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js":
/*!*********************************************************************************************!*\
  !*** ../node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Integer: () => (/* binding */ Integer),\n/* harmony export */   Md5: () => (/* binding */ Md5),\n/* harmony export */   \"default\": () => (/* binding */ bloom_blob_es2018)\n/* harmony export */ });\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar bloom_blob_es2018 = {};\n\n/** @license\nCopyright The Closure Library Authors.\nSPDX-License-Identifier: Apache-2.0\n*/\n\nvar Integer;\nvar Md5;\n(function() {var h;/** @license\n\n Copyright The Closure Library Authors.\n SPDX-License-Identifier: Apache-2.0\n*/\nfunction k(f,a){function c(){}c.prototype=a.prototype;f.D=a.prototype;f.prototype=new c;f.prototype.constructor=f;f.C=function(d,e,g){for(var b=Array(arguments.length-2),r=2;r<arguments.length;r++)b[r-2]=arguments[r];return a.prototype[e].apply(d,b)};}function l(){this.blockSize=-1;}function m(){this.blockSize=-1;this.blockSize=64;this.g=Array(4);this.B=Array(this.blockSize);this.o=this.h=0;this.s();}k(m,l);m.prototype.s=function(){this.g[0]=1732584193;this.g[1]=4023233417;this.g[2]=2562383102;this.g[3]=271733878;this.o=this.h=0;};\nfunction n(f,a,c){c||(c=0);var d=Array(16);if(\"string\"===typeof a)for(var e=0;16>e;++e)d[e]=a.charCodeAt(c++)|a.charCodeAt(c++)<<8|a.charCodeAt(c++)<<16|a.charCodeAt(c++)<<24;else for(e=0;16>e;++e)d[e]=a[c++]|a[c++]<<8|a[c++]<<16|a[c++]<<24;a=f.g[0];c=f.g[1];e=f.g[2];var g=f.g[3];var b=a+(g^c&(e^g))+d[0]+3614090360&4294967295;a=c+(b<<7&4294967295|b>>>25);b=g+(e^a&(c^e))+d[1]+3905402710&4294967295;g=a+(b<<12&4294967295|b>>>20);b=e+(c^g&(a^c))+d[2]+606105819&4294967295;e=g+(b<<17&4294967295|b>>>15);\nb=c+(a^e&(g^a))+d[3]+3250441966&4294967295;c=e+(b<<22&4294967295|b>>>10);b=a+(g^c&(e^g))+d[4]+4118548399&4294967295;a=c+(b<<7&4294967295|b>>>25);b=g+(e^a&(c^e))+d[5]+1200080426&4294967295;g=a+(b<<12&4294967295|b>>>20);b=e+(c^g&(a^c))+d[6]+2821735955&4294967295;e=g+(b<<17&4294967295|b>>>15);b=c+(a^e&(g^a))+d[7]+4249261313&4294967295;c=e+(b<<22&4294967295|b>>>10);b=a+(g^c&(e^g))+d[8]+1770035416&4294967295;a=c+(b<<7&4294967295|b>>>25);b=g+(e^a&(c^e))+d[9]+2336552879&4294967295;g=a+(b<<12&4294967295|\nb>>>20);b=e+(c^g&(a^c))+d[10]+4294925233&4294967295;e=g+(b<<17&4294967295|b>>>15);b=c+(a^e&(g^a))+d[11]+2304563134&4294967295;c=e+(b<<22&4294967295|b>>>10);b=a+(g^c&(e^g))+d[12]+1804603682&4294967295;a=c+(b<<7&4294967295|b>>>25);b=g+(e^a&(c^e))+d[13]+4254626195&4294967295;g=a+(b<<12&4294967295|b>>>20);b=e+(c^g&(a^c))+d[14]+2792965006&4294967295;e=g+(b<<17&4294967295|b>>>15);b=c+(a^e&(g^a))+d[15]+1236535329&4294967295;c=e+(b<<22&4294967295|b>>>10);b=a+(e^g&(c^e))+d[1]+4129170786&4294967295;a=c+(b<<\n5&4294967295|b>>>27);b=g+(c^e&(a^c))+d[6]+3225465664&4294967295;g=a+(b<<9&4294967295|b>>>23);b=e+(a^c&(g^a))+d[11]+643717713&4294967295;e=g+(b<<14&4294967295|b>>>18);b=c+(g^a&(e^g))+d[0]+3921069994&4294967295;c=e+(b<<20&4294967295|b>>>12);b=a+(e^g&(c^e))+d[5]+3593408605&4294967295;a=c+(b<<5&4294967295|b>>>27);b=g+(c^e&(a^c))+d[10]+38016083&4294967295;g=a+(b<<9&4294967295|b>>>23);b=e+(a^c&(g^a))+d[15]+3634488961&4294967295;e=g+(b<<14&4294967295|b>>>18);b=c+(g^a&(e^g))+d[4]+3889429448&4294967295;c=\ne+(b<<20&4294967295|b>>>12);b=a+(e^g&(c^e))+d[9]+568446438&4294967295;a=c+(b<<5&4294967295|b>>>27);b=g+(c^e&(a^c))+d[14]+3275163606&4294967295;g=a+(b<<9&4294967295|b>>>23);b=e+(a^c&(g^a))+d[3]+4107603335&4294967295;e=g+(b<<14&4294967295|b>>>18);b=c+(g^a&(e^g))+d[8]+1163531501&4294967295;c=e+(b<<20&4294967295|b>>>12);b=a+(e^g&(c^e))+d[13]+2850285829&4294967295;a=c+(b<<5&4294967295|b>>>27);b=g+(c^e&(a^c))+d[2]+4243563512&4294967295;g=a+(b<<9&4294967295|b>>>23);b=e+(a^c&(g^a))+d[7]+1735328473&4294967295;\ne=g+(b<<14&4294967295|b>>>18);b=c+(g^a&(e^g))+d[12]+2368359562&4294967295;c=e+(b<<20&4294967295|b>>>12);b=a+(c^e^g)+d[5]+4294588738&4294967295;a=c+(b<<4&4294967295|b>>>28);b=g+(a^c^e)+d[8]+2272392833&4294967295;g=a+(b<<11&4294967295|b>>>21);b=e+(g^a^c)+d[11]+1839030562&4294967295;e=g+(b<<16&4294967295|b>>>16);b=c+(e^g^a)+d[14]+4259657740&4294967295;c=e+(b<<23&4294967295|b>>>9);b=a+(c^e^g)+d[1]+2763975236&4294967295;a=c+(b<<4&4294967295|b>>>28);b=g+(a^c^e)+d[4]+1272893353&4294967295;g=a+(b<<11&4294967295|\nb>>>21);b=e+(g^a^c)+d[7]+4139469664&4294967295;e=g+(b<<16&4294967295|b>>>16);b=c+(e^g^a)+d[10]+3200236656&4294967295;c=e+(b<<23&4294967295|b>>>9);b=a+(c^e^g)+d[13]+681279174&4294967295;a=c+(b<<4&4294967295|b>>>28);b=g+(a^c^e)+d[0]+3936430074&4294967295;g=a+(b<<11&4294967295|b>>>21);b=e+(g^a^c)+d[3]+3572445317&4294967295;e=g+(b<<16&4294967295|b>>>16);b=c+(e^g^a)+d[6]+76029189&4294967295;c=e+(b<<23&4294967295|b>>>9);b=a+(c^e^g)+d[9]+3654602809&4294967295;a=c+(b<<4&4294967295|b>>>28);b=g+(a^c^e)+d[12]+\n3873151461&4294967295;g=a+(b<<11&4294967295|b>>>21);b=e+(g^a^c)+d[15]+530742520&4294967295;e=g+(b<<16&4294967295|b>>>16);b=c+(e^g^a)+d[2]+3299628645&4294967295;c=e+(b<<23&4294967295|b>>>9);b=a+(e^(c|~g))+d[0]+4096336452&4294967295;a=c+(b<<6&4294967295|b>>>26);b=g+(c^(a|~e))+d[7]+1126891415&4294967295;g=a+(b<<10&4294967295|b>>>22);b=e+(a^(g|~c))+d[14]+2878612391&4294967295;e=g+(b<<15&4294967295|b>>>17);b=c+(g^(e|~a))+d[5]+4237533241&4294967295;c=e+(b<<21&4294967295|b>>>11);b=a+(e^(c|~g))+d[12]+1700485571&\n4294967295;a=c+(b<<6&4294967295|b>>>26);b=g+(c^(a|~e))+d[3]+2399980690&4294967295;g=a+(b<<10&4294967295|b>>>22);b=e+(a^(g|~c))+d[10]+4293915773&4294967295;e=g+(b<<15&4294967295|b>>>17);b=c+(g^(e|~a))+d[1]+2240044497&4294967295;c=e+(b<<21&4294967295|b>>>11);b=a+(e^(c|~g))+d[8]+1873313359&4294967295;a=c+(b<<6&4294967295|b>>>26);b=g+(c^(a|~e))+d[15]+4264355552&4294967295;g=a+(b<<10&4294967295|b>>>22);b=e+(a^(g|~c))+d[6]+2734768916&4294967295;e=g+(b<<15&4294967295|b>>>17);b=c+(g^(e|~a))+d[13]+1309151649&\n4294967295;c=e+(b<<21&4294967295|b>>>11);b=a+(e^(c|~g))+d[4]+4149444226&4294967295;a=c+(b<<6&4294967295|b>>>26);b=g+(c^(a|~e))+d[11]+3174756917&4294967295;g=a+(b<<10&4294967295|b>>>22);b=e+(a^(g|~c))+d[2]+718787259&4294967295;e=g+(b<<15&4294967295|b>>>17);b=c+(g^(e|~a))+d[9]+3951481745&4294967295;f.g[0]=f.g[0]+a&4294967295;f.g[1]=f.g[1]+(e+(b<<21&4294967295|b>>>11))&4294967295;f.g[2]=f.g[2]+e&4294967295;f.g[3]=f.g[3]+g&4294967295;}\nm.prototype.u=function(f,a){void 0===a&&(a=f.length);for(var c=a-this.blockSize,d=this.B,e=this.h,g=0;g<a;){if(0==e)for(;g<=c;)n(this,f,g),g+=this.blockSize;if(\"string\"===typeof f)for(;g<a;){if(d[e++]=f.charCodeAt(g++),e==this.blockSize){n(this,d);e=0;break}}else for(;g<a;)if(d[e++]=f[g++],e==this.blockSize){n(this,d);e=0;break}}this.h=e;this.o+=a;};\nm.prototype.v=function(){var f=Array((56>this.h?this.blockSize:2*this.blockSize)-this.h);f[0]=128;for(var a=1;a<f.length-8;++a)f[a]=0;var c=8*this.o;for(a=f.length-8;a<f.length;++a)f[a]=c&255,c/=256;this.u(f);f=Array(16);for(a=c=0;4>a;++a)for(var d=0;32>d;d+=8)f[c++]=this.g[a]>>>d&255;return f};function p(f,a){var c=q;return Object.prototype.hasOwnProperty.call(c,f)?c[f]:c[f]=a(f)}function t(f,a){this.h=a;for(var c=[],d=!0,e=f.length-1;0<=e;e--){var g=f[e]|0;d&&g==a||(c[e]=g,d=!1);}this.g=c;}var q={};function u(f){return -128<=f&&128>f?p(f,function(a){return new t([a|0],0>a?-1:0)}):new t([f|0],0>f?-1:0)}function v(f){if(isNaN(f)||!isFinite(f))return w;if(0>f)return x(v(-f));for(var a=[],c=1,d=0;f>=c;d++)a[d]=f/c|0,c*=4294967296;return new t(a,0)}\nfunction y(f,a){if(0==f.length)throw Error(\"number format error: empty string\");a=a||10;if(2>a||36<a)throw Error(\"radix out of range: \"+a);if(\"-\"==f.charAt(0))return x(y(f.substring(1),a));if(0<=f.indexOf(\"-\"))throw Error('number format error: interior \"-\" character');for(var c=v(Math.pow(a,8)),d=w,e=0;e<f.length;e+=8){var g=Math.min(8,f.length-e),b=parseInt(f.substring(e,e+g),a);8>g?(g=v(Math.pow(a,g)),d=d.j(g).add(v(b))):(d=d.j(c),d=d.add(v(b)));}return d}var w=u(0),z=u(1),A=u(16777216);h=t.prototype;\nh.m=function(){if(B(this))return -x(this).m();for(var f=0,a=1,c=0;c<this.g.length;c++){var d=this.i(c);f+=(0<=d?d:4294967296+d)*a;a*=4294967296;}return f};h.toString=function(f){f=f||10;if(2>f||36<f)throw Error(\"radix out of range: \"+f);if(C(this))return \"0\";if(B(this))return \"-\"+x(this).toString(f);for(var a=v(Math.pow(f,6)),c=this,d=\"\";;){var e=D(c,a).g;c=F(c,e.j(a));var g=((0<c.g.length?c.g[0]:c.h)>>>0).toString(f);c=e;if(C(c))return g+d;for(;6>g.length;)g=\"0\"+g;d=g+d;}};\nh.i=function(f){return 0>f?0:f<this.g.length?this.g[f]:this.h};function C(f){if(0!=f.h)return !1;for(var a=0;a<f.g.length;a++)if(0!=f.g[a])return !1;return !0}function B(f){return -1==f.h}h.l=function(f){f=F(this,f);return B(f)?-1:C(f)?0:1};function x(f){for(var a=f.g.length,c=[],d=0;d<a;d++)c[d]=~f.g[d];return (new t(c,~f.h)).add(z)}h.abs=function(){return B(this)?x(this):this};\nh.add=function(f){for(var a=Math.max(this.g.length,f.g.length),c=[],d=0,e=0;e<=a;e++){var g=d+(this.i(e)&65535)+(f.i(e)&65535),b=(g>>>16)+(this.i(e)>>>16)+(f.i(e)>>>16);d=b>>>16;g&=65535;b&=65535;c[e]=b<<16|g;}return new t(c,c[c.length-1]&-2147483648?-1:0)};function F(f,a){return f.add(x(a))}\nh.j=function(f){if(C(this)||C(f))return w;if(B(this))return B(f)?x(this).j(x(f)):x(x(this).j(f));if(B(f))return x(this.j(x(f)));if(0>this.l(A)&&0>f.l(A))return v(this.m()*f.m());for(var a=this.g.length+f.g.length,c=[],d=0;d<2*a;d++)c[d]=0;for(d=0;d<this.g.length;d++)for(var e=0;e<f.g.length;e++){var g=this.i(d)>>>16,b=this.i(d)&65535,r=f.i(e)>>>16,E=f.i(e)&65535;c[2*d+2*e]+=b*E;G(c,2*d+2*e);c[2*d+2*e+1]+=g*E;G(c,2*d+2*e+1);c[2*d+2*e+1]+=b*r;G(c,2*d+2*e+1);c[2*d+2*e+2]+=g*r;G(c,2*d+2*e+2);}for(d=0;d<\na;d++)c[d]=c[2*d+1]<<16|c[2*d];for(d=a;d<2*a;d++)c[d]=0;return new t(c,0)};function G(f,a){for(;(f[a]&65535)!=f[a];)f[a+1]+=f[a]>>>16,f[a]&=65535,a++;}function H(f,a){this.g=f;this.h=a;}\nfunction D(f,a){if(C(a))throw Error(\"division by zero\");if(C(f))return new H(w,w);if(B(f))return a=D(x(f),a),new H(x(a.g),x(a.h));if(B(a))return a=D(f,x(a)),new H(x(a.g),a.h);if(30<f.g.length){if(B(f)||B(a))throw Error(\"slowDivide_ only works with positive integers.\");for(var c=z,d=a;0>=d.l(f);)c=I(c),d=I(d);var e=J(c,1),g=J(d,1);d=J(d,2);for(c=J(c,2);!C(d);){var b=g.add(d);0>=b.l(f)&&(e=e.add(c),g=b);d=J(d,1);c=J(c,1);}a=F(f,e.j(a));return new H(e,a)}for(e=w;0<=f.l(a);){c=Math.max(1,Math.floor(f.m()/\na.m()));d=Math.ceil(Math.log(c)/Math.LN2);d=48>=d?1:Math.pow(2,d-48);g=v(c);for(b=g.j(a);B(b)||0<b.l(f);)c-=d,g=v(c),b=g.j(a);C(g)&&(g=z);e=e.add(g);f=F(f,b);}return new H(e,f)}h.A=function(f){return D(this,f).h};h.and=function(f){for(var a=Math.max(this.g.length,f.g.length),c=[],d=0;d<a;d++)c[d]=this.i(d)&f.i(d);return new t(c,this.h&f.h)};h.or=function(f){for(var a=Math.max(this.g.length,f.g.length),c=[],d=0;d<a;d++)c[d]=this.i(d)|f.i(d);return new t(c,this.h|f.h)};\nh.xor=function(f){for(var a=Math.max(this.g.length,f.g.length),c=[],d=0;d<a;d++)c[d]=this.i(d)^f.i(d);return new t(c,this.h^f.h)};function I(f){for(var a=f.g.length+1,c=[],d=0;d<a;d++)c[d]=f.i(d)<<1|f.i(d-1)>>>31;return new t(c,f.h)}function J(f,a){var c=a>>5;a%=32;for(var d=f.g.length-c,e=[],g=0;g<d;g++)e[g]=0<a?f.i(g+c)>>>a|f.i(g+c+1)<<32-a:f.i(g+c);return new t(e,f.h)}m.prototype.digest=m.prototype.v;m.prototype.reset=m.prototype.s;m.prototype.update=m.prototype.u;Md5 = bloom_blob_es2018.Md5=m;t.prototype.add=t.prototype.add;t.prototype.multiply=t.prototype.j;t.prototype.modulo=t.prototype.A;t.prototype.compare=t.prototype.l;t.prototype.toNumber=t.prototype.m;t.prototype.toString=t.prototype.toString;t.prototype.getBits=t.prototype.i;t.fromNumber=v;t.fromString=y;Integer = bloom_blob_es2018.Integer=t;}).apply( typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self  : typeof window !== 'undefined' ? window  : {});\n\n\n//# sourceMappingURL=bloom_blob_es2018.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS93ZWJjaGFubmVsLXdyYXBwZXIvZGlzdC9ibG9vbS1ibG9iL2VzbS9ibG9vbV9ibG9iX2VzMjAxOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxNQUFNOztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYyx3QkFBd0IsZ0JBQWdCLGtCQUFrQiwwQkFBMEIsb0JBQW9CLHdDQUF3QyxtQkFBbUIsd0JBQXdCLG1DQUFtQyxhQUFhLG1CQUFtQixhQUFhLGtCQUFrQixrQkFBa0IsZ0JBQWdCLDZCQUE2QixnQkFBZ0IsVUFBVSxPQUFPLHlCQUF5QixxQkFBcUIscUJBQXFCLHFCQUFxQixvQkFBb0I7QUFDdmdCLGtCQUFrQixTQUFTLGdCQUFnQixtQ0FBbUMsS0FBSyw0RkFBNEYsYUFBYSxLQUFLLGdEQUFnRCxTQUFTLFNBQVMsU0FBUyxhQUFhLCtDQUErQyw2QkFBNkIsMkNBQTJDLDhCQUE4QiwwQ0FBMEM7QUFDeGQsMkNBQTJDLDhCQUE4QiwyQ0FBMkMsNkJBQTZCLDJDQUEyQyw4QkFBOEIsMkNBQTJDLDhCQUE4QiwyQ0FBMkMsOEJBQThCLDJDQUEyQyw2QkFBNkIsMkNBQTJDO0FBQy9kLFFBQVEsNENBQTRDLDhCQUE4Qiw0Q0FBNEMsOEJBQThCLDRDQUE0Qyw2QkFBNkIsNENBQTRDLDhCQUE4Qiw0Q0FBNEMsOEJBQThCLDRDQUE0Qyw4QkFBOEIsMkNBQTJDO0FBQzllLHFCQUFxQiwyQ0FBMkMsNkJBQTZCLDJDQUEyQyw4QkFBOEIsMkNBQTJDLDhCQUE4QiwyQ0FBMkMsNkJBQTZCLDBDQUEwQyw2QkFBNkIsNENBQTRDLDhCQUE4QiwyQ0FBMkM7QUFDbmYsNEJBQTRCLDBDQUEwQyw2QkFBNkIsNENBQTRDLDZCQUE2QiwyQ0FBMkMsOEJBQThCLDJDQUEyQyw4QkFBOEIsNENBQTRDLDZCQUE2QiwyQ0FBMkMsNkJBQTZCO0FBQy9jLDhCQUE4Qiw0Q0FBNEMsOEJBQThCLHVDQUF1Qyw2QkFBNkIsdUNBQXVDLDhCQUE4Qix3Q0FBd0MsOEJBQThCLHdDQUF3Qyw2QkFBNkIsdUNBQXVDLDZCQUE2Qix1Q0FBdUM7QUFDdmUsUUFBUSx1Q0FBdUMsOEJBQThCLHdDQUF3Qyw2QkFBNkIsdUNBQXVDLDZCQUE2Qix1Q0FBdUMsOEJBQThCLHVDQUF1Qyw4QkFBOEIscUNBQXFDLDZCQUE2Qix1Q0FBdUMsNkJBQTZCO0FBQ3RlLHNCQUFzQiw4QkFBOEIsdUNBQXVDLDhCQUE4Qix1Q0FBdUMsNkJBQTZCLDBDQUEwQyw2QkFBNkIsMENBQTBDLDhCQUE4QiwyQ0FBMkMsOEJBQThCLDBDQUEwQyw4QkFBOEI7QUFDN2QsV0FBVyw2QkFBNkIsMENBQTBDLDhCQUE4QiwyQ0FBMkMsOEJBQThCLDBDQUEwQyw4QkFBOEIsMENBQTBDLDZCQUE2QiwyQ0FBMkMsOEJBQThCLDBDQUEwQyw4QkFBOEI7QUFDemQsV0FBVyw4QkFBOEIsMENBQTBDLDZCQUE2QiwyQ0FBMkMsOEJBQThCLHlDQUF5Qyw4QkFBOEIsMENBQTBDLDJCQUEyQix1REFBdUQsMkJBQTJCO0FBQ3ZaLDRCQUE0Qix5QkFBeUIsaURBQWlELElBQUksRUFBRSxhQUFhLEtBQUssK0JBQStCLDRCQUE0QixJQUFJLEVBQUUsK0NBQStDLFVBQVUsSUFBSSxPQUFPLFVBQVUsSUFBSSxxQ0FBcUMsVUFBVSxJQUFJLE9BQU8sU0FBUztBQUNwVix5QkFBeUIsZ0VBQWdFLFNBQVMsWUFBWSxhQUFhLFdBQVcsZUFBZSxpQkFBaUIsV0FBVyxzQkFBc0IsVUFBVSxZQUFZLFVBQVUsSUFBSSxnQkFBZ0IsS0FBSyw4QkFBOEIsVUFBVSxnQkFBZ0IsUUFBUSxnRUFBZ0UsZ0JBQWdCLFNBQVMsK0JBQStCLEtBQUssS0FBSyxhQUFhLHdCQUF3QixVQUFVLFNBQVMsY0FBYyxzQ0FBc0MsNkJBQTZCLHdCQUF3QixjQUFjLG1DQUFtQyx1QkFBdUIscUJBQXFCLEtBQUssNkJBQTZCO0FBQ2x1QixnQkFBZ0IsZ0VBQWdFLFFBQVEsbURBQW1ELGtEQUFrRCxnRkFBZ0YsbUNBQW1DLFdBQVcsTUFBTSw4REFBOEQsc0VBQXNFLFNBQVMsZ0NBQWdDO0FBQzllLGVBQWUsK0JBQStCLG9CQUFvQixnQkFBZ0IsS0FBSyxnQkFBZ0IsMkJBQTJCLGVBQWUsVUFBVSx1QkFBdUIsUUFBUSxtREFBbUQsc0JBQXNCLDBDQUEwQyx3Q0FBd0MsRUFBRSxlQUFlLGNBQWMsa0RBQWtELElBQUksbUJBQW1CLEtBQUssV0FBVyxTQUFTO0FBQ3RkLGdCQUFnQiwrQ0FBK0MsY0FBYyxvQkFBb0IsWUFBWSxhQUFhLDJCQUEyQixVQUFVLGNBQWMsZUFBZSxnQkFBZ0IsWUFBWSx5QkFBeUIsY0FBYyw4QkFBOEIsSUFBSSxpQkFBaUIsOEJBQThCLGlCQUFpQjtBQUNqVyxrQkFBa0IsMERBQTBELEtBQUssS0FBSyxtRkFBbUYsU0FBUyxTQUFTLFNBQVMsY0FBYyxnREFBZ0QsZ0JBQWdCO0FBQ2xSLGdCQUFnQiwwQkFBMEIsdURBQXVELCtCQUErQixrREFBa0QsNENBQTRDLE1BQU0sV0FBVyxRQUFRLGdCQUFnQixnQkFBZ0IsYUFBYSxLQUFLLG9FQUFvRSxnQkFBZ0IsYUFBYSxrQkFBa0IsZUFBZSxrQkFBa0IsZUFBZSxrQkFBa0IsZ0JBQWdCLFFBQVE7QUFDdGYsRUFBRSw2QkFBNkIsUUFBUSxNQUFNLFdBQVcsbUJBQW1CLGdCQUFnQixLQUFLLG1CQUFtQixvQ0FBb0MsZ0JBQWdCLFNBQVM7QUFDaEwsZ0JBQWdCLHdDQUF3QywwQkFBMEIsZ0RBQWdELDZDQUE2QyxrQkFBa0IsNEVBQTRFLGdCQUFnQixVQUFVLGVBQWUsc0JBQXNCLFNBQVMsYUFBYSxNQUFNLEVBQUUsZUFBZSw0QkFBNEIsU0FBUyxVQUFVLGNBQWMsa0JBQWtCLFFBQVEsVUFBVSxFQUFFO0FBQzVkLFFBQVEsa0NBQWtDLDJCQUEyQixPQUFPLGFBQWEsZUFBZSxzQkFBc0IsWUFBWSxXQUFXLFVBQVUsa0JBQWtCLGdCQUFnQixvQkFBb0Isa0JBQWtCLHNEQUFzRCxJQUFJLDBCQUEwQiw0QkFBNEIsaUJBQWlCLHNEQUFzRCxJQUFJLDBCQUEwQjtBQUM1YixrQkFBa0Isc0RBQXNELElBQUksMEJBQTBCLDRCQUE0QixjQUFjLGdDQUFnQyxJQUFJLGlDQUFpQyxvQkFBb0IsZ0JBQWdCLFdBQVcsTUFBTSxnQ0FBZ0MsSUFBSSxvREFBb0Qsb0JBQW9CLGlDQUFpQyxnQ0FBZ0MsaUNBQWlDLDhCQUE4QixnQ0FBZ0MsbUNBQW1DLGlDQUFpQyxrQ0FBa0MsbUNBQW1DLDBDQUEwQyxrQ0FBa0MsZUFBZSxlQUFlLHVDQUF1QyxvSkFBb0o7O0FBRTk0QjtBQUN0RCIsInNvdXJjZXMiOlsid2VicGFjazovL3RhbGtfdG9fdGV4dC8uLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3dlYmNoYW5uZWwtd3JhcHBlci9kaXN0L2Jsb29tLWJsb2IvZXNtL2Jsb29tX2Jsb2JfZXMyMDE4LmpzPzA4MzMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbnZhciBibG9vbV9ibG9iX2VzMjAxOCA9IHt9O1xuXG4vKiogQGxpY2Vuc2VcbkNvcHlyaWdodCBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuXG5TUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuKi9cblxudmFyIEludGVnZXI7XG52YXIgTWQ1O1xuKGZ1bmN0aW9uKCkge3ZhciBoOy8qKiBAbGljZW5zZVxuXG4gQ29weXJpZ2h0IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy5cbiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuKi9cbmZ1bmN0aW9uIGsoZixhKXtmdW5jdGlvbiBjKCl7fWMucHJvdG90eXBlPWEucHJvdG90eXBlO2YuRD1hLnByb3RvdHlwZTtmLnByb3RvdHlwZT1uZXcgYztmLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1mO2YuQz1mdW5jdGlvbihkLGUsZyl7Zm9yKHZhciBiPUFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMikscj0yO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspYltyLTJdPWFyZ3VtZW50c1tyXTtyZXR1cm4gYS5wcm90b3R5cGVbZV0uYXBwbHkoZCxiKX07fWZ1bmN0aW9uIGwoKXt0aGlzLmJsb2NrU2l6ZT0tMTt9ZnVuY3Rpb24gbSgpe3RoaXMuYmxvY2tTaXplPS0xO3RoaXMuYmxvY2tTaXplPTY0O3RoaXMuZz1BcnJheSg0KTt0aGlzLkI9QXJyYXkodGhpcy5ibG9ja1NpemUpO3RoaXMubz10aGlzLmg9MDt0aGlzLnMoKTt9ayhtLGwpO20ucHJvdG90eXBlLnM9ZnVuY3Rpb24oKXt0aGlzLmdbMF09MTczMjU4NDE5Mzt0aGlzLmdbMV09NDAyMzIzMzQxNzt0aGlzLmdbMl09MjU2MjM4MzEwMjt0aGlzLmdbM109MjcxNzMzODc4O3RoaXMubz10aGlzLmg9MDt9O1xuZnVuY3Rpb24gbihmLGEsYyl7Y3x8KGM9MCk7dmFyIGQ9QXJyYXkoMTYpO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYSlmb3IodmFyIGU9MDsxNj5lOysrZSlkW2VdPWEuY2hhckNvZGVBdChjKyspfGEuY2hhckNvZGVBdChjKyspPDw4fGEuY2hhckNvZGVBdChjKyspPDwxNnxhLmNoYXJDb2RlQXQoYysrKTw8MjQ7ZWxzZSBmb3IoZT0wOzE2PmU7KytlKWRbZV09YVtjKytdfGFbYysrXTw8OHxhW2MrK108PDE2fGFbYysrXTw8MjQ7YT1mLmdbMF07Yz1mLmdbMV07ZT1mLmdbMl07dmFyIGc9Zi5nWzNdO3ZhciBiPWErKGdeYyYoZV5nKSkrZFswXSszNjE0MDkwMzYwJjQyOTQ5NjcyOTU7YT1jKyhiPDw3JjQyOTQ5NjcyOTV8Yj4+PjI1KTtiPWcrKGVeYSYoY15lKSkrZFsxXSszOTA1NDAyNzEwJjQyOTQ5NjcyOTU7Zz1hKyhiPDwxMiY0Mjk0OTY3Mjk1fGI+Pj4yMCk7Yj1lKyhjXmcmKGFeYykpK2RbMl0rNjA2MTA1ODE5JjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNyY0Mjk0OTY3Mjk1fGI+Pj4xNSk7XG5iPWMrKGFeZSYoZ15hKSkrZFszXSszMjUwNDQxOTY2JjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMiY0Mjk0OTY3Mjk1fGI+Pj4xMCk7Yj1hKyhnXmMmKGVeZykpK2RbNF0rNDExODU0ODM5OSY0Mjk0OTY3Mjk1O2E9YysoYjw8NyY0Mjk0OTY3Mjk1fGI+Pj4yNSk7Yj1nKyhlXmEmKGNeZSkpK2RbNV0rMTIwMDA4MDQyNiY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTImNDI5NDk2NzI5NXxiPj4+MjApO2I9ZSsoY15nJihhXmMpKStkWzZdKzI4MjE3MzU5NTUmNDI5NDk2NzI5NTtlPWcrKGI8PDE3JjQyOTQ5NjcyOTV8Yj4+PjE1KTtiPWMrKGFeZSYoZ15hKSkrZFs3XSs0MjQ5MjYxMzEzJjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMiY0Mjk0OTY3Mjk1fGI+Pj4xMCk7Yj1hKyhnXmMmKGVeZykpK2RbOF0rMTc3MDAzNTQxNiY0Mjk0OTY3Mjk1O2E9YysoYjw8NyY0Mjk0OTY3Mjk1fGI+Pj4yNSk7Yj1nKyhlXmEmKGNeZSkpK2RbOV0rMjMzNjU1Mjg3OSY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTImNDI5NDk2NzI5NXxcbmI+Pj4yMCk7Yj1lKyhjXmcmKGFeYykpK2RbMTBdKzQyOTQ5MjUyMzMmNDI5NDk2NzI5NTtlPWcrKGI8PDE3JjQyOTQ5NjcyOTV8Yj4+PjE1KTtiPWMrKGFeZSYoZ15hKSkrZFsxMV0rMjMwNDU2MzEzNCY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjImNDI5NDk2NzI5NXxiPj4+MTApO2I9YSsoZ15jJihlXmcpKStkWzEyXSsxODA0NjAzNjgyJjQyOTQ5NjcyOTU7YT1jKyhiPDw3JjQyOTQ5NjcyOTV8Yj4+PjI1KTtiPWcrKGVeYSYoY15lKSkrZFsxM10rNDI1NDYyNjE5NSY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTImNDI5NDk2NzI5NXxiPj4+MjApO2I9ZSsoY15nJihhXmMpKStkWzE0XSsyNzkyOTY1MDA2JjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNyY0Mjk0OTY3Mjk1fGI+Pj4xNSk7Yj1jKyhhXmUmKGdeYSkpK2RbMTVdKzEyMzY1MzUzMjkmNDI5NDk2NzI5NTtjPWUrKGI8PDIyJjQyOTQ5NjcyOTV8Yj4+PjEwKTtiPWErKGVeZyYoY15lKSkrZFsxXSs0MTI5MTcwNzg2JjQyOTQ5NjcyOTU7YT1jKyhiPDxcbjUmNDI5NDk2NzI5NXxiPj4+MjcpO2I9ZysoY15lJihhXmMpKStkWzZdKzMyMjU0NjU2NjQmNDI5NDk2NzI5NTtnPWErKGI8PDkmNDI5NDk2NzI5NXxiPj4+MjMpO2I9ZSsoYV5jJihnXmEpKStkWzExXSs2NDM3MTc3MTMmNDI5NDk2NzI5NTtlPWcrKGI8PDE0JjQyOTQ5NjcyOTV8Yj4+PjE4KTtiPWMrKGdeYSYoZV5nKSkrZFswXSszOTIxMDY5OTk0JjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMCY0Mjk0OTY3Mjk1fGI+Pj4xMik7Yj1hKyhlXmcmKGNeZSkpK2RbNV0rMzU5MzQwODYwNSY0Mjk0OTY3Mjk1O2E9YysoYjw8NSY0Mjk0OTY3Mjk1fGI+Pj4yNyk7Yj1nKyhjXmUmKGFeYykpK2RbMTBdKzM4MDE2MDgzJjQyOTQ5NjcyOTU7Zz1hKyhiPDw5JjQyOTQ5NjcyOTV8Yj4+PjIzKTtiPWUrKGFeYyYoZ15hKSkrZFsxNV0rMzYzNDQ4ODk2MSY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTQmNDI5NDk2NzI5NXxiPj4+MTgpO2I9YysoZ15hJihlXmcpKStkWzRdKzM4ODk0Mjk0NDgmNDI5NDk2NzI5NTtjPVxuZSsoYjw8MjAmNDI5NDk2NzI5NXxiPj4+MTIpO2I9YSsoZV5nJihjXmUpKStkWzldKzU2ODQ0NjQzOCY0Mjk0OTY3Mjk1O2E9YysoYjw8NSY0Mjk0OTY3Mjk1fGI+Pj4yNyk7Yj1nKyhjXmUmKGFeYykpK2RbMTRdKzMyNzUxNjM2MDYmNDI5NDk2NzI5NTtnPWErKGI8PDkmNDI5NDk2NzI5NXxiPj4+MjMpO2I9ZSsoYV5jJihnXmEpKStkWzNdKzQxMDc2MDMzMzUmNDI5NDk2NzI5NTtlPWcrKGI8PDE0JjQyOTQ5NjcyOTV8Yj4+PjE4KTtiPWMrKGdeYSYoZV5nKSkrZFs4XSsxMTYzNTMxNTAxJjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMCY0Mjk0OTY3Mjk1fGI+Pj4xMik7Yj1hKyhlXmcmKGNeZSkpK2RbMTNdKzI4NTAyODU4MjkmNDI5NDk2NzI5NTthPWMrKGI8PDUmNDI5NDk2NzI5NXxiPj4+MjcpO2I9ZysoY15lJihhXmMpKStkWzJdKzQyNDM1NjM1MTImNDI5NDk2NzI5NTtnPWErKGI8PDkmNDI5NDk2NzI5NXxiPj4+MjMpO2I9ZSsoYV5jJihnXmEpKStkWzddKzE3MzUzMjg0NzMmNDI5NDk2NzI5NTtcbmU9ZysoYjw8MTQmNDI5NDk2NzI5NXxiPj4+MTgpO2I9YysoZ15hJihlXmcpKStkWzEyXSsyMzY4MzU5NTYyJjQyOTQ5NjcyOTU7Yz1lKyhiPDwyMCY0Mjk0OTY3Mjk1fGI+Pj4xMik7Yj1hKyhjXmVeZykrZFs1XSs0Mjk0NTg4NzM4JjQyOTQ5NjcyOTU7YT1jKyhiPDw0JjQyOTQ5NjcyOTV8Yj4+PjI4KTtiPWcrKGFeY15lKStkWzhdKzIyNzIzOTI4MzMmNDI5NDk2NzI5NTtnPWErKGI8PDExJjQyOTQ5NjcyOTV8Yj4+PjIxKTtiPWUrKGdeYV5jKStkWzExXSsxODM5MDMwNTYyJjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNiY0Mjk0OTY3Mjk1fGI+Pj4xNik7Yj1jKyhlXmdeYSkrZFsxNF0rNDI1OTY1Nzc0MCY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjMmNDI5NDk2NzI5NXxiPj4+OSk7Yj1hKyhjXmVeZykrZFsxXSsyNzYzOTc1MjM2JjQyOTQ5NjcyOTU7YT1jKyhiPDw0JjQyOTQ5NjcyOTV8Yj4+PjI4KTtiPWcrKGFeY15lKStkWzRdKzEyNzI4OTMzNTMmNDI5NDk2NzI5NTtnPWErKGI8PDExJjQyOTQ5NjcyOTV8XG5iPj4+MjEpO2I9ZSsoZ15hXmMpK2RbN10rNDEzOTQ2OTY2NCY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTYmNDI5NDk2NzI5NXxiPj4+MTYpO2I9YysoZV5nXmEpK2RbMTBdKzMyMDAyMzY2NTYmNDI5NDk2NzI5NTtjPWUrKGI8PDIzJjQyOTQ5NjcyOTV8Yj4+PjkpO2I9YSsoY15lXmcpK2RbMTNdKzY4MTI3OTE3NCY0Mjk0OTY3Mjk1O2E9YysoYjw8NCY0Mjk0OTY3Mjk1fGI+Pj4yOCk7Yj1nKyhhXmNeZSkrZFswXSszOTM2NDMwMDc0JjQyOTQ5NjcyOTU7Zz1hKyhiPDwxMSY0Mjk0OTY3Mjk1fGI+Pj4yMSk7Yj1lKyhnXmFeYykrZFszXSszNTcyNDQ1MzE3JjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNiY0Mjk0OTY3Mjk1fGI+Pj4xNik7Yj1jKyhlXmdeYSkrZFs2XSs3NjAyOTE4OSY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjMmNDI5NDk2NzI5NXxiPj4+OSk7Yj1hKyhjXmVeZykrZFs5XSszNjU0NjAyODA5JjQyOTQ5NjcyOTU7YT1jKyhiPDw0JjQyOTQ5NjcyOTV8Yj4+PjI4KTtiPWcrKGFeY15lKStkWzEyXStcbjM4NzMxNTE0NjEmNDI5NDk2NzI5NTtnPWErKGI8PDExJjQyOTQ5NjcyOTV8Yj4+PjIxKTtiPWUrKGdeYV5jKStkWzE1XSs1MzA3NDI1MjAmNDI5NDk2NzI5NTtlPWcrKGI8PDE2JjQyOTQ5NjcyOTV8Yj4+PjE2KTtiPWMrKGVeZ15hKStkWzJdKzMyOTk2Mjg2NDUmNDI5NDk2NzI5NTtjPWUrKGI8PDIzJjQyOTQ5NjcyOTV8Yj4+PjkpO2I9YSsoZV4oY3x+ZykpK2RbMF0rNDA5NjMzNjQ1MiY0Mjk0OTY3Mjk1O2E9YysoYjw8NiY0Mjk0OTY3Mjk1fGI+Pj4yNik7Yj1nKyhjXihhfH5lKSkrZFs3XSsxMTI2ODkxNDE1JjQyOTQ5NjcyOTU7Zz1hKyhiPDwxMCY0Mjk0OTY3Mjk1fGI+Pj4yMik7Yj1lKyhhXihnfH5jKSkrZFsxNF0rMjg3ODYxMjM5MSY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTUmNDI5NDk2NzI5NXxiPj4+MTcpO2I9YysoZ14oZXx+YSkpK2RbNV0rNDIzNzUzMzI0MSY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjEmNDI5NDk2NzI5NXxiPj4+MTEpO2I9YSsoZV4oY3x+ZykpK2RbMTJdKzE3MDA0ODU1NzEmXG40Mjk0OTY3Mjk1O2E9YysoYjw8NiY0Mjk0OTY3Mjk1fGI+Pj4yNik7Yj1nKyhjXihhfH5lKSkrZFszXSsyMzk5OTgwNjkwJjQyOTQ5NjcyOTU7Zz1hKyhiPDwxMCY0Mjk0OTY3Mjk1fGI+Pj4yMik7Yj1lKyhhXihnfH5jKSkrZFsxMF0rNDI5MzkxNTc3MyY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTUmNDI5NDk2NzI5NXxiPj4+MTcpO2I9YysoZ14oZXx+YSkpK2RbMV0rMjI0MDA0NDQ5NyY0Mjk0OTY3Mjk1O2M9ZSsoYjw8MjEmNDI5NDk2NzI5NXxiPj4+MTEpO2I9YSsoZV4oY3x+ZykpK2RbOF0rMTg3MzMxMzM1OSY0Mjk0OTY3Mjk1O2E9YysoYjw8NiY0Mjk0OTY3Mjk1fGI+Pj4yNik7Yj1nKyhjXihhfH5lKSkrZFsxNV0rNDI2NDM1NTU1MiY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTAmNDI5NDk2NzI5NXxiPj4+MjIpO2I9ZSsoYV4oZ3x+YykpK2RbNl0rMjczNDc2ODkxNiY0Mjk0OTY3Mjk1O2U9ZysoYjw8MTUmNDI5NDk2NzI5NXxiPj4+MTcpO2I9YysoZ14oZXx+YSkpK2RbMTNdKzEzMDkxNTE2NDkmXG40Mjk0OTY3Mjk1O2M9ZSsoYjw8MjEmNDI5NDk2NzI5NXxiPj4+MTEpO2I9YSsoZV4oY3x+ZykpK2RbNF0rNDE0OTQ0NDIyNiY0Mjk0OTY3Mjk1O2E9YysoYjw8NiY0Mjk0OTY3Mjk1fGI+Pj4yNik7Yj1nKyhjXihhfH5lKSkrZFsxMV0rMzE3NDc1NjkxNyY0Mjk0OTY3Mjk1O2c9YSsoYjw8MTAmNDI5NDk2NzI5NXxiPj4+MjIpO2I9ZSsoYV4oZ3x+YykpK2RbMl0rNzE4Nzg3MjU5JjQyOTQ5NjcyOTU7ZT1nKyhiPDwxNSY0Mjk0OTY3Mjk1fGI+Pj4xNyk7Yj1jKyhnXihlfH5hKSkrZFs5XSszOTUxNDgxNzQ1JjQyOTQ5NjcyOTU7Zi5nWzBdPWYuZ1swXSthJjQyOTQ5NjcyOTU7Zi5nWzFdPWYuZ1sxXSsoZSsoYjw8MjEmNDI5NDk2NzI5NXxiPj4+MTEpKSY0Mjk0OTY3Mjk1O2YuZ1syXT1mLmdbMl0rZSY0Mjk0OTY3Mjk1O2YuZ1szXT1mLmdbM10rZyY0Mjk0OTY3Mjk1O31cbm0ucHJvdG90eXBlLnU9ZnVuY3Rpb24oZixhKXt2b2lkIDA9PT1hJiYoYT1mLmxlbmd0aCk7Zm9yKHZhciBjPWEtdGhpcy5ibG9ja1NpemUsZD10aGlzLkIsZT10aGlzLmgsZz0wO2c8YTspe2lmKDA9PWUpZm9yKDtnPD1jOyluKHRoaXMsZixnKSxnKz10aGlzLmJsb2NrU2l6ZTtpZihcInN0cmluZ1wiPT09dHlwZW9mIGYpZm9yKDtnPGE7KXtpZihkW2UrK109Zi5jaGFyQ29kZUF0KGcrKyksZT09dGhpcy5ibG9ja1NpemUpe24odGhpcyxkKTtlPTA7YnJlYWt9fWVsc2UgZm9yKDtnPGE7KWlmKGRbZSsrXT1mW2crK10sZT09dGhpcy5ibG9ja1NpemUpe24odGhpcyxkKTtlPTA7YnJlYWt9fXRoaXMuaD1lO3RoaXMubys9YTt9O1xubS5wcm90b3R5cGUudj1mdW5jdGlvbigpe3ZhciBmPUFycmF5KCg1Nj50aGlzLmg/dGhpcy5ibG9ja1NpemU6Mip0aGlzLmJsb2NrU2l6ZSktdGhpcy5oKTtmWzBdPTEyODtmb3IodmFyIGE9MTthPGYubGVuZ3RoLTg7KythKWZbYV09MDt2YXIgYz04KnRoaXMubztmb3IoYT1mLmxlbmd0aC04O2E8Zi5sZW5ndGg7KythKWZbYV09YyYyNTUsYy89MjU2O3RoaXMudShmKTtmPUFycmF5KDE2KTtmb3IoYT1jPTA7ND5hOysrYSlmb3IodmFyIGQ9MDszMj5kO2QrPTgpZltjKytdPXRoaXMuZ1thXT4+PmQmMjU1O3JldHVybiBmfTtmdW5jdGlvbiBwKGYsYSl7dmFyIGM9cTtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGMsZik/Y1tmXTpjW2ZdPWEoZil9ZnVuY3Rpb24gdChmLGEpe3RoaXMuaD1hO2Zvcih2YXIgYz1bXSxkPSEwLGU9Zi5sZW5ndGgtMTswPD1lO2UtLSl7dmFyIGc9ZltlXXwwO2QmJmc9PWF8fChjW2VdPWcsZD0hMSk7fXRoaXMuZz1jO312YXIgcT17fTtmdW5jdGlvbiB1KGYpe3JldHVybiAtMTI4PD1mJiYxMjg+Zj9wKGYsZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyB0KFthfDBdLDA+YT8tMTowKX0pOm5ldyB0KFtmfDBdLDA+Zj8tMTowKX1mdW5jdGlvbiB2KGYpe2lmKGlzTmFOKGYpfHwhaXNGaW5pdGUoZikpcmV0dXJuIHc7aWYoMD5mKXJldHVybiB4KHYoLWYpKTtmb3IodmFyIGE9W10sYz0xLGQ9MDtmPj1jO2QrKylhW2RdPWYvY3wwLGMqPTQyOTQ5NjcyOTY7cmV0dXJuIG5ldyB0KGEsMCl9XG5mdW5jdGlvbiB5KGYsYSl7aWYoMD09Zi5sZW5ndGgpdGhyb3cgRXJyb3IoXCJudW1iZXIgZm9ybWF0IGVycm9yOiBlbXB0eSBzdHJpbmdcIik7YT1hfHwxMDtpZigyPmF8fDM2PGEpdGhyb3cgRXJyb3IoXCJyYWRpeCBvdXQgb2YgcmFuZ2U6IFwiK2EpO2lmKFwiLVwiPT1mLmNoYXJBdCgwKSlyZXR1cm4geCh5KGYuc3Vic3RyaW5nKDEpLGEpKTtpZigwPD1mLmluZGV4T2YoXCItXCIpKXRocm93IEVycm9yKCdudW1iZXIgZm9ybWF0IGVycm9yOiBpbnRlcmlvciBcIi1cIiBjaGFyYWN0ZXInKTtmb3IodmFyIGM9dihNYXRoLnBvdyhhLDgpKSxkPXcsZT0wO2U8Zi5sZW5ndGg7ZSs9OCl7dmFyIGc9TWF0aC5taW4oOCxmLmxlbmd0aC1lKSxiPXBhcnNlSW50KGYuc3Vic3RyaW5nKGUsZStnKSxhKTs4Pmc/KGc9dihNYXRoLnBvdyhhLGcpKSxkPWQuaihnKS5hZGQodihiKSkpOihkPWQuaihjKSxkPWQuYWRkKHYoYikpKTt9cmV0dXJuIGR9dmFyIHc9dSgwKSx6PXUoMSksQT11KDE2Nzc3MjE2KTtoPXQucHJvdG90eXBlO1xuaC5tPWZ1bmN0aW9uKCl7aWYoQih0aGlzKSlyZXR1cm4gLXgodGhpcykubSgpO2Zvcih2YXIgZj0wLGE9MSxjPTA7Yzx0aGlzLmcubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy5pKGMpO2YrPSgwPD1kP2Q6NDI5NDk2NzI5NitkKSphO2EqPTQyOTQ5NjcyOTY7fXJldHVybiBmfTtoLnRvU3RyaW5nPWZ1bmN0aW9uKGYpe2Y9Znx8MTA7aWYoMj5mfHwzNjxmKXRocm93IEVycm9yKFwicmFkaXggb3V0IG9mIHJhbmdlOiBcIitmKTtpZihDKHRoaXMpKXJldHVybiBcIjBcIjtpZihCKHRoaXMpKXJldHVybiBcIi1cIit4KHRoaXMpLnRvU3RyaW5nKGYpO2Zvcih2YXIgYT12KE1hdGgucG93KGYsNikpLGM9dGhpcyxkPVwiXCI7Oyl7dmFyIGU9RChjLGEpLmc7Yz1GKGMsZS5qKGEpKTt2YXIgZz0oKDA8Yy5nLmxlbmd0aD9jLmdbMF06Yy5oKT4+PjApLnRvU3RyaW5nKGYpO2M9ZTtpZihDKGMpKXJldHVybiBnK2Q7Zm9yKDs2PmcubGVuZ3RoOylnPVwiMFwiK2c7ZD1nK2Q7fX07XG5oLmk9ZnVuY3Rpb24oZil7cmV0dXJuIDA+Zj8wOmY8dGhpcy5nLmxlbmd0aD90aGlzLmdbZl06dGhpcy5ofTtmdW5jdGlvbiBDKGYpe2lmKDAhPWYuaClyZXR1cm4gITE7Zm9yKHZhciBhPTA7YTxmLmcubGVuZ3RoO2ErKylpZigwIT1mLmdbYV0pcmV0dXJuICExO3JldHVybiAhMH1mdW5jdGlvbiBCKGYpe3JldHVybiAtMT09Zi5ofWgubD1mdW5jdGlvbihmKXtmPUYodGhpcyxmKTtyZXR1cm4gQihmKT8tMTpDKGYpPzA6MX07ZnVuY3Rpb24geChmKXtmb3IodmFyIGE9Zi5nLmxlbmd0aCxjPVtdLGQ9MDtkPGE7ZCsrKWNbZF09fmYuZ1tkXTtyZXR1cm4gKG5ldyB0KGMsfmYuaCkpLmFkZCh6KX1oLmFicz1mdW5jdGlvbigpe3JldHVybiBCKHRoaXMpP3godGhpcyk6dGhpc307XG5oLmFkZD1mdW5jdGlvbihmKXtmb3IodmFyIGE9TWF0aC5tYXgodGhpcy5nLmxlbmd0aCxmLmcubGVuZ3RoKSxjPVtdLGQ9MCxlPTA7ZTw9YTtlKyspe3ZhciBnPWQrKHRoaXMuaShlKSY2NTUzNSkrKGYuaShlKSY2NTUzNSksYj0oZz4+PjE2KSsodGhpcy5pKGUpPj4+MTYpKyhmLmkoZSk+Pj4xNik7ZD1iPj4+MTY7ZyY9NjU1MzU7YiY9NjU1MzU7Y1tlXT1iPDwxNnxnO31yZXR1cm4gbmV3IHQoYyxjW2MubGVuZ3RoLTFdJi0yMTQ3NDgzNjQ4Py0xOjApfTtmdW5jdGlvbiBGKGYsYSl7cmV0dXJuIGYuYWRkKHgoYSkpfVxuaC5qPWZ1bmN0aW9uKGYpe2lmKEModGhpcyl8fEMoZikpcmV0dXJuIHc7aWYoQih0aGlzKSlyZXR1cm4gQihmKT94KHRoaXMpLmooeChmKSk6eCh4KHRoaXMpLmooZikpO2lmKEIoZikpcmV0dXJuIHgodGhpcy5qKHgoZikpKTtpZigwPnRoaXMubChBKSYmMD5mLmwoQSkpcmV0dXJuIHYodGhpcy5tKCkqZi5tKCkpO2Zvcih2YXIgYT10aGlzLmcubGVuZ3RoK2YuZy5sZW5ndGgsYz1bXSxkPTA7ZDwyKmE7ZCsrKWNbZF09MDtmb3IoZD0wO2Q8dGhpcy5nLmxlbmd0aDtkKyspZm9yKHZhciBlPTA7ZTxmLmcubGVuZ3RoO2UrKyl7dmFyIGc9dGhpcy5pKGQpPj4+MTYsYj10aGlzLmkoZCkmNjU1MzUscj1mLmkoZSk+Pj4xNixFPWYuaShlKSY2NTUzNTtjWzIqZCsyKmVdKz1iKkU7RyhjLDIqZCsyKmUpO2NbMipkKzIqZSsxXSs9ZypFO0coYywyKmQrMiplKzEpO2NbMipkKzIqZSsxXSs9YipyO0coYywyKmQrMiplKzEpO2NbMipkKzIqZSsyXSs9ZypyO0coYywyKmQrMiplKzIpO31mb3IoZD0wO2Q8XG5hO2QrKyljW2RdPWNbMipkKzFdPDwxNnxjWzIqZF07Zm9yKGQ9YTtkPDIqYTtkKyspY1tkXT0wO3JldHVybiBuZXcgdChjLDApfTtmdW5jdGlvbiBHKGYsYSl7Zm9yKDsoZlthXSY2NTUzNSkhPWZbYV07KWZbYSsxXSs9ZlthXT4+PjE2LGZbYV0mPTY1NTM1LGErKzt9ZnVuY3Rpb24gSChmLGEpe3RoaXMuZz1mO3RoaXMuaD1hO31cbmZ1bmN0aW9uIEQoZixhKXtpZihDKGEpKXRocm93IEVycm9yKFwiZGl2aXNpb24gYnkgemVyb1wiKTtpZihDKGYpKXJldHVybiBuZXcgSCh3LHcpO2lmKEIoZikpcmV0dXJuIGE9RCh4KGYpLGEpLG5ldyBIKHgoYS5nKSx4KGEuaCkpO2lmKEIoYSkpcmV0dXJuIGE9RChmLHgoYSkpLG5ldyBIKHgoYS5nKSxhLmgpO2lmKDMwPGYuZy5sZW5ndGgpe2lmKEIoZil8fEIoYSkpdGhyb3cgRXJyb3IoXCJzbG93RGl2aWRlXyBvbmx5IHdvcmtzIHdpdGggcG9zaXRpdmUgaW50ZWdlcnMuXCIpO2Zvcih2YXIgYz16LGQ9YTswPj1kLmwoZik7KWM9SShjKSxkPUkoZCk7dmFyIGU9SihjLDEpLGc9SihkLDEpO2Q9SihkLDIpO2ZvcihjPUooYywyKTshQyhkKTspe3ZhciBiPWcuYWRkKGQpOzA+PWIubChmKSYmKGU9ZS5hZGQoYyksZz1iKTtkPUooZCwxKTtjPUooYywxKTt9YT1GKGYsZS5qKGEpKTtyZXR1cm4gbmV3IEgoZSxhKX1mb3IoZT13OzA8PWYubChhKTspe2M9TWF0aC5tYXgoMSxNYXRoLmZsb29yKGYubSgpL1xuYS5tKCkpKTtkPU1hdGguY2VpbChNYXRoLmxvZyhjKS9NYXRoLkxOMik7ZD00OD49ZD8xOk1hdGgucG93KDIsZC00OCk7Zz12KGMpO2ZvcihiPWcuaihhKTtCKGIpfHwwPGIubChmKTspYy09ZCxnPXYoYyksYj1nLmooYSk7QyhnKSYmKGc9eik7ZT1lLmFkZChnKTtmPUYoZixiKTt9cmV0dXJuIG5ldyBIKGUsZil9aC5BPWZ1bmN0aW9uKGYpe3JldHVybiBEKHRoaXMsZikuaH07aC5hbmQ9ZnVuY3Rpb24oZil7Zm9yKHZhciBhPU1hdGgubWF4KHRoaXMuZy5sZW5ndGgsZi5nLmxlbmd0aCksYz1bXSxkPTA7ZDxhO2QrKyljW2RdPXRoaXMuaShkKSZmLmkoZCk7cmV0dXJuIG5ldyB0KGMsdGhpcy5oJmYuaCl9O2gub3I9ZnVuY3Rpb24oZil7Zm9yKHZhciBhPU1hdGgubWF4KHRoaXMuZy5sZW5ndGgsZi5nLmxlbmd0aCksYz1bXSxkPTA7ZDxhO2QrKyljW2RdPXRoaXMuaShkKXxmLmkoZCk7cmV0dXJuIG5ldyB0KGMsdGhpcy5ofGYuaCl9O1xuaC54b3I9ZnVuY3Rpb24oZil7Zm9yKHZhciBhPU1hdGgubWF4KHRoaXMuZy5sZW5ndGgsZi5nLmxlbmd0aCksYz1bXSxkPTA7ZDxhO2QrKyljW2RdPXRoaXMuaShkKV5mLmkoZCk7cmV0dXJuIG5ldyB0KGMsdGhpcy5oXmYuaCl9O2Z1bmN0aW9uIEkoZil7Zm9yKHZhciBhPWYuZy5sZW5ndGgrMSxjPVtdLGQ9MDtkPGE7ZCsrKWNbZF09Zi5pKGQpPDwxfGYuaShkLTEpPj4+MzE7cmV0dXJuIG5ldyB0KGMsZi5oKX1mdW5jdGlvbiBKKGYsYSl7dmFyIGM9YT4+NTthJT0zMjtmb3IodmFyIGQ9Zi5nLmxlbmd0aC1jLGU9W10sZz0wO2c8ZDtnKyspZVtnXT0wPGE/Zi5pKGcrYyk+Pj5hfGYuaShnK2MrMSk8PDMyLWE6Zi5pKGcrYyk7cmV0dXJuIG5ldyB0KGUsZi5oKX1tLnByb3RvdHlwZS5kaWdlc3Q9bS5wcm90b3R5cGUudjttLnByb3RvdHlwZS5yZXNldD1tLnByb3RvdHlwZS5zO20ucHJvdG90eXBlLnVwZGF0ZT1tLnByb3RvdHlwZS51O01kNSA9IGJsb29tX2Jsb2JfZXMyMDE4Lk1kNT1tO3QucHJvdG90eXBlLmFkZD10LnByb3RvdHlwZS5hZGQ7dC5wcm90b3R5cGUubXVsdGlwbHk9dC5wcm90b3R5cGUuajt0LnByb3RvdHlwZS5tb2R1bG89dC5wcm90b3R5cGUuQTt0LnByb3RvdHlwZS5jb21wYXJlPXQucHJvdG90eXBlLmw7dC5wcm90b3R5cGUudG9OdW1iZXI9dC5wcm90b3R5cGUubTt0LnByb3RvdHlwZS50b1N0cmluZz10LnByb3RvdHlwZS50b1N0cmluZzt0LnByb3RvdHlwZS5nZXRCaXRzPXQucHJvdG90eXBlLmk7dC5mcm9tTnVtYmVyPXY7dC5mcm9tU3RyaW5nPXk7SW50ZWdlciA9IGJsb29tX2Jsb2JfZXMyMDE4LkludGVnZXI9dDt9KS5hcHBseSggdHlwZW9mIGNvbW1vbmpzR2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGNvbW1vbmpzR2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyAgOiB7fSk7XG5cbmV4cG9ydCB7IEludGVnZXIsIE1kNSwgYmxvb21fYmxvYl9lczIwMTggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ymxvb21fYmxvYl9lczIwMTguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@firebase/webchannel-wrapper/dist/bloom-blob/esm/bloom_blob_es2018.js\n");

/***/ })

};
;